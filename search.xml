<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo</title>
    <url>/2022/04/03/Hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android</title>
    <url>/2021/10/31/Android/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211101213129527.png" alt="image-20211101213129527"></p>
<table>
<thead>
<tr>
<th><strong>.gradle</strong></th>
<th><strong>Android Studio 自动生成的</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>./idea</strong></td>
<td><strong>Android Studio 自动生成的</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>app-build</strong></td>
<td><strong>生成的内容，比如生成的apk，就在build-oitputs-apk</strong></td>
</tr>
<tr>
<td><strong>app-libs</strong></td>
<td><strong>第三方包</strong></td>
</tr>
<tr>
<td><strong>app-src-androidTest</strong></td>
<td><strong>测试用例</strong></td>
</tr>
<tr>
<td><strong>app-src-main-java</strong></td>
<td><strong>java代码</strong></td>
</tr>
<tr>
<td><strong>app-src-main-res</strong></td>
<td><strong>资源，比如string，color等</strong>,drawable图片，可以右键新建图片资源等</td>
</tr>
<tr>
<td><strong>app-src-main-AndroidMainifest.xml</strong></td>
<td><strong>四大组件的注册，图标等</strong></td>
</tr>
<tr>
<td><strong>app-src-test</strong></td>
<td><strong>单元测试</strong></td>
</tr>
<tr>
<td><strong>app-.gitignore</strong></td>
<td><strong>app的版本控制</strong></td>
</tr>
<tr>
<td><strong>app-build-gradle</strong></td>
<td><strong>app模块的构建脚本，比如第三方库的依赖</strong></td>
</tr>
<tr>
<td><strong>app-proguard-rules.pro</strong></td>
<td><strong>项目代码的混淆规则</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>gradle</strong></td>
<td><strong>构建器</strong></td>
</tr>
<tr>
<td><strong>gradle-wrapper</strong></td>
<td><strong>构建器版本</strong></td>
</tr>
<tr>
<td><strong>gradle-wrapper-properties</strong></td>
<td><strong>查看本地是否有构建器版本，没有时会自动下载</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>.gitignore</strong></td>
<td><strong>整个项目公共的版本控制</strong></td>
</tr>
<tr>
<td><strong>build.gradle</strong></td>
<td><strong>整个项目公共的构建脚本</strong></td>
</tr>
<tr>
<td><strong>gradle.properties</strong></td>
<td><strong>整个项目公共的配置文件</strong></td>
</tr>
<tr>
<td><strong>gradlew</strong></td>
<td><strong>写构建器命令时会用,和操作系统有关，Linux，mac</strong></td>
</tr>
<tr>
<td><strong>gradlew.bat</strong></td>
<td><strong>写构建器命令时会用,和操作系统有关，windows</strong></td>
</tr>
<tr>
<td><strong>local.properties</strong></td>
<td><strong>SDK的路径</strong></td>
</tr>
<tr>
<td><strong>settings.gradle</strong></td>
<td><strong>项目中所有引用的模块</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>External Libraries</strong></td>
<td><strong>第三方库</strong></td>
</tr>
</tbody></table>
<h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><h2 id="jetpack"><a href="#jetpack" class="headerlink" title="jetpack"></a>jetpack</h2><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211101214229574.png" alt="image-20211101214229574"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211101214244882.png" alt="image-20211101214244882"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211101214548706.png" alt="image-20211101214548706"></p>
<h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211101220210893.png" alt="image-20211101220210893"></p>
<h2 id="EdieText"><a href="#EdieText" class="headerlink" title="EdieText"></a>EdieText</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102205027867.png" alt="image-20211102205027867"></p>
<h2 id="imageView"><a href="#imageView" class="headerlink" title="imageView"></a>imageView</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102210908946.png" alt="image-20211102210908946"></p>
<p> 缩放类型<img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102211835110.png" alt="image-20211102211835110"></p>
<h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102212711059.png" alt="image-20211102212711059"></p>
<h2 id="Notification-通知-–notification"><a href="#Notification-通知-–notification" class="headerlink" title="Notification 通知 –notification"></a>Notification 通知 –notification</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102213905628.png" alt="image-20211102213905628"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102214856345.png" alt="image-20211102214856345"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102220158432.png" alt="image-20211102220158432"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102215801054.png" alt="image-20211102215801054"></p>
<h2 id="toolbar-–toolbar"><a href="#toolbar-–toolbar" class="headerlink" title="toolbar –toolbar"></a>toolbar –toolbar</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102222735113.png" alt="image-20211102222735113"></p>
<blockquote>
<p>toolbar就是代替themes.xml里面的ActionBar的</p>
</blockquote>
<h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211103195149130.png" alt="image-20211103195149130"></p>
<h2 id="PopWindows"><a href="#PopWindows" class="headerlink" title="PopWindows"></a>PopWindows</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211103212219582.png" alt="image-20211103212219582"></p>
<p>3,4可以通过PopupWindow的构造函数传入</p>
<h2 id="RecyclerView-和-listview类似-–-listview-recycelview"><a href="#RecyclerView-和-listview类似-–-listview-recycelview" class="headerlink" title="RecyclerView 和 listview类似 – listview recycelview"></a>RecyclerView 和 listview类似 – listview recycelview</h2><p>需要在build.gradle中引用依赖库，并注册</p>
<h2 id="ViewPager-–viewpager"><a href="#ViewPager-–viewpager" class="headerlink" title="ViewPager –viewpager"></a>ViewPager –viewpager</h2><p>滑动切换layout</p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211114180905487.png" alt="image-20211114180905487"></p>
<h2 id="ViewPager2-–viewpager-fragment-做UI"><a href="#ViewPager2-–viewpager-fragment-做UI" class="headerlink" title="ViewPager2 –viewpager_fragment 做UI"></a>ViewPager2 –viewpager_fragment 做UI</h2><p>模拟微信界面，可以左右滑动，也可以借助nagative</p>
<p>有两个基类</p>
<p>FragmentPagerAdapter：fragment会缓存</p>
<p>FragmentStatePagerAdapter：会销毁</p>
<h1 id="Activity-Service-Receiver-–MyActivity"><a href="#Activity-Service-Receiver-–MyActivity" class="headerlink" title="Activity Service Receiver –MyActivity"></a>Activity Service Receiver –MyActivity</h1><p>service，bindService</p>
<p>BindService 是与activity挂钩的，一般写法，当activity销毁的时候，自动解绑服务</p>
<p>静态注册接收广播（在清单文件里注册）</p>
<p>动态接收广播</p>
<h1 id="动画-animation–anmi"><a href="#动画-animation–anmi" class="headerlink" title="动画 animation–anmi"></a>动画 animation–anmi</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐帧动画</span></span><br><span class="line">    ImageView imageView = findViewById(R.id.anim);</span><br><span class="line">    AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground();</span><br><span class="line">    imageView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                animationDrawable.start();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                animationDrawable.stop();</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//补间动画</span></span><br><span class="line">    ImageView imageview2 = findViewById(R.id.imageview);</span><br><span class="line">    imageview2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//通过加载xml动画设置文件创建一个animation对象</span></span><br><span class="line">            Animation animation = AnimationUtils.loadAnimation(MainActivity.<span class="keyword">this</span>, R.anim.translate);</span><br><span class="line">            imageview2.startAnimation(animation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性动画</span></span><br><span class="line">    ValueAnimator valueAnimator = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">    valueAnimator.setDuration(<span class="number">2000</span>);</span><br><span class="line">    valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> animatedValue = (<span class="keyword">float</span>)animation.getAnimatedValue();</span><br><span class="line">            Log.e(<span class="string">&quot;&quot;</span>, <span class="string">&quot;onAnimationUpdate: &quot;</span>+animatedValue );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    valueAnimator.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ImageView viewById = findViewById(R.id.imageview2);</span><br><span class="line">    ObjectAnimator alpha = ObjectAnimator.ofFloat(viewById, <span class="string">&quot;alpha&quot;</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">    alpha.setDuration(<span class="number">3000</span>);</span><br><span class="line">    alpha.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">    alpha.setRepeatCount(<span class="number">3</span>);</span><br><span class="line">    alpha.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211114174234884.png" alt="image-20211114174234884"></p>
<h1 id="单位和尺寸"><a href="#单位和尺寸" class="headerlink" title="单位和尺寸"></a>单位和尺寸</h1><p>px：pixels，像素，不同设备显示效果相同</p>
<p>pt：point，一个标准长度单位，1pt=1/72英寸</p>
<p>dp：dip，device independent pixels，设备独立像素，不同设备有不同的显示效果，和设备硬件有关，一般为了支持WVGA、HVGA、CVGA推荐使用这个，不依赖像素。设备越大，1dp占用的像素越多，为了适配不同屏幕像素。</p>
<p>sp：scaled pixels，放大像素，主要用于字体显示。效果和dp一样。</p>
<p>layoutparams：相当于layout信息包，封装了长宽高之类的</p>
<h1 id="Fragment-–fragment"><a href="#Fragment-–fragment" class="headerlink" title="Fragment –fragment"></a>Fragment –fragment</h1><p>获取text的内容</p>
<p>Fragment属于activity，但是又有自己的声明周期 –fragmentmanagerer</p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211115213041543.png" alt="image-20211115213041543"></p>
<h2 id="activity和fragment通信-–fragmentmanagerer"><a href="#activity和fragment通信-–fragmentmanagerer" class="headerlink" title="activity和fragment通信 –fragmentmanagerer"></a>activity和fragment通信 –fragmentmanagerer</h2><h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//activity给fragment通信</span></span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">&quot;Mes&quot;</span>,<span class="string">&quot;activity给fragment通信&quot;</span>);</span><br><span class="line">BlankFragment blankFragment = <span class="keyword">new</span> BlankFragment();</span><br><span class="line">blankFragment.setArguments(bundle);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取activity中的参数可以在类内的任何地方</span></span><br><span class="line">Bundle bundle = <span class="keyword">this</span>.getArguments();</span><br><span class="line">String str=bundle.getString(<span class="string">&quot;Mes&quot;</span>);</span><br><span class="line">Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onCreate: &quot;</span>+str);</span><br></pre></td></tr></table></figure>

<h3 id="java类与类自己通信常用方案：接口"><a href="#java类与类自己通信常用方案：接口" class="headerlink" title="java类与类自己通信常用方案：接口"></a>java类与类自己通信常用方案：接口</h3><h3 id="其他方案，eventBus，LiveData"><a href="#其他方案，eventBus，LiveData" class="headerlink" title="其他方案，eventBus，LiveData"></a>其他方案，eventBus，LiveData</h3><p>处于观察者模式，会关注Fragment和activity的状态，在更新了状态之后，会通知</p>
<h2 id="fragment和fragment通信"><a href="#fragment和fragment通信" class="headerlink" title="fragment和fragment通信"></a>fragment和fragment通信</h2><h1 id="layout–linearlayout"><a href="#layout–linearlayout" class="headerlink" title="layout–linearlayout"></a>layout–linearlayout</h1><h2 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211103213057374.png" alt="image-20211103213057374"></p>
<blockquote>
<p>layout_weight分配的是已经设置的layout_height之外的剩余空间，如果不剩余，甚至还要减去，所以要用权重的话，一般设置layout_height为0dp</p>
<p>分割线的设置，divider设置的是图片，可以使用View来设置背景色的方式设置。</p>
</blockquote>
<h2 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211103223216610.png" alt="image-20211103223216610"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211103223647602.png" alt="image-20211103223647602"></p>
<h2 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h2><p>从左上角开始绘制，后面的会覆盖前面的FrameLayout</p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211104203848184.png" alt="image-20211104203848184"></p>
<h2 id="TableLayout"><a href="#TableLayout" class="headerlink" title="TableLayout"></a>TableLayout</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211104204555603.png" alt="image-20211104204555603"></p>
<h2 id="GridLayout-迷迷糊糊的"><a href="#GridLayout-迷迷糊糊的" class="headerlink" title="GridLayout 迷迷糊糊的"></a>GridLayout 迷迷糊糊的</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211104210609804.png" alt="image-20211104210609804"></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211104210739877.png" alt="image-20211104210739877"></p>
<h2 id="ConstraintLayout-约束布局"><a href="#ConstraintLayout-约束布局" class="headerlink" title="ConstraintLayout 约束布局"></a>ConstraintLayout 约束布局</h2><h1 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h1><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210330212649722.png" alt="image-20210330212649722"></p>
<p>上面就是Adapter以及继承结构图了，接着我们介绍一下实际开发中还用到的几个Adapter吧！</p>
<blockquote>
<ul>
<li><strong>BaseAdapter</strong>：抽象类，实际开发中我们会继承这个类并且重写相关方法，用得最多的一个Adapter！</li>
<li><strong>ArrayAdapter</strong>：支持泛型操作，最简单的一个Adapter，只能展现一行文字~</li>
<li><strong>SimpleAdapter</strong>：同样具有良好扩展性的一个Adapter，可以自定义多种效果！</li>
<li><strong>SimpleCursorAdapter</strong>：用于显示简单文本类型的listView，一般在数据库那里会用到，不过有点过时， 不推荐使用！</li>
</ul>
</blockquote>
<p>其实一个BaseAdapter就够玩的了，至于其他的，实际开发中用得不多，后面用到在讲解~</p>
<h3 id="1）ArrayAdapter使用示例："><a href="#1）ArrayAdapter使用示例：" class="headerlink" title="1）ArrayAdapter使用示例："></a>1）ArrayAdapter使用示例：</h3><p><strong>运行效果图：</strong></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210330213133960.png" alt="image-20210330213133960"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        //要显示的数据</span><br><span class="line">        String[] strs = &#123;&quot;基神&quot;,&quot;B神&quot;,&quot;翔神&quot;,&quot;曹神&quot;,&quot;J神&quot;&#125;;</span><br><span class="line">        //创建ArrayAdapter</span><br><span class="line">        ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;</span><br><span class="line">                (this,android.R.layout.simple_expandable_list_item_1,strs);</span><br><span class="line">        //获取ListView对象，通过调用setAdapter方法为ListView设置Adapter设置适配器</span><br><span class="line">        ListView list_test = (ListView) findViewById(R.id.list_test);</span><br><span class="line">        list_test.setAdapter(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一些相关的东西：</strong></p>
<p>**1.**除了通过数组外，我们还可以写到一个数组资源文件中：</p>
<p>比如：在res\valuse下创建一个数组资源的xml文件：<strong>arrays.xml</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  </span><br><span class="line">&lt;resources&gt;  </span><br><span class="line">    &lt;string-array name=&quot;myarray&quot;&gt;  </span><br><span class="line">    &lt;item&gt;语文&lt;/item&gt;  </span><br><span class="line">    &lt;item&gt;数学&lt;/item&gt;  </span><br><span class="line">    &lt;item&gt;英语&lt;/item&gt;  </span><br><span class="line">    &lt;/string-array&gt;      </span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>

<p>接着布局的listview属性设置下这个列表项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ListView  </span><br><span class="line">        android:id=&quot;@id/list_test&quot;  </span><br><span class="line">        android:layout_height=&quot;match_parent&quot;  </span><br><span class="line">        android:layout_width=&quot;match_parent&quot;   </span><br><span class="line">        android:entries=&quot;@array/myarray&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>就可以了~</p>
<p>当然我们也可以在Java代码中这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this,</span><br><span class="line">        R.array.myarray,android.R.layout.simple_list_item_multiple_choice );</span><br></pre></td></tr></table></figure>

<p>同样也是可以的！</p>
<p>**2.**一开始也说了这个ArrayAdapter支持泛型，那么集合必不可少啦，比如，这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; data = new ArrayList&lt;String&gt;();</span><br><span class="line">data.add(&quot;基神&quot;);</span><br><span class="line">data.add(&quot;B神&quot;)；</span><br><span class="line">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_expandable_list_item_1,data);</span><br></pre></td></tr></table></figure>

<p>就可以了~</p>
<p>**3.**我们看到了在实例化ArrayAdapter的第二个参数： <strong>android.R.layout.simple_expandable_list_item_1</strong> 其实这些是系统给我们提供好的一些ListView模板，有下面几种：</p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210330213158005.png" alt="image-20210330213158005"></p>
<h3 id="2）SimpleAdapter使用示例："><a href="#2）SimpleAdapter使用示例：" class="headerlink" title="2）SimpleAdapter使用示例："></a>2）SimpleAdapter使用示例：</h3><p>SimpleAdapter：简单的Adapter，看似简单，功能强大，下面我们来写个稍微复杂一点的列表 布局吧！</p>
<p><strong>运行效果图：</strong></p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210330213213480.png" alt="image-20210330213213480"></p>
<p><strong>代码实现：</strong></p>
<p>先来编写一个列表项目每一项的布局：</p>
<p><strong>list_item.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义一个用于显示头像的ImageView --&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/imgtou&quot;</span><br><span class="line">        android:layout_width=&quot;64dp&quot;</span><br><span class="line">        android:layout_height=&quot;64dp&quot;</span><br><span class="line">        android:baselineAlignBottom=&quot;true&quot;</span><br><span class="line">        android:paddingLeft=&quot;8dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义一个竖直方向的LinearLayout,把QQ呢称与说说的文本框设置出来 --&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/name&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:paddingLeft=&quot;8dp&quot;</span><br><span class="line">            android:textColor=&quot;#1D1D1C&quot;</span><br><span class="line">            android:textSize=&quot;20sp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/says&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:paddingLeft=&quot;8px&quot;</span><br><span class="line">            android:textColor=&quot;#B4B4B9&quot;</span><br><span class="line">            android:textSize=&quot;14sp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>接下来是<strong>MainActivity.java</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private String[] names = new String[]&#123;&quot;B神&quot;, &quot;基神&quot;, &quot;曹神&quot;&#125;;</span><br><span class="line">    private String[] says = new String[]&#123;&quot;无形被黑，最为致命&quot;, &quot;大神好厉害~&quot;, &quot;我将带头日狗~&quot;&#125;;</span><br><span class="line">    private int[] imgIds = new int[]&#123;R.mipmap.head_icon1, R.mipmap.head_icon2, R.mipmap.head_icon3&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; listitem = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; names.length; i++) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; showitem = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            showitem.put(&quot;touxiang&quot;, imgIds[i]);</span><br><span class="line">            showitem.put(&quot;name&quot;, names[i]);</span><br><span class="line">            showitem.put(&quot;says&quot;, says[i]);</span><br><span class="line">            listitem.add(showitem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建一个simpleAdapter</span><br><span class="line">        SimpleAdapter myAdapter = new SimpleAdapter(getApplicationContext(), listitem, R.layout.list_item, new String[]&#123;&quot;touxiang&quot;, &quot;name&quot;, &quot;says&quot;&#125;, new int[]&#123;R.id.imgtou, R.id.name, R.id.says&#125;);</span><br><span class="line">        ListView listView = (ListView) findViewById(R.id.list_test);</span><br><span class="line">        listView.setAdapter(myAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，上面就是SimpleAdapter的简单用法了，有点意思</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="button设置颜色但是不起作用"><a href="#button设置颜色但是不起作用" class="headerlink" title="button设置颜色但是不起作用"></a>button设置颜色但是不起作用</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102214229757.png" alt="image-20211102214229757"></p>
<h2 id="activity没有响应跳转"><a href="#activity没有响应跳转" class="headerlink" title="activity没有响应跳转"></a>activity没有响应跳转</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> NotificationManager manager;</span><br><span class="line"><span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)</span><br><span class="line">    &#123;</span><br><span class="line">        NotificationChannel notificationChannel = <span class="keyword">new</span> NotificationChannel(<span class="string">&quot;onlychannelID&quot;</span>, <span class="string">&quot;测试通知&quot;</span>, NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line">        manager.createNotificationChannel(notificationChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写完之后可能没有跳转，为啥呢，在NotificationActivity里要注册一下，点住类名，按住Alt+Enter，点击Add activity to manifest</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, NotificationActivity.class);</span><br><span class="line">    PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前三个属性是必须设置的</span></span><br><span class="line">    notification= <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">&quot;onlychannelID&quot;</span>)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;通知测试&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;通知测试通知测试&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_baseline_stairs_24)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.image))</span><br><span class="line">            .setColor(Color.parseColor(<span class="string">&quot;#FF0000&quot;</span>))</span><br><span class="line">            .setContentIntent(pendingIntent)</span><br><span class="line">            .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActionBar所在的位置"><a href="#ActionBar所在的位置" class="headerlink" title="ActionBar所在的位置"></a>ActionBar所在的位置</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211102223754785.png" alt="image-20211102223754785"></p>
<h2 id="Alt-insert"><a href="#Alt-insert" class="headerlink" title="Alt+insert"></a>Alt+insert</h2><h1 id="添加高德地图"><a href="#添加高德地图" class="headerlink" title="添加高德地图"></a>添加高德地图</h1><h2 id="1-申请高德地图开放平台的key"><a href="#1-申请高德地图开放平台的key" class="headerlink" title="1.申请高德地图开放平台的key"></a>1.申请高德地图开放平台的key</h2><p> <a href="https://console.amap.com/dev/key/app">https://console.amap.com/dev/key/app</a></p>
<p>1.1 创建应用，添加，设置packageName和SHA1，其中packageName是工程中build.gradle的applicationId</p>
<p>1.2 命令行，输入where keytool -》 keytool -v -list -keystore C:\Users\Administrator.android\debug.keystore，这个是dubug版本的，把SHA1输入开放平台，得到一个Key</p>
<h2 id="2-配置工程"><a href="#2-配置工程" class="headerlink" title="2.配置工程"></a>2.配置工程</h2><h3 id="2-1-第一种方式-app-gt-build-gradle"><a href="#2-1-第一种方式-app-gt-build-gradle" class="headerlink" title="2.1 第一种方式 app  -&gt;  build.gradle"></a>2.1 第一种方式 app  -&gt;  build.gradle</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.mymaptest&quot;</span></span><br><span class="line">        minSdk <span class="number">21</span></span><br><span class="line">        targetSdk <span class="number">26</span> <span class="comment">//原来是31，可能有点高，改成了26</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="function">minifyEnabled <span class="keyword">false</span></span></span><br><span class="line"><span class="function">            proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>)</span>, &#x27;proguard-rules.pro&#x27;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    compileOptions </span>&#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.android.material:material:1.3.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.+&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//高德地图</span></span><br><span class="line">    <span class="function">implementation <span class="title">fileTree</span><span class="params">(dir: <span class="string">&#x27;libs&#x27;</span>, include: [<span class="string">&#x27;*.jar&#x27;</span>])</span></span></span><br><span class="line"><span class="function">    <span class="comment">//3D地图so及jar</span></span></span><br><span class="line"><span class="function">    implementation &#x27;com.amap.api:3dmap:latest.integration&#x27;</span></span><br><span class="line"><span class="function">    <span class="comment">//定位功能</span></span></span><br><span class="line"><span class="function">    implementation &#x27;com.amap.api:location:latest.integration&#x27;</span></span><br><span class="line"><span class="function">    <span class="comment">//搜索功能</span></span></span><br><span class="line"><span class="function">    implementation &#x27;com.amap.api:search:latest.integration&#x27;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>project -&gt;  build.gradle</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()<span class="comment">//保证有这个</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:7.0.3&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意修改完之后需要同步！</p>
<h3 id="2-2-第二种方式-添加jar和so文件"><a href="#2-2-第二种方式-添加jar和so文件" class="headerlink" title="2.2 第二种方式 添加jar和so文件"></a>2.2 第二种方式 添加jar和so文件</h3><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124233844113.png" alt="image-20211124233844113"></p>
<p>创建两个文件夹，有的话就不用创建，把jar和armeabi、x86拷进去，一定要注意</p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124233949924.png" alt="image-20211124233949924"></p>
<p>这个一定要有，妈的，没有这个一直黑屏，在app的gradle里面加上cpu筛选！！！！！</p>
<h2 id="3-添加mapview"><a href="#3-添加mapview" class="headerlink" title="3.添加mapview"></a>3.添加mapview</h2><p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.amap.api.maps.MapView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/map&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mymaptest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.amap.api.maps.AMap;</span><br><span class="line"><span class="keyword">import</span> com.amap.api.maps.MapView;</span><br><span class="line"><span class="keyword">import</span> com.amap.api.maps.MapsInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MapView mMapView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//隐私合规校验失败：</span></span><br><span class="line">        MapsInitializer.updatePrivacyShow(<span class="keyword">this</span>,<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line">        MapsInitializer.updatePrivacyAgree(<span class="keyword">this</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取地图控件引用</span></span><br><span class="line">        mMapView = (MapView) findViewById(R.id.map);</span><br><span class="line">        <span class="comment">//在activity执行onCreate时执行mMapView.onCreate(savedInstanceState)，创建地图</span></span><br><span class="line">        mMapView.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//在activity执行onDestroy时执行mMapView.onDestroy()，销毁地图</span></span><br><span class="line">        mMapView.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="comment">//在activity执行onResume时执行mMapView.onResume ()，重新绘制加载地图</span></span><br><span class="line">        mMapView.onResume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        <span class="comment">//在activity执行onPause时执行mMapView.onPause ()，暂停地图的绘制</span></span><br><span class="line">        mMapView.onPause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        <span class="comment">//在activity执行onSaveInstanceState时执行mMapView.onSaveInstanceState (outState)，保存地图当前的状态</span></span><br><span class="line">        mMapView.onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>manifest</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.mymaptest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许访问网络，必选权限--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许获取粗略位置，若用GPS实现定位小蓝点功能则必选--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许获取设备和运营商信息，用于问题排查和网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许获取网络状态，用于网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许获取wifi网络信息，用于网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许获取wifi状态改变，用于网络定位，若无gps但仍需实现定位小蓝点功能则此权限必选--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CHANGE_WIFI_STATE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许写入扩展存储，用于数据缓存，若无此权限则写到私有目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许写设备缓存，用于问题排查--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--允许读设备等信息，用于问题排查--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.MyMapTest&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;com.amap.api.v2.apikey&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;8d558066019e07d8ed92d91d568b2b6a	&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-模拟器黑屏白屏的问题"><a href="#4-模拟器黑屏白屏的问题" class="headerlink" title="4.模拟器黑屏白屏的问题"></a>4.模拟器黑屏白屏的问题</h2><p>有可能是版本太高，有可能是库不对，我静态加载进来的时候是不行的、</p>
<h2 id="5-模拟器能显示地图范围，但是就是显示不出来地图内容"><a href="#5-模拟器能显示地图范围，但是就是显示不出来地图内容" class="headerlink" title="5.模拟器能显示地图范围，但是就是显示不出来地图内容"></a>5.模拟器能显示地图范围，但是就是显示不出来地图内容</h2><p>可能是连不了网，需要先给模拟器联网</p>
<ol>
<li>确保你的模拟器处于打开状态。</li>
<li>键盘win+r然后输入cmd调出命令框。</li>
<li>定位到你的sdk目录下的platform-tools文件下：<br><img src="https://www.pianshen.com/images/871/c744ffb79e6d0cd794cfda09c7ff4c37.png" alt="在这里插入图片描述"></li>
<li>输入adb root获取权限。（这一步如果没有做会导致后面一步无法看到模拟器的dns配置并且无法更改哦）<br><img src="https://www.pianshen.com/images/567/a15e2b69a6500d9f83666df2cacdcbf7.png" alt="在这里插入图片描述"></li>
<li>输入adb shell进入shell。<br><img src="https://www.pianshen.com/images/55/e007660767a4ac7dba620cee26ee42d7.png" alt="在这里插入图片描述"></li>
<li>输入getprop命令查看模拟器的信息。<br><img src="https://www.pianshen.com/images/830/7b5d06562cb6de7c8f7e18c1d0daecde.png" alt="在这里插入图片描述"><br>往下拉可以找到dns的配置信息：<br><img src="https://www.pianshen.com/images/322/b60bb27626945771e57916b079d8ed82.png" alt="在这里插入图片描述"></li>
<li>输入命令setprop net.dns1 127.0.0.123将模拟器的dns与电脑统一。<br><img src="https://www.pianshen.com/images/943/9e7e881eae8fe6122e5786cd421a38b7.png" alt="在这里插入图片描述"><br>接下来可以再次输入getprop命令来查看模拟器的dns配置是否成功修改：<br><img src="https://www.pianshen.com/images/955/2c031bff61e1ba336654a1f6bf049a9b.png" alt="在这里插入图片描述"></li>
<li>修改成功之后就你的模拟器就应该可以正常上网了。<br>打开百度：<br><img src="https://www.pianshen.com/images/525/ff0951115e59bcf83b15a70f65a0873d.png" alt="在这里插入图片描述"></li>
</ol>
<h2 id="6-完了之后还不行，有可能是GPU的锅，"><a href="#6-完了之后还不行，有可能是GPU的锅，" class="headerlink" title="6.完了之后还不行，有可能是GPU的锅，"></a>6.完了之后还不行，有可能是GPU的锅，</h2><p>高德地图 V2 版本采用 opengl 技术绘制，支持 Android2.2 及以上系统。</p>
<p>所以模拟器需要支持，在模拟器设置里面选择emulation</p>
<p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211120203225670.png" alt="image-20211120203225670"></p>
<h2 id="7-Android-KO-authentication-token-does-not-match-emulator-console-auth-token"><a href="#7-Android-KO-authentication-token-does-not-match-emulator-console-auth-token" class="headerlink" title="7.Android  KO: authentication token does not match ~/.emulator_console_auth_token"></a>7.Android  KO: authentication token does not match ~/.emulator_console_auth_token</h2><p>在Windows上，该文件位于当前用户文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\Users\&lt;current_user&gt;\.emulator_console_auth_token </span><br></pre></td></tr></table></figure>

<p>您可以使用记事本打开该文件并复制令牌。</p>
<p>现在，你可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth your-token-here</span><br></pre></td></tr></table></figure>

<h2 id="8-不显示标题栏"><a href="#8-不显示标题栏" class="headerlink" title="8. 不显示标题栏"></a>8. 不显示标题栏</h2><p><img src="/2021/10/31/Android/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123221557126.png" alt="image-20211123221557126"></p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p><img src="/2021/10/31/Android/oOo\source_posts\Android\image-20220521200126624.png" alt="image-20220521200126624"></p>
<p><strong>注意事项：</strong></p>
<blockquote>
<ol>
<li><p>onPause()和onStop()被调用的前提是**： 打开了一个新的Activity！而前者是旧Activity还可见的状态；后者是旧Activity已经不可见！</p>
</li>
<li><p>另外，亲测：AlertDialog和PopWindow是不会触发上述两个回调方法的~</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-highlevel</title>
    <url>/2021/10/19/OpenGL-highlevel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h1><p>在[坐标系统](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/08 Coordinate Systems/)小节中，我们渲染了一个3D箱子，并且运用了深度缓冲(Depth Buffer)来防止被阻挡的面渲染到其它面的前面。在这一节中，我们将会更加深入地讨论这些储存在深度缓冲（或z缓冲(z-buffer)）中的深度值(Depth Value)，以及它们是如何确定一个片段是处于其它片段后方的。</p>
<p>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。</p>
<p>当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。</p>
<p>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后，我们将在[下一节](<a href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL/02 Stencil testing/)中讨论）在屏幕空间中运行的。屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。</p>
<blockquote>
<p>现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</p>
<p>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。</p>
</blockquote>
<p>深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure>

<p>当它启用的时候，如果一个片段通过了深度测试的话，OpenGL会在深度缓冲中储存该片段的z值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>

<p>可以想象，在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但<strong>不</strong>希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。OpenGL允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为<code>GL_FALSE</code>就可以了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDepthMask</span>(GL_FALSE);</span><br></pre></td></tr></table></figure>

<p>注意这只在深度测试被启用的时候才有效果。</p>
<h2 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h2><p>OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glDepthFunc(GL_LESS);</span><br></pre></td></tr></table></figure>

<p>这个函数接受下面表格中的比较运算符：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GL_ALWAYS</td>
<td align="left">永远通过深度测试</td>
</tr>
<tr>
<td align="left">GL_NEVER</td>
<td align="left">永远不通过深度测试</td>
</tr>
<tr>
<td align="left">GL_LESS</td>
<td align="left">在片段深度值小于缓冲的深度值时通过测试</td>
</tr>
<tr>
<td align="left">GL_EQUAL</td>
<td align="left">在片段深度值等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td align="left">GL_LEQUAL</td>
<td align="left">在片段深度值小于等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td align="left">GL_GREATER</td>
<td align="left">在片段深度值大于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td align="left">GL_NOTEQUAL</td>
<td align="left">在片段深度值不等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td align="left">GL_GEQUAL</td>
<td align="left">在片段深度值大于等于缓冲区的深度值时通过测试</td>
</tr>
</tbody></table>
<p>默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。</p>
<p>让我们看看改变深度函数会对视觉输出有什么影响。我们将使用一个新的代码配置，它会显示一个没有光照的基本场景，里面有两个有纹理的立方体，放置在一个有纹理的地板上。你可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/1.1.depth_testing/depth_testing.cpp">这里</a>找到源代码。</p>
<p>在源代码中，我们将深度函数改为GL_ALWAYS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDepthFunc(GL_ALWAYS);</span><br></pre></td></tr></table></figure>

<p>这将会模拟我们没有启用深度测试时所得到的结果。深度测试将会永远通过，所以最后绘制的片段将会总是会渲染在之前绘制片段的上面，即使之前绘制的片段本就应该渲染在最前面。因为我们是最后渲染地板的，它会覆盖所有的箱子片段：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_testing_func_always.png" alt="img"></p>
<p>将它重新设置为GL_LESS，这会将场景还原为原有的样子：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_testing_func_less.png" alt="img"></p>
<h2 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h2><p>深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的<strong>近平面</strong>(Near)和<strong>远平面</strong>(Far)之间的任何值。我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间，其中的一种方式就是将它们线性变换到[0, 1]范围之间。下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值：<br>$$<br>Fdepth=(z−near)/(far−near)<br>$$<br>这里的nearnear和farfar值是我们之前提供给投影矩阵设置可视平截头体的（见[坐标系统](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/08 Coordinate Systems/)）那个 <em>near</em> 和 <em>far</em> 值。这个方程需要平截头体中的一个z值，并将它变换到了[0, 1]的范围中。z值和对应的深度值之间的关系可以在下图中看到：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_linear_graph.png" alt="img"></p>
<blockquote>
<p>注意所有的方程都会将非常近的物体的深度值设置为接近0.0的值，而当物体非常接近远平面的时候，它的深度值会非常接近1.0。</p>
</blockquote>
<p>然而，在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。</p>
<p>由于非线性方程与 1/z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：<br>$$<br>Fdepth=(1/z−1/near)/(1/far−1/near)<br>$$<br>如果你不知道这个方程是怎么回事也不用担心。重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。深度缓冲中0.5的值并不代表着物体的z值是位于平截头体的中间了，这个顶点的z值实际上非常接近近平面！你可以在下图中看到z值和最终的深度缓冲值之间的非线性关系：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_non_linear_graph.png" alt="img"></p>
<p>可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。如果你想深度了解投影矩阵究竟做了什么，我建议阅读<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">这篇文章</a>。</p>
<p>如果我们想要可视化深度缓冲的话，非线性方程的效果很快就会变得很清楚。</p>
<h2 id="深度缓冲的可视化"><a href="#深度缓冲的可视化" class="headerlink" title="深度缓冲的可视化"></a>深度缓冲的可视化</h2><p>我们知道片段着色器中，内建gl_FragCoord向量的z值包含了那个特定片段的深度值。如果我们将这个深度值输出为颜色，我们可以显示场景中所有片段的深度值。我们可以根据片段的深度值返回一个颜色向量来完成这一工作：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="built_in">gl_FragCoord</span>.z), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你再次运行程序的话，你可能会注意到所有东西都是白色的，看起来就想我们所有的深度值都是最大的1.0。所以为什么没有靠近0.0（即变暗）的深度值呢？</p>
<p>你可能还记得在上一部分中说到，屏幕空间中的深度值是非线性的，即它在z值很小的时候有很高的精度，而z值很大的时候有较低的精度。片段的深度值会随着距离迅速增加，所以几乎所有的顶点的深度值都是接近于1.0的。如果我们小心地靠近物体，你可能会最终注意到颜色会渐渐变暗，显示它们的z值在逐渐变小：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_testing_visible_depth.png" alt="img"></p>
<p>这很清楚地展示了深度值的非线性性质。近处的物体比起远处的物体对深度值有着更大的影响。只需要移动几厘米就能让颜色从暗完全变白。</p>
<p>然而，我们也可以让片段非线性的深度值变换为线性的。要实现这个，我们需要仅仅反转深度值的投影变换。这也就意味着我们需要首先将深度值从[0, 1]范围重新变换到[-1, 1]范围的标准化设备坐标（裁剪空间）。接下来我们需要像投影矩阵那样反转这个非线性方程（方程2），并将这个反转的方程应用到最终的深度值上。最终的结果就是一个线性的深度值了。听起来是可行的，对吧？</p>
<p>首先我们将深度值变换为NDC，不是非常困难：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float z = depth * 2.0 - 1.0;</span><br></pre></td></tr></table></figure>

<p>接下来使用获取到的z值，应用逆变换来获取线性的深度值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float linearDepth = (2.0 * near * far) / (far + near - z * (far - near));</span><br></pre></td></tr></table></figure>

<p>这个方程是用投影矩阵推导得出的，它使用了方程2来非线性化深度值，返回一个near与far之间的深度值。这篇注重数学的<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">文章</a>为感兴趣的读者详细解释了投影矩阵，它也展示了这些方程是怎么来的。</p>
<p>将屏幕空间中非线性的深度值变换至线性深度值的完整片段着色器如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">float near = 0.1; </span><br><span class="line">float far  = 100.0; </span><br><span class="line"></span><br><span class="line">float LinearizeDepth(float depth) </span><br><span class="line">&#123;</span><br><span class="line">    float z = depth * 2.0 - 1.0; // back to NDC </span><br><span class="line">    return (2.0 * near * far) / (far + near - z * (far - near));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;             </span><br><span class="line">    float depth = LinearizeDepth(gl_FragCoord.z) / far; // 为了演示除以 far</span><br><span class="line">    FragColor = vec4(vec3(depth), 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于线性化的深度值处于near与far之间，它的大部分值都会大于1.0并显示为完全的白色。通过在main函数中将线性深度值除以far，我们近似地将线性深度值转化到[0, 1]的范围之间。这样子我们就能逐渐看到一个片段越接近投影平截头体的远平面，它就会变得越亮，更适用于展示目的。</p>
<p>如果我们现在运行程序，我们就能看见深度值随着距离增大是线性的了。尝试在场景中移动，看看深度值是怎样以线性变化的。</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_testing_visible_linear.png" alt="img"></p>
<p>颜色大部分都是黑色，因为深度值的范围是0.1的<strong>近</strong>平面到100的<strong>远</strong>平面，它离我们还是非常远的。结果就是，我们相对靠近近平面，所以会得到更低的（更暗的）深度值。</p>
<h2 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h2><p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p>
<p>在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。</p>
<p>如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/depth_testing_z_fighting.png" alt="img"></p>
<p>深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突、</p>
<h3 id="防止深度冲突"><a href="#防止深度冲突" class="headerlink" title="防止深度冲突"></a>防止深度冲突</h3><p>第一个也是最重要的技巧是<strong>永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠</strong>。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p>
<p>第二个技巧是<strong>尽可能将近平面设置远一些</strong>。在前面我们提到了精度在靠近<strong>近</strong>平面时是非常高的，所以如果我们将<strong>近</strong>平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的<strong>近</strong>平面距离。</p>
<p>另外一个很好的技巧是牺牲一些性能，<strong>使用更高精度的深度缓冲</strong>。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p>
<p>我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。</p>
<h1 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h1><p>当片段着色器处理完一个片段之后，**模板测试(Stencil Test)<strong>会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做</strong>模板缓冲(Stencil Buffer)**，我们可以在渲染的时候更新它来获得一些很有意思的效果。</p>
<p>一个模板缓冲中，（通常）每个**模板值(Stencil Value)**是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。</p>
<blockquote>
<p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p>
</blockquote>
<p>模板缓冲的一个简单的例子如下：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/stencil_buffer.png" alt="img"></p>
<p>模板缓冲首先会被清除为0，之后在模板缓冲中使用1填充了一个空心矩形。场景中的片段将会只在片段的模板值为1的时候会被渲染（其它的都被丢弃了）。</p>
<p>模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们<strong>写入</strong>了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以<strong>读取</strong>这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：</p>
<ul>
<li>启用模板缓冲的写入。</li>
<li>渲染物体，更新模板缓冲的内容。</li>
<li>禁用模板缓冲的写入。</li>
<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li>
</ul>
<p>所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。</p>
<p>你可以启用GL_STENCIL_TEST来启用模板测试。在这一行代码之后，所有的渲染调用都会以某种方式影响着模板缓冲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br></pre></td></tr></table></figure>

<p>注意，和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br></pre></td></tr></table></figure>

<p>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为<code>0x00</code>，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); <span class="comment">// 每一位写入模板缓冲时都保持原样</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br></pre></td></tr></table></figure>

<p>大部分情况下你都只会使用<code>0x00</code>或者<code>0xFF</code>作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。</p>
<h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><p>和深度测试一样，我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。一共有两个函数能够用来配置模板测试：glStencilFunc和glStencilOp。</p>
<p>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：</p>
<ul>
<li><code>func</code>：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的<code>ref</code>值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li>
<li><code>ref</code>：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li>
<li><code>mask</code>：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</li>
</ul>
<p>在一开始的那个简单的模板例子中，函数被设置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glStencilFunc(GL_EQUAL, 1, 0xFF)</span><br></pre></td></tr></table></figure>

<p>这会告诉OpenGL，只要一个片段的模板值等于(<code>GL_EQUAL</code>)参考值1，片段将会通过测试并被绘制，否则会被丢弃。</p>
<p>但是glStencilFunc仅仅描述了OpenGL应该对模板缓冲内容做什么，而不是我们应该如何更新缓冲。这就需要glStencilOp这个函数了。</p>
<p>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，我们能够设定每个选项应该采取的行为：</p>
<ul>
<li><code>sfail</code>：模板测试失败时采取的行为。</li>
<li><code>dpfail</code>：模板测试通过，但深度测试失败时采取的行为。</li>
<li><code>dppass</code>：模板测试和深度测试都通过时采取的行为。</li>
</ul>
<p>每个选项都可以选用以下的其中一种行为：</p>
<table>
<thead>
<tr>
<th align="left">行为</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GL_KEEP</td>
<td align="left">保持当前储存的模板值</td>
</tr>
<tr>
<td align="left">GL_ZERO</td>
<td align="left">将模板值设置为0</td>
</tr>
<tr>
<td align="left">GL_REPLACE</td>
<td align="left">将模板值设置为glStencilFunc函数设置的<code>ref</code>值</td>
</tr>
<tr>
<td align="left">GL_INCR</td>
<td align="left">如果模板值小于最大值则将模板值加1</td>
</tr>
<tr>
<td align="left">GL_INCR_WRAP</td>
<td align="left">与GL_INCR一样，但如果模板值超过了最大值则归零</td>
</tr>
<tr>
<td align="left">GL_DECR</td>
<td align="left">如果模板值大于最小值则将模板值减1</td>
</tr>
<tr>
<td align="left">GL_DECR_WRAP</td>
<td align="left">与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td>
</tr>
<tr>
<td align="left">GL_INVERT</td>
<td align="left">按位翻转当前的模板缓冲值</td>
</tr>
</tbody></table>
<p>默认情况下glStencilOp是设置为<code>(GL_KEEP, GL_KEEP, GL_KEEP)</code>的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</p>
<p>所以，通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。</p>
<h2 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h2><p>仅仅看了前面的部分你还是不太可能能够完全理解模板测试的工作原理，所以我们将会展示一个使用模板测试就可以完成的有用特性，它叫做物体轮廓(Object Outlining)。</p>
<p><img src="/2021/10/19/OpenGL-highlevel/stencil_object_outlining.png" alt="img"></p>
<p>物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：</p>
<ol>
<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li>
<li>渲染物体。</li>
<li>禁用模板写入以及深度测试。</li>
<li>将每个物体缩放一点点。</li>
<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>
<li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li>
<li>再次启用模板写入和深度测试。</li>
</ol>
<p>这个过程将每个物体的片段的模板缓冲设置为1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。</p>
<p>所以我们首先来创建一个很简单的片段着色器，它会输出一个边框颜色。我们简单地给它设置一个硬编码的颜色值，将这个着色器命名为shaderSingleColor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vec4(0.04, 0.28, 0.26, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只想给那两个箱子加上边框，所以我们让地板不参与这个过程。我们希望首先绘制地板，再绘制两个箱子（并写入模板缓冲），之后绘制放大的箱子（并丢弃覆盖了之前绘制的箱子片段的那些片段）。</p>
<p>我们首先启用模板测试，并设置测试通过或失败时的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glEnable(GL_STENCIL_TEST);</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);</span><br></pre></td></tr></table></figure>

<p>如果其中的一个测试失败了，我们什么都不做，我们仅仅保留当前储存在模板缓冲中的值。如果模板测试和深度测试都通过了，那么我们希望将储存的模板值设置为参考值，参考值能够通过glStencilFunc来设置，我们之后会设置为1。</p>
<p>我们将模板缓冲清除为0，对箱子中所有绘制的片段，将模板值更新为1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glStencilFunc(GL_ALWAYS, 1, 0xFF); // 所有的片段都应该更新模板缓冲</span><br><span class="line">glStencilMask(0xFF); // 启用模板缓冲写入</span><br><span class="line">normalShader.use();</span><br><span class="line">DrawTwoContainers();</span><br></pre></td></tr></table></figure>

<p>通过使用GL_ALWAYS模板测试函数，我们保证了箱子的每个片段都会将模板缓冲的模板值更新为1。因为片段永远会通过模板测试，在绘制片段的地方，模板缓冲会被更新为参考值。</p>
<p>现在模板缓冲在箱子被绘制的地方都更新为1了，我们将要绘制放大的箱子，但这次要禁用模板缓冲的写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glStencilFunc(GL_NOTEQUAL, 1, 0xFF);</span><br><span class="line">glStencilMask(0x00); // 禁止模板缓冲的写入</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line">shaderSingleColor.use(); </span><br><span class="line">DrawTwoScaledUpContainers();</span><br></pre></td></tr></table></figure>

<p>我们将模板函数设置为GL_NOTEQUAL，它会保证我们只绘制箱子上模板值不为1的部分，即只绘制箱子在之前绘制的箱子之外的部分。注意我们也禁用了深度测试，让放大的箱子，即边框，不会被地板所覆盖。</p>
<p>记得要在完成之后重新启用深度缓冲。</p>
<p>场景中物体轮廓的完整步骤会看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  </span><br><span class="line"></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); </span><br><span class="line"></span><br><span class="line">glStencilMask(0x00); // 记得保证我们在绘制地板的时候不会更新模板缓冲</span><br><span class="line">normalShader.use();</span><br><span class="line">DrawFloor()  </span><br><span class="line"></span><br><span class="line">glStencilFunc(GL_ALWAYS, 1, 0xFF); </span><br><span class="line">glStencilMask(0xFF); </span><br><span class="line">DrawTwoContainers();</span><br><span class="line"></span><br><span class="line">glStencilFunc(GL_NOTEQUAL, 1, 0xFF);</span><br><span class="line">glStencilMask(0x00); </span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line">shaderSingleColor.use(); </span><br><span class="line">DrawTwoScaledUpContainers();</span><br><span class="line">glStencilMask(0xFF);</span><br><span class="line">glEnable(GL_DEPTH_TEST);  </span><br></pre></td></tr></table></figure>

<p>只要你理解了模板缓冲背后的大体思路，这个代码片段就不是那么难理解了。如果还是不能理解的话，尝试再次仔细阅读之前的部分，并尝试通过上面使用的范例，完全理解每个函数的功能。</p>
<p>在[深度测试](<a href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL/01 Depth testing/)小节的场景中，这个轮廓算法的结果看起来会像是这样的：</p>
<p><img src="/2021/10/19/OpenGL-highlevel/stencil_scene_outlined.png" alt="img"></p>
<p>可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/2.stencil_testing/stencil_testing.cpp">这里</a>查看源代码，看看物体轮廓算法的完整代码。</p>
<p>你可以看到这两个箱子的边框重合了，这通常都是我们想要的结果（想想策略游戏中，我们希望选择10个单位，合并边框通常是我们想需要的结果）。如果你想让每个物体都有一个完整的边框，你需要对每个物体都清空模板缓冲，并有创意地利用深度缓冲。</p>
<p>你看到的物体轮廓算法在需要显示选中物体的游戏（想想策略游戏）中非常常见。这样的算法能够在一个模型类中轻松实现。你可以在模型类中设置一个boolean标记，来设置需不需要绘制边框。如果你有创造力的话，你也可以使用后期处理滤镜(Filter)，像是高斯模糊(Gaussian Blur)，让边框看起来更自然。</p>
<p>除了物体轮廓之外，模板测试还有很多用途，比如在一个后视镜中绘制纹理，让它能够绘制到镜子形状中，或者使用一个叫做阴影体积(Shadow Volume)的模板缓冲技术渲染实时阴影。模板缓冲为我们已经很丰富的OpenGL工具箱又提供了一个很好的工具。</p>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL_3D</title>
    <url>/2021/09/21/OpenGL-3D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><ul>
<li><strong>OpenGL</strong>： 一个定义了函数布局和输出的图形API的正式规范。</li>
<li><strong>GLAD</strong>： 一个拓展加载库，用来为我们加载并设定所有OpenGL函数指针，从而让我们能够使用所有（现代）OpenGL函数。</li>
<li>**视口(Viewport)**： 我们需要渲染的窗口。</li>
<li>**图形管线(Graphics Pipeline)**： 一个顶点在呈现为像素之前经过的全部过程。</li>
<li>**着色器(Shader)**： 一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。</li>
<li>**标准化设备坐标(Normalized Device Coordinates, NDC)**： 顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见。</li>
<li>**顶点缓冲对象(Vertex Buffer Object)**： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。</li>
<li>**顶点数组对象(Vertex Array Object)**： 存储缓冲区和顶点属性状态。</li>
<li>**索引缓冲对象(Element Buffer Object)**： 一个存储索引供索引化绘制使用的缓冲对象。</li>
<li><strong>Uniform</strong>： 一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且只需要被设定一次。</li>
<li>**纹理(Texture)**： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。</li>
<li>**纹理缠绕(Texture Wrapping)**： 定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式。</li>
<li>**纹理过滤(Texture Filtering)**： 定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式。这通常在纹理被放大情况下发生。</li>
<li>**多级渐远纹理(Mipmaps)**： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。</li>
<li><strong>stb_image.h</strong>： 图像加载库。</li>
<li>**纹理单元(Texture Units)**： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。</li>
<li>**向量(Vector)**： 一个定义了在空间中方向和/或位置的数学实体。</li>
<li>**矩阵(Matrix)**： 一个矩形阵列的数学表达式。</li>
<li><strong>GLM</strong>： 一个为OpenGL打造的数学库。</li>
<li>**局部空间(Local Space)**： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。</li>
<li>**世界空间(World Space)**： 所有的坐标都相对于全局原点。</li>
<li>**观察空间(View Space)**： 所有的坐标都是从摄像机的视角观察的。</li>
<li>**裁剪空间(Clip Space)**： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL负责处理剩下的事情（裁剪/透视除法）。</li>
<li>**屏幕空间(Screen Space)**： 所有的坐标都由屏幕视角来观察。坐标的范围是从0到屏幕的宽/高。</li>
<li><strong>LookAt矩阵</strong>： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。</li>
<li>**欧拉角(Euler Angles)**： 被定义为偏航角(Yaw)，俯仰角(Pitch)，和滚转角(Roll)从而允许我们通过这三个值构造任何3D方向。</li>
</ul>
<h1 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h1><p>GLM是OpenGL Mathematics的缩写，它是一个****只有头文件的*<em><strong>库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的<a href="https://glm.g-truc.net/0.9.8/index.html">网站</a>上下载。把头文件的根目录复制到你的</strong></em>*includes****文件夹，然后你就可以使用这个库了。</p>
<blockquote>
<p>GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 glm::mat4 mat = glm::mat4(1.0f)。如果你想与本教程的代码保持一致，请使用低于0.9.9版本的GLM，或者改用上述代码初始化所有的矩阵。</p>
</blockquote>
<p>我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>我们来看看是否可以利用我们刚学的变换知识把一个向量(1, 0, 0)位移(1, 1, 0)个单位（注意，我们把它定义为一个glm::vec4类型的值，齐次坐标设定为1.0）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本</span></span><br><span class="line"><span class="comment">// 下面这行代码就需要改为:</span></span><br><span class="line"><span class="comment">// glm::mat4 trans = glm::mat4(1.0f)</span></span><br><span class="line"><span class="comment">// 之后将不再进行提示</span></span><br><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line">std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>我们先用GLM内建的向量类定义一个叫做vec的向量。接下来定义一个mat4类型的trans，默认是一个4×4单位矩阵。下一步是创建一个变换矩阵，我们是把单位矩阵和一个位移向量传递给glm::translate函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。 之后我们把向量乘以位移矩阵并且输出最后的结果。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是(1 + 1, 0 + 1, 0 + 0)，也就是(2, 1, 0)。这个代码片段将会输出210，所以这个位移矩阵是正确的。</p>
<p>我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把箱子逆时针旋转90度。然后缩放0.5倍，使它变成原来的一半大。我们先来创建变换矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure>

<p>首先，我们把箱子在每个轴都缩放到0.5倍，然后沿z轴旋转90度。GLM希望它的角度是弧度制的(Radian)，所以我们使用glm::radians将角度转化为弧度。注意有纹理的那面矩形是在XY平面上的，所以我们需要把它绕着z轴旋转。因为我们把这个矩阵传递给了GLM的每个函数，GLM会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。</p>
<p>下一个大问题是：如何把矩阵传递给着色器？我们在前面简单提到过GLSL里也有一个mat4类型。所以我们将修改顶点着色器让其接收一个mat4的uniform变量，然后再用矩阵uniform乘以位置向量：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> transform;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = transform * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>f);</span><br><span class="line">    TexCoord = <span class="type">vec2</span>(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GLSL也有mat2和mat3类型从而允许了像向量一样的混合运算。前面提到的所有数学运算（像是标量-矩阵相乘，矩阵-向量相乘和矩阵-矩阵相乘）在矩阵类型里都可以使用。当出现特殊的矩阵运算的时候我们会特别说明。</p>
</blockquote>
<p>在把位置向量传给gl_Position之前，我们先添加一个uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了90度。当然，我们仍需要把变换矩阵传递给着色器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br></pre></td></tr></table></figure>

<p>我们首先查询uniform变量的地址，然后用有Matrix4fv后缀的glUniform函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们我们是否希望对我们的矩阵进行置换(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要置换矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。</p>
<p>我们创建了一个变换矩阵，在顶点着色器中声明了一个uniform，并把矩阵发送给了着色器，着色器会变换我们的顶点坐标。最后的结果应该看起来像这样：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921193228557.png" alt="image-20210921193228557"></p>
<p>完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，看看我们是否可以让箱子随着时间旋转，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。我们使用GLFW的时间函数来获取不同时间的角度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">translate</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, (<span class="keyword">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>

<p>要记住的是前面的例子中我们可以在任何地方声明变换矩阵，但是现在我们必须在每一次迭代中创建它，从而保证我们能够不断更新旋转角度。这也就意味着我们不得不在每次游戏循环的迭代中重新创建变换矩阵。通常在渲染场景的时候，我们也会有多个需要在每次渲染迭代中都用新值重新创建的变换矩阵</p>
<p>在这里我们先把箱子围绕原点(0, 0, 0)旋转，之后，我们把旋转过后的箱子位移到屏幕的右下角。记住，实际的变换顺序应该与阅读顺序相反：尽管在代码中我们先位移再旋转，实际的变换却是先应用旋转再是位移的。明白所有这些变换的组合，并且知道它们是如何应用到物体上是一件非常困难的事情。只有不断地尝试和实验这些变换你才能快速地掌握它们。</p>
<p>如果你做对了，你将看到下面的结果：</p>
<p><a href="https://learnopengl-cn.github.io/img/01/07/transformations.mp4">https://learnopengl-cn.github.io/img/01/07/transformations.mp4</a></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = transform * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">	TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, aTexCoord.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// texture samplers</span></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// linearly interpolate between both textures (80% container, 20% awesomeface)</span></span><br><span class="line">	FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/filesystem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/shader_s.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;5.1.transform.vs&quot;</span>, <span class="string">&quot;5.1.transform.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="comment">// positions          // texture coords</span></span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="comment">// top right</span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom right</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom left</span></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>  <span class="comment">// top left </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// first triangle</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// second triangle</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO, EBO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture coord attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.<span class="built_in">use</span>(); </span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create transformations</span></span><br><span class="line">        glm::mat4 transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// make sure to initialize matrix to identity matrix first</span></span><br><span class="line">        transform = glm::<span class="built_in">rotate</span>(transform, (<span class="keyword">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));<span class="comment">//旋转</span></span><br><span class="line">		transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));<span class="comment">//位移</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// get matrix&#x27;s uniform location and set matrix</span></span><br><span class="line">        ourShader.<span class="built_in">use</span>();</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(transformLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h1><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的****x*<em><strong>，</strong></em>*y*<em><strong>，</strong></em>*z*<em><strong>坐标都应该在</strong></em>*-1.0*<em><strong>到</strong></em>*1.0****之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标<mark class="hl-label blue">(这个过程就是投影变换)</mark> 。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>
<p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个****过渡****坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>
<ul>
<li>· 局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>· 世界空间(World Space)</li>
<li>· 观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>· 裁剪空间(Clip Space)</li>
<li>· 屏幕空间(Screen Space)</li>
</ul>
<p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921155808272.png" alt="image-20210921155808272"></p>
<ol>
<li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li>
<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>
<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>
<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li>
<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>
</ol>
<p>我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>
<h2 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h2><p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说Blender）中创建了一个立方体。你创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在****局部****空间中：它们相对于你的物体来说都是局部的。</p>
<p>我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。</p>
<h2 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h2><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的。</p>
<p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。</p>
<h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。</p>
<h2 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h2><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。</p>
<p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</p>
<p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p>
<p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p>
<p>由投影矩阵创建的<em><strong>*观察箱*</strong></em>(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p>
<p>一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</p>
<p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。</p>
<p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。</p>
<h3 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h3><p>正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921192057442.png" alt="image-20210921192057442"></p>
<p>上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。</p>
<p>要创建一个正射投影矩阵，我们可以使用GLM的内置函数glm::ortho：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::<span class="built_in">ortho</span>(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。</p>
<p>正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>如果你曾经体验过****实际生活****给你带来的景象，你就会注意到离你越远的东西看起来更小。这个奇怪的效果称之为透视(Perspective)。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921192205461.png" alt="image-20210921192205461"></p>
<p>正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921192220575.png" alt="image-20210921192220575"></p>
<p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由Songho写的<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">文章</a>。</p>
<p>在GLM中可以这样创建一个透视投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="keyword">float</span>)width/(<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>同样，glm::perspective所做的其实就是创建了一个定义了可视空间的大****平截头体****，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921192243802.png" alt="image-20210921192243802"></p>
<p>它的第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的****近*<em><strong>和</strong></em>*远****平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p>
<blockquote>
<p>当你把透视矩阵的 <strong>near</strong> 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。</p>
</blockquote>
<p>当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 <strong>Blender</strong> 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在Blender里面使用两种投影方式的对比：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921192344564.png" alt="image-20210921192344564"></p>
<p>你可以看到，使用透视投影的话，远处的顶点看起来比较小，而在正射投影中每个顶点距离观察者的距离都是一样的。</p>
<h3 id="投影的理解"><a href="#投影的理解" class="headerlink" title="投影的理解"></a>投影的理解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//着色器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GL_ES</span></span><br><span class="line"><span class="comment">// Set default precision to medium</span></span><br><span class="line">precision mediump <span class="keyword">int</span>;</span><br><span class="line">precision mediump <span class="keyword">float</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">uniform mat4 btpMat;</span><br><span class="line">attribute vec4 attrPos;</span><br><span class="line">attribute vec2 attrTexCoord;</span><br><span class="line">varying vec2 texture_coord;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = btpMat * attrPos;</span><br><span class="line">    texture_coord = attrTexCoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//帧缓冲</span></span><br><span class="line">m_showPTexture = <span class="keyword">new</span> <span class="built_in">QOpenGLFramebufferObject</span>(width,height);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_showPTexture-&gt;<span class="built_in">texture</span>());</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"></span><br><span class="line"><span class="comment">//着色器程序</span></span><br><span class="line">m_BToPProgram = <span class="keyword">new</span> <span class="built_in">QOpenGLShaderProgram</span>();</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">addShaderFromSourceFile</span>(QOpenGLShader::Vertex, <span class="string">&quot;:/shader/radarShadar/vertex_shader.glsl&quot;</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">addShaderFromSourceFile</span>(QOpenGLShader::Fragment, <span class="string">&quot;:/shader/radarShadar/fragment_shader.glsl&quot;</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">link</span>();</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">bind</span>();</span><br><span class="line">m_btopUniformbtpMat = m_BToPProgram-&gt;<span class="built_in">uniformLocation</span>(<span class="string">&quot;btpMat&quot;</span>);</span><br><span class="line">m_btopvbo-&gt;<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> points = m_lineNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2π,这些点形成了单位圆</span></span><br><span class="line"><span class="keyword">float</span> ls = <span class="number">6.283185</span>/points;</span><br><span class="line"><span class="keyword">float</span> *arrVertex = <span class="keyword">new</span> <span class="keyword">float</span>[(<span class="keyword">int</span>)points*<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> i=<span class="number">0</span>;i&lt;points;i++)&#123;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>] = <span class="built_in">qSin</span>(i*ls);</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">1</span>] = <span class="built_in">qCos</span>(i*ls);</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">2</span>] = <span class="number">0.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">3</span>] = <span class="number">1.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">4</span>] =  (i)/points;</span><br><span class="line"></span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">5</span>] = <span class="number">0.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">6</span>] = <span class="number">0.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">7</span>] = <span class="number">0.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">8</span>] = <span class="number">0.0F</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">9</span>] = (i)/points;</span><br><span class="line"></span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">10</span>] = <span class="built_in">qSin</span>((i+<span class="number">1</span>)*ls);</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">11</span>] = <span class="built_in">qCos</span>((i+<span class="number">1</span>)*ls);</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">12</span>] =  <span class="number">0.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">13</span>] =  <span class="number">1.0f</span>;</span><br><span class="line">arrVertex[(<span class="keyword">int</span>)i*<span class="number">15</span>+<span class="number">14</span>] =  (i+<span class="number">1</span>)/points;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定VAO VBO</span></span><br><span class="line">m_btopvbo-&gt;<span class="built_in">bind</span>();</span><br><span class="line">m_btopvbo-&gt;<span class="built_in">allocate</span>(arrVertex, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)*(<span class="keyword">int</span>)points*<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">m_btopvao = <span class="keyword">new</span> QOpenGLVertexArrayObject;</span><br><span class="line">m_btopvao-&gt;<span class="built_in">create</span>();</span><br><span class="line">m_btopvao-&gt;<span class="built_in">bind</span>();</span><br><span class="line"><span class="keyword">int</span> attr = <span class="number">-1</span>;</span><br><span class="line">attr = m_BToPProgram-&gt;<span class="built_in">attributeLocation</span>(<span class="string">&quot;attrPos&quot;</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">setAttributeBuffer</span>(attr, GL_FLOAT, <span class="number">0</span>,</span><br><span class="line"><span class="number">3</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>) * <span class="number">5</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">enableAttributeArray</span>(attr);</span><br><span class="line"></span><br><span class="line">attr = m_BToPProgram-&gt;<span class="built_in">attributeLocation</span>(<span class="string">&quot;attrTexCoord&quot;</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">setAttributeBuffer</span>(attr, GL_FLOAT, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>),</span><br><span class="line"><span class="number">2</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>) * <span class="number">5</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">enableAttributeArray</span>(attr);</span><br><span class="line">m_btopvao-&gt;<span class="built_in">release</span>();</span><br><span class="line">m_btopvbo-&gt;<span class="built_in">release</span>();</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">release</span>();</span><br><span class="line"><span class="keyword">delete</span> []arrVertex;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">m_showPTexture-&gt;<span class="built_in">bind</span>();</span><br><span class="line"><span class="comment">//在当前这个帧缓冲上下文中渲染</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>,<span class="number">0</span>,m_showPTexture-&gt;<span class="built_in">size</span>().<span class="built_in">width</span>(),m_showPTexture-&gt;<span class="built_in">size</span>().<span class="built_in">height</span>());</span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">0.0f</span>);				<span class="comment">// 清空背景色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">m_btopvao-&gt;<span class="built_in">bind</span>();</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">bind</span>();</span><br><span class="line"><span class="comment">//投影的理解，把left,right,bottom,top范围内的内容投影到视口里显示出来</span></span><br><span class="line"><span class="comment">//这儿投影的上下左右值和画的时候上下左右值不一样，是两个东西，画是在着色器里画，首先在着色器里面计算坐标，超过投影范围的不显示也就不画了</span></span><br><span class="line"><span class="comment">//比如画的时候画在了【-1,1】，但是投影的时候投影【0,1】，那在顶点着色器里面经过计算就只画了【0,1】范围内1/4的东西投影到视口，所以只能看到【0,1】范围内1/4的东西</span></span><br><span class="line">m_projectMat2.<span class="built_in">setToIdentity</span>();</span><br><span class="line">m_projectMat2.<span class="built_in">ortho</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1.0f</span>,<span class="number">1.0f</span>);</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">setUniformValue</span>(m_BToPProgram-&gt;<span class="built_in">uniformLocation</span>(<span class="string">&quot;btpMat&quot;</span>), m_projectMat2);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);<span class="comment">//启用纹理贴图</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, BID);</span><br><span class="line"><span class="built_in">glUniform1i</span>(m_BToPProgram-&gt;<span class="built_in">uniformLocation</span>(<span class="string">&quot;samp&quot;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>,m_lineNum*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);<span class="comment">//绑定纹理</span></span><br><span class="line">m_btopvao-&gt;<span class="built_in">release</span>();</span><br><span class="line">m_BToPProgram-&gt;<span class="built_in">release</span>();</span><br><span class="line">m_showPTexture-&gt;<span class="built_in">release</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/OpenGL-3D/image-20210924191610687.png" alt="image-20210924191610687"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果画在【-1,1】，投影的时候投影【-1,1】，那在顶点着色器里面经过计算就只画了【-1,1】范围内东西投影到视口，所以看到【-1,1】范围内东西</span><br><span class="line">m_projectMat2.setToIdentity();</span><br><span class="line">m_projectMat2.ortho(-1,1,1,-1,-1.0f,1.0f);</span><br><span class="line">m_BToPProgram-&gt;setUniformValue(m_btopUniformbtpMat, m_projectMat2);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/OpenGL-3D/image-20210924191638358.png" alt="image-20210924191638358"></p>
<h2 id="把它们都组合到一起"><a href="#把它们都组合到一起" class="headerlink" title="把它们都组合到一起"></a>把它们都组合到一起</h2><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：<br>$$<br>Vclip=Mprojection⋅Mview⋅Mmodel⋅VlocalVclip=Mprojection⋅Mview⋅Mmodel⋅Vlocal<br>$$<br>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。</p>
<blockquote>
<p><em><strong>*然后呢？*</strong></em></p>
<p>顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对****裁剪坐标*<em><strong>执行</strong></em>*透视除法*<em><strong>从而将它们变换到</strong></em>*标准化设备坐标*<em><strong>。OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到</strong></em>*屏幕坐标****，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为视口变换。</p>
</blockquote>
<h2 id="进入3D"><a href="#进入3D" class="headerlink" title="进入3D"></a>进入3D</h2><p>在开始进行3D绘图时，我们首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以****变换****它们到全局的世界空间。让我们变换一下我们的平面，将其绕着x轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(<span class="number">-55.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。</p>
<p>接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，我们位于原点(0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子：</p>
<ul>
<li>· 将摄像机向后移动，和将整个场景向前移动是一样的。</li>
</ul>
<p>这正是观察矩阵所做的，我们以相反于摄像机移动的方向移动整个场景。因为我们想要往后移动，并且OpenGL是一个右手坐标系(Right-handed System)，所以我们需要沿着z轴的正方向移动。我们会通过将场景沿着z轴负方向平移来实现。它会给我们一种我们在往后移动的感觉。</p>
<blockquote>
<p><em><strong>*右手坐标系(Right-handed System)*</strong></em></p>
<p>按照惯例，OpenGL是一个右手坐标系。简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下：</p>
<p><img src="/2021/09/21/OpenGL-3D/wps1.jpg" alt="img"> </p>
<p>为了理解为什么被称为右手坐标系，按如下的步骤做：</p>
<p>· 沿着正y轴方向伸出你的右臂，手指着上方。</p>
<p>· 大拇指指向右方。</p>
<p>· 食指指向上方。</p>
<p>· 中指向下弯曲90度。</p>
<p>如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。如果你用左臂来做这些动作，你会发现z轴的方向是相反的。这个叫做左手坐标系，它被DirectX广泛地使用。注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。</p>
</blockquote>
<p>在下一个教程中我们将会详细讨论如何在场景中移动。就目前来说，观察矩阵是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure>

<p>最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个uniform变换矩阵然后将它乘以顶点坐标：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意乘法要从右向左读</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还应该将矩阵传入着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> modelLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;model&quot;</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(modelLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line">... <span class="comment">// 观察矩阵和投影矩阵与之类似</span></span><br></pre></td></tr></table></figure>

<p>我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会：</p>
<ul>
<li>· 稍微向后倾斜至地板方向。</li>
<li>· 离我们有一些距离。</li>
<li>· 有透视效果（顶点越远，变得越小）。</li>
</ul>
<p>让我们检查一下结果是否满足这些要求：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921194508238.png" alt="image-20210921194508238"></p>
<h3 id="更多的3D"><a href="#更多的3D" class="headerlink" title="更多的3D"></a>更多的3D</h3><p>到目前为止，我们一直都在使用一个2D平面，而且甚至是在3D空间里！所以，让我们大胆地拓展我们的2D平面为一个3D立方体。要想渲染一个立方体，我们一共需要36个顶点（6个面 x 每个面有2个三角形组成 x 每个三角形有3个顶点），这36个顶点的位置你可以从<a href="https://learnopengl.com/code_viewer.php?code=getting-started/cube_vertices">这里</a>获取。</p>
<p>为了有趣一点，我们将让立方体随着时间旋转：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">model = glm::<span class="built_in">rotate</span>(model, (<span class="keyword">float</span>)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">50.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>然后我们使用glDrawArrays来绘制立方体，但这一次总共有36个顶点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<p>如果一切顺利的话你应该能得到下面这样的效果：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921201900959.png" alt="image-20210921201900959"></p>
<p>这的确有点像是一个立方体，但又有种说不出的奇怪。立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。之所以这样是因为OpenGL是一个三角形一个三角形地来绘制你的立方体的，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。</p>
<p>幸运的是，OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。通过使用Z缓冲，我们可以配置OpenGL来进行深度测试。</p>
<h4 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h4><p>OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为<mark class="hl-label Buffer)">深度缓冲(Depth</mark> 。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的****z****值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。</p>
<p>然而，如果我们想要确定OpenGL真的执行了深度测试，首先我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的。我们可以通过glEnable函数来开启深度测试。<mark class="hl-label blue">glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它</mark> 。现在我们想启用深度测试，需要开启GL_DEPTH_TEST：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure>

<p>因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在glClear函数中指定DEPTH_BUFFER_BIT位来清除深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/OpenGL-3D/image-20210921202420750.png" alt="image-20210921202420750"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意乘法要从右向左读</span></span><br><span class="line">	gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0f</span>);</span><br><span class="line">	TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, aTexCoord.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"><span class="comment">// texture samplers</span></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// linearly interpolate between both textures (80% container, 20% awesomeface)</span></span><br><span class="line">	FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/filesystem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/shader_m.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configure global opengl state</span></span><br><span class="line">    <span class="comment">// -----------------------------</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;6.2.coordinate_systems.vs&quot;</span>, <span class="string">&quot;6.2.coordinate_systems.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">//激活layout=0的位置</span></span><br><span class="line">    <span class="comment">// texture coord attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);<span class="comment">//激活layout=1的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);<span class="comment">//采样器texture1采集texture_0的纹理单元</span></span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);<span class="comment">//采样器texture2采集texture_1的纹理单元</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// also clear the depth buffer now!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// activate shader</span></span><br><span class="line">        ourShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create transformations</span></span><br><span class="line">        glm::mat4 model         = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// make sure to initialize matrix to identity matrix first</span></span><br><span class="line">        glm::mat4 view          = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        glm::mat4 projection    = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        model = glm::<span class="built_in">rotate</span>(model, (<span class="keyword">float</span>)<span class="built_in">glfwGetTime</span>(), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        view  = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br><span class="line">        projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//有个需要注意的地方，这里把三个矩阵分开了，在着色器里面是先旋转再平移最后投影，如果</span></span><br><span class="line">        <span class="comment">//在着色器外部直接做好旋转平移，也就是吧model和view合起来的话，不能如下：</span></span><br><span class="line">        <span class="comment">//model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(1.0f, 1.0f, 0.0f));</span></span><br><span class="line">        <span class="comment">//model  = glm::translate(model, glm::vec3(0.0f, 0.0f, -3.0f));</span></span><br><span class="line">        <span class="comment">//因为上面的写法看起来像是先旋转后平移了，实际上结果是相反的，先平移后旋转了，所以结果看起来不对，正确的应该如下：</span></span><br><span class="line">        <span class="comment">//model  = glm::translate(model, glm::vec3(0.0f, 0.0f, -3.0f));</span></span><br><span class="line">        <span class="comment">//model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(1.0f, 1.0f, 0.0f));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// retrieve the matrix uniform locations</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> modelLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;model&quot;</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> viewLoc  = <span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;view&quot;</span>);</span><br><span class="line">        <span class="comment">// pass them to the shaders (3 different ways)</span></span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(modelLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line">        <span class="built_in">glUniformMatrix4fv</span>(viewLoc, <span class="number">1</span>, GL_FALSE, &amp;view[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it&#x27;s often best practice to set it outside the main loop only once.</span></span><br><span class="line">        ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render box</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更多的立方体！"><a href="#更多的立方体！" class="headerlink" title="更多的立方体！"></a>更多的立方体！</h4><p>现在我们想在屏幕上显示10个立方体。每个立方体看起来都是一样的，区别在于它们在世界的位置及旋转角度不同。立方体的图形布局已经定义好了，所以当渲染更多物体的时候我们不需要改变我们的缓冲数组和属性数组，我们唯一需要做的只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中。</p>
<p>首先，让我们为每个立方体定义一个位移向量来指定它在世界空间的位置。我们将在一个glm::vec3数组中定义10个立方体位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，在游戏循环中，我们调用glDrawArrays 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次。注意我们也对每个箱子加了一点旋转：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  glm::mat4 model;</span><br><span class="line">  model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">  <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i; </span><br><span class="line">  model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">  ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/OpenGL-3D/image-20210921203449787.png" alt="image-20210921203449787"></p>
<h1 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h1><p>前面的教程中我们讨论了观察矩阵以及如何使用观察矩阵移动场景（我们向后移动了一点）。OpenGL本身没有<em><strong>*摄像机*</strong></em>(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种****我们****在移动的感觉，而不是场景在移动。</p>
<h2 id="摄像机-观察空间"><a href="#摄像机-观察空间" class="headerlink" title="摄像机/观察空间"></a>摄像机/观察空间</h2><p>当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右测的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921231251366.png" alt="image-20210921231251366"></p>
<h3 id="1-摄像机位置"><a href="#1-摄像机位置" class="headerlink" title="1. 摄像机位置"></a>1. 摄像机位置</h3><p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。我们把摄像机位置设置为上一节中的那个相同的位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">不要忘记正z轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着z轴的正方向移动。</mark> 

<h3 id="2-摄像机方向"><a href="#2-摄像机方向" class="headerlink" title="2. 摄像机方向"></a>2. 摄像机方向</h3><mark class="hl-label blue">这里指的是摄像机指向哪个方向</mark> 。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量：

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::<span class="built_in">normalize</span>(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>****方向****向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。</p>
</blockquote>
<h3 id="3-右轴"><a href="#3-右轴" class="headerlink" title="3. 右轴"></a>3. 右轴</h3><p>我们需要的另一个向量是一个<em><strong>*右向量*</strong></em>(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个<em><strong>*上向量*</strong></em>(Up Vector)。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(up, cameraDirection));</span><br></pre></td></tr></table></figure>

<h3 id="4-上轴"><a href="#4-上轴" class="headerlink" title="4. 上轴"></a>4. 上轴</h3><p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把右向量和方向向量进行叉乘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure>

<p>在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做<a href="http://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process">格拉姆—施密特正交化</a>(Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个LookAt矩阵了，它在创建摄像机的时候非常有用。</p>
<h2 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h2><p>使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是****LookAt****矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210921231714178.png" alt="image-20210921231714178"></p>
<p>其中R是右向量，U是上向量，D是方向向量，P是摄像机位置向量。注意，****位置向量是相反的****，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p>
<p>幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，<strong>一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量，不是上轴）</strong>。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">           glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">           glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>

<p>glm::LookAt函数需要<strong>一个摄像机位置、对准的目标和上向量</strong>。它会创建一个和在上一节使用的一样的观察矩阵。</p>
<p>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。</p>
<p>我们需要用到一点三角学的知识来在每一帧创建一个x和z坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算x和y坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径radius，在每次渲染迭代中使用GLFW的glfwGetTime函数重新创建观察矩阵，来扩大这个圆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="keyword">float</span> camX = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line"><span class="keyword">float</span> camZ = <span class="built_in">cos</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(camX, <span class="number">0.0</span>, camZ), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos, <span class="number">1.0f</span>);</span><br><span class="line">	TexCoord = <span class="built_in">vec2</span>(aTexCoord.x, aTexCoord.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// texture samplers</span></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// linearly interpolate between both textures (80% container, 20% awesomeface)</span></span><br><span class="line">	FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/filesystem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/shader_m.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configure global opengl state</span></span><br><span class="line">    <span class="comment">// -----------------------------</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;7.1.camera.vs&quot;</span>, <span class="string">&quot;7.1.camera.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// world space positions of our cubes</span></span><br><span class="line">    glm::vec3 cubePositions[] = &#123;</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span> (<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture coord attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass projection matrix to shader (as projection matrix rarely changes there&#x27;s no need to do this per frame)</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------------------------------------------------------------</span></span><br><span class="line">    glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// activate shader</span></span><br><span class="line">        ourShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// camera/view transformation</span></span><br><span class="line">        glm::mat4 view = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// make sure to initialize matrix to identity matrix first</span></span><br><span class="line">        <span class="keyword">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> camX   = <span class="built_in">sin</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line">        <span class="keyword">float</span> camZ   = <span class="built_in">cos</span>(<span class="built_in">glfwGetTime</span>()) * radius;</span><br><span class="line">        view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(camX, <span class="number">0.0f</span>, camZ), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render boxes</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// calculate the model matrix for each object and pass it to shader before drawing</span></span><br><span class="line">            glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">            <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">            model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/OpenGL-3D/image-20210923212457640.png" alt="image-20210923212457640"></p>
<blockquote>
<p>附：手动实现LookAt矩阵</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom implementation of the LookAt function</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">calculate_lookAt_matrix</span><span class="params">(glm::vec3 position, glm::vec3 target, glm::vec3 worldUp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. Position = known</span></span><br><span class="line">    <span class="comment">// 2. Calculate cameraDirection</span></span><br><span class="line">    glm::vec3 zaxis = glm::<span class="built_in">normalize</span>(position - target);</span><br><span class="line">    <span class="comment">// 3. Get positive right axis vector</span></span><br><span class="line">    glm::vec3 xaxis = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(glm::<span class="built_in">normalize</span>(worldUp), zaxis));</span><br><span class="line">    <span class="comment">// 4. Calculate camera up vector</span></span><br><span class="line">    glm::vec3 yaxis = glm::<span class="built_in">cross</span>(zaxis, xaxis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create translation and rotation matrix</span></span><br><span class="line">    <span class="comment">// In glm we access elements as mat[col][row] due to column-major layout</span></span><br><span class="line">    glm::mat4 translation = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// Identity matrix by default</span></span><br><span class="line">    translation[<span class="number">3</span>][<span class="number">0</span>] = -position.x; <span class="comment">// Third column, first row</span></span><br><span class="line">    translation[<span class="number">3</span>][<span class="number">1</span>] = -position.y;</span><br><span class="line">    translation[<span class="number">3</span>][<span class="number">2</span>] = -position.z;</span><br><span class="line">    glm::mat4 rotation = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    rotation[<span class="number">0</span>][<span class="number">0</span>] = xaxis.x; <span class="comment">// First column, first row</span></span><br><span class="line">    rotation[<span class="number">1</span>][<span class="number">0</span>] = xaxis.y;</span><br><span class="line">    rotation[<span class="number">2</span>][<span class="number">0</span>] = xaxis.z;</span><br><span class="line">    rotation[<span class="number">0</span>][<span class="number">1</span>] = yaxis.x; <span class="comment">// First column, second row</span></span><br><span class="line">    rotation[<span class="number">1</span>][<span class="number">1</span>] = yaxis.y;</span><br><span class="line">    rotation[<span class="number">2</span>][<span class="number">1</span>] = yaxis.z;</span><br><span class="line">    rotation[<span class="number">0</span>][<span class="number">2</span>] = zaxis.x; <span class="comment">// First column, third row</span></span><br><span class="line">    rotation[<span class="number">1</span>][<span class="number">2</span>] = zaxis.y;</span><br><span class="line">    rotation[<span class="number">2</span>][<span class="number">2</span>] = zaxis.z; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return lookAt matrix as combination of translation and rotation matrix</span></span><br><span class="line">    <span class="keyword">return</span> rotation * translation; <span class="comment">// Remember to read from right to left (first translation then rotation)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t forget to replace glm::lookAt with your own version</span></span><br><span class="line"><span class="comment">// view = glm::lookAt(glm::vec3(camX, 0.0f, camZ), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));</span></span><br><span class="line">view = <span class="built_in">calculate_lookAt_matrix</span>(glm::<span class="built_in">vec3</span>(camX, <span class="number">0.0f</span>, camZ), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure>



<h2 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h2><p>让摄像机绕着场景转的确很有趣，但是让我们自己移动摄像机会更有趣！首先我们必须设置一个摄像机系统，所以在我们的程序前面定义一些摄像机变量很有用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// camera</span></span><br><span class="line">glm::vec3 cameraPos   = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line"><span class="comment">//direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">glm::vec3 cameraFront = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);<span class="comment">//摄像机方向向量，(cameraTarget - cameraPos)</span></span><br><span class="line">glm::vec3 cameraUp    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure>

<p>LookAt函数现在成了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">view = glm::<span class="built_in">lookAt</span>(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure>

<p>我们首先将摄像机位置设置为之前定义的cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新cameraPos向量。</p>
<p>我们已经为GLFW的键盘输入定义过一个processInput函数了，我们来新添加几个需要检查的按键命令：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">float</span> cameraSpeed = <span class="number">0.05f</span>; <span class="comment">// adjust accordingly</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们按下<em><strong>*WASD*<em><strong>键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个</strong></em>*右向量*</strong></em>(Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的横移(Strafe)效果。</p>
<blockquote>
<p>注意，我们对****右向量****进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据cameraFront变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。</p>
</blockquote>
<p>现在你就应该能够移动摄像机了，虽然移动速度和系统有关，你可能会需要调整一下cameraSpeed。</p>
<h3 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h3><p>目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用processInput函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。</p>
<p>图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p>
<p>我们跟踪两个全局变量来计算出deltaTime值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>; <span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>; <span class="comment">// 上一帧的时间</span></span><br></pre></td></tr></table></figure>

<p>在每一帧中我们计算出新的deltaTime以备后用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure>

<p>现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h2><p>为了能够改变视角，我们需要根据鼠标的输入改变cameraFront向量。然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。如果你对三角学知之甚少，别担心，你可以跳过这一部分，直接复制粘贴我们的代码；当你想了解更多的时候再回来看。</p>
<h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，下面的图片展示了它们的含义：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210923213618580.png" alt="image-20210923213618580"></p>
<p>俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何****翻滚****摄像机，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。</p>
<p>对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p>
<p><img src="/2021/09/21/OpenGL-3D/image-20210923213700433.png" alt="image-20210923213700433"></p>
<p>如果我们把斜边边长定义为1，我们就能知道邻边的长度是<br>$$<br>cos x/h=cos x/1=cos x<br>$$<br>它的对边是<br>$$<br>sin y/h=sin y/1=sin y<br>$$<br>这样我们获得了能够得到x和y方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p>
<p><img src="/2021/09/21/OpenGL-3D/camera_pitch.png" alt="img"></p>
<p>这个三角形看起来和前面的三角形很像，所以如果我们想象自己在xz平面上，看向y轴，我们可以基于第一个三角形计算来计算它的长度/y方向的强度(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的y值等于sin θ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch)); <span class="comment">// 注意我们先把角度转为弧度</span></span><br></pre></td></tr></table></figure>

<p>这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br></pre></td></tr></table></figure>

<p>看看我们是否能够为偏航角找到需要的分量：</p>
<p><img src="/2021/09/21/OpenGL-3D/camera_yaw.png" alt="img"></p>
<p>就像俯仰角的三角形一样，我们可以看到x分量取决于<code>cos(yaw)</code>的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)); <span class="comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:这里的偏航角没有y分量的偏移，个人理解是因为偏航角的变化与Y轴无关，而俯仰角与XYZ轴都有关系</p>
</blockquote>
<p>这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的3维方向向量了。你可能会奇怪：我们怎么得到俯仰角和偏航角？</p>
<h3 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h3><p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p>
<p>首先我们要告诉<strong>GLFW</strong>，它应该隐藏光标，并捕捉(Capture)它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure>

<p>在调用这个函数之后，无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口。对于FPS摄像机系统来说非常完美。</p>
<p>为了计算俯仰角和偏航角，我们需要让GLFW监听鼠标移动事件。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里的xpos和ypos代表当前鼠标的位置。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br></pre></td></tr></table></figure>

<p>在处理FPS风格摄像机的鼠标输入的时候，我们必须在最终获取方向向量之前做下面这几步：</p>
<ol>
<li>计算鼠标距上一帧的偏移量。</li>
<li>把偏移量添加到摄像机的俯仰角和偏航角中。</li>
<li>对偏航角和俯仰角进行最大和最小值的限制。</li>
<li>计算方向向量。</li>
</ol>
<p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是800x600）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line"><span class="keyword">float</span> yoffset = lastY - ypos; <span class="comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span></span><br><span class="line">lastX = xpos;</span><br><span class="line">lastY = ypos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">xoffset *= sensitivity;</span><br><span class="line">yoffset *= sensitivity;</span><br></pre></td></tr></table></figure>

<p>注意我们把偏移量乘以了sensitivity（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p>
<p>接下来我们把偏移量加到全局变量pitch和yaw上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yaw   += xoffset;</span><br><span class="line">pitch += yoffset;</span><br></pre></td></tr></table></figure>

<p>第三步，我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">  pitch =  <span class="number">89.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">  pitch = <span class="number">-89.0f</span>;</span><br></pre></td></tr></table></figure>

<p>注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p>
<p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw));</span><br><span class="line">cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br></pre></td></tr></table></figure>

<p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于cameraFront向量已经包含在GLM的lookAt函数中，我们这就没什么问题了。</p>
<p>如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的xpos和ypos会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个<code>bool</code>变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(firstMouse) <span class="comment">// 这个bool变量初始时是设定为true的</span></span><br><span class="line">&#123;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">    firstMouse = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的代码应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>作为我们摄像机系统的一个附加内容，我们还会来实现一个缩放(Zoom)接口。在之前的教程中我们说<strong>视野</strong>(Field of View)或<strong>fov</strong>定义了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大(Zoom In)了的感觉。我们会使用鼠标的滚轮来放大。与鼠标移动、键盘输入一样，我们需要一个鼠标滚轮的回调函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;</span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当滚动鼠标滚轮的时候，yoffset值代表我们竖直滚动的大小。当scroll_callback函数被调用后，我们改变全局变量fov变量的内容。因为<code>45.0f</code>是默认的视野值，我们将会把缩放级别(Zoom Level)限制在<code>1.0f</code>到<code>45.0f</code>。</p>
<p>我们现在在每一帧都必须把透视投影矩阵上传到GPU，但现在使用fov变量作为它的视野：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>最后不要忘记注册鼠标滚轮的回调函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br></pre></td></tr></table></figure>



<h2 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methods</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Camera_Movement</span> &#123;</span></span><br><span class="line">    FORWARD,</span><br><span class="line">    BACKWARD,</span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default camera values</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> YAW         = <span class="number">-90.0f</span>;<span class="comment">//yaw 初始化为 -90.0 度，因为 0.0 的 yaw 导致方向向量指向右侧，因此我们最初向左旋转一点。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PITCH       =  <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> SPEED       =  <span class="number">2.5f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> SENSITIVITY =  <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> ZOOM        =  <span class="number">45.0f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// An abstract camera class that processes input and calculates the corresponding Euler Angles, Vectors and Matrices for use in OpenGL</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// camera Attributes</span></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line">    <span class="comment">// euler Angles</span></span><br><span class="line">    <span class="keyword">float</span> Yaw;</span><br><span class="line">    <span class="keyword">float</span> Pitch;</span><br><span class="line">    <span class="comment">// camera options</span></span><br><span class="line">    <span class="keyword">float</span> MovementSpeed;</span><br><span class="line">    <span class="keyword">float</span> MouseSensitivity;</span><br><span class="line">    <span class="keyword">float</span> Zoom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor with vectors</span></span><br><span class="line">    <span class="built_in">Camera</span>(glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), <span class="keyword">float</span> yaw = YAW, <span class="keyword">float</span> pitch = PITCH) : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED), <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM)</span><br><span class="line">    &#123;</span><br><span class="line">        Position = position;</span><br><span class="line">        WorldUp = up;</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor with scalar values</span></span><br><span class="line">    <span class="built_in">Camera</span>(<span class="keyword">float</span> posX, <span class="keyword">float</span> posY, <span class="keyword">float</span> posZ, <span class="keyword">float</span> upX, <span class="keyword">float</span> upY, <span class="keyword">float</span> upZ, <span class="keyword">float</span> yaw, <span class="keyword">float</span> pitch) : <span class="built_in">Front</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">MovementSpeed</span>(SPEED), <span class="built_in">MouseSensitivity</span>(SENSITIVITY), <span class="built_in">Zoom</span>(ZOOM)</span><br><span class="line">    &#123;</span><br><span class="line">        Position = glm::<span class="built_in">vec3</span>(posX, posY, posZ);</span><br><span class="line">        WorldUp = glm::<span class="built_in">vec3</span>(upX, upY, upZ);</span><br><span class="line">        Yaw = yaw;</span><br><span class="line">        Pitch = pitch;</span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// returns the view matrix calculated using Euler Angles and the LookAt Matrix</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">lookAt</span>(Position, Position + Front, Up);<span class="comment">//Up可以换成WorldUp</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessKeyboard</span><span class="params">(Camera_Movement direction, <span class="keyword">float</span> deltaTime)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里的上下是摄像机的前进后退，要改成视野的上下可以把Front换成WorldUp</span></span><br><span class="line">        <span class="keyword">float</span> velocity = MovementSpeed * deltaTime;</span><br><span class="line">        <span class="keyword">if</span> (direction == FORWARD)</span><br><span class="line">            Position += Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == BACKWARD)</span><br><span class="line">            Position -= Front * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == LEFT)</span><br><span class="line">            Position -= Right * velocity;</span><br><span class="line">        <span class="keyword">if</span> (direction == RIGHT)</span><br><span class="line">            Position += Right * velocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processes input received from a mouse input system. Expects the offset value in both the x and y direction.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(<span class="keyword">float</span> xoffset, <span class="keyword">float</span> yoffset, GLboolean constrainPitch = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        xoffset *= MouseSensitivity;</span><br><span class="line">        yoffset *= MouseSensitivity;</span><br><span class="line"></span><br><span class="line">        Yaw   += xoffset;</span><br><span class="line">        Pitch += yoffset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make sure that when pitch is out of bounds, screen doesn&#x27;t get flipped</span></span><br><span class="line">        <span class="keyword">if</span> (constrainPitch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">89.0f</span>;</span><br><span class="line">            <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">                Pitch = <span class="number">-89.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update Front, Right and Up Vectors using the updated Euler angles</span></span><br><span class="line">        <span class="built_in">updateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseScroll</span><span class="params">(<span class="keyword">float</span> yoffset)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Zoom -= (<span class="keyword">float</span>)yoffset;</span><br><span class="line">        <span class="keyword">if</span> (Zoom &lt; <span class="number">1.0f</span>)</span><br><span class="line">            Zoom = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (Zoom &gt; <span class="number">45.0f</span>)</span><br><span class="line">            Zoom = <span class="number">45.0f</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// calculates the front vector from the Camera&#x27;s (updated) Euler Angles</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// calculate the new Front vector</span></span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        <span class="comment">// also re-calculate the Right and Up vector</span></span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));  <span class="comment">// normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.</span></span><br><span class="line">        Up    = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/filesystem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/shader_m.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;learnopengl/camera.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera</span></span><br><span class="line"><span class="function">Camera <span class="title">camera</span><span class="params">(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>))</span></span>;</span><br><span class="line"><span class="keyword">float</span> lastX = SCR_WIDTH / <span class="number">2.0f</span>;</span><br><span class="line"><span class="keyword">float</span> lastY = SCR_HEIGHT / <span class="number">2.0f</span>;</span><br><span class="line"><span class="keyword">bool</span> firstMouse = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timing</span></span><br><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>;	<span class="comment">// time between current frame and last frame</span></span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line">    <span class="built_in">glfwSetCursorPosCallback</span>(window, mouse_callback);</span><br><span class="line">    <span class="built_in">glfwSetScrollCallback</span>(window, scroll_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell GLFW to capture our mouse</span></span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configure global opengl state</span></span><br><span class="line">    <span class="comment">// -----------------------------</span></span><br><span class="line">    <span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;7.4.camera.vs&quot;</span>, <span class="string">&quot;7.4.camera.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// world space positions of our cubes</span></span><br><span class="line">    glm::vec3 cubePositions[] = &#123;</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture coord attribute</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = <span class="built_in">stbi_load</span>(<span class="string">&quot;..\\..\\..\\resources\\textures\\awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// per-frame time logic</span></span><br><span class="line">        <span class="comment">// --------------------</span></span><br><span class="line">        <span class="keyword">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// activate shader</span></span><br><span class="line">        ourShader.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pass projection matrix to shader (note that in this case it could change every frame)</span></span><br><span class="line">        glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(camera.Zoom), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">        ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// camera/view transformation</span></span><br><span class="line">        glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();</span><br><span class="line">        ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render boxes</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// calculate the model matrix for each object and pass it to shader before drawing</span></span><br><span class="line">            glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>); <span class="comment">// make sure to initialize matrix to identity matrix first</span></span><br><span class="line">            model = glm::<span class="built_in">translate</span>(model, cubePositions[i]);</span><br><span class="line">            <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">            model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            ourShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        camera.<span class="built_in">ProcessKeyboard</span>(FORWARD, deltaTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        camera.<span class="built_in">ProcessKeyboard</span>(BACKWARD, deltaTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        camera.<span class="built_in">ProcessKeyboard</span>(LEFT, deltaTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        camera.<span class="built_in">ProcessKeyboard</span>(RIGHT, deltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the mouse moves, this callback is called</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos; <span class="comment">// reversed since y-coordinates go from bottom to top</span></span><br><span class="line"></span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    camera.<span class="built_in">ProcessMouseMovement</span>(xoffset, yoffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the mouse scroll wheel scrolls, this callback is called</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    camera.<span class="built_in">ProcessMouseScroll</span>(yoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-light</title>
    <url>/2021/10/17/OpenGL-light/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="创建一个光照场景"><a href="#创建一个光照场景" class="headerlink" title="创建一个光照场景"></a>创建一个光照场景</h1><p>首先我们需要一个物体来作为被投光(Cast the light)的对象，我们将使用前面教程中的那个著名的立方体箱子。我们还需要一个物体来代表光源在3D场景中的位置。简单起见，我们依然使用一个立方体来代表光源。</p>
<p>填一个顶点缓冲对象(VBO)，设定一下顶点属性指针和其它一些乱七八糟的东西.</p>
<p>我们首先需要一个顶点着色器来绘制箱子。与之前的顶点着色器相比，容器的顶点位置是保持不变的（虽然这一次我们不需要纹理坐标了），因此顶点着色器中没有新的代码。我们将会使用之前教程顶点着色器的精简版：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得更新你的顶点数据和属性指针使其与新的顶点着色器保持一致（当然你可以继续留着纹理数据和属性指针。在这一节中我们将不会用到它们，但有一个全新的开始也不是什么坏主意）。</p>
<p>因为我们还要创建一个表示灯（光源）的立方体，所以我们还要为这个灯创建一个专门的VAO。当然我们也可以让这个灯和其它物体使用同一个VAO，简单地对它的model（模型）矩阵做一些变换就好了，然而接下来的教程中我们会频繁地对顶点数据和属性指针做出修改，我们并不想让这些修改影响到灯（我们只关心灯的顶点位置），因此我们有必要为灯创建一个新的VAO。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lightVAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line"><span class="comment">// 只需要绑定VBO不用再次设置VBO的数据，因为箱子的VBO数据中已经包含了正确的立方体顶点数据</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="comment">// 设置灯立方体的顶点属性（对我们的灯来说仅仅只有位置数据）</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码对你来说应该非常直观。现在我们已经创建了表示灯和被照物体箱子，我们只需要再定义一个片段着色器就行了：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(lightColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个片段着色器从uniform变量中接受物体的颜色和光源的颜色。正如本节一开始所讨论的那样，我们将光源的颜色和物体（反射的）颜色相乘。这个着色器理解起来应该很容易。我们把物体的颜色设置为之前提到的珊瑚红色，并把光源设置为白色。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在此之前不要忘记首先 use 对应的着色器程序（来设定uniform）</span></span><br><span class="line">lightingShader.<span class="built_in">use</span>();</span><br><span class="line">lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;objectColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>要注意的是，当我们修改顶点或者片段着色器后，灯的位置或颜色也会随之改变，这并不是我们想要的效果。我们不希望灯的颜色在接下来的教程中因光照计算的结果而受到影响，而是希望它能够与其它的计算分离。我们希望灯一直保持明亮，不受其它颜色变化的影响（这样它才更像是一个真实的光源）。</p>
<p>为了实现这个目标，我们需要为灯的绘制创建另外的一套着色器，从而能保证它能够在其它光照着色器发生改变的时候不受影响。顶点着色器与我们当前的顶点着色器是一样的，所以你可以直接把现在的顶点着色器用在灯上。灯的片段着色器给灯定义了一个不变的常量白色，保证了灯的颜色一直是亮的：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>); <span class="comment">// 将向量的四个分量全部设置为1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们想要绘制我们的物体的时候，我们需要使用刚刚定义的光照着色器来绘制箱子（或者可能是其它的物体）。当我们想要绘制灯的时候，我们会使用灯的着色器。在之后的教程里我们会逐步更新这个光照着色器，从而能够慢慢地实现更真实的效果。</p>
<p>使用这个灯立方体的主要目的是为了让我们知道光源在场景中的具体位置。我们通常在场景中定义一个光源的位置，但这只是一个位置，它并没有视觉意义。为了显示真正的灯，我们将表示光源的立方体绘制在与光源相同的位置。我们将使用我们为它新建的片段着色器来绘制它，让它一直处于白色的状态，不受场景中的光照影响。</p>
<p>我们声明一个全局<code>vec3</code>变量来表示光源在场景的世界空间坐标中的位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后我们把灯位移到这里，然后将它缩小一点，让它不那么明显：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">model = glm::<span class="built_in">mat4</span>();</span><br><span class="line">model = glm::<span class="built_in">translate</span>(model, lightPos);</span><br><span class="line">model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>));</span><br></pre></td></tr></table></figure>

<p>绘制灯立方体的代码应该与下面的类似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lampShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="comment">// 设置模型、视图和投影矩阵uniform</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 绘制灯立方体对象</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(lightVAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<p>请把上述的所有代码片段放在你程序中合适的位置，这样我们就能有一个干净的光照实验场地了。如果一切顺利，运行效果将会如下图所示：</p>
<p><img src="/2021/10/17/OpenGL-light/colors_scene.png" alt="img"></p>
<p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为冯氏光照模型(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_phong.png" alt="img"></p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<h1 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h1><p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上<strong>反射</strong>，对一个物体产生间接的影响。考虑到这种情况的算法叫做**全局照明(Global Illumination)**算法，但是这种算法既开销高昂又极其复杂。</p>
<p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即<strong>环境光照</strong>。正如你在上一节所学到的，我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</p>
<p>把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = ambient * objectColor;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你现在运行你的程序，你会注意到冯氏光照的第一个阶段已经应用到你的物体上了。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不是完全黑的。它看起来应该像这样：</p>
<p><img src="/2021/10/17/OpenGL-light/ambient_lighting.png" alt="img"></p>
<h1 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h1><p>环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。为了能够更好的理解漫反射光照，请看下图：</p>
<p><img src="/2021/10/17/OpenGL-light/diffuse_light.png" alt="img"></p>
<p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线垂直于物体表面，这束光对物体的影响会最大化（译注：更亮）。为了测量光线和片段的角度，我们使用一个叫做法向量(Normal Vector)的东西，它是垂直于片段表面的一个向量（这里以黄色箭头表示），我们在后面再讲这个东西。这两个向量之间的角度很容易就能够通过点乘计算出来。</p>
<p>你可能记得在[变换](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/07 Transformations/)那一节教程里，我们知道两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就应该越小。</p>
<blockquote>
<p>注意，为了（只）得到两个向量夹角的余弦值，我们使用的是单位向量（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了（见[变换](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/07 Transformations/)）。</p>
</blockquote>
<p>点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。</p>
<p>所以，计算漫反射光照需要什么？</p>
<ul>
<li>法向量：一个垂直于顶点表面的向量。</li>
<li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li>
</ul>
<h2 id="法向量"><a href="#法向量" class="headerlink" title="法向量"></a>法向量</h2><p>法向量是一个垂直于顶点表面的（单位）向量。由于顶点本身并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于3D立方体不是一个复杂的形状，所以我们可以简单地把法线数据手工添加到顶点数据中。试着去想象一下，这些法向量真的是垂直于立方体各个平面的表面的（一个立方体由6个平面组成）。</p>
<p>由于我们向顶点数组添加了额外的数据，所以我们应该更新光照的顶点着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在我们已经向每个顶点添加了一个法向量并更新了顶点着色器，我们还要更新顶点属性指针。注意，灯使用同样的顶点数组作为它的顶点数据，然而灯的着色器并没有使用新添加的法向量。我们不需要更新灯的着色器或者是属性的配置，但是我们必须至少修改一下顶点属性指针来适应新的顶点数组的大小：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们只想使用每个顶点的前三个float，并且忽略后三个float，所以我们只需要把<strong>步长</strong>参数改成<code>float</code>大小的6倍就行了。</p>
<blockquote>
<p>虽然对灯的着色器使用不能完全利用的顶点数据看起来不是那么高效，但这些顶点数据已经从箱子对象载入后开始就储存在GPU的内存里了，所以我们并不需要储存新数据到GPU内存中。这实际上比给灯专门分配一个新的VBO更高效了。</p>
</blockquote>
<p>所有光照的计算都是在片段着色器里进行，所以我们需要将法向量由顶点着色器传递到片段着色器。我们这么做：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    Normal = aNormal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，在片段着色器中定义相应的输入变量：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br></pre></td></tr></table></figure>

<h2 id="计算漫反射光照"><a href="#计算漫反射光照" class="headerlink" title="计算漫反射光照"></a>计算漫反射光照</h2><p>我们现在对每个顶点都有了法向量，但是我们仍然需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为uniform：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br></pre></td></tr></table></figure>

<p>然后在渲染循环中（渲染循环的外面也可以，因为它不会改变）更新uniform。我们使用在前面声明的<strong>lightPos</strong>向量作为光源位置：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">lightingShader.setVec3(&quot;lightPos&quot;, lightPos);</span><br></pre></td></tr></table></figure>

<p>最后，我们还需要片段的位置。我们会在世界空间中进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，并计算它的世界空间坐标：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;  </span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    Normal = aNormal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在片段着色器中添加相应的输入变量。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br></pre></td></tr></table></figure>

<p>现在，所有需要的变量都设置好了，我们可以在片段着色器中添加光照计算了。</p>
<p>我们需要做的第一件事是计算光源和片段位置之间的方向向量。前面提到，光的方向向量是光源位置向量与片段位置向量之间的向量差。你可能记得在[变换](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/07 Transformations/)教程中，我们能够简单地通过让两个向量相减的方式计算向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以我们把法线和最终的方向向量都进行标准化：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line"><span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个十分常见的错误。</p>
</blockquote>
<p>下一步，我们对norm和lightDir向量进行点乘，计算光源对当前片段实际的漫发射影响。结果值再乘以光的颜色，得到漫反射分量。<strong>两个向量之间的角度越大，漫反射分量就会越小：</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> diffuse = diff * lightColor;</span><br></pre></td></tr></table></figure>

<p>如果两个向量之间的角度大于90度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用max函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它，除非你是那种古怪的艺术家。</p>
<p>现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec3 result = (ambient + diffuse) * objectColor;</span><br><span class="line">FragColor = vec4(result, 1.0);</span><br></pre></td></tr></table></figure>

<p>如果你的应用(和着色器)编译成功了，你可能看到类似的输出：</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_diffuse.png" alt="img"></p>
<p>你可以看到使用了漫反射光照，立方体看起来就真的像个立方体了。尝试在你的脑中想象一下法向量，并在立方体周围移动，注意观察法向量和光的方向向量之间的夹角越大，片段就会越暗。</p>
<p>如果你在哪卡住了，可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.1.basic_lighting_diffuse/basic_lighting_diffuse.cpp">这里</a>对比一下完整的源代码。</p>
<h2 id="最后一件事"><a href="#最后一件事" class="headerlink" title="最后一件事"></a>最后一件事</h2><p>现在我们已经把法向量从顶点着色器传到了片段着色器。可是，目前片段着色器里的计算都是在世界空间坐标中进行的。所以，我们是不是应该把法向量也转换为世界空间坐标？基本正确，但是这不是简单地把它乘以一个模型矩阵就能搞定的。</p>
<p>首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，位移不应该影响到法向量。因此，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。</p>
<p>其次，如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。下面的图展示了应用了不等比缩放的模型矩阵对法向量的影响：</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_normal_transformation.png" alt="img"></p>
<p>每当我们应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p>
<p>修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵(Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。如果你想知道这个矩阵是如何计算出来的，建议去阅读这个<a href="http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/">文章</a>。</p>
<p>法线矩阵被定义为「模型矩阵左上角的逆矩阵的转置矩阵」。真是拗口，如果你不明白这是什么意思，别担心，我们还没有讨论逆矩阵(Inverse Matrix)和转置矩阵(Transpose Matrix)。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵(Model-view Matrix)上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。</p>
<p>在顶点着色器中，我们可以使用inverse和transpose函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意我们还要把被处理过的矩阵强制转换为3×3矩阵，来保证它失去了位移属性以及能够乘以<code>vec3</code>的法向量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Normal = mat3(transpose(inverse(model))) * aNormal;</span><br></pre></td></tr></table></figure>

<p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果你进行了不等比缩放，使用法线矩阵去乘以法向量就是必不可少的了。</p>
<blockquote>
<p>即使是对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。用作学习目这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前你最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。</p>
</blockquote>
<h1 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h1><p>如果你还没被这些光照计算搞得精疲力尽，我们就再把镜面高光(Specular Highlight)加进来，这样冯氏光照才算完整。</p>
<p>和漫反射光照一样，镜面光照也是依据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向，例如玩家是从什么方向看着这个片段的。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么，无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化。你可以从下面的图片看到效果：</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_specular_theory.png" alt="img"></p>
<p>我们通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p>
<p>观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p>
<blockquote>
<p>我们选择在世界空间进行光照计算，但是大多数人趋向于在观察空间进行光照计算。在观察空间计算的好处是，观察者的位置总是(0, 0, 0)，所以这样你直接就获得了观察者位置。可是我发现在学习的时候在世界空间中计算光照更符合直觉。如果你仍然希望在观察空间计算光照的话，你需要将所有相关的向量都用观察矩阵进行变换（记得也要改变法线矩阵）。</p>
</blockquote>
<p>为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个uniform添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line">lightingShader.setVec3(&quot;viewPos&quot;, camera.Position);</span><br></pre></td></tr></table></figure>

<p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个镜面强度(Specular Intensity)变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> specularStrength = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们把它设置为1.0f，我们会得到一个非常亮的镜面光分量，这对于一个珊瑚色的立方体来说有点太多了。下一节教程中我们会讨论如何合理设置这些光照强度，以及它们是如何影响物体的。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br></pre></td></tr></table></figure>

<p>需要注意的是我们对<code>lightDir</code>向量进行了取反。<code>reflect</code>函数要求第一个向量是<strong>从</strong>光源指向片段位置的向量，但是<code>lightDir</code>当前正好相反，是从片段<strong>指向</strong>光源（由先前我们计算<code>lightDir</code>向量时，减法的顺序决定）。为了保证我们得到正确的<code>reflect</code>向量，我们通过对<code>lightDir</code>向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已标准化的<code>norm</code>向量。</p>
<p>剩下要做的是计算镜面分量。下面的代码完成了这件事：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line"><span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure>

<p>我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度(Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_specular_shininess.png" alt="img"></p>
<p>我们不希望镜面成分过于显眼，所以我们把指数保持为32。剩下的最后一件事情是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>我们现在为冯氏光照计算了全部的光照分量。根据你的视角，你可以看到类似下面的画面：</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_specular.png" alt="img"></p>
<p>你可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.2.basic_lighting_specular/basic_lighting_specular.cpp">这里</a>找到完整源码。</p>
<blockquote>
<p>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以（开销大的）光照计算频率会更低。然而，顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。</p>
<p><img src="/2021/10/17/OpenGL-light/basic_lighting_gouruad.png" alt="img"></p>
<p>在顶点着色器中实现的冯氏光照模型叫做Gouraud着色(Gouraud Shading)，而不是冯氏着色(Phong Shading)。记住，由于插值，这种光照看起来有点逊色。冯氏着色能产生更平滑的光照效果。</p>
</blockquote>
<p>现在你应该能够看到着色器的强大之处了。只用很少的信息，着色器就能计算出光照如何影响到所有物体的片段颜色。[下一节](<a href="https://learnopengl-cn.github.io/02">https://learnopengl-cn.github.io/02</a> Lighting/03 Materials/)中，我们会更深入的研究光照模型，看看我们还能做些什么。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lighting</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// camera</span></span><br><span class="line"><span class="function">Camera <span class="title">camera</span><span class="params">(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>))</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">   <span class="comment">// ------------------------------------</span></span><br><span class="line">   <span class="function">Shader <span class="title">lightingShader</span><span class="params">(<span class="string">&quot;2.2.basic_lighting.vs&quot;</span>, <span class="string">&quot;2.2.basic_lighting.fs&quot;</span>)</span></span>;</span><br><span class="line">   <span class="function">Shader <span class="title">lightCubeShader</span><span class="params">(<span class="string">&quot;2.2.light_cube.vs&quot;</span>, <span class="string">&quot;2.2.light_cube.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">   <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">   <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">       <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// first, configure the cube&#x27;s VAO (and VBO)</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, cubeVAO;</span><br><span class="line">   <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;cubeVAO);</span><br><span class="line">   <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">   <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// position attribute</span></span><br><span class="line">   <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// normal attribute</span></span><br><span class="line">   <span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line">   <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// second, configure the light&#x27;s VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube)</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> lightCubeVAO;</span><br><span class="line">   <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;lightCubeVAO);</span><br><span class="line">   <span class="built_in">glBindVertexArray</span>(lightCubeVAO);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">   <span class="comment">// note that we update the lamp&#x27;s position attribute&#x27;s stride to reflect the updated buffer data</span></span><br><span class="line">   <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// render loop</span></span><br><span class="line">   <span class="comment">// -----------</span></span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// per-frame time logic</span></span><br><span class="line">       <span class="comment">// --------------------</span></span><br><span class="line">       <span class="keyword">float</span> currentFrame = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">       deltaTime = currentFrame - lastFrame;</span><br><span class="line">       lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// input</span></span><br><span class="line">       <span class="comment">// -----</span></span><br><span class="line">       <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// render</span></span><br><span class="line">       <span class="comment">// ------</span></span><br><span class="line">       <span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line">       <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// be sure to activate shader when setting uniforms/drawing objects</span></span><br><span class="line">       lightingShader.<span class="built_in">use</span>();</span><br><span class="line">       lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;objectColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">       lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">       lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;lightPos&quot;</span>, lightPos);<span class="comment">//光源位置</span></span><br><span class="line">       lightingShader.<span class="built_in">setVec3</span>(<span class="string">&quot;viewPos&quot;</span>, camera.Position);<span class="comment">//摄像机位置</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// view/projection transformations</span></span><br><span class="line">       glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(camera.Zoom), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">       glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();</span><br><span class="line">       lightingShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">       lightingShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// world transformation</span></span><br><span class="line">       glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">       lightingShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// render the cube</span></span><br><span class="line">       <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">       <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// also draw the lamp object</span></span><br><span class="line">       lightCubeShader.<span class="built_in">use</span>();</span><br><span class="line">       lightCubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">       lightCubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">       model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">       model = glm::<span class="built_in">translate</span>(model, lightPos);</span><br><span class="line">       model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>)); <span class="comment">// a smaller cube</span></span><br><span class="line">       lightCubeShader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">glBindVertexArray</span>(lightCubeVAO);</span><br><span class="line">       <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">       <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">       <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">       <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">   <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">   <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;cubeVAO);</span><br><span class="line">   <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;lightCubeVAO);</span><br><span class="line">   <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure>

<p>光源着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>); <span class="comment">// set alle 4 vector values to 1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标物体着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;  <span class="comment">//法线矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * <span class="type">vec4</span>(FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos; </span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos; </span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ambient,光的颜色乘以一个很小的常量环境因子</span></span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// diffuse </span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);<span class="comment">//顶点法向量</span></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);<span class="comment">//光源与顶点的向量，顶点指向光源</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);<span class="comment">//点乘</span></span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * lightColor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="type">float</span> specularStrength = <span class="number">0.5</span>;<span class="comment">//镜面强度</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);<span class="comment">//视线方向向量</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);  <span class="comment">//从光源指向片段位置的向量*顶点法向量</span></span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);<span class="comment">//计算镜面分量,32是高光的反光度,一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小</span></span><br><span class="line">    <span class="type">vec3</span> specular = specularStrength * spec * lightColor;  </span><br><span class="line">        </span><br><span class="line">    <span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL</title>
    <url>/2021/09/06/OpenGL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><em><strong>*透视(Perspective)*</strong></em><br><em><strong>*变换(Transformation)*</strong></em><br>****投影矩阵(Projection Matrix)****：用于将3D坐标转换为2D屏幕坐标<br><em><strong>*光栅化(Rasterization)*</strong></em>: 实际绘制或填充每个顶点之间的像素形成线段<br><em><strong>*着色器(Shader)*</strong></em> 是在图形硬件上执行的单独程序，用来处理顶点和执行光栅化任务<br><em><strong>*纹理贴图(Texture Mapping)*</strong></em><br><em><strong>*混合(Blending)*</strong></em>: 将不同的颜色混在一起<br><em><strong>*可编程着色器(Programmable Shader)*</strong></em><br>****位平面(bitplane)****：指一块内存区域，保存了屏幕上每个像素的位信息<br>****平截头体(Frustum)：****透视投影的视景体，四棱台的形状<br>****片段(Fragment)：**<strong>不是最后的像素数据, 但和像素对应, fragment需要经过处理</strong>(blend,texture,lighting…)**才会得到最后的像素。</p>
<p><em><strong>*视口(Viewport)*</strong></em>: 把绘图坐标映射到窗口坐标的区域<br><em><strong>*图元(Primitives)*</strong></em>: 一维或二维的实体或表面(点，直线，多边形)<br><em><strong>*顶点(Vertex)*</strong></em>: OpenGL顶点是4个分量**(x, y, z,** <em>*<em>*<em>w*</em>*</em>*</em><em>)<strong>，</strong></em>*<em>w*</em>*<strong>为0时代表空间中的点，</strong>**<em>w*</em>***为1时代表方向<br>****视景体(View Volume)****：定义了一个场景如何映射到屏幕上（透视投影还是正投影）其次，视景体定义了哪此部分被剪裁到最终的图像之外。</p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p><strong>标准化设备坐标(Normalized Device Coordinates, NDC)</strong></p>
<p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是****标准化设备坐标****了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间<mark class="hl-label default">（传入顶点时，如果不是按照NDC坐标传入，就需要投影矩阵在顶点着色器中重投影到NDC坐标，比如传入[-180,180]，就需要一个[-180,180]的矩阵去去转换）red</mark> 。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p>
<p><img src="/2021/09/06/OpenGL/image-20210906214558153.png" alt="image-20210906214558153"></p>
<p>与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p>
<p>你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过glViewport函数提供的数据【-1,1】-&gt;【0,1】，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p>
<p><strong>顶点-&gt;标准化设备坐标-&gt;屏幕空间坐标-&gt;片段</strong></p>
<p>中心为00，范围在【-1,1】，可以超过这个范围，提供投影矩阵就可以。对应的指定纹理包装和滤波</p>
<p>纹理坐标</p>
<p>纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角</p>
<p>正交投影</p>
<p>右手系，指向屏幕里面是负，指向屏幕外面是正</p>
<mark class="hl-label red">正交投影，用屏幕坐标绘制，左上为00</mark> 

<p><img src="/2021/09/06/OpenGL/wps2.jpg" alt="img"> </p>
<h2 id="矩阵模式："><a href="#矩阵模式：" class="headerlink" title="矩阵模式："></a>矩阵模式：</h2><p>不同的操作需要切换到不同的矩阵下进行，操作必须和矩阵对应，否则操作无效</p>
<p>下面函数就是用来<mark class="hl-label blue">指定哪一个矩阵是当前矩阵</mark> ，有三种选择(<mark class="hl-label blue">投影矩阵，模型视图矩阵，纹理矩阵</mark> )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glMatrixMode</span><span class="params">(GLenum mode)</span></span>;</span><br><span class="line"></span><br><span class="line">GL_PROJECTION 要对投影相关进行操作，也就是把物体投影到一个平面上</span><br><span class="line">GL_MODELVIEW  要对模型视景的操作，</span><br><span class="line">GL_TEXTURE    要对纹理相关进行操作</span><br></pre></td></tr></table></figure>

<p><strong>模型视图矩阵是模型矩阵和视图矩阵相乘得到的单一矩阵</strong></p>
<blockquote>
<p><em><strong>*注意：设置完glMatrixMode之后必须调用glLoadIdentity，*</strong></em></p>
</blockquote>
<h3 id="模型矩阵-GL-MODELVIEW"><a href="#模型矩阵-GL-MODELVIEW" class="headerlink" title="模型矩阵 GL_MODELVIEW"></a>模型矩阵 GL_MODELVIEW</h3><p>调用模型矩阵，需要考虑清楚是否需要清空成单位矩阵，比如：</p>
<p>平移时（glTranslatef），如果需要循环，那就不能清空，这样会在上一次矩阵的基础上继续移动，造成循环的效果；如果清空了，每次乘以新的模型矩阵结果都不会变；</p>
<p>缩放时（glScalef），需要清空，不然每次在都在前一次的矩阵基础上继续缩放，会造成越来越大或者越来越小；</p>
<p>旋转时（glRotatef），如果是传递进去的递增的值，那就可以清空，否则不能清空。</p>
<p>需要指定滤波的包装参数，否则超过边界后会出现未知的结果。</p>
<h3 id="投影矩阵-GL-PROJECTION"><a href="#投影矩阵-GL-PROJECTION" class="headerlink" title="投影矩阵 GL_PROJECTION"></a>投影矩阵 GL_PROJECTION</h3><p>透视投影</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gluPerspective</span>(<span class="number">60</span>,<span class="built_in"><span class="keyword">double</span></span>(_width)/<span class="built_in"><span class="keyword">double</span></span>(_height),<span class="number">0.1</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p> 正交投影</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glOrtho</span>(<span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">2.0f</span>, <span class="number">-1000.0</span>, <span class="number">1000.0</span>);</span><br><span class="line"><span class="built_in">glBegin</span>(GL_QUADS);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure>

<p>画在了rect(-1,-1,1,1)范围上，而且显示Rect(-2.0f,2.0f,-2.0f,2.0f)范围，所以都会显示出来，</p>
<p><img src="/2021/09/06/OpenGL/wps3.jpg" alt="img"> </p>
<p>但是如果是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glOrtho</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">glBegin</span>(GL_QUADS);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure>

<p>画在了rect(-1,-1,1,1)范围上，但是只显示Rect(0,0,1,1)范围，所以只能显示****1/4****的区域。</p>
<p><img src="/2021/09/06/OpenGL/wps4.jpg" alt="img"> </p>
<p> 要特别注意，上面两个只能针对直接绘制在界面行的，如直接传递顶点和纹理坐标，不使用shader的情况；</p>
<p>从顶点着色器出来的坐标是标准化之后的，标准设备坐标就是[-1,1],所以如果传进去的是真实的值，比如地图的经纬度[-180,180],[-90,90],那用上面的投影设置方式是行不通的，得通过传矩阵的方式将[-180,180],[-90,90]投影到[-1,1]。</p>
<p>或者换个理解，投影的含义，就是把left,right,bottom,top范围内的内容投影到视口里显示出来，不使用着色器时，用glortho，使用着色器时，用投影矩阵的形式传进去，但是最终的目的都是把left,right,bottom,top范围内的内容投影到视口里显示出来，在这个过程中，有两种情况：</p>
<p>1.不传纹理，直接给坐标点，这个过程关键在于坐标点是否处于投影的范围内，传入给的坐标点可能超过这个范围，可能等于，可能小于。超过范围，那就画不出来；小于范围，那就留有空余的地方。比如要显示长宽都为4K个点的方形，那就得用4K为边界的投影矩阵，大于4K的，比如8K，结果就如同缩小了一样，比如上上图（同样的视口，要显示8K×8K，你只显示了4K×4K，占得空间肯定就小了）；小于4K了，比如2K，结果就如同放大一样，比如上图（同样的视口，要显示2K×2K就满了，你给了个4K×4K，超过的就显示不出来了），视口是没有变化的，只不过里面的内容变了，本来可以显示全球的，只显示了中国，看起来是放大了，本来只能显示中国，你给显示了全球，看起来是缩小了。</p>
<p>2.传入纹理，纹理坐标就是【0,1】，正常来说，全部显示在视口里，应该把投影矩阵设置为【-1,1】刚好匹配上，即用纹理的【0,1】填充视口的【-1,1】，但是如果改变了投影，比如放大到【-2,2】，意味着用【-2,2】范围的东西来填充整个视口，但是纹理的【0,1】只填充了视口的【-1,1】，所以看起来就是缩小了；如果用【0,1】范围的东西填充视口，但是纹理的【0,1】填充了视口的【-1,1】，超过范围了，那就只能显示整幅图的1/4（这有个重要前提，那就是确保用纹理的【0,1】填充视口的【-1,1】，否则我们完全可以改变投影的同时，改变传入的顶点坐标，让两者匹配上就完事了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glOrtho</span>(<span class="number">0</span>, <span class="number">640</span>, <span class="number">480</span>, <span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBegin</span>(GL_QUADS);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-640</span>, <span class="number">-480</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">640</span>, <span class="number">-480</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-640</span>, <span class="number">480</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br></pre></td></tr></table></figure>



<h2 id="投影："><a href="#投影：" class="headerlink" title="投影："></a>投影：</h2><p><em><strong>*OpenGL支持两种投影，透视投影和正投影*</strong></em></p>
<p>****正投影(Orthographic Projection)****：又名平行投影，此时可以指定的视景体是长方体<br><em><strong>*透视投影(Perspective Projection)*<em><strong>：会进行透视除法距离观察者远的对象会变小，此时指定的视景体是</strong></em>*平截头体*</strong></em></p>
<p>下图左侧是正投影的视景体，右图是透视投影的视景体 **<em>*<em>即平截头体(Frustum)*</em>*</em>*</p>
<p><img src="/2021/09/06/OpenGL/image-20210906205041016.png" alt="image-20210906205041016"></p>
<p>正投影，glOrtho()给定投影矩阵，个人理解是指定多大范围的设备（范围是[-1,1]）内容显示在视口中</p>
<p>**<em>*<em>首先必须把当前矩阵设为投影矩阵, 才能修改投影方式*</em>*</em>*</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glMatrixMode</span>( GL_PROJECTION );</span><br><span class="line"><span class="built_in">glLoadIdentity</span>();</span><br><span class="line"><span class="comment">//正投影</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glOrtho</span><span class="params">(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top,GLdouble near,GLdouble far)</span></span>;</span><br><span class="line"><span class="comment">//glOrtho就是一个正射投影函数。它创建一个平行视景体。实际上这个函数的操作是创建一个正射投影矩阵，并且用这个矩阵乘以当前矩阵。</span></span><br><span class="line"><span class="comment">//如果绘制的图空间本身就是二维的，可以使gluOrtho2D.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//透视投影</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glFrustum</span><span class="params">(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)</span></span>;</span><br><span class="line"><span class="comment">//glFrustum函数定义一个平截头体，它计算一个用于实现透视投影的矩阵，并把它与当前的投影矩阵（一般是单位矩阵）相乘。该函数构造了一个视景体用来将模型进行投影，来裁剪模型，决定模型哪些在视景体里面，哪些在视景体的外面，在视景体之外的就不可见。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glPerspective</span><span class="params">(GLdouble fov, GLdouble aspect, GLdouble near, GLdouble far)</span></span></span><br><span class="line"><span class="function"><span class="comment">//glPerspective也是用于透视投影，功能和glFrustum非常相似，参数不一样</span></span></span><br></pre></td></tr></table></figure>

<p>基本的透视投影模型由视点Observer、near近平面和far远平面（远平面可以是无限远，在这里我们设定一个值便于理解），三部分构成（要求Observer不在near上），称为视椎体。Observer可以认为是观察者的位置，也是观察三维世界的角度。near近平面一般被认为渲染三维对象透视图的二维平面。对于世界即near和far之间中的任一点X，构造一条起点为Observer并经过X点的射线R，R与平面near的交点Xp即是X点的透视投影结果。三维世界的物体可以看作是由点集合{Xi} 构成的，这样依次构造起点为Observer，并经过点Xi的射线Ri，这些射线与视平面fnear的交点集合便是三维世界在当前视点的透视图。</p>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>在我们画出出色的效果之前，首先要做的就是创建一个OpenGL上下文(Context)和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL有目的地从这些操作抽象(Abstract)出去。这意味着我们不得不自己处理创建窗口，定义OpenGL上下文以及处理用户输入。</p>
<p>幸运的是，有一些库已经提供了我们所需的功能，其中一部分是特别针对OpenGL的。这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。最流行的几个库有<mark class="hl-label blue">GLUT，SDL，SFML和GLFW</mark> 。在教程里我们将使用****GLFW****。</p>
<p>在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置窗口的<em><strong>*维度*</strong></em>(Dimension)：</p>
<blockquote>
<p>glViewport(0, 0, 800, 600);</p>
</blockquote>
<p>glViewport函数前两个参数控制窗口<mark class="hl-label blue">左下角</mark> 的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p>
<p>我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。</p>
<blockquote>
<p>OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1<mark class="hl-label blue">(标准设备坐标)</mark> ，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</p>
</blockquote>
<h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p>一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由<a href="http://www.khronos.org/">Khronos组织</a>制定并维护的规范(Specification)。</p>
<p>OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定(<mark class="hl-label blue">译注：这里开发者是指编写OpenGL库的人,而库的开发者开发出来的有glew、glut、glfw等等</mark> ）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。</p>
<p>实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。</p>
<p>所有版本的OpenGL规范文档都被公开的寄存在Khronos那里。有兴趣的读者可以找到OpenGL3.3（我们将要使用的版本）的<a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf">规范文档</a>。如果你想深入到OpenGL的细节（只关心函数功能的描述而不是函数的实现），这是个很好的选择。如果你想知道每个函数****具体的****运作方式，这个规范也是一个很棒的参考。</p>
<h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>****GLSL(OpenGL Shading Language)****即OpenGL着色语言<br>这是一种非常类似于C的程序设计语言。但是，GLSL不会对应用程序流程和逻辑进行控制，而是用于渲染操作。 </p>
<h2 id="OpenGL扩展机制"><a href="#OpenGL扩展机制" class="headerlink" title="OpenGL扩展机制"></a>OpenGL扩展机制</h2><p>opengl支持不同硬件厂商扩展API或者枚举<br>可以动态查询使用的OpenGL支持的扩展，使用GLEW库更简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GLint ext_count;</span><br><span class="line"><span class="built_in">glGetIntegerv</span>(GL_NUM_EXTENSIONS, &amp;ext_count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得扩展api的字符串名称</span></span><br><span class="line"><span class="built_in">glGetStringi</span>(GL_EXTENSIONS, i)</span><br></pre></td></tr></table></figure>

<h2 id="核心模式与立即渲染模式"><a href="#核心模式与立即渲染模式" class="headerlink" title="核心模式与立即渲染模式"></a>核心模式与立即渲染模式</h2><p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p>
<p>当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL****实际****运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。</p>
<p>现今，更高版本的OpenGL已经发布（写作时最新版本为4.5），你可能会问：既然OpenGL 4.5 都出来了，为什么我们还要学习OpenGL 3.3？答案很简单，所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。</p>
<p>使用扩展的代码大多看上去如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 使用硬件支持的全新的现代特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 不支持此扩展: 用旧的方式去做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：<mark class="hl-label blue">设置选项，操作缓冲</mark> 。最后，我们使用当前OpenGL上下文来渲染。</p>
<p>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过<mark class="hl-label blue">改变一些上下文变量</mark> 来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，<mark class="hl-label blue">下一个绘制命令</mark> 就会画出线段而不是三角形。</p>
<p>当使用OpenGL的时候，我们会遇到一些<mark class="hl-label blue">状态设置函数</mark> (State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>使用一个自定义的颜色清空屏幕。我们可以通过调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure>

<p>注意，除了glClear之外，我们还调用了glClearColor来设置清空屏幕所用的颜色。当调用glClear函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为glClearColor里所设置的颜色。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p>
<p>你应该能够回忆起来我们在 <strong>OpenGL</strong> 这节教程的内容，glClearColor函数是一个****状态设置*<em><strong>函数，而glClear函数则是一个</strong></em>*状态使用****的函数，它使用了当前的状态来获取应该清除为的颜色。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。</p>
<mark class="hl-label red">在OpenGL中一个对象是指一些选项的集合，它代表**OpenGL状态的一个子集**。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。</mark> 可以把对象看做一个C风格的结构体(Struct)：

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_name</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> option1;</span><br><span class="line">  <span class="keyword">int</span>  option2;</span><br><span class="line">  <span class="keyword">char</span>[] name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em><strong>*译注*</strong></em></p>
<blockquote>
<p>在更新前的教程中一直使用的都是OpenGL的基本类型，但由于作者觉得在本教程系列中并没有一个必须使用它们的原因，所有的类型都改为了自带类型。但是请仍然记住，使用OpenGL的类型的好处是保证了在各平台中每一种类型的大小都是统一的。你也可以使用其它的定宽类型(Fixed-width Type)来实现这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenObject</span>(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// 绑定对象至上下文</span></span><br><span class="line"><span class="built_in">glBindObject</span>(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line"><span class="built_in">glSetObjectOption</span>(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line"><span class="built_in">glSetObjectOption</span>(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line"><span class="built_in">glBindObject</span>(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p>
<p>目前提供的示例代码只是OpenGL如何操作的一个大致描述，通过阅读以后的教程你会遇到很多实际的例子。</p>
<p>使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p>
</blockquote>
<h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，<mark class="hl-label blue">实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</mark> ）管理的。</p>
<p>图形渲染管线可以被划分为<mark class="hl-label blue">两个主要部分</mark> ：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<blockquote>
<p>2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</p>
</blockquote>
<p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的。</p>
<p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。</p>
<p><img src="/2021/09/06/OpenGL/image-20210906213223520.png" alt="image-20210906213223520"></p>
<p>如你所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。我们会概括性地解释一下渲染管线的每个部分，让你对图形渲染管线的工作方式有个大概了解。</p>
<h2 id="顶点数据输入"><a href="#顶点数据输入" class="headerlink" title="顶点数据输入"></a>顶点数据输入</h2><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)</p>
<blockquote>
<p>参照GLSL，感觉像是着色器输入的数据分配有一个属性，如坐标属性，颜色属性，也可以参考更多属性一节</p>
<p>顶点数组中就是一堆数据，啥也不知道，只有在传进顶点着色器里面的时候分配了属性才做为某一个具体的顶点属性</p>
</blockquote>
<p>表示(我理解是在顶点着色器里描述顶点数据的，有坐标，颜色等属性)的，它可以包含任何我们想用的数据，但是简单起见，还是假定每个顶点只由一个3D位置和一些颜色值组成。</p>
<blockquote>
<p>当我们谈论一个“位置”的时候，它代表在一个“空间”中所处地点的这个特殊属性；同时“空间”代表着任何一种坐标系，比如x、y、z三维坐标系，x、y二维坐标系，或者一条直线上的x和y的线性关系，只不过二维坐标系是一个扁扁的平面空间，而一条直线是一个很瘦的长长的空间。</p>
<p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>
</blockquote>
<h2 id="进入顶点着色器"><a href="#进入顶点着色器" class="headerlink" title="进入顶点着色器"></a>进入顶点着色器</h2><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<h2 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h2><p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本例子中是一个三角形。</p>
<h2 id="进入几何着色器"><a href="#进入几何着色器" class="headerlink" title="进入几何着色器"></a>进入几何着色器</h2><p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行<mark class="hl-label blue">裁切</mark> (Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<blockquote>
<p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</p>
</blockquote>
<h2 id="进入片段着色器"><a href="#进入片段着色器" class="headerlink" title="进入片段着色器"></a>进入片段着色器</h2><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p>
<p>在现代OpenGL中，我们****必须****定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p>
<h2 id="Opengl绘制方式"><a href="#Opengl绘制方式" class="headerlink" title="Opengl绘制方式"></a>Opengl绘制方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">产生-》激活-》启用-》绑定</span><br><span class="line"><span class="keyword">unsigned</span>    texId;</span><br><span class="line"><span class="built_in">glGenTextures</span>( <span class="number">1</span>, &amp;texId);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D,texId);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);<span class="comment">//设置滤波</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,<span class="number">0</span>,GL_RGBA,w,h,<span class="number">0</span>,GL_RGBA,GL_UNSIGNED_BYTE,data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glActiveTextureARB</span>(GL_TEXTURE0_ARB);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D,  _texture1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glActiveTextureARB</span>(GL_TEXTURE1_ARB);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D,  _texture2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//旧方式</span></span><br><span class="line"><span class="built_in">glBegin</span>(GL_QUADS);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE0_ARB, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glMultiTexCoord2fARB</span>(GL_TEXTURE1_ARB, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glVertex3f</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点（纹理）数组的方式</span></span><br><span class="line"><span class="built_in">glEnableClientState</span>(GL_VERTEX_ARRAY);</span><br><span class="line"><span class="built_in">glVertexPointer</span>(<span class="number">3</span>,GL_FLOAT,         <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex),     &amp;cubeVertices[<span class="number">0</span>].x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClientActiveTextureARB</span>(GL_TEXTURE0_ARB);<span class="comment">//启用客户端纹理数组</span></span><br><span class="line"><span class="built_in">glTexCoordPointer</span>(<span class="number">2</span>,GL_FLOAT,       <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex),     &amp;cubeVertices[<span class="number">0</span>].u);</span><br><span class="line"><span class="built_in">glEnableClientState</span>(GL_TEXTURE_COORD_ARRAY);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClientActiveTextureARB</span>(GL_TEXTURE1_ARB);</span><br><span class="line"><span class="built_in">glTexCoordPointer</span>(<span class="number">2</span>,GL_FLOAT,       <span class="built_in"><span class="keyword">sizeof</span></span>(Vertex),     &amp;cubeVertices[<span class="number">0</span>].u);</span><br><span class="line"><span class="built_in">glEnableClientState</span>(GL_TEXTURE_COORD_ARRAY);</span><br><span class="line">会有疑问？两张纹理都调用内存里面的纹理坐标，会不会冲突？不会，因为取这个坐标是只读的。</span><br></pre></td></tr></table></figure>



<h1 id="OPenGL概念"><a href="#OPenGL概念" class="headerlink" title="OPenGL概念"></a>OPenGL概念</h1><h2 id="顶点缓冲对象：Vertex-Buffer-Object，VBO"><a href="#顶点缓冲对象：Vertex-Buffer-Object，VBO" class="headerlink" title="顶点缓冲对象：Vertex Buffer Object，VBO"></a>顶点缓冲对象：Vertex Buffer Object，VBO</h2><p>我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">   <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">   <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的<em><strong>*深度*</strong></em>(Depth, <mark class="hl-label blue">通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源</mark> 。)都是一样的，从而使它看上去像是2D的。</p>
<p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>
<p>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>
<p>顶点缓冲对象是我们在[OpenGL](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started/01 OpenGL/)教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure>

<p>OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型（数据不同也可以）。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);  </span><br></pre></td></tr></table></figure>

<p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来<mark class="hl-label blue">配置当前绑定的缓冲(VBO)</mark> 。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<p>glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)，用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p>
<p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>
<p>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。</p>
<h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着****我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性****。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。</p>
<p>我们的顶点缓冲数据会被解析为下面这样子：</p>
<p><img src="/2021/09/06/OpenGL/wps5.jpg" alt="img"> </p>
<ul>
<li>位置数据被储存为32位（4字节）浮点值。</li>
<li>每个位置包含3个这样的值。</li>
<li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。</li>
<li>数据中第一个值在缓冲开始的位置。</li>
</ul>
<p>有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：</p>
<ul>
<li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。</li>
<li>第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。</li>
<li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。</li>
<li>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。</li>
<li>最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li>
</ul>
<p>每个顶点属性从一个VBO管理的内存中获得它的数据，<mark class="hl-label red">而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。</mark> </p>
<p>如下面的代码，先绑定VBO，再指定location=0位置的着色器代码使用这个VBO中存储的数据（如果还有别的位置，可以继续写，绑定VBO再指定其他位置的代码使用相应的VBO数据）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);	<span class="comment">// Vertex attributes stay the same</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；<mark class="hl-label blue">顶点属性默认是禁用的</mark> 。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针//这的0不是解绑，而是指激活着色器中location为0的顶点属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">//这的0不是解绑，而是指激活着色器中location为0的顶点属性</span></span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line"><span class="built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();</span><br></pre></td></tr></table></figure>

<p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p>
<h2 id="顶点数组对象：Vertex-Array-Object，VAO"><a href="#顶点数组对象：Vertex-Array-Object，VAO" class="headerlink" title="顶点数组对象：Vertex Array Object，VAO"></a>顶点数组对象：Vertex Array Object，VAO</h2><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中</p>
<blockquote>
<p>OpenGL的核心模式****要求****我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</p>
</blockquote>
<p>一个顶点数组对象会储存以下这些内容：</p>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
<p><img src="/2021/09/06/OpenGL/image-20210909165917619.png" alt="image-20210909165917619"></p>
<p>创建一个VAO和创建一个VBO很类似：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">unsigned <span class="type">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure>

<p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(<span class="keyword">vertices</span>), <span class="keyword">vertices</span>, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES,<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p>
<h2 id="索引缓冲对象：Element-Buffer-Object，EBO或Index-Buffer-Object，IBO"><a href="#索引缓冲对象：Element-Buffer-Object，EBO或Index-Buffer-Object，IBO" class="headerlink" title="索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO"></a>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</h2><p>索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。</p>
<p>索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="keyword">vertices</span>[] = &#123;</span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned <span class="type">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建索引缓冲对象：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">unsigned <span class="type">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure>

<p>与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<p>要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</p>
<p>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。</p>
<p><img src="/2021/09/06/OpenGL/image-20210909184321462.png" alt="image-20210909184321462"></p>
<blockquote>
<p>当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</p>
</blockquote>
<p>最后的初始化和绘制代码现在看起来像这样：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="type">float</span> <span class="keyword">vertices</span>[] = &#123;</span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">0.5</span>f, <span class="number">0.0</span>f   <span class="comment">// 左上角</span></span><br><span class="line">        &#125;;</span><br><span class="line">    unsigned <span class="type">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">unsigned <span class="type">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">unsigned <span class="type">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">unsigned <span class="type">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">    <span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">// check for shader compile errors</span></span><br><span class="line"><span class="type">int</span> success;</span><br><span class="line">char infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"><span class="comment">// check for shader compile errors</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接着色器</span></span><br><span class="line"><span class="type">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line"><span class="comment">// check for linking errors</span></span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(<span class="keyword">vertices</span>), <span class="keyword">vertices</span>, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针//这的0不是解绑，而是指激活着色器中location为0的顶点属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);<span class="comment">//这的0不是解绑，而是指激活着色器中location为0的顶点属性</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。</p>
<p><img src="/2021/09/06/OpenGL/image-20210909184508240.png" alt="image-20210909184508240"></p>
<blockquote>
<p><em><strong>*线框模式(Wireframe Mode)*</strong></em></p>
<p>要想用线框模式绘制你的三角形，你可以通过glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。</p>
</blockquote>
<h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><p>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种<mark class="hl-label red">把输入转化为输出</mark> 的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>
<p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>
<p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p>
<p>一个典型的着色器有下面的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>GLSL有数据类型可以来指定变量的种类。GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。GLSL也有两种容器类型，它们会在这个教程中使用很多，分别是向量(Vector)和矩阵(Matrix)。</p>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）：</p>
<table>
<thead>
<tr>
<th><em><strong>*类型*</strong></em></th>
<th><em><strong>*含义*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>vecn</td>
<td>包含n个float分量的默认向量</td>
</tr>
<tr>
<td>bvecn</td>
<td>包含n个bool分量的向量</td>
</tr>
<tr>
<td>ivecn</td>
<td>包含n个int分量的向量</td>
</tr>
<tr>
<td>uvecn</td>
<td>包含n个unsigned int分量的向量</td>
</tr>
<tr>
<td>dvecn</td>
<td>包含n个double分量的向量</td>
</tr>
</tbody></table>
<p>大多数时候我们使用vecn，因为float足够满足大多数要求了。</p>
<p>一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量<mark class="hl-label Division)上）">（注意vec.w分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective</mark> 。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。</p>
<p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec2 someVec;</span><br><span class="line">vec4 differentVec = someVec.xyxx;</span><br><span class="line">vec3 anotherVec = differentVec.zyw;</span><br><span class="line">vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br></pre></td></tr></table></figure>

<p>你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个vec2向量中去获取.z元素。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec2 vect = <span class="built_in">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line">vec4 result = <span class="built_in">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec4 otherResult = <span class="built_in">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。学完教程你会看到很多新颖的管理向量的例子。</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h2 id="输入与输出-layout"><a href="#输入与输出-layout" class="headerlink" title="输入与输出 layout"></a>输入与输出 layout</h2><p>虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。</p>
<p>顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入（gl_Position）。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。</p>
<blockquote>
<p>也可以忽略layout (location = 0)标识符，通过在OpenGL代码中使用glGetAttribLocation查询属性位置值(Location)，但这样会更容易理解而且节省你（和OpenGL）的工作量。</p>
</blockquote>
<p>另一个例外是片段着色器，它需要一个vec4颜色输出变量（FragColor），因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。</p>
<p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。</p>
<p><em><strong>*顶点着色器*</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line">out vec4 vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">  vertexColor = <span class="built_in">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>*片段着色器*</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec4 vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在顶点着色器中声明了一个vertexColor变量作为vec4输出，并在片段着色器中声明了一个类似的vertexColor。由于它们名字相同且类型相同，片段着色器中的vertexColor就和顶点着色器中的vertexColor链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。</p>
<h2 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h2><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。我们来看看这次是否能通过uniform设置三角形的颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">uniform vec4 ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在片段着色器中声明了一个uniform vec4的ourColor，并把片段着色器的输出颜色设置为uniform值的内容。因为uniform是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个uniform，所以我们不用在那里定义它。</p>
<blockquote>
<p>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p>
</blockquote>
<p>这个uniform现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中uniform属性的索引/位置值。当我们得到uniform的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> timeValue = <span class="built_in">glfwGetTime</span>();</span><br><span class="line"><span class="keyword">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">int</span> vertexColorLocation = <span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glUniform4f</span>(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>首先我们通过glfwGetTime()获取运行的秒数。然后我们使用sin函数让颜色在0.0到1.0之间改变，最后将结果储存到greenValue里。</p>
<p>接着，我们用glGetUniformLocation查询uniform ourColor的位置值。我们为查询函数提供着色器程序和uniform的名字（这是我们希望获得的位置值的来源）。如果glGetUniformLocation返回-1就代表没有找到这个位置值。最后，我们可以通过glUniform4f函数设置uniform值。注意，<mark class="hl-label red">查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你***\*必须\****先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。</mark> </p>
<blockquote>
<p>因为OpenGL在其核心是一个C库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有：</p>
<table>
<thead>
<tr>
<th><em><strong>*后缀*</strong></em></th>
<th><em><strong>*含义*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>f</td>
<td>函数需要一个float作为它的值</td>
</tr>
<tr>
<td>i</td>
<td>函数需要一个int作为它的值</td>
</tr>
<tr>
<td>ui</td>
<td>函数需要一个unsigned int作为它的值</td>
</tr>
<tr>
<td>3f</td>
<td>函数需要3个float作为它的值</td>
</tr>
<tr>
<td>fv</td>
<td>函数需要一个float向量/数组作为它的值</td>
</tr>
</tbody></table>
<p>每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定uniform的4个float值，所以我们通过glUniform4f传递我们的数据(注意，我们也可以使用fv版本)。</p>
</blockquote>
<h2 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器 Vertex Shader"></a>顶点着色器 Vertex Shader</h2><p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nrAttributes;</span><br><span class="line"><span class="built_in">glGetIntegerv</span>(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Maximum nr of vertex attributes supported: &quot;</span> &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>通常情况下它至少会返回16个，大部分情况下是够用了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，GLSL看起来很像C语言。每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。</p>
<p>下一步，使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。创建一个vec3输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值。</p>
<p>为了设置顶点着色器的输出，我们必须把位置数据赋值给<mark class="hl-label blue">预定义</mark> 的gl_Position变量，它在幕后是vec4类型的。在main函数的最后，我们将gl_Position设置的值会成为该顶点着色器的输出。</p>
<p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至OpenGL的可视区域内<mark class="hl-label blue">（投影矩阵）</mark> 。</p>
<h2 id="片段着色器-Fragment-Shader"><a href="#片段着色器-Fragment-Shader" class="headerlink" title="片段着色器 Fragment Shader"></a>片段着色器 Fragment Shader</h2><p>片段着色器所做的是计算像素最后的颜色输出。</p>
<blockquote>
<p>在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用out关键字声明输出变量，这里我们命名为FragColor。下面，我们将一个alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。</p>
<p>编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">unsigned <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p>
<h2 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h2><p>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为unsigned int，然后用glCreateShader创建这个着色器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure>

<p>我们把需要创建的着色器类型以参数形式提供给glCreateShader(GL_VERTEX_SHADER/GL_FRAGMENT_SHADER)。</p>
<p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br></pre></td></tr></table></figure>

<p>glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为NULL。</p>
<p>你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br></pre></td></tr></table></figure>

<p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译的时候没有检测到任何错误，着色器就被编译成功了。</p>
<p>编译上面两节的着色器：</p>
<p>顶点着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">unsigned <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure>

<p>片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">unsigned <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure>

<h2 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h2><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p>
<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p>
<p>创建一个程序对象很简单：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">unsigned <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。</p>
<p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>

<h2 id="更多属性！"><a href="#更多属性！" class="headerlink" title="更多属性！"></a>更多属性！</h2><p>在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="keyword">vertices</span>[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够<mark class="hl-label blue">接收颜色值作为一个顶点属性输入</mark> 。需要注意的是我们用layout标识符来把aColor属性的位置值设置为1：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不再使用uniform来传递片段的颜色了，现在使用ourColor输出变量，我们必须再修改一下片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样：</p>
<p><img src="/2021/09/06/OpenGL/image-20210909190241227.png" alt="image-20210909190241227"></p>
<p>知道了现在使用的布局，我们就可以使用glVertexAttribPointer函数更新顶点格式，</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="type">float</span> <span class="keyword">vertices</span>[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f,  <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">unsigned <span class="type">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">unsigned <span class="type">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">// check for shader compile errors</span></span><br><span class="line"><span class="type">int</span> success;</span><br><span class="line">char infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"><span class="comment">// check for shader compile errors</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接着色器</span></span><br><span class="line"><span class="type">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line"><span class="comment">// check for linking errors</span></span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(<span class="keyword">vertices</span>), <span class="keyword">vertices</span>, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设定顶点属性指针</span></span><br><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span>* sizeof(<span class="type">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES,<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</p>
<p>由于我们现在有了两个顶点属性，我们不得不重新计算****步长****值。为获得数据队列中下一个属性值（比如位置向量的下个x分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为6乘以float的字节数（=24字节）。<br>同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(float)，用字节来计算就是12字节。</p>
<p><img src="/2021/09/06/OpenGL/image-20210909190332616.png" alt="image-20210909190332616"></p>
<p>片段着色器中进行的所谓<mark class="hl-label blue">片段插值</mark> (Fragment Interpolation)的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。<br>基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。</p>
<p>这正是在这个三角形中发生了什么。我们有3个顶点，和相应的3个颜色，从这个三角形的像素来看它可能包含50000左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。</p>
<h2 id="我们自己的着色器类"><a href="#我们自己的着色器类" class="headerlink" title="我们自己的着色器类"></a>我们自己的着色器类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span>; <span class="comment">// 包含glad来获取所有的必须OpenGL头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 程序ID</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">    <span class="built_in">Shader</span>(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath);</span><br><span class="line">    <span class="comment">// 使用/激活程序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// uniform工具函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Shader</span>(<span class="keyword">const</span> <span class="keyword">char</span>* vertexPath, <span class="keyword">const</span> <span class="keyword">char</span>* fragmentPath)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 从文件路径中获取顶点/片段着色器</span></span><br><span class="line">    std::string vertexCode;</span><br><span class="line">    std::string fragmentCode;</span><br><span class="line">    std::ifstream vShaderFile;</span><br><span class="line">    std::ifstream fShaderFile;</span><br><span class="line">    <span class="comment">// 保证ifstream对象可以抛出异常：</span></span><br><span class="line">    vShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">    fShaderFile.<span class="built_in">exceptions</span> (std::ifstream::failbit | std::ifstream::badbit);</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        vShaderFile.<span class="built_in">open</span>(vertexPath);</span><br><span class="line">        fShaderFile.<span class="built_in">open</span>(fragmentPath);</span><br><span class="line">        std::stringstream vShaderStream, fShaderStream;</span><br><span class="line">        <span class="comment">// 读取文件的缓冲内容到数据流中</span></span><br><span class="line">        vShaderStream &lt;&lt; vShaderFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">        fShaderStream &lt;&lt; fShaderFile.<span class="built_in">rdbuf</span>();       </span><br><span class="line">        <span class="comment">// 关闭文件处理器</span></span><br><span class="line">        vShaderFile.<span class="built_in">close</span>();</span><br><span class="line">        fShaderFile.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 转换数据流到string</span></span><br><span class="line">        vertexCode   = vShaderStream.<span class="built_in">str</span>();</span><br><span class="line">        fragmentCode = fShaderStream.<span class="built_in">str</span>();     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(std::ifstream::failure e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vShaderCode = vertexCode.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fShaderCode = fragmentCode.<span class="built_in">c_str</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 编译着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertex, fragment;</span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    vertex = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertex, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertex);</span><br><span class="line">    <span class="comment">// 打印编译错误（如果有的话）</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertex, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span>(!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertex, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">	fragment = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragment, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragment);</span><br><span class="line">    <span class="comment">// 打印编译错误（如果有的话）</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragment, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span>(!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragment, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::fragment::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 着色器程序</span></span><br><span class="line">    ID = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(ID, vertex);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(ID, fragment);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(ID);</span><br><span class="line">    <span class="comment">// 打印连接错误（如果有的话）</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(ID, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span>(!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(ID, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertex);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">glUseProgram</span>(ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), (<span class="keyword">int</span>)value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> std::string &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ID, name.<span class="built_in">c_str</span>()), value); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;path/to/shaders/shader.vs&quot;</span>, <span class="string">&quot;path/to/shaders/shader.fs&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    ourShader.<span class="built_in">use</span>();</span><br><span class="line">    ourShader.<span class="built_in">setFloat</span>(<span class="string">&quot;someUniform&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">DrawStuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>纹理不是一张图片，而是一系列的图片，会分级，第0级表示最大的，慢慢的级别变大，图会变小，每次长宽会减少1/2，所以整体会减少到原来的1/4，到最高级就只剩下一个像素了**(参考多级渐远纹理)**。</p>
<p>分级是为了缩放的时候减少插值计算的时间。</p>
<p>分级纹理要求长宽必须是****4****的倍数，这样能保证最高级是一个像素。</p>
<blockquote>
<p>有些图片没有mipmap，我们可以自己制作，opengl没有这样的函数，可以使用glu库的<em>gluBuild2DMipmaps</em>()函数，它会根据长宽自己计算（或者自己写for循环，每一级用glTexImage2D指定不同的数据）。它实际上就干了两件事：for循环调用glTexImage2D，循环的次数是宽高每次/2+图片缩放</p>
</blockquote>
<p><strong>这样生成的多级纹理就可以使用下面的滤波选项了</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//     GL_NEAREST	在mip基层上使用最邻近过滤</span></span><br><span class="line"><span class="comment">//     GL_LINEAR	在mip基层上使用线性过滤</span></span><br><span class="line"><span class="comment">//     GL_NEAREST_MIPMAP_NEAREST	选择最邻近的mip层，并使用最邻近过滤</span></span><br><span class="line"><span class="comment">//     GL_NEAREST_MIPMAP_LINEAR	在mip层之间使用线性插值和最邻近过滤</span></span><br><span class="line"><span class="comment">//     GL_LINEAR_MIPMAP_NEAREST	选择最邻近的mip层，使用线性过滤</span></span><br><span class="line"><span class="comment">//     GL_LINEAR_MIPMAP_LINEAR	在mip层之间使用线性插值和使用线性过滤，又称三线性mipmap</span></span><br></pre></td></tr></table></figure>

<p>可以使用glTexImage2D（）指定往第几级里填数据，我们一般使用第二个参数是0，表示把数据填充到第0级，也就是最大的那张图。我们可以循环不同级给他不同的数据</p>
<p><img src="/2021/09/06/OpenGL/image-20210909192149175.png" alt="image-20210909192149175"></p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p>
<p><img src="/2021/09/06/OpenGL/image-20210909192259766.png" alt="image-20210909192259766"></p>
<p>我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。</p>
<p>纹理坐标看起来就像这样：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">1.0</span>f <span class="comment">// 上中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉OpenGL该怎样对纹理****采样****。</p>
<h2 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h2><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</p>
<table>
<thead>
<tr>
<th><em><strong>*环绕方式*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>GL_REPEAT</td>
<td>对纹理的默认行为。重复纹理图像。</td>
</tr>
<tr>
<td>GL_MIRRORED_REPEAT</td>
<td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
</tr>
<tr>
<td>GL_CLAMP_TO_EDGE</td>
<td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
</tr>
<tr>
<td>GL_CLAMP_TO_BORDER</td>
<td>超出的坐标为用户指定的边缘颜色。</td>
</tr>
</tbody></table>
<p>当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：</p>
<p><img src="/2021/09/06/OpenGL/image-20210909192421776.png" alt="image-20210909192421776"></p>
<p>前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure>

<p>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</p>
<p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。</p>
<blockquote>
<p>Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</p>
</blockquote>
<p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920163910614.png" alt="image-20210920163910614"></p>
<p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920163927200.png" alt="image-20210920163927200"></p>
<p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920163946221.png" alt="image-20210920163946221"></p>
<p>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p>
<p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<h3 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h3><p>想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p>
<p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920164308346.png" alt="image-20210920164308346"></p>
<p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。</p>
<p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p>
<table>
<thead>
<tr>
<th><em><strong>*过滤方式*</strong></em></th>
<th><em><strong>*描述*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>GL_NEAREST_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_NEAREST</td>
<td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td>GL_NEAREST_MIPMAP_LINEAR</td>
<td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td>GL_LINEAR_MIPMAP_LINEAR</td>
<td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody></table>
<p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p>
<h2 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h2><h3 id="stb-image-h"><a href="#stb-image-h" class="headerlink" title="stb_image.h"></a>stb_image.h</h3><p>stb_image.h是<a href="https://github.com/nothings">Sean Barrett</a>的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h可以在<a href="https://github.com/nothings/stb/blob/master/stb_image.h">这里</a>下载。下载这一个头文件，将它以stb_image.h的名字加入你的工程，并另创建一个新的C++文件，输入以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含stb_image.h并编译就可以了。</p>
<p>下面的教程中，我们会使用一张<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg">木箱</a>的图片。要使用stb_image.h加载图片，我们需要使用它的stbi_load函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数首先接受一个图像文件的位置作为输入。接下来它需要三个int作为它的第二、第三和第四个参数，stb_image.h将会用图像的****宽度*<em><strong>、</strong></em>*高度*<em><strong>和</strong></em>*颜色通道的个数****填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。</p>
<h3 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h3><p>和之前生成的OpenGL对象一样，纹理也是使用ID引用的。让我们来创建一个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br></pre></td></tr></table></figure>

<p>glGenTextures函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的unsigned int数组中（我们的例子中只是单独的一个unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure>

<p>现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过glTexImage2D来生成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"><span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span> (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, <span class="keyword">const</span> <span class="keyword">void</span> *pixels);</span><br><span class="line"><span class="comment">//把pixels数据填充到第level层.</span></span><br></pre></td></tr></table></figure>

<p>函数很长，参数也不少，所以我们一个一个地讲解：</p>
<ul>
<li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li>
<li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li>
<li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。</li>
<li>第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li>
<li>下个参数应该总是被设为0（历史遗留的问题）。</li>
<li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。</li>
<li>最后一个参数是真正的图像数据。</li>
</ul>
<p>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果<mark class="hl-label blue">要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</mark> </p>
<p>生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></figure>

<p>生成一个纹理的过程应该看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br></pre></td></tr></table></figure>

<h3 id="应用纹理-采样器-Sampler"><a href="#应用纹理-采样器-Sampler" class="headerlink" title="应用纹理 采样器(Sampler)"></a>应用纹理 采样器(Sampler)</h3><p>我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//右上位置（0.5f,  0.5f, 0.0f）用指定的（1.0f, 0.0f, 0.0f）颜色填充；右上位置用纹理（1.0f, 1.0f）位置的颜色填充</span></span><br></pre></td></tr></table></figure>

<p>由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920165356695.png" alt="image-20210920165356695"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);<span class="comment">//参考更多属性一节，location为0和1的已经填入了数据，所以在这填入2的数据</span></span><br></pre></td></tr></table></figure>

<p>注意，我们同样需要调整前面两个顶点属性的步长参数为8 * sizeof(float)。</p>
<p>接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location = 0) in vec3 aPos;</span><br><span class="line">layout (location = 1) in vec3 aColor;</span><br><span class="line">layout (location = 2) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = vec4(aPos, 1.0);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器应该接下来会把输出变量TexCoord作为输入变量。</p>
<p>片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。</p>
<p>现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/06/OpenGL/image-20210920170252535.png" alt="image-20210920170252535"></p>
<p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/06/OpenGL/image-20210920170310294.png" alt="image-20210920170310294"></p>
<h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>你可能会奇怪为什么sampler2D变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。</p>
<p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, <span class="built_in">texture</span>);</span><br></pre></td></tr></table></figure>

<p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</p>
<blockquote>
<p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;<span class="comment">//第一个采样器，可以采集一个纹理单元</span></span><br><span class="line">uniform sampler2D texture2;<span class="comment">//第二个采样器，可以采集另一个纹理单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出颜色现在是两个纹理的结合。GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是0.0，它会返回第一个输入；如果是1.0，会返回第二个输入值。0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色。</p>
<p>为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，****先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元****：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们还要通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p>
<p>我们要通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。</p>
<blockquote>
<p>用的时候依次激活对应纹理单元，再将纹理绑定对应的纹理单元，然后在draw</p>
<p>纹理和纹理单元感觉不是一回事，纹理就是一张一张的图片，而纹理单元是固定的，同一个纹理单元，比如第一个纹理单元激活后可以绑定这个纹理，也可以绑定其他纹理，可以切换，所以经过片段着色器采集像素时可以采集同一个纹理单元中不同纹理的颜色，见【深度测试– 4.advanced_opengl__1.1.depth_testing】</p>
<p>但是我们需要设置采样器属于哪个纹理单元</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">urShader.<span class="built_in">use</span>(); <span class="comment">// 别忘记在激活着色器前先设置uniform！</span></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">// 手动设置，采集0号位置的纹理单元</span></span><br><span class="line">ourShader.<span class="built_in">setInt</span>(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>); <span class="comment">// 或者使用着色器类设置，采集1号位置的纹理单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) </span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用glUniform1i设置采样器，我们保证了每个uniform采样器对应着正确的纹理单元。你应该能得到下面的结果：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920171752802.png" alt="image-20210920171752802"></p>
<p>你可能注意到纹理上下颠倒了！这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。很幸运，stb_image.h能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>在让stb_image.h在加载图片时翻转y轴之后你就应该能够获得下面的结果了：</p>
<p><img src="/2021/09/06/OpenGL/image-20210920171805730.png" alt="image-20210920171805730"></p>
<h2 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成纹理</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture1;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成纹理</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture2;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture2);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data1 = <span class="built_in">stbi_load</span>(<span class="string">&quot;container1.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data1);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stbi_image_free</span>(data1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line">out vec3 ourColor;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line"><span class="comment">// check for shader compile errors</span></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line">uniform sampler2D texture1;<span class="comment">//第一个采样器，可以采集一个纹理单元</span></span><br><span class="line">uniform sampler2D texture2;<span class="comment">//第二个采样器，可以采集另一个纹理单元</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"><span class="comment">// check for shader compile errors</span></span><br><span class="line"><span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接着色器</span></span><br><span class="line"><span class="keyword">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line"><span class="comment">// check for linking errors</span></span><br><span class="line"><span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span>* <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 纹理属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">// 手动设置片段着色器中纹理采样器outTexture对应的是哪个位置</span></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(shaderProgram, <span class="string">&quot;texture2&quot;</span>), <span class="number">1</span>); <span class="comment">// 手动设置片段着色器中纹理采样器outTexture对应的是哪个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h1><p>到目前为止，我们已经使用了很多屏幕缓冲了：用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在内存中。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</p>
<p>我们目前所做的所有操作都是在默认帧缓冲的渲染缓冲上进行的。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。有了我们自己的帧缓冲，我们就能够有更多方式来渲染了。</p>
<p>你可能不能很快理解帧缓冲的应用，但渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果。首先我们会讨论它是如何工作的，之后我们将来实现这些炫酷的后期处理效果。</p>
<h2 id="创建一个帧缓冲"><a href="#创建一个帧缓冲" class="headerlink" title="创建一个帧缓冲"></a>创建一个帧缓冲</h2><p>和OpenGL中的其它对象一样，我们会使用一个叫做glGenFramebuffers的函数来创建一个帧缓冲对象(Framebuffer Object, FBO)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fbo;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br></pre></td></tr></table></figure>

<p>这种创建和使用对象的方式我们已经见过很多次了，所以它的使用函数也和其它的对象类似。首先我们创建一个帧缓冲对象，将它绑定为激活的(Active)帧缓冲，做一些操作，之后解绑帧缓冲。我们使用glBindFramebuffer来绑定帧缓冲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, fbo);</span><br></pre></td></tr></table></figure>

<p>在绑定到GL_FRAMEBUFFER目标之后，所有的****读取*<em><strong>和</strong></em>*写入*<em><strong>帧缓冲的操作将会影响当前绑定的帧缓冲。我们也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到</strong></em>*读取目标或写入目标****。绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上。</p>
<p>不幸的是，我们现在还不能使用我们的帧缓冲，因为它还不完整(Complete)，一个完整的帧缓冲需要满足以下的条件：</p>
<ul>
<li>· 附加至少一个缓冲（颜色、深度或模板缓冲）。</li>
<li>· 至少有一个颜色附件(Attachment)。</li>
<li>· 所有的附件都必须是完整的（保留了内存）。</li>
<li>· 每个缓冲都应该有相同的样本数。</li>
</ul>
<p>从上面的条件中可以知道，我们需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以GL_FRAMEBUFFER为参数调用glCheckFramebufferStatus，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml">这些</a>值的其中之一。如果它返回的是GL_FRAMEBUFFER_COMPLETE，帧缓冲就是完整的了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line"><span class="comment">// 执行胜利的舞蹈</span></span><br></pre></td></tr></table></figure>

<p>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中。由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。出于这个原因，渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在完成所有的帧缓冲操作之后，不要忘记删除这个帧缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br></pre></td></tr></table></figure>

<p>在完整性检查执行之前，我们需要给帧缓冲附加一个附件。附件是一个内存位置，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer Object)。</p>
<h3 id="纹理附件"><a href="#纹理附件" class="headerlink" title="纹理附件"></a>纹理附件</h3><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就想它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。</p>
<p>为帧缓冲创建一个纹理和创建一个普通的纹理差不多：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>

<p>主要的区别就是，我们将维度设置为了屏幕大小（尽管这不是必须的），并且我们给纹理的data参数传递了NULL。对于这个纹理，我们仅仅分配了内存而没有填充它。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</p>
<blockquote>
<p>如果你想将你的屏幕渲染到一个更小或更大的纹理上，你需要（在渲染到你的帧缓冲之前）再次调用glViewport，使用纹理的新维度作为参数，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。</p>
</blockquote>
<p>现在我们已经创建好一个纹理了，要做的最后一件事就是将它附加到帧缓冲上了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>glFrameBufferTexture2D有以下的参数：</p>
<ul>
<li><p>· target：帧缓冲的目标（绘制、读取或者两者皆有）</p>
</li>
<li><p>· attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。</p>
</li>
<li><p>· textarget：你希望附加的纹理类型</p>
</li>
<li><p>· texture：要附加的纹理本身</p>
</li>
<li><p>· level：多级渐远纹理的级别。我们将它保留为0。</p>
</li>
</ul>
<p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。</p>
<p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。要将深度和模板缓冲附加为一个纹理的话，我们使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式，让它包含合并的深度和模板值。将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子可以在下面找到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(</span><br><span class="line">  GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, </span><br><span class="line">  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h3><p>渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。<mark class="hl-label blue">渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</mark> </p>
<p>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是****只写****的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</p>
<p>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</p>
<p>创建一个渲染缓冲对象的代码和帧缓冲的代码很类似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>, &amp;rbo);</span><br><span class="line"><span class="comment">//我们需要绑定这个渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的rbo</span></span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></table></figure>

<p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们****需要*<em><strong>深度和模板值用于测试，但不需要对它们进行</strong></em>*采样****，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p>
<p>创建一个深度和模板渲染缓冲对象可以通过调用glRenderbufferStorage函数来完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个渲染缓冲对象和纹理对象类似，不同的是这个对象是专门被设计作为图像使用的，而不是纹理那样的通用数据缓冲(General Purpose Data Buffer)。这里我们选择GL_DEPTH24_STENCIL8作为内部格式，它封装了24位的深度和8位的模板缓冲。</p>
<p>最后一件事就是附加这个渲染缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></table></figure>

<p>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。****通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。****性能方面它不会产生非常大的影响的。</p>
<h2 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h2><p>将场景渲染到一个附加到帧缓冲对象上的颜色纹理中，之后将在一个横跨整个屏幕的四边形上绘制这个纹理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先要创建一个帧缓冲对象，并绑定它，这些都很直观：</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> framebuffer;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;framebuffer);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line"><span class="comment">//接下来我们需要创建一个纹理图像，我们将它作为一个颜色附件附加到帧缓冲上。我们将纹理的维度设置为窗口的宽度和高度，并且不初始化它的数据：</span></span><br><span class="line"><span class="comment">// 生成纹理</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texColorBuffer;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texColorBuffer);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texColorBuffer);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将它附加到当前绑定的帧缓冲对象</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, <span class="number">0</span>); </span><br></pre></td></tr></table></figure>

<p>我们还希望OpenGL能够进行深度测试（如果你需要的话还有模板测试），所以我们还需要添加一个深度（和模板）附件到帧缓冲中。由于我们只希望采样颜色缓冲，而不是其它的缓冲，我们可以为它们创建一个渲染缓冲对象。</p>
<p>创建一个渲染缓冲对象不是非常复杂。我们需要记住的唯一事情是，我们将它创建为一个深度****和*<em><strong>模板附件渲染缓冲对象。我们将它的</strong></em>*内部****格式设置为GL_DEPTH24_STENCIL8，对我们来说这个精度已经足够了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>, &amp;rbo);</span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, rbo); </span><br><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);  </span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, <span class="number">0</span>);<span class="comment">//当我们为渲染缓冲对象分配了足够的内存之后，我们可以解绑这个渲染缓冲。</span></span><br></pre></td></tr></table></figure>

<p>接下来，作为完成帧缓冲之前的最后一步，我们将渲染缓冲对象附加到帧缓冲的深度****和****模板附件上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></table></figure>

<p>最后，我们希望检查帧缓冲是否是完整的，如果不是，我们将打印错误信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>记得要解绑帧缓冲，保证我们不会不小心渲染到错误的帧缓冲上。</p>
<p>现在这个帧缓冲就完整了，我们只需要绑定这个帧缓冲对象，让渲染到帧缓冲的缓冲中而不是默认的帧缓冲中。之后的渲染指令将会影响当前绑定的帧缓冲。所有的深度和模板操作都会从当前绑定的帧缓冲的深度和模板附件中（如果有的话）读取。如果你忽略了深度缓冲，那么所有的深度测试操作将不再工作，因为当前绑定的帧缓冲中不存在深度缓冲。</p>
<p>所以，要想绘制场景到一个纹理上，我们需要采取以下的步骤：</p>
<ul>
<li><p>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景（绘制在了这个自定义的帧缓冲上，没有显示在屏幕上）</p>
</li>
<li><p>绑定默认的帧缓冲</p>
</li>
<li><p>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理(把帧缓冲的纹理，也是颜色缓冲作为默认帧缓冲的纹理输入，在屏幕显示出来)。</p>
</li>
</ul>
<p>我们将会绘制[深度测试](<a href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL/01 Depth testing/)小节中的场景，但这次使用的是旧的<a href="https://learnopengl-cn.github.io/img/04/05/container.jpg">箱子</a>纹理。</p>
<p>为了绘制这个四边形，我们将会新创建一套简单的着色器。我们将不会包含任何花哨的矩阵变换，因为我们提供的是标准化设备坐标的<a href="https://learnopengl.com/code_viewer.php?code=advanced/framebuffers_quad_vertices">顶点坐标</a>，所以我们可以直接将它们设定为顶点着色器的输出。顶点着色器是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">    TexCoords = aTexCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并没有太复杂的东西。片段着色器会更加基础，我们做的唯一一件事就是从纹理中采样：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> screenTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123; </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(screenTexture, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就靠你来为屏幕四边形创建并配置一个VAO了。帧缓冲的一个渲染迭代将会有以下的结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一处理阶段(Pass)</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// 我们现在不使用模板缓冲</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">DrawScene</span>();    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二处理阶段</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>); <span class="comment">// 返回默认</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>); </span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">screenShader.<span class="built_in">use</span>();  </span><br><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureColorbuffer);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11</title>
    <url>/2021/07/13/C-11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="默认函数控制"><a href="#默认函数控制" class="headerlink" title="默认函数控制"></a><strong>默认函数控制</strong></h2><p>在C++中对于空类编译器会生成一些默认的成员函数，如果在类中显式定义了，编译器将不会重新生成默认版本。有时候这样的规则可能被忘记，最常见的是声明了带参数的构造函数，必要时则需要定义不带参数的版本以实例化无参的对象。而且有时编译器会生成，有时又不生成，容易造成混乱，于是C++11让程序员可以控制是否需要编译器生成。</p>
<p>显式缺省函数</p>
<p>在C++11中，可以在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本，用=default修饰的函数称为显式缺省函数，由编译器生成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>删除默认函数</p>
<p>如果能想要限制某些默认函数的生成，在C++98中，是该函数设置成private，并且不给定义，这样只要其他人想要调用就会报错。在C++11中更简单，只需在该函数声明加上=delete即可，该语法指示编译器不生成对应函数的默认版本，称=delete修饰的函数为删除函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>



<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h3><p>使用 auto 的时候必须对变量进行初始化</p>
<p>auto 不能在函数的参数中使用。</p>
<p>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。</p>
<blockquote>
<p>这个和Auto的前提一样，Auto使用必须初始化，只有静态成员变量在定义的时候要求初始化，非静态的只有声明，没有定义，和Auto的前提相悖了。</p>
</blockquote>
<p>auto 关键字不能定义数组</p>
<p>auto 不能作用于模板参数</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><blockquote>
<p>decltype 是 <a href="http://c.biancheng.net/cplus/">C++</a>11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导</p>
<p>decltype 是“declare type”的缩写，译为“声明类型”。</p>
</blockquote>
<p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br><span class="line"><span class="comment">//其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</strong></p>
<p><strong>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。</strong></p>
<p><strong>auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开</strong></p>
</blockquote>
<p>decltype 可以写成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>exp 注意事项原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</em></p>
</blockquote>
<h3 id="使用-decltype-exp-获取类型时，编译器将根据以下三条规则得出结果："><a href="#使用-decltype-exp-获取类型时，编译器将根据以下三条规则得出结果：" class="headerlink" title="使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果："></a>使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</h3><ul>
<li>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，按照推导规则 1，对于一般的表达式，decltype 的推导结果就和这个表达式的类型一致。</p>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">(<span class="keyword">double</span>)</span></span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>)) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fun_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被<code>( )</code>包围：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span><span class="keyword">public</span>:    <span class="keyword">int</span> x;&#125;;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="keyword">const</span> Base obj;    <span class="comment">//带有括号的表达式    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。    //加法表达式    int n = 0, m = 0;    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们知道，<mark class="hl-label blue">auto只能用于类的静态成员，不能用于类的非静态成员（普通成员）</mark> ，如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>using namespace std;template <span class="meta-string">&lt;typename T&gt;</span>class Base &#123;public:    void func(T&amp; container) &#123;        m_it = container.begin();    &#125;private:    typename T::iterator m_it;  <span class="comment">//注意这里&#125;;int main()&#123;    const vector&lt;int&gt; v;    Base&lt;const vector&lt;int&gt;&gt; obj;    obj.func(v);    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<p>要想解决这个问题，在之前的 C++98/03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="keyword">public</span>:    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;        m_it = container.<span class="built_in">begin</span>();    &#125;<span class="keyword">private</span>:    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里&#125;;</span></span><br></pre></td></tr></table></figure>

<p>看起来是不是很清爽？</p>
<p>注意，有些低版本的编译器不支持<code>T().begin()</code>这种写法，以上代码我在 VS2019 下测试通过，在 VS2015 下测试失败。</p>
<h2 id="auto-和-decltype-的区别"><a href="#auto-和-decltype-的区别" class="headerlink" title="auto 和 decltype 的区别"></a>auto 和 decltype 的区别</h2><p>对 cv 限定符的处理「cv 限定符」是 const 和 volatile 关键字的统称：</p>
<ul>
<li>const 关键字用来表示数据是只读的，也就是不能被修改；</li>
<li>volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取。</li>
</ul>
<p>在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。</p>
<p>以下是 auto 关键字对 cv 限定符的推导规则：</p>
<ul>
<li>如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。</li>
<li>如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。</li>
</ul>
<p>下面的例子演示了对 const 限定符的推导：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非指针非引用类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="number">10</span>;</span><br><span class="line">n2 = <span class="number">99</span>;  <span class="comment">//赋值不报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(n1) n3 = <span class="number">20</span>;</span><br><span class="line">n3 = <span class="number">5</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;n1;</span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br><span class="line">*p2 = <span class="number">66</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(p1) p3 = p1;</span><br><span class="line">*p3 = <span class="number">19</span>;  <span class="comment">//赋值报错</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 中无法将一个变量的完整类型输出，我们通过对变量赋值来判断它是否被 const 修饰；如果被 const 修饰那么赋值失败，如果不被 const 修饰那么赋值成功。虽然这种方案不太直观，但也是能达到目的的。</p>
<p>n2 赋值成功，说明不带 const，也就是 const 被 auto 抛弃了，这验证了 auto 的第一条推导规则。p2 赋值失败，说明是带 const 的，也就是 const 没有被 auto 抛弃，这验证了 auto 的第二条推导规则。</p>
<p>n3 和 p3 都赋值失败，说明 decltype 不会去掉表达式的 const 属性。</p>
<blockquote>
<p>对引用的处理当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。请看下面的例子：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r1 = n;</span><br><span class="line">    <span class="comment">//auto推导</span></span><br><span class="line">    <span class="keyword">auto</span> r2 = r1;</span><br><span class="line">    r2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//decltype推导</span></span><br><span class="line">    <span class="keyword">decltype</span>(r1) r3 = n;</span><br><span class="line">    r3 = <span class="number">99</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>10, 10, 20<br>99, 99, 99</p>
<p>从运行结果可以发现，给 r2 赋值并没有改变 n 的值，这说明 r2 没有指向 n，而是自立门户，单独拥有了一块内存，这就证明 r 不再是引用类型，它的引用类型被 auto 抛弃了。</p>
<p>给 r3 赋值，n 的值也跟着改变了，这说明 r3 仍然指向 n，它的引用类型被 decltype 保留了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>auto 虽然在书写格式上比 decltype 简单，但是它的推导规则复杂，有时候会改变表达式的原始类型；而 decltype 比较纯粹，它一般会坚持保留原始表达式的任何类型，让推导的结果更加原汁原味。</p>
<p>从代码是否健壮的角度考虑，我推荐使用 decltype，它没有那么多是非；但是 decltype 总是显得比较麻烦，尤其是当表达式比较复杂时，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;<span class="keyword">decltype</span>(nums.<span class="built_in">begin</span>()) it = nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>而如果使用 auto 就会清爽很多：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<h2 id="C-返回值类型后置（跟踪返回值类型）"><a href="#C-返回值类型后置（跟踪返回值类型）" class="headerlink" title="C++返回值类型后置（跟踪返回值类型）"></a>C++返回值类型后置（跟踪返回值类型）</h2><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。考虑下面这个场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure>

<p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p>
<p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) <span class="built_in">add</span>(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，直接像上面这样写是编译不过的。因为<mark class="hl-label blue">t、u在参数列表中，而C++的返回值是前置语法，在返回值定义的时候参数变量还不存在。</mark> </p>
<p>可行的写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>() + <span class="built_in">U</span>()) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;<span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) <span class="built_in">add</span>(T t, U u)&#123;    <span class="keyword">return</span> t + u;&#125;</span><br></pre></td></tr></table></figure>

<p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>因此，在 C++11 中增加了<strong>返回类型后置（trailing-return-type，又称跟踪返回类型）</strong>语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</p>
<p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;<span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>&#123;    <span class="keyword">return</span> t + u;&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步说明这个语法，再看另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;<span class="function"><span class="keyword">float</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(val))</span></span>&#123;    <span class="keyword">return</span> <span class="built_in">foo</span>(val);&#125;</span><br></pre></td></tr></table></figure>


<p>如果说前一个例子中的 add 使用 C++98/03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。</p>
<p>在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>
<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。</p>
<h2 id="C-11使用using定义别名（替代typedef）"><a href="#C-11使用using定义别名（替代typedef）" class="headerlink" title="C++11使用using定义别名（替代typedef）"></a>C++11使用using定义别名（替代typedef）</h2><p>在 <a href="http://c.biancheng.net/cplus/">C++</a> 中可以通过 typedef 重定义一个类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure>

<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">uint_t</span>)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>

<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。</p>
<p>想象下面这个场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;<span class="comment">// ...typedef std::map&lt;std::string, std::string&gt; map_str_t;// ...</span></span><br></pre></td></tr></table></figure>

<p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<p>因此，在 C++98/03 中往往不得不这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;<span class="class"><span class="keyword">struct</span> <span class="title">str_map</span>&#123;</span>    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;&#125;;<span class="comment">// ...str_map&lt;int&gt;::type map1;// ...</span></span><br></pre></td></tr></table></figure>

<p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p>
<p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;<span class="keyword">using</span> <span class="keyword">str_map_t</span> = std::map&lt;std::string, Val&gt;;<span class="comment">// ...str_map_t&lt;int&gt; map1;</span></span><br></pre></td></tr></table></figure>

<p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p>
<p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned inttypedef unsigned int uint_t;using uint_t = unsigned int;// 重定义std::maptypedef std::map&lt;std::string, int&gt; map_int_t;using map_int_t = std::map&lt;std::string, int&gt;;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p>
<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">struct</span> <span class="title">func_t</span>&#123;</span>    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;&#125;;<span class="comment">// 使用 func_t 模板func_t&lt;int&gt;::type xx_1;/* C++11 */template &lt;typename T&gt;using func_t = void (*)(T, T);// 使用 func_t 模板func_t&lt;int&gt; xx_2;</span></span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。</p>
<p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</int></p>
<p>因此，下面这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span> (*func_call)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; func_call)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>

<p>同样是无法实现重载的，func_t<int> 只是 void(*)(int, int) 类型的等价物。</int></p>
<p>using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p>
<p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="keyword">using</span> <span class="keyword">type_t</span> = T;<span class="comment">// ...type_t&lt;int&gt; i;</span></span><br></pre></td></tr></table></figure>

<p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t<int> 将等价于 int。</int></p>
<h2 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h2><p>在 <a href="http://c.biancheng.net/cplus/">C++</a>98/03 标准中，<strong>类</strong>模板可以有默认的模板参数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">int</span>, U N = <span class="number">0</span>&gt;struct Foo&#123;    <span class="comment">// ...&#125;;</span></span><br></pre></td></tr></table></figure>

<p>但是却不支持<strong>函数</strong>的默认模板参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;  <span class="comment">// error in C++98/03: default template argumentsvoid func()&#123;    // ...&#125;</span></span><br></pre></td></tr></table></figure>


<p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;    <span class="built_in">func</span>();   <span class="comment">//T = int    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
</blockquote>
<p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>, <span class="keyword">typename</span> U&gt;R <span class="built_in">func</span>(U val)&#123;    <span class="keyword">return</span> val;&#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int    func&lt;char&gt;(97);         // R=char, U=int    func&lt;double, int&gt;(97);  // R=double, U=int    return 0;&#125;</span></span><br></pre></td></tr></table></figure>


<p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</char></p>
<p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">double</span>&gt;<span class="keyword">void</span> <span class="built_in">func</span>(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)&#123;    <span class="comment">//...&#125;int main()&#123;    func(&#x27;c&#x27;); //T=char, U=double    func();    //编译报错    return 0;&#125;</span></span><br></pre></td></tr></table></figure>


<p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T=char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。</p>
<h2 id="C-11-lambda匿名函数"><a href="#C-11-lambda匿名函数" class="headerlink" title="C++11 lambda匿名函数"></a>C++11 lambda匿名函数</h2><p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则是被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<p>继 Python、Java、C#、PHP 等众多高级编程语言都支持 lambda 匿名函数后，C++11 标准终于引入了 lambda，本节将带领大家系统地学习 lambda 表达式的具体用法。</p>
<h3 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h3><p>定义一个 lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) <span class="keyword">mutable</span> <span class="keyword">noexcept</span>/<span class="keyword">throw</span>() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中各部分的含义分别为：</p>
<p><strong>1) [外部变量方位方式说明符]</strong><br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</p>
<blockquote>
<p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
</blockquote>
<p><strong>2) (参数)</strong><br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
<p><strong>3) mutable</strong><br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
<p>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<p><strong>4) noexcept/throw()</strong><br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<p><strong>5) -&gt; 返回值类型</strong><br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p>
<p><strong>6) 函数体</strong><br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<blockquote>
<p>其中，红色标识的参数是定义 lambda 表达式时必须写的，而绿色标识的参数可以省略。</p>
</blockquote>
<p>比如，如下就定义了一个最简单的 lambda 匿名函数：</p>
<p>[]{}</p>
<p>显然，此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，这是一个没有任何功能的 lambda 匿名函数。</p>
<blockquote>
<h4 id="lambda匿名函数中的-外部变量-对于-lambda-匿名函数的使用，令多数初学者感到困惑的就是-外部变量-的使用。其实很简单，无非表-1-所示的这几种编写格式。"><a href="#lambda匿名函数中的-外部变量-对于-lambda-匿名函数的使用，令多数初学者感到困惑的就是-外部变量-的使用。其实很简单，无非表-1-所示的这几种编写格式。" class="headerlink" title="lambda匿名函数中的[外部变量]对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。"></a>lambda匿名函数中的[外部变量]对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。</h4></blockquote>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[=]</td>
<td>只有一个 = 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[=,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p> 注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<p>【例 1】lambda 匿名函数的定义和使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>1 2 3 4</p>
<p>程序第 8 行通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。而如果使用普通函数，需以如下代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_up</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序中 sort_up() 函数的功能和上一个程序中的 lambda 匿名函数完全相同。显然在类似的场景中，使用 lambda 匿名函数更有优势。</p>
<p>除此之外，虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; <span class="keyword">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为</p>
<p>10 20</p>
<p>可以看到，程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<p>【例 2】值传递和引用传递的区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lambda1:<span class="number">1</span> <span class="number">2</span> <span class="number">310l</span>ambda2:<span class="number">10</span> <span class="number">20</span> <span class="number">30100</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。</p>
<p>其中，lambda1 匿名函数是以 [=] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。</p>
<blockquote>
<p>感兴趣的读者，可自行尝试在 lambda1 匿名函数中修改 num_1、num_2 或者 num_3 的值，观察编译器的报错信息。</p>
</blockquote>
<p>当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;    num_1 = <span class="number">10</span>;    num_2 = <span class="number">20</span>;    num_3 = <span class="number">30</span>;    <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改    cout &lt;&lt; num_1 &lt;&lt; &quot; &quot;         &lt;&lt; num_2 &lt;&lt; &quot; &quot;         &lt;&lt; num_3 &lt;&lt; endl;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</p>
<p>【例 3】执行抛出异常类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main()&#123;    auto except = []()throw(int) &#123;        throw 10;    &#125;;        try &#123;        except();    &#125;    catch (int) &#123;        cout &lt;&lt; <span class="meta-string">&quot;捕获到了整形异常&quot;</span>;    &#125;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>捕获到了整形异常</p>
<p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p>
<p>在此基础上，在看一下反例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main()&#123;    auto except1 = []()noexcept&#123;        throw 100;    &#125;;    auto except2 = []()throw(char)&#123;        throw 10;    &#125;;    try&#123;        except1();        except2();    &#125;catch(int)&#123;        cout &lt;&lt; <span class="meta-string">&quot;捕获到了整形异常&quot;</span>&lt;&lt; endl;    &#125;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>


<p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p>
<blockquote>
<p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p>
</blockquote>
<h2 id="C-11非受限联合体（union）"><a href="#C-11非受限联合体（union）" class="headerlink" title="C++11非受限联合体（union）"></a>C++11非受限联合体（union）</h2><p>在 C/<a href="http://c.biancheng.net/cplus/">C++</a> 中，联合体（Union）是一种<mark class="hl-label blue">构造数据类型</mark>  。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。</p>
<p>C++11 标准规定，任何<mark class="hl-label blue">非引用类型</mark> 都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<p>关于 POD 类型稍后我们会讲解，大家先不要着急。</p>
<p>接下来，我们具体看一下 C++11 对 C++98 的改进。</p>
<h3 id="1-C-11-允许非-POD-类型，C-98-不允许联合体的成员是非-POD-类型，但是-C-1-1-取消了这种限制。"><a href="#1-C-11-允许非-POD-类型，C-98-不允许联合体的成员是非-POD-类型，但是-C-1-1-取消了这种限制。" class="headerlink" title="1. C++11 允许非 POD 类型，C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。"></a>1. C++11 允许非 POD 类型，C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</h3><p>POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。<br>POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ol>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为 public。</li>
<li>类中的第一个非静态成员的类型与其基类不同，例如：</li>
</ol>
<p>class B1{};<br>class B2 : B1 { B1 b; };</p>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。<br>5) 在类或者结构体继承时，满足以下两种情况之一：</p>
<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
<p>我们来看具体的例子：</p>
<p>class B1 { static int n; };<br>class B2 : B1 { int n1; };<br>class B3 : B2 { static int n2; };</p>
<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<ol start="6">
<li><p>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p>
</li>
<li><p>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p>
</li>
</ol>
<h3 id="2-C-11-允许联合体有静态成员C-11-删除了联合体不允许拥有静态成员的限制。例如："><a href="#2-C-11-允许联合体有静态成员C-11-删除了联合体不允许拥有静态成员的限制。例如：" class="headerlink" title="2. C++11 允许联合体有静态成员C++11 删除了联合体不允许拥有静态成员的限制。例如："></a>2. C++11 允许联合体有静态成员C++11 删除了联合体不允许拥有静态成员的限制。例如：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union U &#123;</span><br><span class="line">    static int func() &#123;</span><br><span class="line">        int n = 3;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h3 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h3><blockquote>
<p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
</blockquote>
<p>这条规则可能导致对象构造失败，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new（稍后会讲解这个概念），代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h4 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h4><blockquote>
<p><strong>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</strong></p>
</blockquote>
<p>placement new 的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) <span class="built_in">ClassConstruct</span>(...)</span><br></pre></td></tr></table></figure>

<p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用<mark class="hl-label red">已经申请好的内存来生成对象</mark>  ，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h3 id="非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下："><a href="#非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下："></a>非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</h3><p>union U{<br>  union { int x; }; //此联合体为匿名联合体<br>};</p>
<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为<mark class="hl-label red">“枚举式类”</mark>  。示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> &#123;</span> STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的<mark class="hl-label red">“变长成员”</mark>  来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>
<h2 id="C-11-constexpr：验证是否为常量表达式"><a href="#C-11-constexpr：验证是否为常量表达式" class="headerlink" title="C++11 constexpr：验证是否为常量表达式"></a>C++11 constexpr：验证是否为常量表达式</h2><p>常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段。</p>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<blockquote>
<p>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
</blockquote>
<h3 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h3><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序执行结果为：</p>
<p>2</p>
<blockquote>
<p>可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
</blockquote>
<p>可以看到，程序第 5 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>可以发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足<mark class="hl-label blue">num是const常量且使用常量表达式为其初始化</mark>  这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p>
<blockquote>
<p>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p>
</blockquote>
<blockquote>
<p>另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
</blockquote>
<h3 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h3><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，<mark class="hl-label blue">只能包含一条return返回语句</mark>  。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<ol start="2">
<li>该函数必须有返回值，即函数的返回值类型不能是 void。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<ol start="3">
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>3<br>6</p>
<blockquote>
<p>可自行将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
</blockquote>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<ol start="4">
<li>return 返回的表达式必须是常量表达式，举个例子：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;int num = 3;constexpr int display(int x)&#123;    return num + x;&#125;int main()&#123;    <span class="comment">//调用常量表达式函数    int a[display(3)] = &#123; 1,2,3,4 &#125;;    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<blockquote>
<p>注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣可自行尝试编码测试。</p>
</blockquote>
<h3 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h3><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="keyword">char</span> *name,<span class="keyword">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<blockquote>
<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
</blockquote>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<blockquote>
<p>注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
</blockquote>
<h3 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h3><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。<br>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> =</span> <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10<br>10</p>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li>第 28 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li>
<li>第 21 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li>
</ul>
<h2 id="C-11-constexpr和const的区别"><a href="#C-11-constexpr和const的区别" class="headerlink" title="C++11 constexpr和const的区别"></a>C++11 constexpr和const的区别</h2><p>constexpr 是 C++ 11 标准新添加的关键字，在此之前（C++ 98/03标准）只有 const 关键字，其在实际使用中经常会表现出两种不同的语义。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，dis_1() 和 dis_2() 函数中都包含一个 const int x，但 dis_1() 函数中的 x 无法完成初始化 array 容器的任务，而 dis_2() 函数中的 x 却可以。</p>
<blockquote>
<p><strong>这是因为，dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器。</strong></p>
</blockquote>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p>
<blockquote>
<p>在上面的实例程序中，dis_2() 函数中使用 const int x 是不规范的，应使用 constexpr 关键字。</p>
</blockquote>
<p>有读者可能会问，“只读”不就意味着其不能被修改吗？答案是否定的，“只读”和“不允许被修改”之间并没有必然的联系，举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; con_b = a;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>20</p>
<p>可以看到，程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p>
<p>在大部分实际场景中，const 和 constexpr 是可以混用的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>


<p>它们是完全等价的，都可以在程序的编译阶段计算出结果。但在某些场景中，必须明确使用 constexpr，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">sqr1</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">sqr2</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr1(10)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr2(10)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中，因为 sqr2() 函数的返回值仅有 const 修饰，而没有用更明确的 constexpr 修饰，导致其无法用于初始化 array 容器（只有常量才能初始化 array 容器）。</p>
<p>总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p>
<h2 id="C-11右值引用"><a href="#C-11右值引用" class="headerlink" title="C++11右值引用"></a>C++11右值引用</h2><blockquote>
<p>C++左值和右值右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。</p>
</blockquote>
<p>在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p>
<blockquote>
<p>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<p>通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。</p>
<ol>
<li>可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5 不能为左值</span></span><br><span class="line"></span><br><span class="line">其中，变量 a 就是一个左值，而字面量 <span class="number">5</span> 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p>
<p>前面提到，其实 C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98/03 标准不支持为 <mark class="hl-label blue">右值</mark>   建立 <mark class="hl-label blue">非常量左值</mark>   引用，但允许使用 <mark class="hl-label blue">常量左值引用</mark>   操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">const int &amp;b = num;</span><br><span class="line">const int &amp;c = 10;</span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<blockquote>
<p>话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 /03 标准产生冲突，最终选定了 2 个 ‘&amp;’ 表示右值引用。</p>
</blockquote>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span><br><span class="line">int &amp;&amp; a = 10;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int &amp;&amp; a = 10;</span><br><span class="line">a = 100;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>程序输出结果为 100。</p>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int&amp;&amp; a = 10;//编译器不会报错</span><br></pre></td></tr></table></figure>


<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用 的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
<p>学到这里，一些读者可能无法记清楚 左值引用 和 右值引用 各自可以引用左值还是右值，这里给大家一张表格，方便大家记忆：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>可以引用的值类型</th>
<th>使用场景</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<p>表中，Y 表示支持，N 表示不支持。</p>
<blockquote>
<p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值（本节中已经做了大篇幅的讲解），而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。对于纯右值和将亡值，都属于右值，读者知道即可，不必深究。</p>
</blockquote>
<h2 id="C-11移动构造函数"><a href="#C-11移动构造函数" class="headerlink" title="C++11移动构造函数"></a>C++11移动构造函数</h2><p>在 C++ 11 标准之前（C++ 98/03 标准中），如果<mark class="hl-label blue">想用其它对象初始化一个同类的新对象</mark>  ，只能借助类中的复制（拷贝）构造函数。通过《<a href="http://c.biancheng.net/view/2334.html">C++拷贝构造函数</a>》一节的学习我们知道，拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。</p>
<blockquote>
<p>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   <span class="built_in">demo</span>(<span class="keyword">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。<mark class="hl-label blue">否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次</mark>  。</p>
</blockquote>
<p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
<ol>
<li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个<mark class="hl-label blue">匿名对象</mark>  ；</li>
<li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li>
<li>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li>
<li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li>
</ol>
<p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure>

<p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!        &lt;-- 执行 <span class="built_in">demo</span>()</span><br><span class="line">copy construct!    &lt;-- 执行 <span class="keyword">return</span> <span class="built_in">demo</span>()</span><br><span class="line">class destruct!     &lt;-- 销毁 <span class="built_in">demo</span>() 产生的匿名对象</span><br><span class="line">copy construct!    &lt;-- 执行 a = <span class="built_in">get_demo</span>()</span><br><span class="line">class destruct!     &lt;-- 销毁 <span class="built_in">get_demo</span>() 返回的临时对象</span><br><span class="line">class destruct!     &lt;-- 销毁 a</span><br></pre></td></tr></table></figure>

<p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p>
<blockquote>
<p>事实上，此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p>
</blockquote>
<p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p>
<h3 id="C-移动构造函数（移动语义的具体实现）"><a href="#C-移动构造函数（移动语义的具体实现）" class="headerlink" title="C++移动构造函数（移动语义的具体实现）"></a>C++移动构造函数（移动语义的具体实现）</h3><blockquote>
<p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源<mark class="hl-label red">“移为已用”</mark>  。</p>
</blockquote>
<p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p>
<blockquote>
<p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p>
</blockquote>
<p>例如，下面程序对 demo 类进行了修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">demo</span>(<span class="keyword">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p>
<p>construct!<br>move construct!<br>class destruct!<br>move construct!<br>class destruct!<br>class destruct!</p>
<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
<h3 id="C-11-move-函数：将左值强制转换为右值"><a href="#C-11-move-函数：将左值强制转换为右值" class="headerlink" title="C++11 move()函数：将左值强制转换为右值"></a>C++11 move()函数：将左值强制转换为右值</h3><p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</p>
<blockquote>
<p>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
</blockquote>
<p>move() 函数的用法也很简单，其语法格式如下：</p>
<p>move( arg )</p>
<p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p>
<p>【例 1】move() 函数的基础应用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movedemo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="keyword">const</span> movedemo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:\n&quot;</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:\n&quot;</span>;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line">move construct!</span><br></pre></td></tr></table></figure>

<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<blockquote>
<p>注意，调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 28行代码会导致程序运行时发生错误。</p>
</blockquote>
<p>【例 2】灵活使用 move() 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    <span class="built_in">second</span>(second &amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>construct!<br>first move construct!<br>second move construct</p>
<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 次move() 函数：</p>
<ul>
<li>程序第 28 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li>
<li>程序第 20 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li>
</ul>
<h2 id="C-11完美转发"><a href="#C-11完美转发" class="headerlink" title="C++11完美转发"></a>C++11完美转发</h2><p>完美转发，它指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。</p>
<blockquote>
<p>在 C++ 中，一个表达式不是左值就是右值。有关如何判断一个表达式是左值还是右值，可阅读《<a href="http://c.biancheng.net/view/7829.html">C++右值引用</a>》一文做详细了解。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void function(T t) &#123;</span><br><span class="line">    otherdef(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。</p>
<p>显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</p>
<blockquote>
<p>读者可能会问，完美转发这样严苛的参数传递机制，很常用吗？C++98/03 标准中几乎不会用到，但 C++11 标准为 C++ 引入了右值引用和移动语义，因此很多场景中是否实现完美转发，直接决定了该参数的传递过程使用的是拷贝语义（调用拷贝构造函数）还是移动语义（调用移动构造函数）。</p>
</blockquote>
<p>事实上，C++98/03 标准下的 C++ 也可以实现完美转发，只是实现方式比较笨拙。通过前面的学习我们知道，C++ 98/03 标准中只有左值引用，并且可以细分为非 const 引用和 const 引用。其中，使用非 const 引用作为函数模板参数时，只能接收左值，无法接收右值；而 const 左值引用既可以接收左值，也可以接收右值，但考虑到其 const 属性，除非被调用函数的参数也是 const 属性，否则将无法直接传递。</p>
<p>这也就意味着，单独使用任何一种引用形式，可以实现转发，但无法保证完美。因此如果使用 C++ 98/03 标准下的 C++ 语言，我们可以采用函数模板重载的方式实现完美转发，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数模板，分别接收左值和右值</span></span><br><span class="line"><span class="comment">//接收右值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收左值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);<span class="comment">//5 是右值</span></span><br><span class="line">    <span class="keyword">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);<span class="comment">//x 是左值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>从输出结果中可以看到，对于右值 5 来说，它实际调用的参数类型为 const T&amp; 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T&amp; 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。</p>
<p>显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。</p>
<p>仍以 function() 函数为例，在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; num = n;</span><br><span class="line"><span class="built_in">function</span>(num); <span class="comment">// T 为 int&amp;</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; num2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">function</span>(num2); <span class="comment">// T 为 int &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>其中，由 function(num) 实例化的函数底层就变成了 function(int &amp; &amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。要知道，C++98/03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：</p>
<ul>
<li>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; = A&amp;）；</li>
<li>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; = A&amp;&amp;）。</li>
</ul>
<blockquote>
<p>在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
</blockquote>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p>
<p>C++11 标准的开发者已经帮我们想好的解决方案，该新标准还引入了一个模板函数<mark class="hl-label red">forword<T>()</T></mark>  ，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>注意程序中第 12~16 行，此 function() 模板函数才是实现完美转发的最终版本。可以看到，forword() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。</p>
<p>总的来说，在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数。由此即可轻松实现函数模板中参数的完美转发。 </p>
<h2 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h2><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。</p>
<p>事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。</p>
<p>如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98/03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。</p>
<p>所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<blockquote>
<p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
</blockquote>
<p>接下来，我们将分别对 shared_ptr、unique_ptr 以及 weak_ptr 这 3 个智能指针的特性和用法做详细的讲解，本节先介绍 shared_ptr 智能指针。</p>
<h2 id="C-11-shared-ptr智能指针-1"><a href="#C-11-shared-ptr智能指针-1" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h2><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr<T>（其中 T 表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用<mark class="hl-label blue">计数机制</mark>  ，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h4 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h4><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</T></p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：</T></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure>

<p>注意，空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。</p>
<ol start="2">
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p>
<p>同时，C++11 标准中还提供了 std::make_shared<T> 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>以上 2 种方式创建的 p3 是完全相同。</p>
<ol start="3">
<li>除此之外，shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数，例如：</T></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure>

<p>如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用<mark class="hl-label blue">拷贝构造函数</mark>  。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是<mark class="hl-label blue">移动构造函数</mark>  。另外和调用拷贝构造函数不同，<mark class="hl-label blue">用std::move(p4)初始化p5,会使得p5拥有了p4的堆内存，而p4则变成了空智能指针</mark>  。</p>
<p>注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li>
</ol>
<p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p>
<p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete<T> 模板类，我们也可以自定义释放规则：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="keyword">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteInt</span><span class="params">(<span class="keyword">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际上借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shared_ptr<T> 模板类还提供有其它一些初始化智能指针的方法，感兴趣的读者可前往讲解 <a href="http://www.cplusplus.com/reference/memory/shared_ptr/shared_ptr/">shared_ptr 的官网</a>做系统了解。</T></p>
</blockquote>
<h4 id="2、shared-ptr模板类提供的成员方法"><a href="#2、shared-ptr模板类提供的成员方法" class="headerlink" title="2、shared_ptr模板类提供的成员方法"></a>2、shared_ptr<T>模板类提供的成员方法</T></h4><p>为了方便使用 shared_ptr 智能指针，shared_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</T></p>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td>
</tr>
<tr>
<td>operator*()</td>
<td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td>
</tr>
<tr>
<td>get()</td>
<td>获得 shared_ptr 对象内部包含的普通指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td>
</tr>
<tr>
<td>unique()</td>
<td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td>
</tr>
</tbody></table>
<blockquote>
<p> 除此之外，C++11 标准还支持同一类型的 shared_ptr 对象，或者 shared_ptr 和 nullptr 之间，进行 ==，!=，&lt;，&lt;=，&gt;，&gt;= 运算。</p>
</blockquote>
<p>下面程序演示了 shared_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p1 为空<br>10<br>1</p>
<h2 id="C-11-unique-ptr智能指针"><a href="#C-11-unique-ptr智能指针" class="headerlink" title="C++11 unique_ptr智能指针"></a>C++11 unique_ptr智能指针</h2><p>作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
</blockquote>
<p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr<T>（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr智能指针的创建"><a href="#unique-ptr智能指针的创建" class="headerlink" title="unique_ptr智能指针的创建"></a>unique_ptr智能指针的创建</h3><p>考虑到不同实际场景的需要，unique_ptr<T> 模板类提供了多个实用的构造函数，这里列举了几种常用的构造 unique_ptr 智能指针的方式。</T></p>
<ol>
<li>通过以下 2 种方式，可以创建出空的 unique_ptr 指针：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。</p>
<blockquote>
<p>和可以用 make_shared<T>() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。</T></p>
</blockquote>
<ol start="3">
<li>基于 unique_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique_ptr 模板类没有提供拷贝构造函数，<mark class="hl-label blue">只提供了移动构造函数</mark>  。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（nullptr）。</p>
<ol start="4">
<li>默认情况下，unique_ptr 指针采用 std::default_delete<T> 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。例如：</T></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myDel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr模板类提供的成员方法"><a href="#unique-ptr模板类提供的成员方法" class="headerlink" title="unique_ptr模板类提供的成员方法"></a>unique_ptr<T>模板类提供的成员方法</T></h3><p>为了方便使用 unique_ptr 智能指针，unique_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</T></p>
<table>
<thead>
<tr>
<th>成员函数名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator*()</td>
<td>获取当前 unique_ptr 指针指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>operator =()</td>
<td>重载了 = 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。</td>
</tr>
<tr>
<td>operator <a href></a></td>
<td>重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。</td>
</tr>
<tr>
<td>get()</td>
<td>获取当前 unique_ptr 指针内部包含的普通指针。</td>
</tr>
<tr>
<td>get_deleter()</td>
<td>获取当前 unique_ptr 指针释放堆内存空间所用的规则。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。</td>
</tr>
<tr>
<td>release()</td>
<td>释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td>
</tr>
<tr>
<td>reset(p)</td>
<td>其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>交换当前 unique_ptr 指针和同类型的 x 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，C++11标准还支持同类型的 unique_ptr 指针之间，以及 unique_ptr 和 nullptr 之间，做 ==，!=，&lt;，&lt;=，&gt;，&gt;= 运算。</p>
</blockquote>
<p>下面程序演示了 unique_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    *p5 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// p 接收 p5 释放的堆内存,但该存储空间并不会被销毁。</span></span><br><span class="line">    <span class="keyword">int</span> * p = p5.<span class="built_in">release</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断 p5 是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p5) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is not nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; p6;</span><br><span class="line">    <span class="comment">//p6 获取 p 的所有权</span></span><br><span class="line">    p6.<span class="built_in">reset</span>(p);</span><br><span class="line">    cout &lt;&lt; *p6 &lt;&lt; endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p5 is nullptr<br>10</p>
<h2 id="C-11-weak-ptr智能指针"><a href="#C-11-weak-ptr智能指针" class="headerlink" title="C++11 weak_ptr智能指针"></a>C++11 weak_ptr智能指针</h2><p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr<T>（ T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 weak_ptr 类型指针，程序中应首先包含如下 2 条语句：</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。</p>
<p>需要注意的是，当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。<br>除此之外，weak_ptr<T> 模板类中没有重载 * 和 -&gt; 运算符，这也就意味着，<mark class="hl-label blue">weak_ptr类型指针只能访问所指的堆内存，而无法修改它</mark>  。</T></p>
<h4 id="1、weak-ptr指针的创建"><a href="#1、weak-ptr指针的创建" class="headerlink" title="1、weak_ptr指针的创建"></a>1、weak_ptr指针的创建</h4><p>创建一个 weak_ptr 指针，有以下 3 种方式：</p>
<ol>
<li>可以创建一个空 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="keyword">int</span>&gt; wp1;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）。</p>
<ol start="3">
<li>weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。</p>
<h4 id="2-weak-ptr模板类提供的成员方法"><a href="#2-weak-ptr模板类提供的成员方法" class="headerlink" title="2) weak_ptr模板类提供的成员方法"></a>2) weak_ptr模板类提供的成员方法</h4><p>和 shared_ptr<T>、unique_ptr<T> 相比，weak_ptr<T> 模板类提供的成员方法不多，表 1 罗列了常用的成员方法及各自的功能。</T></T></T></p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>重载 = 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>将当前 weak_ptr 指针置为空指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。</td>
</tr>
<tr>
<td>expired()</td>
<td>判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td>
</tr>
<tr>
<td>lock()</td>
<td>如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相 同的 shared_ptr 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>再次强调，weak_ptr<T> 模板类没有重载 * 和 -&gt; 运算符，因此 weak_ptr 类型指针只能访问某一 shared_ptr 指针指向的堆内存空间，无法对其进行修改。</T></p>
</blockquote>
<p>下面的样例演示了 weak_ptr 指针以及表 1 中部分成员方法的基本用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp2)</span></span>;</span><br><span class="line">    <span class="comment">//输出和 wp 同指向的 shared_ptr 类型指针的数量</span></span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//释放 sp2</span></span><br><span class="line">    sp2.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据</span></span><br><span class="line">    cout &lt;&lt; *(wp.<span class="built_in">lock</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>2<br>1<br>10</p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/2021/06/27/C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><h2 id="1-带可变参数的函数由来"><a href="#1-带可变参数的函数由来" class="headerlink" title="1.带可变参数的函数由来"></a>1.带可变参数的函数由来</h2><p>当<strong>函数中的参数个数不确定</strong>时，这时候就需要带可变参数的函数！</p>
<p>如我们经常使用的C库函数printf()实际就是一个可变参数的函数，</p>
<p><strong>其原型为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int   printf(   const   char*   format,   ...);</span><br></pre></td></tr></table></figure>

<p>它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf( &quot;%d &quot;,i);   </span><br><span class="line">printf( &quot;%s &quot;,s);   </span><br><span class="line">printf( &quot;the   number   is   %d   ,string   is:%s &quot;,   i,   s);   </span><br></pre></td></tr></table></figure>

<h2 id="2-带可变参数函数的实现，"><a href="#2-带可变参数函数的实现，" class="headerlink" title="2.带可变参数函数的实现，"></a>2.带可变参数函数的实现，</h2><p>原理：</p>
<ul>
<li>使用了<strong>指针参数</strong>来解决参数的可变问题，指针参数随着其移动指向不同的参数；</li>
<li>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数。</li>
</ul>
<p>C语言标准库中头文件stdarg.h索引的接口包含了一组能够遍历变长参数列表的宏。</p>
<p>头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdarg.h&gt;</span><br></pre></td></tr></table></figure>

<p>几个宏</p>
<p>(1).  <strong>va_list</strong> 定义一个指针</p>
<p>用来<strong>定义</strong>一个<strong>表示参数表中各个参数</strong>的<strong>变量</strong>，即定义了一个指向参数的指针， 用于指示可选的参数.</p>
<p>如：<strong>va_list ap</strong>;</p>
<p>(2). <strong>va_start(ap,v)</strong> 初始化指针  </p>
<p>使参数列表指针<strong>ap</strong>指向函数参数列表中的第一个<strong>可选参数</strong>，<strong>v</strong>是位于第一个可选参数之前的<strong>固定参数</strong>, 或者说最后一个固定参数.通常用于指定可变参数列表中参数的个数！</p>
<p>如有一va函数的声明是void va_test(char a, char b, char c, …), 则它的固定参数依次是a,b,c, 最后一个固定参数v为c, 因此就是va_start(<strong>ap</strong>, c).</p>
<p>(3). va_arg(<strong>ap</strong>, type) 返回参数列表中指针<strong>ap</strong>所指的参数, 返回类型为type. 并使指针<strong>ap</strong>指向参数列表中下一个参数.返回的是可选参数, 不包括固定参数.</p>
<p>(4). va_end(<strong>ap</strong>) 清空参数列表, 并置参数指针arg_ptr无效.</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="keyword">int</span> i,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simple_va_fun</span>(<span class="number">100</span>);   </span><br><span class="line">    <span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="keyword">int</span> i,...)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    va_list   arg_ptr;   <span class="comment">//定义可变参数指针 </span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr,i);   <span class="comment">// i为最后一个固定参数</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="built_in">va_arg</span>(arg_ptr,<span class="keyword">int</span>);   <span class="comment">//返回第一个可变参数，类型为int</span></span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">va_arg</span>(arg_ptr,<span class="keyword">char</span>);   <span class="comment">//返回第二个可变参数，类型为char</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);        <span class="comment">//  清空参数指针</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d %d %c\n&quot;</span>,i,j,c);   </span><br><span class="line">    <span class="keyword">return</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出为</span></span><br><span class="line"><span class="comment">100 4193388 ?</span></span><br><span class="line"><span class="comment">100 200 ?</span></span><br><span class="line"><span class="comment">100 200 a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>  思路：</p>
<p>（1）首先在函数里定义一个va_list型的变量,这里是arg_ptr,这个变量是指向参数的指针.</p>
<p>（2）然后用va_start宏初始化变量arg_ptr,这个宏的第二个参数是第一个可变参数的前一个参数,是一个固定的参数.</p>
<p>（3）然后用va_arg返回第一个可变的参数,并赋值给整数j。va_arg的第二个参数是你要返回的参数的类型,这里是int型. 返回第一个可变参数后arg_ptr指向第二个可变参数，用同样的方法返回并赋值给c，类型为char类型。</p>
<p>（4）最后用va_end宏结束可变参数的获取。</p>
<p>**小结：<br>**可变参数的函数原理其实很简单,而va系列是以宏定义来定义的,实现跟堆栈相关.我们写一个可变函数的C函数时,有利也有弊,所以在不必要的场合,我们无需用到可变参数.如果在C++里,我们应该利用C++的多态性来实现可变参数的功能,尽量避免用C语言的方式来实现。</p>
<h1 id="隐式类型转换与显式类型转换"><a href="#隐式类型转换与显式类型转换" class="headerlink" title="隐式类型转换与显式类型转换"></a>隐式类型转换与显式类型转换</h1><h2 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1. 隐式类型转换"></a>1. 隐式类型转换</h2><p>在有隐式类型转换的表达式中，不需要明确指定一个类型的对象该转换为另外哪一个类型，这个工作将隐含地由编译器来完成，编译器将分析表达式的含义，进行类型转换。</p>
<p>隐式类型转换针对不同的类型有不同的转换方式，总体可以分为两种类型，算术类型和类类型。</p>
<h3 id="1-1-算术类型转换"><a href="#1-1-算术类型转换" class="headerlink" title="1.1 算术类型转换"></a>1.1 算术类型转换</h3><p>算术类型转换的设计原则是尽可能避免损失精度。</p>
<p>具体地，有以下几条参考规则：</p>
<ol>
<li><strong>整型提升：将小整数类型转换成较大的整数类型</strong>。例如，如果一个运算对象的类型是long double，那么另外一个运算对象，无论它的类型是什么，都会被转换成long double。</li>
<li><strong>有符号类型转换为无符号类型</strong>。类型转换一般不会改变对象内存的值，当一个有符号类型的对象转换为无符号类型时，其表示出来的值可能发生变化，例如，int a = -1 (0xff); unsigned int b = a; 则b的值为255。</li>
<li><strong>在条件判断中，非布尔类型自动转换为布尔类型</strong>。如果指针或算术类型的值为0，转换为false，否则转换为true。</li>
</ol>
<p>类型级别从高到低的顺序是long double, double, float, unsigned long long, long long, long, unsigned int 和 int。</p>
<h3 id="1-2-类类型转换"><a href="#1-2-类类型转换" class="headerlink" title="1.2 类类型转换"></a>1.2 类类型转换</h3><p>在C++中，可以通过定义单参数构造函数或者转换函数来进行类类型转换，这种方式也称为用户定义的转换（User-Defined Conversion）。这种方式在使用的时候不需要指明转换类型，而是由编译器自动进行选择转换函数，所以也是一种隐式类型转换。</p>
<p>用户定义的类类型转换可以由编译器自动执行，但是编译器每次只能执行一种类类型的转换。如果一个类型转换为另外一个类型，需要同时进行多次转换，这种转换将会失败。</p>
<p><strong>1.2.1 转换构造函数</strong></p>
<p>如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为转换构造函数。在转换中只允许一步类类型的转换。</p>
<p>最常见的例子就是将C类型字符串转换为string类型，例如 string s = “hello world”，因为string类有一个构造函数string(const char *s)。</p>
<p>《C++ Primer》中提到：</p>
<blockquote>
<p><strong>“可以用 单个形参来调用 的构造函数定义了从 形参类型 到 该类类型 的一个隐式转换。”</strong></p>
</blockquote>
<p><strong>这里应该注意的是， “可以用单个形参进行调用” 并不是指构造函数只能有一个形参，而是它可以有多个形参，但那些形参都是有默认实参的。</strong></p>
<p><strong>那么，什么是“隐式转换”呢？ 上面这句话也说了，是从 构造函数形参类型 到 该类类型 的一个编译器的自动转换。</strong></p>
<p>下面通过代码来看一看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOOK</span>  //定义了一个书类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _bookISBN ;  <span class="comment">//书的ISBN号</span></span><br><span class="line">        <span class="keyword">float</span> _price ;    <span class="comment">//书的价格</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//定义了一个成员函数，这个函数即是那个“期待一个实参为类类型的函数”</span></span><br><span class="line">        <span class="comment">//这个函数用于比较两本书的ISBN号是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSameISBN</span><span class="params">(<span class="keyword">const</span> BOOK &amp; other )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> other._bookISBN==_bookISBN;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">//类的构造函数，即那个“能够用一个参数进行调用的构造函数”（虽然它有两个形参，但其中一个有默认实参，只用一个参数也能进行调用）</span></span><br><span class="line">        <span class="built_in">BOOK</span>(string ISBN,<span class="keyword">float</span> price=<span class="number">0.0f</span>):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">&quot;A-A-A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">&quot;B-B-B&quot;</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(B)&lt;&lt;endl;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">string</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">BOOK</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl;    <span class="comment">//显式创建临时对象，也即是编译器干的事情。（char* --&gt; string也是一次转换）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>代码中可以看到，isSameISBN函数是期待一个BOOK类类型形参的，但我们却传递了一个string类型的给它，这不是它想要的啊！还好，BOOK类中有个构造函数，它使用一个string类型实参进行调用，编译器调用了这个构造函数，隐式地将stirng类型转换为BOOK类型（构造了一个BOOK临时对象），再传递给isSameISBN函数。</strong></p>
<p>　　<strong>隐式类类型转换还是会带来风险的，正如上面标记，隐式转换得到类的临时变量，完成操作后就消失了，我们构造了一个完成测试后被丢弃的对象。</strong></p>
<p>　　<strong>我们可以通过explicit声明来抑制这种转换:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explicit BOOK(string ISBN,float price=0.0f):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>explicit关键字只能用于类内部的构造函数声明上.这样一来，BOOK类构造函数就不能用于隐式地创造对象了，编译上面的代码会出现这样的提示：</strong></p>
<p><img src="/2021/06/27/C/0.9681160255789087.png" alt="img"></p>
<p> <strong>现在用户只能进行显示类型转换，显式地创建临时对象。</strong></p>
<p> <strong>总结一下：</strong></p>
<ol>
<li>　　<strong>可以使用一个实参进行调用，不是指构造函数只能有一个形参。</strong></li>
<li>　　<strong>隐式类类型转换容易引起错误，除非你有明确理由使用隐式类类型转换，否则，将可以用一个实参进行调用的构造函数都声明为explicit。</strong></li>
<li>   <strong>explicit只能用于类内部构造函数的声明。它虽然能避免隐式类型转换带来的问题，但需要用户能够显式创建临时对象（对用户提出了要求）。</strong></li>
</ol>
<p><strong>1.2.2 类型转换函数</strong></p>
<p>在类类型转换中，我们通常有两个需求，一个是将其他类型的数据转换为我们自定义类的类型，另一个是将自定义类的类型在需要的时候转换为其他的数据类型。转换构造函数能很好地满足前一个需求，针对后面一个需求，我们除了可以使用普通的成员函数进行显示转换，在C++中，还可以使用类型转换函数进行隐式转换。</p>
<p>类型转换函数的作用就是将一个类的对象转换成另一类型的数据。</p>
<p>我们经常写下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while( cin &gt;&gt; num )&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入操作符 &gt;&gt; 是二元操作符，返回做操作数作为其表达式结果，因此cin &gt;&gt; num返回cin,然而cin是输入流istream的对象，该对象能出现在条件表达式中，是因为在istream中定义了类型转换函数 operator bool();</p>
<p>类型转换函数一般形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">operator 目标类型()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    return 目标类型数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A(const int x) : _x(x) &#123;&#125;</span><br><span class="line">    operator int() &#123; return _x; &#125;</span><br><span class="line">private:</span><br><span class="line">    int _x;</span><br><span class="line">&#125;;</span><br><span class="line">int main () &#123;</span><br><span class="line">    A a(10);</span><br><span class="line">    int res = a + 20;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为30.</p>
<p>由于类A定义了从该类对象到int类型的转换函数，所以在进行整数算术运算的时候，可以直接使用该类对象，因为编译器会隐式地调用该类型转换函数将类对象转换为整型数据。</p>
<h2 id="2-显示类型转换"><a href="#2-显示类型转换" class="headerlink" title="2. 显示类型转换"></a>2. 显示类型转换</h2><p>显示类型转换就是在表达式中明确指定将一种类型转换为另一种类型。隐式类型转换一般是由编译器进行转换操作，显示类型转换是由程序员写明要转换成的目标类型。显示类型转换又被称为强制类型转换。</p>
<h3 id="2-1-C风格的强制转换"><a href="#2-1-C风格的强制转换" class="headerlink" title="2.1 C风格的强制转换"></a>2.1 C风格的强制转换</h3><p>C风格的强制转换很简单，不管什么类型的转换都可以使用使用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type val = (type)(expression);</span><br></pre></td></tr></table></figure>

<p>当然，C++支持C风格的强制转换，但是C风格的强制转换可能带来一些隐患，让一些问题难以察觉。</p>
<h3 id="2-2-C-命名的强制类型转换"><a href="#2-2-C-命名的强制类型转换" class="headerlink" title="2.2 C++命名的强制类型转换"></a>2.2 C++命名的强制类型转换</h3><p>C++提供了4个命名的强制类型转换，它们都有如下的基本形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type val = cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>cast-name是static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种。在这里简单探讨一下。</p>
<p>const_cast 把const强转成非const修饰</p>
<p>在 c 语言中强转是可以把一个不想关的类型都可以强转，但是这样就很容易出问题，如果我们用了const_cast 如果要把两个两个不相关的类型的const转到非const是不行的。这样就限制了出错的概率，，增强了代码的可读性，但是实际中，大多数还是喜欢采用c语言，但是我们必须得知道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int i = 10;//在c++中这样编译器会优化为寄存器变量用volatile</span><br><span class="line">int* j = const_cast&lt;int*&gt;(&amp;i); // const 与非 const 转换</span><br></pre></td></tr></table></figure>

<p>static_cast 隐式类型转换</p>
<p>什么是隐式类型的转换，隐式类型转换，就像c语言中我们可以把一个整型 int 赋值给一个 float 这就是隐式类型的转换。 </p>
<p>我们简单的写一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    float j = i; // 在c语言中的隐式类型的转换</span><br><span class="line">    // 用static_cast转换</span><br><span class="line">    float j = static_cast&lt;float&gt;(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写增强了代码的可读性</p>
<p>reinterpret_cast 不相关类型转换</p>
<p>这强制类型转换是就像 c语言中的强转。 </p>
<p>我们举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef void (* FUNC)();</span><br><span class="line">int DoSomething (int i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;DoSomething&quot; &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void Test ()</span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">    // reinterpret_cast可以编译器以FUNC的定义方式去看待 DoSomething函数</span><br><span class="line">    // C++不保证所有的函数指针都被一样的使用，所以这样用有时会产生不确定的结果</span><br><span class="line">    //</span><br><span class="line">    FUNC f = reinterpret_cast&lt; FUNC&gt;(DoSomething );</span><br><span class="line">    f(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就把一个函数赋值，还可以调用。</p>
<p>dynamic_cast虚函数中的父类赋给子类的转化</p>
<p>dynamic_cast用于将一个父类对象的指针转换为子类对象的指针或引用（动态转换） </p>
<p>向上转型：子类对象指针-&gt;父类指针/引用（不需要转换）  <strong>多态</strong></p>
<p>向下转型：父类对象指针-&gt;子类指针/引用（用dynamic_cast转型是安全的）</p>
<p>这里用这种强转必须要虚函数的类，用dynamic_cast来转换父类付给子类的时候，有时候可以，有时候不行，这样用dynamic_cast 强转就会在转变的过程中去判断，如果可以把父类给子类就强转，如果不行就返回0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public :</span><br><span class="line">    virtual void f()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;&#125;;</span><br><span class="line">void fun (A* pa)</span><br><span class="line">&#123;</span><br><span class="line">    // dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回</span><br><span class="line">    B* pb1 = static_cast&lt;B*&gt;(pa);</span><br><span class="line">    B* pb2 = dynamic_cast&lt;B*&gt;(pa);</span><br><span class="line">    cout&lt;&lt;&quot;pb1:&quot; &lt;&lt;pb1&lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt;&quot;pb2:&quot; &lt;&lt;pb2&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    fun(&amp;a);</span><br><span class="line">    fun(&amp;b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/oOo/source/_posts/C/1e3067cc-a5f4-481b-ba39-7197037f07de.png" alt="img"></p>
<p>红色标记的是强转失败，因为把父类赋给子类失败。强转就会判断是否成功。 </p>
<p>如果用c语言中强转可以成功，但是如果强转后，去访问有可能会访问越界。</p>
<p>explicit关键字</p>
<p>在强转中，对于单参数的构造函数，支持隐式类型的转换，所以当我们不需要隐式类型的转换的时候，我们就可以加上explicit关键字来防止，在构造函数的时候发生隐式类型的转换。 </p>
<p>单参数的类构造函数的隐式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span> <span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A(int a)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A(const A&amp; a)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _a ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span> <span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 隐式转换-&gt; A tmp(1); A a2(tmp);</span></span><br><span class="line">    A a2 = <span class="number">1</span>; <span class="comment">// 这是因为单参数支持隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们加上关键字后，用 = 来进行隐式类型转换，是编译不能通过的。 </p>
<p><img src="/2021/06/27/C/cdb1adc2-b704-4f96-a34f-5c84dcad9daa.png" alt="img"></p>
<p>如果我们不加就可以通过。</p>
<h1 id="左值-右值-width-既能被赋值又能取值的原因所在"><a href="#左值-右值-width-既能被赋值又能取值的原因所在" class="headerlink" title="左值 右值   width()既能被赋值又能取值的原因所在"></a>左值 右值   width()既能被赋值又能取值的原因所在</h1><p>C/C++编程中不是经常出现术语（左值）和rvalue（右值），但是一旦出现，它们的语意就不是特别清晰。最经常看到它们的地方是在编译错误和警告信息中。比如，用gcc编译下面的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int foo() &#123; return 2; &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo() = 2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.c: In function &#x27;main&#x27;:</span><br><span class="line">test.c:8:5: error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure>

<p>是的，这段代码不是合法的并且不是你想写的，但是那个错误信息提到了lvalue，一个通常在C/C++教程中不能找到的术语。另一个例子就是用g++编译下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int&amp; foo()</span><br><span class="line">&#123;</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在那个错误为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">testcpp.cpp: Infunction &#x27;int&amp; foo()&#x27;:</span><br><span class="line">testcpp.cpp:5:12: error: invalid initialization of non-const reference of type &#x27;int&amp;&#x27; from an rvalue of type &#x27;int&#x27;</span><br></pre></td></tr></table></figure>

<p>再次，那个错误信息提到了难以理解的rvalue。那么在C/C++中lvalue和rvalue意味着什么？这是我打算 在这篇文字中探讨的。</p>
<h2 id="一个简单定义"><a href="#一个简单定义" class="headerlink" title="一个简单定义"></a>一个简单定义</h2><p>这个部分先给出lvalue和rvalue的一个简单定义。文章下面将会详细描述。<br>lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。<br>rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是在不在内存中占有确定位置的表达式。</p>
<h2 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h2><p>上面的术语定义可能不是特别清楚，所以马上看一些简单例子是重要的。<br>假设我们定义了一个整形变量并且给它赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int var;</span><br><span class="line">var = 4;</span><br></pre></td></tr></table></figure>

<p>赋值运算符要求一个lvalue作为它的左操作数，当然var是一个左值，因为它是一个占确定内存空间的对象。另一方面，下面的代码是无效的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 = var;        //ERROR!</span><br><span class="line">(var + 10) = 4; //ERROR!</span><br></pre></td></tr></table></figure>

<p>常量<code>4</code>和表达式<code>var+1</code>都不是lvalue(它们是rvalue)。它们不是lvalue，因为都是表达式的临时结果，没有确定的内存空间（换句话说，它们只是计算的周期驻留在临时的寄存器中）。因此给它们赋值没有语意-这里没有地方给它们赋值。<br>因此现在应该清楚了第一个代码片段的错误信息。<code>foo</code>返回一个临时的rvalue。尝试给它赋值，<code>foo()=2</code>，是一个错误；编译器期待在赋值运算符的左部分看到一个lvalue。 </p>
<blockquote>
<p><strong>不是所有的对函数调用结果赋值都是无效的。比如，C++的引用（reference）让这成为可能：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int globalvar = 20;</span><br><span class="line">int&amp; foo()</span><br><span class="line">&#123;</span><br><span class="line">    return globalvar;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo() = 10;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>foo</code>返回一个引用，这是一个左值，所以它可以被赋值。实际上，C++从函数中返回左值的能力对于实现一些重载运算符时很重要的。一个普遍的例子是在类中为实现某种查找访问而重载中括号运算符 []。<code>std::map</code>可以这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::map&lt;int, float&gt; mymap;</span><br><span class="line">mymap[10]=5.6;</span><br></pre></td></tr></table></figure>

<p>给 mymap[10] 赋值是合法的因为非const的重载运算符 std::map::operator[] 返回一个可以被赋值的引用。</p>
<h2 id="可修改的左值"><a href="#可修改的左值" class="headerlink" title="可修改的左值"></a>可修改的左值</h2><p>开始在C语言中左值定义，它字面上意味着“合适作为赋值的左边部分”。然而，之后C标准中添加了const关键字后，这个定义不得不重新定义。毕竟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a = 10; //‘a’是一个左值</span><br><span class="line">a = 10;           //但是它不能被赋值</span><br></pre></td></tr></table></figure>

<p>因此需要更深层次的重定义。不是所有的左值都能被赋值。这些可以称为可修改的左值。正式的，C99标准定义可修改左值为：</p>
<blockquote>
<p>[…] 一个左值没有数组类型，没有不完全类型，没有const修饰的类型，并且如果它是结构体或联合体，则没有任何const修饰的成员(包含，递归包含，任何成员元素的集合)。</p>
</blockquote>
<h2 id="左值和右值的转换"><a href="#左值和右值的转换" class="headerlink" title="左值和右值的转换"></a>左值和右值的转换</h2><p>通常来说，语言构造一个对象的值要求右值作为它的参数。例如，二元加运算符 ‘+’ 要求两个右值作为它的参数并且返回一个右值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1;     //a是一个左值</span><br><span class="line">int b = 2;     //b是一个左值</span><br><span class="line">int c = a + b; //＋需要右值，所以a和b都转换成右值，并且返回一个右值</span><br></pre></td></tr></table></figure>

<p>从先前分析可以看到，<code>a</code>和<code>b</code>都是左值。因此，在代码第三行，它们经历了一次从左值到右值的转换。所以的左值不能是数组，函数或不完全类型都可以转换成右值。<br><strong>另一个方向的转换呢？右值可以转换成左值吗？当然不能！根据它的定义这将违反左值的语义[1]。</strong><br>当然，这并不意味着左值不能通过更加显式的方法产生至右值。例如，一元运算符‘*’（解引用）拿一个右值作为参数而产生一个左值作为结果。考虑下面有效的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[] = &#123;1, 2&#125;;</span><br><span class="line">int* p = &amp;arr[0];</span><br><span class="line">*(p + 1) = 10;    //对的：p+1是一个右值，但是*(p+1)是一个左值</span><br></pre></td></tr></table></figure>

<p>相反的，一元取地址符 ‘&amp;’ 拿一个左值作为参数并且生成一个右值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int var = 10;</span><br><span class="line">int* bad_addr = &amp;(var + 1); //错误：‘&amp;’运算符要求一个左值</span><br><span class="line">int* addr = &amp;var;           //正确：var是左值</span><br><span class="line">&amp;var = 40;                  //错误：赋值运算符的左操作数要求一个左值</span><br></pre></td></tr></table></figure>

<p>‘&amp;’ 符号在C++中扮演了另一个重要角色-它允许定义应用类型。这被称为“左值引用”。非const左值引用不能被赋右值，因为这将要求一个无效的右值到左值的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::string&amp; sref = std::string(); //错误：无效的初始化，用一个右值类型‘std::string’初始化非const引用类型‘std::string&amp;’</span><br></pre></td></tr></table></figure>

<p>常量左值引用可以被赋右值。因为它们是常量，不能通过引用被修改，因此修改一个右值没问题。这使得C++中接受常量引用作为函数形参成为可能，这避免了一些不必要的临时对象的拷贝和构造。</p>
<h2 id="CV修饰的右值"><a href="#CV修饰的右值" class="headerlink" title="CV修饰的右值"></a>CV修饰的右值</h2><p>如果我们仔细地读了C++标准中讨论左值到右值的转换问题[2]，我们注意到它这样说的：</p>
<blockquote>
<p>一个非函数，非数组类型的左值（3.10）T可以被转换成一个右值。[…]如果T是一个非类类型，那么转换成的右值类型是T的非CV修饰版本。否则，那个右值类型是T。</p>
</blockquote>
<p>什么是“cv-unqualified”的东西？CV-qualifier是一个被用来描述const和volatile类型修饰符的术语。<br>C++标准的3.9.3部分：</p>
<blockquote>
<p>每个非CV修饰的完全或不完全对象类型或者是空类型（3.9）都有三个相关的cv修饰版本的类型：const修饰版，volatile修饰版，和一个const-volatile版。[…]一个类型的cv修饰和非cv修饰版是不同的类型。然而，它们有想同的代指和对齐要求（3.9）</p>
</blockquote>
<p>但是这和右值右什么关系？是的，在C语言中，右值没有cv修饰的类型。仅仅左值可以。在C++中，一方面，类的右值有cv修饰的类型，但是内置类型（像int）则不能。考虑下面的这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    void foo() const &#123; std::cout &lt;&lt; &quot;A::foo() const\n&quot;; &#125;</span><br><span class="line">    void foo() &#123; std::cout &lt;&lt; &quot;A::foo()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A bar() &#123; return A(); &#125;</span><br><span class="line">const A cbar() &#123; return A(); &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    bar().foo();  //调用foo</span><br><span class="line">    cbar().foo(); //调用foo const</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 函数的第二个调用实际上调用的是 <code>A</code> 的 <code>foo () const</code> 方法，因为 <code>cbar</code> 返回的是 <code>const A</code> 类型，这是与 <code>A</code> 不同的。这正是上个引用中最后一句话的意思。也可以注意到 <code>cbar</code> 返回的是一个右值。因此这也是一个 cv修饰的右值的例子。</p>
<h2 id="右值引用（C-11）"><a href="#右值引用（C-11）" class="headerlink" title="右值引用（C++11）"></a>右值引用（C++11）</h2><p>右值引用和相关的移动语义是C++11标准中引入的最强大的特性之一。对这个特性更广泛的讨论超过了这篇小文章的范畴[3]，但是我任然想提供一些简单的例子，因为我认为这是一个合适的地方去证明理解左值和右值对理解重要的语言概念有帮助。<br>我已经在文章中花了大部分去解释左值和右值主要的区别之一是左值可以被修改，而右值不能。好的，C++11中对于这个区别添加了一个关键的转换，通在一些特殊的情况允许我们去定义右值得引用然后修改它。<br>作为一个例子，考虑下面一个简单的动态 “整数vector” 实现。这里我只展示相关的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Intvec</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Intvec(size_t num = 0)</span><br><span class="line">        : m_size(num), m_data(new int[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Intvec()</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;destructor&quot;);</span><br><span class="line">        if (m_data) &#123;</span><br><span class="line">            delete[] m_data;</span><br><span class="line">            m_data = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Intvec(const Intvec&amp; other)</span><br><span class="line">        : m_size(other.m_size), m_data(new int[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;copy constructor&quot;);</span><br><span class="line">        for (size_t i = 0; i &lt; m_size; ++i)</span><br><span class="line">            m_data[i] = other.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Intvec&amp; operator=(const Intvec&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;copy assignment operator&quot;);</span><br><span class="line">        Intvec tmp(other);</span><br><span class="line">        std::swap(m_size, tmp.m_size);</span><br><span class="line">        std::swap(m_data, tmp.m_data);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void log(const char* msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;[&quot; &lt;&lt; this &lt;&lt; &quot;] &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t m_size;</span><br><span class="line">    int* m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，我们定义了通常的构造器，析构器，拷贝构造器和拷贝赋值运算符[4]，所有这些都用一个打印输出函数让我们知道它们实际上是在什么时候被调用。<br>我们运行一些简单代码，将 <code>v1</code> 的内容 拷贝到 <code>v2</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intvec v1(20);</span><br><span class="line">Intvec v2;</span><br><span class="line">cout &lt;&lt; &quot;assigning lvalue...\n&quot;;</span><br><span class="line">v2 = v1;</span><br><span class="line">cout &lt;&lt; &quot;ended assigning lvalue...\n&quot;;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assigning lvalue...</span><br><span class="line">[0x28fef8] copy assignment operator</span><br><span class="line">[0x28fec8] copy constructor</span><br><span class="line">[0x28fec8] destructor</span><br><span class="line">ended assigning lvalue...</span><br></pre></td></tr></table></figure>

<p>的确是这样-这显示了 <code>operator=</code> 内部执行过程。但是假设我们赋一些右值给 <code>v2</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; &quot;assigning rvalue...\n&quot;;</span><br><span class="line">v2 = Intvec(33);</span><br><span class="line">cout &lt;&lt; &quot;ended assigning rvalue...\n&quot;;</span><br></pre></td></tr></table></figure>

<p>虽然这里我只是赋一个刚刚构造的vector，但是这只是真是证明一个非常普遍的例子，一些临时的右值被构造然后被赋值给 <code>v2</code>（比如，这可能发生在函数中返回一个<code>vector</code>）。现在的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[0x28ff08] constructor</span><br><span class="line">[0x28fef8] copy assignment operator</span><br><span class="line">[0x28fec8] copy constructor</span><br><span class="line">[0x28fec8] destructor</span><br><span class="line">[0x28ff08] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure>

<p>哇，这看起来有好多工作。尤其是，它有一对额外的构造/析构调用。不幸的是，这是个额外工作，没有任何用，因为在拷贝赋值运算符的内部，另一个临时拷贝的对象在被创建和析构。<br>还好，没问题。C++11给我们右值引用可以实现“移动语义”，特别是一个“移动赋值运算符”[5]。我们来添加另一个 <code>operator=</code> 到 <code>Intvec</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intvec&amp; operator=(Intvec&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    log(&quot;move assignment operator&quot;);</span><br><span class="line">    std::swap(m_size, other.m_size);</span><br><span class="line">    std::swap(m_data, other.m_data);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;&amp;</code> 语法是新的右值引用。的确如它名字一样-给我们一个右值的引用，在调用之后将被析构。我们可以使用我们只是“偷”这个内部的右值这个事实-我们根本不需要它们！输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[0x28ff08] constructor</span><br><span class="line">[0x28fef8] move assignment operator</span><br><span class="line">[0x28ff08] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure>

<p>这里发生的是我们的移动赋值运算符被调用，因为我们的给<code>v2</code>赋右值。临时对象Intvec(33)创建的构造和析构调用任然需要，但是另一个在赋值运算符内部的临时对象不再需要。移动运算符只是简单的切换右值的内部缓冲区为自己的，分配它所以右值析构器将会释放我们对象自己不再使用的缓冲区。很紧凑。<br>我要再次提醒的是这个例子只是移动语义和右值引用的冰山一角。你可以料到，这是个复杂的主题，有许多的案例需要考虑。我这里只是证明C++中左值和右值不同的一个有趣应用。编译器显然知道一些对象什么时候是右值，并且能够在编译期分配调用正确的构造器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>[1] 右值可以显式地赋给左值。隐式转换的缺乏意味着右值不能再左值期待的地方使用。<br>[2] 这在C++11标准草案的4.1部分。<br>[3] 你可以简单的通过谷歌“rvalue references”找到很多有用的资料。一些我个人认为有用的资源：<a href="https://www.artima.com/cppsource/rvalue.html">这个</a>，<a href="https://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11">这个</a>，<a href="http://thbecker.net/articles/rvalue_references/section_01.html">尤其是这个</a>。<br>[4] 从异常安全的角度，这是一个标准的拷贝赋值运算符实现。通过使用拷贝构造器和不抛出异常的 <code>std::swap</code>，它确保如果异常抛出，未初始化的内存没有中间状态发生。<br>[5] 因此现在你应该知道为什么我一直指出我的 <code>operator=</code> 为拷贝赋值运算符。在C++11中这个区别很重要。</p>
<h1 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h1><blockquote>
<mark class="hl-label red">指针本身存在调用栈中，指针指的数据在堆中。</mark>  
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">test</span><span class="params">(<span class="keyword">int</span> *b)</span> <span class="comment">//b可以是静态数组的数组名，也可以是动态数组的首地址</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="comment">//输出传入的数组各元素 </span></span><br><span class="line">    cout&lt;&lt;*(b+i)&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">int</span> *c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//动态创建一个数组  </span></span><br><span class="line">    <span class="comment">//如果将绿色部分换为int c[5];则主函数中调用test无法得到c数组  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  <span class="comment">//新数组的各项值等于传入的数组各项值加5  </span></span><br><span class="line">     *(c+i)=*(b+i)+<span class="number">5</span>;  </span><br><span class="line">    <span class="keyword">return</span> c;     <span class="comment">//返回新创建的动态数组的首地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *b=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line">    <span class="comment">//创建动态数组b </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//赋值 </span></span><br><span class="line">     *(b+i)=i;  <span class="comment">//绿色部分也可以换为int b[5]=&#123;0,1,2,3,4&#125;;即也可以是静态数组</span></span><br><span class="line">    <span class="keyword">int</span> *c=<span class="built_in">test</span>(b);   <span class="comment">//将b作为参数，调用test函数，返回值赋给c </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  <span class="comment">//输出test返回的数组的各项  </span></span><br><span class="line">     cout&lt;&lt;*(c+i)&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</p>
<p>声明格式为：*类型标识符 函数名(参数表)</p>
<p>这似乎并不难理解，再进一步描述一下。</p>
<p>看看下面这个函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fun(int x,int y);</span><br></pre></td></tr></table></figure>

<p>这种函数应该都很熟悉，其实就是一个函数，然后返回值是一个 int 类型，是一个数值。</p>
<p>接着看下面这个函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *fun(int x,int y);</span><br></pre></td></tr></table></figure>

<p>这和上面那个函数唯一的区别就是在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。</p>
<p>这样描述应该很容易理解了，所谓的<strong>指针函数也没什么特别的，和普通函数对比不过就是其返回了一个指针（即地址值）而已。</strong></p>
<p>指针函数的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *fun(int x,int y);</span><br><span class="line">int * fun(int x,int y)；</span><br><span class="line">int* fun(int x,int y);</span><br></pre></td></tr></table></figure>

<p>这个写法看个人习惯，其实如果*靠近返回值类型的话可能更容易理解其定义。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _Data&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;Data;</span><br><span class="line">//指针函数</span><br><span class="line">Data* f(int a,int b)&#123;</span><br><span class="line">    Data * data = new Data;</span><br><span class="line">    data-&gt;a = a;</span><br><span class="line">    data-&gt;b = b;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    //调用指针函数</span><br><span class="line">    Data * myData = f(4,5);</span><br><span class="line">    qDebug() &lt;&lt; &quot;f(4,5) = &quot; &lt;&lt; myData-&gt;a &lt;&lt; myData-&gt;b;</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(4,5) = 4 5</span><br></pre></td></tr></table></figure>

<p>注意：在调用指针函数时，需要一个同类型的指针来接收其函数的返回值。</p>
<p>不过也可以将其返回值定义为 void*类型，在调用的时候强制转换返回值为自己想要的类型，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//指针函数</span><br><span class="line">void* f(int a,int b)&#123;</span><br><span class="line">    Data * data = new Data;</span><br><span class="line">    data-&gt;a = a;</span><br><span class="line">    data-&gt;b = b;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span><br></pre></td></tr></table></figure>

<p>其输出结果是一样的，不过不建议这么使用，因为强制转换可能会带来风险。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p>
<p>声明格式：类型说明符 (*函数名) (参数)</p>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*fun)(int x,int y);</span><br></pre></td></tr></table></figure>

<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure>

<p>取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</p>
<p>调用函数指针的方式也有两种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<p>两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。</p>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//第一种写法</span></span><br><span class="line">    fun = add;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"> <span class="comment">//第二种写法</span></span><br><span class="line">    fun = &amp;sub;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;(*fun)(5,3) = &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">fun</span>(<span class="number">5</span>,<span class="number">3</span>)；</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(*fun)(1,2) = 3</span><br><span class="line">(*fun)(5,2) = 2 2</span><br></pre></td></tr></table></figure>

<p>上面说到的几种赋值和调用方式我都分别使用了，其输出结果是一样的。</p>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><h3 id="定义不同"><a href="#定义不同" class="headerlink" title="定义不同"></a>定义不同</h3><p>指针函数本质是一个函数，其返回值为指针。</p>
<p>函数指针本质是一个指针，其指向一个函数。</p>
<h3 id="写法不同"><a href="#写法不同" class="headerlink" title="写法不同"></a>写法不同</h3><p>指针函数：int* fun(int x,int y);</p>
<p>函数指针：int (*fun)(int x,int y);</p>
<p>可以简单粗暴的理解为，指针函数的*是属于数据类型的，而函数指针的星号是属于函数名的。</p>
<p>再简单一点，可以这样辨别两者：函数名带括号的就是函数指针，否则就是指针函数。</p>
<h3 id="类成员函数的指针（非静态）"><a href="#类成员函数的指针（非静态）" class="headerlink" title="类成员函数的指针（非静态）"></a><strong>类成员函数的指针（非静态）</strong></h3><p>指向类成员函数的指针与普通函数指针的区别在于，前者需要匹配函数的参数类型和个数以及返回值类型，还要匹配该函数指针所属的类类型。</p>
<p>这是因为非静态的成员函数必须被绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数（所有类的对象都有自己数据成员的拷贝，但是成员函数都是共用的，为了区分是谁调用了成员函数，就必须有this指针，this指针是隐式的添加到函数参数列表里去的）。</p>
<p>所以，对于类成员函数的指针使用包含以下几个步骤：</p>
<p>声明： 指向类的成员函数的指针需要在指针前面加上类的类型，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef 返回值 (类名::*指针类型名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>赋值： 需要用类的成员函数地址赋值，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针类型名 指针名 = &amp;类名::成员函数名;</span><br></pre></td></tr></table></figure>

<p>注意：这里的这个&amp;符号是比较重要的：不加&amp;，编译器会认为是在这里调用成员函数，所以需要给出参数列表，否则会报错；加了&amp;，才认为是要获取函数指针。这是C++专门做了区别对待。</p>
<p>调用： 针对调用的对象是对象还是指针，分别用.*和-&gt;*进行调用，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(类对象.*指针名)(参数列表);</span><br><span class="line">(类指针-&gt;*指针名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>注意：这里的前面一对括号是很重要的，因为()的优先级高于成员操作符指针的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Calculation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int add(int a,int b)&#123; //非静态函数</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef int (Calculation::*FuncCal)(int,int);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FuncCal funAdd = &amp;Calculation::add;</span><br><span class="line">    Calculation * calPtr = new Calculation;</span><br><span class="line">    int ret = (calPtr-&gt;*funAdd)(1,2); //通过指针调用</span><br><span class="line">    Calculation cal;</span><br><span class="line">    int ret2 = (cal.*funAdd)(3,4); //通过对象调用</span><br><span class="line">    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ret2 = &quot; &lt;&lt; ret2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指向类的静态函数的指针"><a href="#指向类的静态函数的指针" class="headerlink" title="指向类的静态函数的指针"></a><strong>指向类的静态函数的指针</strong></h3><p>类的静态成员函数和普通函数的函数指针的区别在于，他们是不依赖于具体对象的，所有实例化的对象都共享同一个静态成员，所以静态成员也没有this指针的概念。</p>
<p>所以，指向类的静态成员的指针就是普通的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Calculation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static int add(int a,int b)&#123; //静态函数</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef int (*FuncCal)(int,int);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FuncCal funAdd = &amp;Calculation::add;</span><br><span class="line">    int ret = (*funAdd)(1,2); //直接引用</span><br><span class="line">    int ret2 = funAdd(3,4); //直接引用</span><br><span class="line">    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ret2 = &quot; &lt;&lt; ret2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++中的匿名对象是pure RValue, 因而不能作为引用传进去。</span><br><span class="line">匿名对象只存在于构造该对象的那行代码，离开构造匿名对象的那行代码后立即调用析构函数。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Some</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="built_in">Some</span>(<span class="keyword">int</span> s)&#123;n=s;&#125;  </span><br><span class="line">  ~<span class="built_in">Some</span>()&#123;  </span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;destroy\n&quot;</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ret</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="built_in">Some</span>(<span class="number">111</span>).<span class="built_in">ret</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;wait\n&quot;</span>;  </span><br><span class="line">        cin.<span class="built_in">get</span>();  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象的使用与优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    string course;</span><br><span class="line">public:</span><br><span class="line">    Teacher(const char *n,const char *c):name(n),course(c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;创建&quot; &lt;&lt; course &lt;&lt; &quot;老师&quot; &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Teacher(const Teacher&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        name = t.name;</span><br><span class="line">        course = t.course;</span><br><span class="line">        cout &lt;&lt; &quot;复制&quot; &lt;&lt; course &lt;&lt; &quot;老师&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Teacher()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;辞退&quot; &lt;&lt; course &lt;&lt; &quot;老师&quot;  &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher t1(&quot;陈宗权&quot;,&quot;C++&quot;);//构造函数</span><br><span class="line">    Teacher t2 = t1;//拷贝构造函数</span><br><span class="line">    //用临时匿名对象来初始化一个新对象</span><br><span class="line">    //编译器一般会优化成直接用创建临时对象的参数来创建新对象</span><br><span class="line">    Teacher t3 = Teacher(&quot;杨强&quot;,&quot;UC&quot;);</span><br><span class="line">    t2 = t3; //赋值函数</span><br><span class="line">    cout &lt;&lt; &quot;=======&quot; &lt;&lt;endl;</span><br><span class="line">    t2 = Teacher(&quot;徐薇薇&quot;,&quot;咨询&quot;); // 没有优化 创建匿名对象  调用赋值操作赋值函数，且匿名对象被析构</span><br><span class="line">    cout &lt;&lt; &quot;=======&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">创建C++老师陈宗权</span><br><span class="line">复制C++老师陈宗权</span><br><span class="line">创建UC老师杨强</span><br><span class="line">=======</span><br><span class="line">创建咨询老师徐薇薇</span><br><span class="line">辞退咨询老师徐薇薇</span><br><span class="line">=======</span><br><span class="line">辞退UC老师杨强</span><br><span class="line">辞退咨询老师徐薇薇</span><br><span class="line">辞退C++老师陈宗权</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ol>
<li>匿名对象的生命周期</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat类 无参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Cat</span>(Const Cat&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat类 拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat类 析构函数 &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playStage</span><span class="params">()</span> <span class="comment">//一个舞台，展示对象的生命周期</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Cat</span>();             <span class="comment">/*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；执行完此行代码，</span></span><br><span class="line"><span class="comment">                            因为外部没有接此匿名对象的变量，此匿名又被析构了*/</span> 赋值操作</span><br><span class="line">    Cat cc = <span class="built_in">Cat</span>();    <span class="comment">/*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；然后将此匿名变</span></span><br><span class="line"><span class="comment">                            成了cc这个实例对象，此匿名对象没有被析构。*/</span> 拷贝构造函数</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;cc 对象好没有被析构&quot;</span>&lt;&lt;endl;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">playStage</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="if-中同时出现赋值语句和判断"><a href="#if-中同时出现赋值语句和判断" class="headerlink" title="if 中同时出现赋值语句和判断"></a>if 中同时出现赋值语句和判断</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span> &gt; res;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">            <span class="keyword">if</span> ((iter = map1.<span class="built_in">find</span>(complement) )!= map1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            map1[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-调用-python3-6"><a href="#C-调用-python3-6" class="headerlink" title="C++ 调用 python3.6"></a>C++ 调用 python3.6</h1><p><a href="https://blog.csdn.net/lingtianyulong/article/details/81146495">https://blog.csdn.net/lingtianyulong/article/details/81146495</a> </p>
<p>使用Python3.6,在VS2013与VS2017中进行调用，其中的遇到了各种坑，将暂时遇到的坑先进行整理；</p>
<p>1：py文件不能以 test命名，不知道为什么，以test1,test2之类的命名都可以，但就是不能使用 test命名，否则，找不到函数名，即</p>
<p>  pFunc = PyObject_GetAttrString(pModule, “hello”);该代码找不到 python 中的 hello()函数；</p>
<p>2：若 .py 文件中，有语法错误，则不能导入；</p>
<p>  这点尤为重要，一定先运行python文件，没问题了再放到c++里，第一次调用就因为函数下面的代码没有对齐一直找不到问题</p>
<p>3：要导入.py文件所在的路径，如下所示：</p>
<p>  PyRun_SimpleString(“import sys”);</p>
<p>  PyRun_SimpleString(“sys.path.append(‘F:\C++ WorkSpace\CallPython\CallPython’)”);</p>
<p>其中，修改后的C++代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化python</span></span><br><span class="line">    <span class="built_in">Py_Initialize</span>();</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;sys.path.append(&#x27;F:\\C++ WorkSpace\\CallPython\\CallPython&#x27;)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义python类型的变量</span></span><br><span class="line">    PyObject *pModule = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pFunc = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pArg = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pClass = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pInstance = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pDict = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//直接运行python代码</span></span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;print(&#x27;python start&#x27;)&quot;</span>);</span><br><span class="line">    <span class="comment">//引入模块</span></span><br><span class="line">    pModule = <span class="built_in">PyImport_ImportModule</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!pModule)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Import Module Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取模块字典属性</span></span><br><span class="line">    pDict = <span class="built_in">PyModule_GetDict</span>(pModule);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">////直接获取模块中的函数</span></span><br><span class="line">    pFunc = <span class="built_in">PyObject_GetAttrString</span>(pModule, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//参数类型转换，传递一个字符串。将c/c++类型的字符串转换为python类型，元组中的python类型查看python文档</span></span><br><span class="line">    pArg = <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;(s)&quot;</span>, <span class="string">&quot;hello charity&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用直接获得的函数,并传递参数</span></span><br><span class="line">    <span class="built_in">PyEval_CallObject</span>(pFunc, pArg);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从字典属性中获取函数</span></span><br><span class="line">    pFunc = <span class="built_in">PyDict_GetItemString</span>(pDict, <span class="string">&quot;arg&quot;</span>);</span><br><span class="line">    <span class="comment">// 参数类型转换,传递两个整型参数</span></span><br><span class="line">    pArg = <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;(i, i)&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 调用函数,并得到 python 类型的返回值</span></span><br><span class="line">    result = <span class="built_in">PyEval_CallObject</span>(pFunc, pArg);</span><br><span class="line">    <span class="comment">// c 用来保存 C/C++ 类型的返回值</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将 python 类型的返回值转换为 C/C++类型</span></span><br><span class="line">    <span class="built_in">PyArg_Parse</span>(result, <span class="string">&quot;i&quot;</span>, &amp;c);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a+b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过字典属性获取模块中的类 </span></span><br><span class="line">    pClass = <span class="built_in">PyDict_GetItemString</span>(pDict, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!pClass)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;获取模块中的类失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实例化获取的类</span></span><br><span class="line">    pInstance = <span class="built_in">PyInstanceMethod_New</span>(pClass);</span><br><span class="line">    <span class="comment">//调用类的方法</span></span><br><span class="line">    result = <span class="built_in">PyObject_CallMethod</span>(pInstance, <span class="string">&quot;say_hello&quot;</span>, <span class="string">&quot;(s,s)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;charity&quot;</span>);</span><br><span class="line">    <span class="comment">//输出返回值</span></span><br><span class="line">    <span class="keyword">char</span>* name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">PyArg_Parse</span>(result, <span class="string">&quot;s&quot;</span>, &amp;name);   <span class="comment">//这个函数的第二个参数相当扯淡，具体看下文的英文，类型使用字符来表示的，例如“s”代表 str &quot;i&quot; 代表int，个人感觉相当扯淡</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;print(&#x27;python end&#x27;)&quot;</span>);</span><br><span class="line">    <span class="comment">////释放python</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Py_Finalize</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">hello</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;hello world&quot;</span>)</span></span><br><span class="line"><span class="function">    print(s)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">def arg(a, b):</span></span><br><span class="line"><span class="function">    print(<span class="string">&#x27;a=&#x27;</span>, a)</span></span><br><span class="line"><span class="function">    print(<span class="string">&#x27;b=&#x27;</span>, b)</span></span><br><span class="line"><span class="function">    return a + b</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">class Test:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;init&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def say_hello(self, name):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;hello&quot;</span>, name)</span></span><br><span class="line"><span class="function">        return name</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">python start</span><br><span class="line">hello world</span><br><span class="line">hello charity</span><br><span class="line">a= <span class="number">1</span></span><br><span class="line">b= <span class="number">2</span></span><br><span class="line">a+b = <span class="number">3</span></span><br><span class="line">hello charity</span><br><span class="line">charity</span><br><span class="line">python end</span><br></pre></td></tr></table></figure>

<p>请按任意键继续. . .</p>
<p>给python函数中的变量赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Py_SetPythonHome</span>(<span class="string">L&quot;C:\\Anaconda&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化Python</span></span><br><span class="line">    <span class="comment">//在使用Python系统前，必须使用Py_Initialize对其</span></span><br><span class="line">    <span class="comment">//进行初始化。它会载入Python的内建模块并添加系统路</span></span><br><span class="line">    <span class="comment">//径到模块搜索路径中。这个函数没有返回值，检查系统</span></span><br><span class="line">    <span class="comment">//是否初始化成功需要使用Py_IsInitialized。</span></span><br><span class="line">    <span class="built_in">Py_Initialize</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 检查初始化是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Py_IsInitialized</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加当前路径。这里注意下面三句都不可少，</span></span><br><span class="line">    <span class="comment">//添加的是当前路径。但是我打印了sys.path,</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;import sys&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;from sklearn.externals import joblib&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;import librosa&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;import numpy as np&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;print &#x27;---import sys---&#x27;&quot;);</span></span><br><span class="line">    <span class="comment">//下面这个./表示当前工程的路径，如果使用../则为上级路径，根据此来设置</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;sys.path.append(&#x27;./&#x27;)&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;print(&#x27;python start&#x27;)&quot;);</span></span><br><span class="line">    PyObject *pName = <span class="literal">NULL</span>, *pModule = <span class="literal">NULL</span>, *pDict = <span class="literal">NULL</span>, *pFunc = <span class="literal">NULL</span>, *pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 载入名为python的脚本</span></span><br><span class="line">    <span class="comment">//pName = PyString_FromString(&quot;cpython&quot;);</span></span><br><span class="line">    pModule = <span class="built_in">PyImport_ImportModule</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pModule) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t find your_file.py&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pDict = <span class="built_in">PyModule_GetDict</span>(pModule);</span><br><span class="line">    <span class="keyword">if</span> (!pDict) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 找出函数名为signal_classfication的函数</span></span><br><span class="line">    pFunc = <span class="built_in">PyDict_GetItemString</span>(pDict, <span class="string">&quot;signal_classfication&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pFunc || !<span class="built_in">PyCallable_Check</span>(pFunc)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t find function [display]&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将参数传进去。1代表一个参数。</span></span><br><span class="line">    pArgs = <span class="built_in">PyTuple_New</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//  PyObject* Py_BuildValue(char *format, ...)</span></span><br><span class="line">    <span class="comment">//  把C++的变量转换成一个Python对象。当需要从</span></span><br><span class="line">    <span class="comment">//  C++传递变量到Python时，就会使用这个函数。此函数</span></span><br><span class="line">    <span class="comment">//  有点类似C的printf，但格式不同。常用的格式有</span></span><br><span class="line">    <span class="comment">//  s 表示字符串，</span></span><br><span class="line">    <span class="comment">//  i 表示整型变量，</span></span><br><span class="line">    <span class="comment">//  f 表示浮点数，</span></span><br><span class="line">    <span class="comment">//  O 表示一个Python对象。</span></span><br><span class="line">    PyObject* pList = <span class="literal">NULL</span>;</span><br><span class="line">    pList = <span class="built_in">PyList_New</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PyList_Append</span>(pList, <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;i&quot;</span>, boxing[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PyTuple_SetItem</span>(pArgs, <span class="number">0</span>, pList);</span><br><span class="line">    <span class="built_in">PyTuple_SetItem</span>(pArgs, <span class="number">1</span>, <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;s&quot;</span>, date));</span><br><span class="line">    <span class="comment">// 调用Python函数</span></span><br><span class="line">    PyObject* pReturn = <span class="built_in">PyObject_CallObject</span>(pFunc, pArgs);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">PyList_Size</span>(pReturn);</span><br><span class="line">    <span class="comment">//int size = 7;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;sum：&quot; &lt;&lt;  size &lt;&lt; endl; </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> res[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">if</span> (pReturn != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PyObject *pListItem_1 = <span class="built_in">PyList_GetItem</span>(pReturn, j);</span><br><span class="line">            <span class="built_in">PyArg_Parse</span>(pListItem_1, <span class="string">&quot;d&quot;</span>, &amp;res[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="按位于-按位或"><a href="#按位于-按位或" class="headerlink" title="按位于 按位或"></a>按位于 按位或</h1><p>8位二进制=2位十六进制=1位十进制=1字节</p>
<p>value &amp; 0x2000，把第三位取出来，别的都不要了，然后&gt;&gt;12,向右移动了12位，原来的第三位就变成了第15位，别的位都是0，然后转成两个字节16位的数</p>
<p>0x2000（0010 0000 0000 0000）-&gt;0000 0000 0000 0010</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8位</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FeatureSupports</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  MIN = <span class="number">0x0001</span>,  <span class="comment">//0000 0001</span></span><br><span class="line">  SECOND = <span class="number">0x0002</span>,<span class="comment">//0000 0010</span></span><br><span class="line">  THIRD = <span class="number">0x0004</span>, <span class="comment">//0000 0100</span></span><br><span class="line">  FORTH = <span class="number">0x0008</span>, <span class="comment">//0000 1000</span></span><br><span class="line">  FIFTH = <span class="number">0x0010</span>, <span class="comment">//0001 0000</span></span><br><span class="line">  SIX = <span class="number">0x0020</span>,  <span class="comment">//0010 0000</span></span><br><span class="line">  SEVEN = <span class="number">0x0040</span>, <span class="comment">//0100 0000</span></span><br><span class="line">  MAX = <span class="number">0x0080</span>,  <span class="comment">//1000 0000</span></span><br><span class="line">  FULL = <span class="number">0x00FF</span>,  <span class="comment">//1111 1111</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>位操作</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>***/</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立一个标志位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> globalMark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入第2、3、4位</span></span><br><span class="line">globalMark |= FeatureSupports::SECOND| FeatureSupports::THIRD | FeatureSupports::FORTH;<span class="comment">//0000 1110,得14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a= globalMark &amp; FeatureSupports::SECOND;<span class="comment">//检查第二位是否为1，得0010即2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b = globalMark &amp; <span class="number">0x0006</span>;<span class="comment">//检查第二位与第三位是否都为1，得0110即6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个体现了优先级：位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> c = (globalMark &amp; <span class="number">0x0006</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">//源数据是1110，与0x0006（0110）按位与，得到0110，右移一位，得0011即3</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> d = globalMark &amp; <span class="number">0x0006</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//源数据是0x0006（0110），右移一位，得0011,与1110按位与，得到0010，即2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消除第三位，取反的方法不依赖机器字长，而且还能指定要清除的实际位，所以比下面的【消除后两位】使用的直接按位与的方法好</span></span><br><span class="line">globalMark &amp;= ~FeatureSupports::THIRD;<span class="comment">//0000 0100取反得1111 1011，与0000 1110按位与， 得0000 1010即10</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> e=~FeatureSupports::THIRD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消除后两位</span></span><br><span class="line">globalMark &amp;= <span class="number">0xFFFFFFFC</span>;<span class="comment">//1111 1100与0000 1010按位与，得0000 1000即8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反置一位，可用异或运算符</span></span><br><span class="line">globalMark ^= <span class="number">0x2</span>;<span class="comment">//0000 1000异或第二位，即得0000 1010,即10</span></span><br><span class="line">globalMark ^= <span class="number">0x2</span>;<span class="comment">//0000 1010异或第二位，即得0000 1000,即8</span></span><br></pre></td></tr></table></figure>



<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>1 位逻辑运算符：</p>
<p>   <strong>&amp;</strong> （位  “与”）  and<br>   <strong>^</strong> （位  “异或”）<br>   <strong>|</strong>  （位   “或”）  or<br>   <strong>~</strong> （位  “取反”）<br>2 移位运算符：<br>   **&lt;&lt;**（左移）</p>
<p>   **&gt;&gt;**（右移）</p>
<p><strong>优先级</strong></p>
<p>位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </p>
<h2 id="二：位逻辑运算"><a href="#二：位逻辑运算" class="headerlink" title="二：位逻辑运算"></a>二：位逻辑运算</h2><p><strong>&amp; 运算</strong>  ———————–**-2个都为1-》1**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>&amp;<span class="number">1</span> =<span class="number">0</span>;  </span><br><span class="line"><span class="number">0</span>&amp;<span class="number">0</span> =<span class="number">0</span>;</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">0</span> =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&amp;<span class="number">1</span> =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00111</span>&amp; <span class="number">11100</span>  =<span class="number">00100</span></span><br></pre></td></tr></table></figure>

<p>&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。</p>
<p>这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数</p>
<p>—————————————————————–</p>
<p><strong>| 运算</strong>—————————<strong>1个为1–》1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">0</span>=<span class="number">0</span>;  </span><br><span class="line"><span class="number">0</span>|<span class="number">1</span>=<span class="number">1</span>;</span><br><span class="line"><span class="number">1</span>|<span class="number">0</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00111</span>|  <span class="number">11100</span>  =<span class="number">11111</span></span><br></pre></td></tr></table></figure>

<p>| 运算通常用于二进制特定位上的无条件赋值，例如一个数|1的结果就是把二进制最末位强行变为1</p>
<p>如果需要把二进制最末位变成0，对这个数 |1之后再减一就可以了，其实际意义就是把这个数强行变成最近接的偶数</p>
<p>——————————————————————–</p>
<p><strong>^ 运算</strong>—————————<strong>不同则为1，相同则为0 // 当且仅当两个运算值中有一个为1但不同时为1时，返回值为1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>^<span class="number">1</span>=<span class="number">1</span>；</span><br><span class="line"><span class="number">1</span>^<span class="number">0</span>=<span class="number">1</span>；</span><br><span class="line"><span class="number">1</span>^<span class="number">1</span>=<span class="number">0</span>；</span><br><span class="line"><span class="number">0</span>^<span class="number">0</span>=<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="number">00111</span> ^ <span class="number">11100</span>     =<span class="number">11011</span></span><br></pre></td></tr></table></figure>

<p>^运算通常用于对二进制的特定一位进行取反操作，^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a^b)^b=a；</p>
<p>^运算可以用于简单的加密，比如原始值int a = 19880516;密钥 int key =1314520; 进行加密 int data=key^a = 20665500;解密 data^key == a；</p>
<p>^运算还可以实现两个值的交换而不需要中间变量，例如：</p>
<p>先看加减法中交换实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> &amp;a,<span class="keyword">long</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = a+b;</span><br><span class="line">   b = a-b;</span><br><span class="line">   a = a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> &amp;a,<span class="keyword">long</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a = a^b;</span><br><span class="line">  b = a^b;</span><br><span class="line">  a = a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 ^运算可以理解成类似加法（+）记忆 ， 1+1 =0，1+0 =1，0+1 =1；0+0 =0；//因为机器码是二进制，1+1=2%2 =0，其实不然</p>
<p>—————————————————————————————————</p>
<p><strong>~运算</strong></p>
<p><del>运算的定义把内存中的0和1全部取反，所以</del>运算时要格外小心，你需要注意整数类型有没符号，如果~的对象是无符号整数（不能表示负数），那么他的值就是它与它的上界限的之差，因为无符号类型的数是用0000到0000到FFFF依次表示的。</p>
<p>下面的两个程序（仅语言不同）均返回65435。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var</span><br><span class="line">   a:word;</span><br><span class="line">begin</span><br><span class="line">   a:=<span class="number">100</span>;</span><br><span class="line">   a:=<span class="keyword">not</span>  a;</span><br><span class="line">   <span class="built_in">writenln</span>(a);</span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    unsingned <span class="keyword">short</span> a = <span class="number">100</span>;</span><br><span class="line">​    a = ~a;</span><br><span class="line">​    <span class="built_in">printf</span>(“%d\n”,a);</span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 ~的对象是有符号的整数，情况就不一样了，详见最后面整数类型的存储</p>
<h2 id="三：位移运算"><a href="#三：位移运算" class="headerlink" title="三：位移运算"></a>三：位移运算</h2><p><strong>&lt;&lt;运算</strong></p>
<p>a&lt;&lt;b 表示把a转为二进制后左移b位（在后面添加 b个0）。例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100&lt;&lt;2 =110010000 =400，可以看出，a&lt;&lt;b的值实际上就是a乘以2的b次方，因为在二进制数后面添加一个0就相当该数乘以2，2个零即2的2次方 等于4。通常认为a&lt;&lt;1比a*2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作尽量用左移一位来代替。</p>
<p>定义一些常量可能会用到&lt;&lt;运算。你可以方便的用1&lt;&lt;16 -1 来表示65535（unsingned int  最大值16位系统）。很多<a href="http://lib.csdn.net/base/datastructure">算法</a>和<a href="http://lib.csdn.net/base/datastructure">数据结构</a>要求数据模块必须是2的幂，此时就可以用&lt;&lt;来定义MAX_N等常量。</p>
<p><strong>&gt;&gt;运算</strong></p>
<p>和&lt;&lt;相似，a&gt;&gt;b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们经常用&gt;&gt;1来代替 /2（div 2),比如二分查找、堆的插入操作等等。想办法用&gt;&gt;代替除法运算可以使程序的效率大大提高。最大公约数的二进制算法用除以2操作来代替慢的出奇的%（mod）运算，效率可以提高60%。</p>
<p>int a =100;</p>
<p>a/4 ==a&gt;&gt;2;</p>
<p><strong>位移运算运用 例子</strong></p>
<p><strong>1.合并数据</strong></p>
<p>缩短数据：int a =4; int b=2;  可以将数据 a,b 保存于一个变量 int c中,在此int 类型为32位</p>
<p>a=0x0000 0004; / /十六进制</p>
<p>b=0x0000 0002;</p>
<p>int c = a&lt;&lt;16;//左移操作-将a数据向左移动16位=0x0004 0000</p>
<p> c |=b;  // （|）操作，一个为1 则为1，所以高16位不变，低16位值为 b值，即c = 0x0004 0002;完成数据的合并</p>
<p><strong>2.解析数据</strong></p>
<p>上面c = 0x0004 0002;</p>
<p>读取高位：int a1 = c&gt;&gt;16; / / 右移16位，消除低位数据，读取高位数据 a1 = 0x0000 0004</p>
<p>读取低位：int a2 = c&0xFFFF; //（&amp;）操作，2个都为1 则为1，所以0xFFFF 即 0X0000 FFFF, 所以高位全为0，低位的 1不变，0还是0，a2=0x0000 0002,读取低位成功</p>
<p>读取低位2：int a2 = c&lt;&lt;16; 消除高位，低位存入高位，a2=0x0002 0000;</p>
<p>​                      a2 = a2&gt;&gt;16;高位存入低位，消除低位; a2 = 0x0000 0002;</p>
<p><strong>下面列举一些常见的二进制位的变换操作</strong></p>
<table>
<thead>
<tr>
<th>去掉最后一位</th>
<th>101101-&gt;10110</th>
<th>x&gt;&gt;1</th>
</tr>
</thead>
<tbody><tr>
<td>在最后加一个0</td>
<td>101101-&gt;1011010</td>
<td>x&lt;&lt;1</td>
</tr>
<tr>
<td>在最后加一个1</td>
<td>101101-&gt;1011011</td>
<td>(x&lt;&lt;1)+1</td>
</tr>
<tr>
<td>把最后一位变成1</td>
<td>101100-&gt;101101</td>
<td>x | 1</td>
</tr>
<tr>
<td>把最后一位变成0</td>
<td>101101-&gt;101100</td>
<td>(x |1) - 1</td>
</tr>
<tr>
<td>最后一位取反</td>
<td>101101-&gt;101100</td>
<td>x ^ 1</td>
</tr>
<tr>
<td>把右数第K位变成1</td>
<td>101001-&gt;101101,k=3</td>
<td>x  | (1&lt;&lt;(k-1))</td>
</tr>
<tr>
<td>把右数第K位变成0</td>
<td>101101-&gt;101101,k=3</td>
<td>x &amp; ~(1&lt;&lt;(k-1))</td>
</tr>
<tr>
<td>右数第k位取反</td>
<td>101001-&gt;101101,k=3</td>
<td>x ^ (1&lt;&lt;(k-1))</td>
</tr>
<tr>
<td>取末三位</td>
<td>1101101-&gt;101</td>
<td>x &amp;7</td>
</tr>
<tr>
<td>取末k位</td>
<td>1101101-&gt;1101,k=5</td>
<td>x &amp; (1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>取右数第k位</td>
<td>1101101-&gt;1,k=4</td>
<td>x &gt;&gt; (k-1)&amp;1</td>
</tr>
<tr>
<td>把末k位变成1</td>
<td>101001-&gt;101111,k=4</td>
<td>x|(1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>末k位取反</td>
<td>101001-&gt;100110,k=4</td>
<td>x^(1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>把右边连续的1变成0</td>
<td>100101111-&gt;100100000</td>
<td>x&amp;(x+1)</td>
</tr>
<tr>
<td>把右起第一个0变成1</td>
<td>100101111-&gt;100111111</td>
<td>x|(x+1)</td>
</tr>
<tr>
<td>把右边连续的0变成1</td>
<td>11011000-&gt;11011111</td>
<td>x|(x-1)</td>
</tr>
<tr>
<td>取右边连续的1</td>
<td>100101111-&gt;1111</td>
<td>(x^(x+1))&gt;&gt;1</td>
</tr>
<tr>
<td>去掉右起第一个1的左边</td>
<td>100101000-&gt;1000</td>
<td>x&amp;(x^(x-1))</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>最后一个会在树状数组中用到</p>
<p><strong>整数类型的储存</strong></p>
<p>前面 所说的位运算都没有涉及负数，都假设这些运算是在unsingned/word类型（只能表示正数的整型）上进行操作。</p>
<p>但计算机如何处理有正负符号的整型呢？这个设计到补码，反码知识点，请看下面</p>
<p>​    假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：00000000 00000000 00000000 00000101<br>5转换成二进制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。<br>​    现在想知道，-5在计算机中如何表示？<br>   <strong>在计算机中，负数以其正值的补码形式表达</strong>。</p>
<p>   什么叫补码呢？这得从原码，反码说起。</p>
<h2 id="四：反码，补码-可借鉴《字符串相关-gt-十进制与二进制的转换》"><a href="#四：反码，补码-可借鉴《字符串相关-gt-十进制与二进制的转换》" class="headerlink" title="四：反码，补码(可借鉴《字符串相关-&gt;十进制与二进制的转换》)"></a><strong>四：反码，补码</strong>(可借鉴《字符串相关-&gt;十进制与二进制的转换》)</h2><p>​    反码和补码的目的就是为了解决负数的问题</p>
<p>​    在计算机内，定点数有3种表示法：<mark class="hl-label blue">原码、反码和补码</mark>  </p>
<p>​    所谓原码就是前面所介绍的二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。</p>
<blockquote>
<p><strong>反码表示法规定</strong>：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</p>
<p><strong>补码表示法规定</strong>：正数的补码与其原码相同；负数的补码是在其反码的末位加1。</p>
</blockquote>
<p>   有原码就可以了，为什么还需要反码和补码？</p>
<p>   反码是用来算补码的，原码和补码都是用在CPU的基本运算里的，比如数据类型是short：<br>   计算5  -  2，并由于实际上CPU没有实现减法电路（注：计算机的硬件结构中只有加法器，所以大部分的运算都必须最终转换为加法，原码没有办法做减法，而在我们使用的汇编、C等其他高级语言中使用的都是原码，原码转换成补码都是在计算机的最底层进行的）。原码计算是  5＋（－2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    0101</span><br><span class="line">＋  1010</span><br><span class="line">——- </span><br><span class="line">    1111 </span><br></pre></td></tr></table></figure>

<p> ＝－7？显然出错<br> 所以不管正数还是负数，都使用补码来表示（正数原码和补码是一样的）， 2的补码是1110，然后用5补  +  2补  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0101  </span><br><span class="line">+ 1110  </span><br><span class="line">——  </span><br><span class="line">  0011  </span><br></pre></td></tr></table></figure>

<p> ＝3，正确</p>
<p>《<a href="http://blog.csdn.net/wuguai4/article/details/7321440">补码的运算方法详见此链接</a>》<br>所以理论上（也仅仅是理论上）我们只要让减数通过一个求反电路，再通过一个+1电路，然后通过加法电路就可以实现减法了。 </p>
<p>所以补码的设计目的是:<br>⑴使符号位能与有效值部分一起参加运算,从而简化运算规则.<br>⑵使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计</p>
<p>​    <strong>原码</strong>：在数值前直接加一符号位的表示法。</p>
<p>　　       例如： 符号位 数值位　　            [+7]原= 0 0000111 　　            [-7]原= 1 0000111 </p>
<p>​    注意：a： 数0的原码有两种形式：        [+0]原= 0 0000000                     [<a href="http://baike.baidu.com/view/1199203.htm">-0</a>]原=1 0000000</p>
<p>　  　     b： 8位二进制原码的表示范围：-127～+127<br>　<strong>反码</strong>：正数：正数的反码与原码相同。</p>
<p>　　       负数：负数的反码，符号位为“1”，数值部分按位取反。</p>
<p>   例如： 符号位 数值位               　             [+7]反= 0 0000111 　　             [-7]反= 1 1111000 　  </p>
<p>   注意：a：数0的反码也有两种形式，即   [+0]反= 0 0000000　  　            [- 0]反=1 1111111　      </p>
<p>​              b.：8位二进制反码的表示范围：-127～+127</p>
<p>​    <strong>补码：</strong></p>
<p>​     <strong>1）</strong>模的概念：把一个计量单位称之为模或模数。例如，时钟是以12进制进行计数循环的，即以12为模。在时钟上，时针加上（正拨）12的整数位或减去（反拨）12的整数位，时针的位置不变。14点钟在舍去模12后，成为（下午）2点钟（14=14-12=2）。从0点出发逆时针拨10格即减去10小时，也可看成从0点出发顺时针拨2格（加 上2时），即2点（0-10=-10=-10+12=2）。因此，在模12的前提下，-10可映射为+2。由此可见，对于一个模数为12的循环系统来说，加2和减10的效果是一样的； 因此，在以12为模的系统中，凡是减10的运算都可以用加2来代替，这就把减法问题转化成加法问题了（注：计算机的硬件结构中只有加法器，所以大部分的运算都必 须最终转换为加法）。10和2对模12而言互为补数。</p>
<p>　　     同理，计算机的运算部件与寄存器都有一定字长的限制（假设字长为8），因此它的运算也是一种模运算。当计数器计满8位也就是256个数后会产生溢出，又从头开始         计数。产生溢出的量就是计数器的模，显然，8位二进制数，它的模数为8=256。在计算中，两个互补的数称为“补码”。</p>
<p>  <strong>2）</strong>补码的表示：</p>
<p>　　    正数：正数的补码和原码相同。　　    </p>
<p>​           负数：负数的补码则是符号位为“1”。并且，这个“1”既是符号位，也是数值位。数值部分按位取反后再在末位（最低位）加1。也就是“反码+1”。　　</p>
<p>​           例如： 符号位 数值位　　       [+7]补= 0 0000111    [-7]补= 1 1111001 </p>
<p>　　   补码在微型机中是一种重要的编码形式，请注意：</p>
<p>　　<strong>a：</strong> 采用补码后，可以方便地将减法运算转化成加法运算，运算过程得到简化。正数的补码即是它所表示的数的真值，而负数的补码的数值部份却不是它所表示的数的真值。采用补码进行运算，所得结果仍为补码。</p>
<p>　　<strong>b.：</strong>与原码、反码不同，数值0的补码只有一个，即 [0]补=0 0000000。</p>
<p>　　<strong>c.：</strong>若字长为8位，则补码所表示的范围为-128～+127；进行补码运算时，应注意所得结果不应超过补码所能表示数的范围。</p>
<p><strong>源码、反码和补码之间的转化</strong></p>
<p>​    由于正数的源码、反码、补码表示方法相同，不需转换。</p>
<p>​     在此，仅以负数情况分析。</p>
<p>​     <strong>1）已知原码，求补码</strong></p>
<p>​         例：已知某数X的源码为10110100，试求X的补码和反码。</p>
<p>​         解：由【X】原=10110100看出，X为负数。求其反码时，符号位不变，数值部分按位求反；求其补码时，再在其反码的末位加1。</p>
<p>​         10110100 原码</p>
<p>​         11001011反码，符号位不变，数值取反</p>
<p>​         1+1</p>
<p>​         11001100 补码</p>
<p>​         故：【X】补 = 11001100，【X】反 = 11001011。</p>
<p>​      <strong>2）已知补码，求原码。</strong></p>
<p>​         分析：按照求负数补码的你过程，数值部分应是最低位减1，然后取反。但是对二进制数来说，先减1后取反和先取反后加1得到的结果是一样的，故仍可采用取反加1的方法。</p>
<p>​         例：已知某数X的补码1110110，试求其原码。</p>
<p>​        解：由【X】补 = 11101110知，X为负数。</p>
<p>​         采用逆推法</p>
<p>​         11101110 补码</p>
<p>​         11101101反码（符号位不变，数值取反加1）</p>
<p>​         10010010原码（符号位不变，数值取反）</p>
<p>​          算法2：</p>
<p>​         设源码 =  A；可见A为负数</p>
<p>​         设反码 = B；</p>
<p>​         因为补码 = 反码+1；所以</p>
<p>​          B +1 = 11101110；</p>
<p>​          B = 11101110 - 1 </p>
<p>​            = 11101101;</p>
<p>​          A =B取反（符号位不变） = 10010010；</p>
<p><strong>有符号数运算时的溢出问题，看下下面两个题目</strong></p>
<p>两个数相加怎么变成了负数？？？</p>
<p><strong>1）</strong> （+72）+（+98）=？</p>
<p>　　0 1 0 0 1 0 0 0  +72</p>
<p>　　+</p>
<p>​        0 1 1 0 0 0 1 0  +98</p>
<p>　　1 0 1 0 1 0 1 0  -86　　两负数相加怎么会得出正数？？？ </p>
<p><strong>2）</strong>（-83）+（-80）=？　　</p>
<p>​        1 0 1 0 1 1 0 1 -83</p>
<p>　　+</p>
<p>​        1 0 1 1 0 0 0 0  -80</p>
<p>　　0 1 0 1 1 1 0 1  +93　　</p>
<p>思考：这两个题目，按照正常的法则来运算，但结果显然不正确，这是怎么回事呢？　　</p>
<p>答案：这是因为发生了溢出。　　</p>
<p>如果计算机的字长为n位，n位二进制数的最高位为符号位，其余n-1位为数值位，采用补码表示法时，可表示的数X的范围是 -2的<em>n-1</em>次幂≤X≤2的<em>n-1</em>次幂-1　　</p>
<p>当n=8时，可表示的有符号数的范围为-128～+127。两个有符号数进行加法运算时，如果运算结果超出可表示的有符号数的范围时，就会发生溢出，使计算结果出错。很显然，溢出只能出现在两个同符号数相加或两个异符号数相减的情况下。　　</p>
<p>对于加法运算，如果次高位（数值部分最高位）形成进位加入最高位，而最高位（符号位）相加（包括次高位的进位）却没有进位输出时，或者反过来，次高位没有进位加入最高位，但最高位却有进位输出时，都将发生溢出。因为这两种情况是：两个正数相加，结果超出了范围，形式上变成了负数；两负数相加，结果超出了范围，形式上变成了正数。　</p>
<p>而对于减法运算，当次高位不需从最高位借位，但最高位却需借位（正数减负数，差超出范围），或者反过来，次高位需从最高位借位，但最高位不需借位（负数减正数，差超出范围），也会出现溢出。　　</p>
<p>在计算机中，数据是以补码的形式存储的，所以补码在<a href="http://baike.baidu.com/view/1219.htm">c语言</a>的教学中有比较重要的地位，而讲解补码必须涉及到原码、反码。本部分演示作何一个整数的原码、反码、补码。过程与结果显示在列表框中，结果比较少，不必自动清除，而过程是相同的，没有必要清除。故需设清除各部分及清除全部的按钮。测试时注意最大、最小正负数。用户使用时注意讲解不会溢出：当有一个数的反码的全部位是1才会溢出，那么它的原码是10000…，它不是负数，故不会溢出。　　</p>
<p>在n位的机器数中，最高位为符号位，该位为零表示为正，为一表示为负；其余n-1位为数值位，各位的值可为零或一。当真值为正时，原码、反码、补码数值位完全相同；当真值为负时，原码的数值位保持原样，反码的数值位是原码数值位的各位取反，补码则是反码的最低位加一。注意符号位不变。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h2 id="提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。"><a href="#提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。" class="headerlink" title="提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。"></a>提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。</h2><p>　　1.原码的求法:</p>
<p>​       (1)对于正数,转化为二进制数,在最前面添加一符号位(这是规定的),用1表示负数,0表示正数.如:0000 0000是一个字节,其中0为符号位,表示是正数,其它七位表示二进制的值.其实,机器不管这些,什么符号位还是值,机器统统看作是值来计算. 正数的原码、反码、补码是同一个数!</p>
<p>　　(2)对于负数,转化为二进制数,前面符号位为1.表示是负数.　　计算原码只要在转化的二进制数前面加上相应的符号位就行了.　</p>
<p>​    　2.反码的求法:对于负数,将原码各位取反,符号位不变.　　</p>
<p>​        3.补码的求法:对于负数,将反码加上二进制的1即可,也就是反码在最后一位上加上1就是补码了.</p>
<p>来源： <a href="https://blog.csdn.net/a1351937368/article/details/77746574/">https://blog.csdn.net/a1351937368/article/details/77746574/</a></p>
<h2 id="位屏蔽"><a href="#位屏蔽" class="headerlink" title="位屏蔽"></a>位屏蔽</h2><p>位屏蔽是指为了检查一个字节中的某些位,可以让这个字节和屏蔽字(<a href="https://www.baidu.com/s?wd=bit&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">bit</a> mask)进行按位与操作–屏蔽字中与要检查的位对应的位全部为1,而其余的位(被屏蔽的位)全部为0.<br>为了置位所需要的位,可以让数据和屏蔽字进行按位或操作.<br>为了清除所需的位,可以让数据和对屏蔽字按位取反所得的值进行按位与操作</p>
<p>位屏蔽的含义是从包含多个位集的一个或一组字节中选出指定的一(些)位。为了检查一个字节中的某些位，可以让这个字节和屏蔽字(<a href="https://www.baidu.com/s?wd=bit&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">bit</a> mask)进行按位与操作(C的按位与运算符为＆)——屏蔽字中与要检查的位对应的位全部为1，而其余的位(被屏蔽的位)全部为0。例如，为了检查变量flags的最低位，你可以让flags和最低位的屏蔽字进行按位与操作：flags&amp;1；<br>为了置位所需的位，可以让数据和屏蔽字进行按位或操作(C的按位或运算符为|)。例如，你可以这样置位flags的最低位：flags = flags | 1；或者这样：flags |= 1；<br>为了清除所需的位，可以让数据和对屏蔽字按位取反所得的值进行按位与操作。例如，你可以这样清除flags的最低位：flags = flags&amp; <del>1;或者这样：flags&amp;=</del>1 ;</p>
<h1 id="C-说明符与限定符"><a href="#C-说明符与限定符" class="headerlink" title="C++说明符与限定符"></a>C++说明符与限定符</h1><h2 id="说明符"><a href="#说明符" class="headerlink" title="说明符"></a><strong>说明符</strong></h2><p>\1. auto： 在C++11中不再是说明符。在C++11前，auto指出变量为自动变量，但在C++11后，auto用于自动类型推导。</p>
<p>\2. register：用于声明中指示寄存器存储，但在C++11中，它只是显示地指出变量是自动的。</p>
<p>\3. static：静态声明。用在作用域为整个文件的声明中时，表示内部链接行；用于局部声明中，表示无链接性。表示静态存储变量，只要定义过一次，便永久存储（直到程序结束），但是只能在一个函数体和代码块或者一个文件中使用。</p>
<p>\4. extern：引用声明，即声明引用其他地方定义的变量。</p>
<p>\5. thread_local：C++11新增。该变量的生命周期与其所属线程的生命周期一致。thread_local变量之于线程，犹如常规静态变量之于整个程序。</p>
<p>\6. mutable：表面变量是可更改的。即使结构（类）或变量为const类型，其成员也是可以被修改的。</p>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>\1. const：常量声明。const类型变量的连接性为内部的，即所有的文件可以声明相同的const变量。但全局变量默认是外部的。</p>
<p>\2. volatile：表面即使程序代码没有对内存单元做修改，但其值也可能发生了改变。该关键字表面不要对该变量进行优化，程序取值时会去内存中取值。</p>
<h1 id="C-四个cast的用法"><a href="#C-四个cast的用法" class="headerlink" title="C++四个cast的用法"></a>C++四个cast的用法</h1><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static_cast</td>
<td>用于良性转换，一般不会导致意外发生，风险很低。</td>
</tr>
<tr>
<td>const_cast</td>
<td>用于 const 与非 const、volatile 与非 volatile 之间的转换。</td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>借助 RTTI，用于类型安全的向下转型（Downcasting）。</td>
</tr>
</tbody></table>
<p>这四个的使用方式都一样：**T t = XXX_cast<T>(expressions)**。</T></p>
<p><strong>1，****const_cast</strong> 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。</p>
<p>下面我们以 const 为例来说明 const_cast 的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;n);</span><br><span class="line">    *p = <span class="number">234</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p = &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>n = 100<br>*p = 234</p>
<p><code>&amp;n</code>用来获取 n 的地址，它的类型为<code>const int *</code>，必须使用 const_cast 转换为<code>int *</code>类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。</p>
<p>有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的<code>#define</code>，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，第 8 行代码被修改成了下面的形式：</p>
<p>cout&lt;&lt;”n = “&lt;&lt;100&lt;&lt;endl;</p>
<p>这样以来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。</p>
<p>使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。</p>
<p><strong>2<strong><strong>，</strong></strong>static_cast</strong> 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；void <a href="http://c.biancheng.net/c/80/">指针</a>和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等；有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。<br>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。<br>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。</p>
<p>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</p>
<p>下面的代码演示了 static_cast 的正确用法和错误用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面是正确的用法</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">12.5</span>, <span class="number">23.8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line">    <span class="keyword">void</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line">    <span class="keyword">double</span> real= <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c);  <span class="comment">//调用类型转换函数</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//下面的用法是错误的</span></span><br><span class="line">    <span class="keyword">float</span> *p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">    p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3，****dynamic_cast</strong> 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。<br>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。<strong>dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</strong></p>
<p>dynamic_cast 的语法格式为：</p>
<p>dynamic_cast <newType> (expression)</newType></p>
<p>newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。</p>
<p>对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出<code>std::bad_cast</code>异常。</p>
<h2 id="1-向上转型（Upcasting）"><a href="#1-向上转型（Upcasting）" class="headerlink" title="1) 向上转型（Upcasting）"></a>1) 向上转型（Upcasting）</h2><p>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了。<br>「向上转型时不执行运行期检测」虽然提高了效率，但也留下了安全隐患，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> a = <span class="number">0</span>): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): <span class="built_in">Base</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    Derived *pd1 = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">35</span>, <span class="number">78</span>);</span><br><span class="line">    Base *pb1 = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(pd1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd1 = &quot;</span>&lt;&lt;pd1&lt;&lt;<span class="string">&quot;, pb1 = &quot;</span>&lt;&lt;pb1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb1-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;</span><br><span class="line">    pb1-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    Derived *pd2 = <span class="keyword">reinterpret_cast</span>&lt;Derived*&gt;(&amp;n);</span><br><span class="line">    Base *pb2 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(pd2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd2 = &quot;</span>&lt;&lt;pd2&lt;&lt;<span class="string">&quot;, pb2 = &quot;</span>&lt;&lt;pb2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb2-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;  <span class="comment">//输出一个垃圾值</span></span><br><span class="line">    pb2-&gt;<span class="built_in">func</span>();  <span class="comment">//内存错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况①是正确的，没有任何问题。对于情况②，pd 指向的是整型变量 n，并没有指向一个 Derived 类的对象，在使用 dynamic_cast 进行类型转换时也没有检查这一点，而是将 pd 的值直接赋给了 pb（这里并不需要调整偏移量），最终导致 pb 也指向了 n。因为 pb 指向的不是一个对象，所以<code>get_a()</code>得不到 m_a 的值（实际上得到的是一个垃圾值），<code>pb2-&gt;func()</code>也得不到 func() 函数的正确地址。</p>
<blockquote>
<p><code>pb2-&gt;func()</code>得不到 func() 的正确地址的原因在于，pb2 指向的是一个假的“对象”，它没有虚函数表，也没有虚函数表指针，而 func() 是虚函数，必须到虚函数表中才能找到它的地址。</p>
</blockquote>
<h2 id="2-向下转型（Downcasting）"><a href="#2-向下转型（Downcasting）" class="headerlink" title="2) 向下转型（Downcasting）"></a>2) 向下转型（Downcasting）</h2><p>向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。那么，哪些向下转型是安全地呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    B *pb;</span><br><span class="line">    C *pc;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> <span class="built_in">D</span>();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Downcasting failed: A* to B*<br>Downcasting failed: A* to C*<br>-————————<br>Downcasting successfully: A* to B*<br>Class D<br>Downcasting successfully: A* to C*<br>Class D</p>
<p>这段代码中类的继承顺序为：A –&gt; B –&gt; C –&gt; D。pa 是<code>A*</code>类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为<code>B*</code>或<code>C*</code>类型。当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为<code>B*</code>或<code>C*</code>类型。同样都是向下转型，为什么 pa 指向的对象不同，转换的结果就大相径庭呢？</p>
<p>在《<a href="http://c.biancheng.net/view/vip_2304.html">C++ RTTI机制下的对象内存模型（透彻）</a>》一节中，虚函数存在时对象的真实内存模型中，每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheri<a href="http://c.biancheng.net/ref/tan.html">tan</a>ce Chain），也就是如下图所示的样子：<img src="/2021/06/27/C/0.829305009718994.png" alt="img"><br>当使用 dynamic_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类)的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p>
<p>对于本例中的情况①，pa 指向 A 类对象，根据该对象找到的就是 A 的类型信息，当程序从这个节点开始向上遍历时，发现 A 的上方没有要转换的 B 类型或 C 类型（实际上 A 的上方没有任何类型了），所以就转换败了。对于情况②，pa 指向 D 类对象，根据该对象找到的就是 D 的类型信息，程序从这个节点向上遍历的过程中，发现了 C 类型和 B 类型，所以就转换成功了。</p>
<p>总起来说，dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。</p>
<p>从表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，dynamic_cast 只是让不同的基类指针指向同一个派生类对象罢了。</p>
<p><strong>4</strong>  <strong>reinterpret_cast 关键字</strong></p>
<p>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</p>
<p>reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。</p>
<p>下面的代码代码演示了 reinterpret_cast 的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将 char* 转换为 float*</span></span><br><span class="line">    <span class="keyword">char</span> str[]=<span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="keyword">float</span> *p1 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">float</span>*&gt;(str);</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将 int 转换为 int*</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//将 A* 转换为 int*</span></span><br><span class="line">    p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">25</span>, <span class="number">96</span>));</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>3.0262e+29<br>25</p>
<p>可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将<code>A*</code>转换为<code>int*</code>，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。</p>
<h1 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h1><p>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。c++中的友元为封装隐藏这堵不透明的墙开了一个小孔，外界可以通过这个小孔窥视内部的秘密。</p>
<p>友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。 </p>
<h2 id="友元函数-："><a href="#友元函数-：" class="headerlink" title="友元函数 ："></a>友元函数 ：</h2><p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> 类型 函数名(形式参数);</span><br><span class="line">友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。</span><br><span class="line">一个函数可以是多个类的友元函数，只需要在各个类中分别声明。</span><br><span class="line">友元函数的调用与一般函数的调用方式和原理一致。</span><br></pre></td></tr></table></figure>

<h2 id="友元类-："><a href="#友元类-：" class="headerlink" title="友元类 ："></a>友元类 ：</h2><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。 </p>
<p>当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下： </p>
<p>friend class 类名; </p>
<p>其中：friend和class是关键字，类名必须是程序中的一个已定义过的类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Radius</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span>;</span>               <span class="comment">//声明Circle为Radius的友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Show_r</span><span class="params">(Radius &amp;n)</span></span>;     <span class="comment">//声明Show_r为友元函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Radius</span>(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Radius</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show_r</span><span class="params">(Radius &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;圆的半径为: &quot;</span>&lt;&lt;n.r&lt;&lt;endl;    <span class="comment">//调用Radius对象的私有成员变量r</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>()    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(Radius a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s = a.r * a.r * <span class="number">3.1415926</span>;             <span class="comment">//调用Radius对象的私有成员变量r</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Radius <span class="title">objRadius</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    Circle objCircle;</span><br><span class="line">    <span class="built_in">Show_r</span>( objRadius );</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;面积为：&quot;</span>&lt;&lt;objCircle.<span class="built_in">area</span>(objRadius)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> 类型 函数名(形式参数);</span><br></pre></td></tr></table></figure>

<p>转载部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、为什么要引入友元函数：在实现类之间数据共享时，减少系统开销，提高效率</span><br><span class="line">  具体来说：为了使其他类的成员函数直接访问该类的私有变量</span><br><span class="line">  即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数</span><br><span class="line">  优点：能够提高效率，表达简单、清晰</span><br><span class="line">  缺点：友元函数破环了封装机制，尽量不使用成员函数，除非不得已的情况下才使用友元函数。</span><br></pre></td></tr></table></figure>

<h2 id="2、什么时候使用友元函数："><a href="#2、什么时候使用友元函数：" class="headerlink" title="2、什么时候使用友元函数："></a>2、什么时候使用友元函数：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)运算符重载的某些场合需要使用友元。</span><br><span class="line">2)两个类要共享数据的时候</span><br></pre></td></tr></table></figure>

<h2 id="3、怎么使用友元函数："><a href="#3、怎么使用友元函数：" class="headerlink" title="3、怎么使用友元函数："></a>3、怎么使用友元函数：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">友元函数的参数：</span><br><span class="line">   因为友元函数没有<span class="keyword">this</span>指针，则参数要有三种情况：</span><br><span class="line">   <span class="number">1</span>、  要访问非<span class="keyword">static</span>成员时，需要对象做参数；--常用(友元函数常含有参数)</span><br><span class="line">   <span class="number">2</span>、  要访问<span class="keyword">static</span>成员或全局变量时，则不需要对象做参数</span><br><span class="line">   <span class="number">3</span>、  如果做参数的对象是全局对象，则不需要对象做参数</span><br></pre></td></tr></table></figure>

<p>友元函数的位置：</p>
<p>  因为友元函数是类外的函数，所以它的声明可以放在类的私有段或公有段且没有区别。</p>
<p>友元函数的调用：</p>
<p>  可以直接调用友元函数，不需要通过对象或指针</p>
<p>友元函数的分类：</p>
<p>根据这个函数的来源不同，可以分为三种方法：</p>
<p>1、普通函数友元函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a) 目的：使普通函数能够访问类的友元</span><br><span class="line">b) 语法：声明位置：公有私有均可，常写为公有</span><br><span class="line">                 声明： <span class="keyword">friend</span> + 普通函数声明</span><br><span class="line">                 实现位置：可以在类外或类中</span><br><span class="line">                 实现代码：与普通函数相同（不加不用<span class="keyword">friend</span>和类::）</span><br><span class="line">                 调用：类似普通函数，直接调用</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INTEGER</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj)</span></span>;<span class="comment">//声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj)</span><span class="comment">//不使用friend和类：：</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INTEGER obj;</span><br><span class="line">    <span class="built_in">Print</span>(obj);<span class="comment">//直接调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类Y的所有成员函数都为类X友元函数—友元类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a）目的：使用单个声明使Y类的所有函数成为类X的友元</span><br><span class="line">       它提供一种类之间合作的一种方式，使类Y的对象可以具有类X和类Y的功能</span><br><span class="line">       具体来说：</span><br><span class="line">       前提：A是B的友元（=》A中成员函数可以访问B中有所有成员，包括私有成员和公有成员--老忘）</span><br><span class="line">       则：在A中，借助类B，可以直接使用～B . 私有变量～的形式访问私有变量</span><br><span class="line">b）语法：声明位置：公有私有均可，常写为私有(把类看成一个变量)</span><br><span class="line">       声明： <span class="keyword">friend</span> + 类名---不是对象啊</span><br><span class="line">       调用：</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">boy</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(girl &amp;)</span></span>;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span> <span class="comment">//函数disp()为类boy的成员函数，也是类girl的友元函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;boy&#x27;s name is:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;age&lt;&lt;endl;<span class="comment">//正常情况，boy的成员函数disp中直接访问boy的私有变量</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;girl&#x27;s name is:&quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;x.age&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span></span><br><span class="line">    <span class="comment">//正常情况下，只允许在girl的成员函数中访问girl的私有变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">    <span class="keyword">friend</span> boy;   <span class="comment">//声明类boy是类girl的友元 </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">girl</span>();  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    boy b; </span><br><span class="line">    girl g; </span><br><span class="line">    b.<span class="built_in">disp</span>(g);  <span class="comment">//b调用自己的成员函数，但是以g为参数，友元机制体现在函数disp中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类Y的一个成员函数为类X的友元函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a）目的：使类Y的一个成员函数成为类X的友元</span><br><span class="line">         具体而言：而在类Y的这个成员函数中，借助参数X，可以直接以X。私有变量的形式访问私有变量</span><br><span class="line">  b）语法：声明位置：声明在公有中 （本身为函数）</span><br><span class="line">         声明：<span class="keyword">friend</span> + 成员函数的声明</span><br><span class="line">         调用：先定义Y的对象y---使用y调用自己的成员函数---自己的成员函数中使用了友元机制</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">boy</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(girl &amp;)</span></span>;    </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">girl</span>(<span class="keyword">char</span> *N,<span class="keyword">int</span> A); </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;)</span></span>; <span class="comment">//声明类boy的成员函数disp()为类girl的友元函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;boy&#x27;s name is:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;age&lt;&lt;endl;  <span class="comment">//访问自己(boy)的对象成员,直接访问自己的私有变量  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;girl&#x27;s name is:&quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;x.age&lt;&lt;endl; </span><br><span class="line">    <span class="comment">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span></span><br><span class="line">    <span class="comment">//正常情况下，只允许在girl的成员函数中访问girl的私有变量 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">boy <span class="title">b</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">girl <span class="title">g</span><span class="params">()</span></span>; </span><br><span class="line">    b.<span class="built_in">disp</span>(g); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在模板类中使用友元operator&lt;&lt;(对&lt;&lt;运算符的重载)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a)使用方法：</span><br><span class="line">在模板类中声明：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br><span class="line">在模板类中定义：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VexType</span>,<span class="keyword">class</span> <span class="title">ArcType</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b)注意</span><br><span class="line">把函数声明非模板函数：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; cout,<span class="keyword">const</span> MGraph&amp; G); </span><br><span class="line">把函数声明为模板函数：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br><span class="line">或：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;VexType,ArcType&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>在函数声明中加入operator&lt;&lt; &lt;&gt;：是将operator&lt;&lt;函数定义为函数模板，将函数模板申明为类模板的友员时,是一对一绑定的 </p>
<p>实际的声明函数：这里模板参数可以省略，但是尖括号不可以省略 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;VexType,ArcType&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br></pre></td></tr></table></figure>

<p>5、友元函数和类的成员函数的区别：成员函数有this指针，而友元函数没有this指针。</p>
<p>6、记忆：A是B的友元《=》A是B的朋友《=》借助B的对象，在A中可以直接 通过B。成员变量（可以是公有，也可以为私有变量） 的方式访问B</p>
<hr>
<p>因为友元函数是类外的函数所以友元函数的声明放在了类外或则类内是没有区别的 </p>
<p>友元函数可以直接调用不需要通过对象或者指针</p>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><h2 id="一、什么是拷贝构造函数"><a href="#一、什么是拷贝构造函数" class="headerlink" title="一、什么是拷贝构造函数"></a><strong>一、什么是拷贝构造函数</strong></h2><p>  首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b=a;</span><br></pre></td></tr></table></figure>

<p> 而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。<br> 下面看一个类对象拷贝的简单例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。<br> <img src="/2021/06/27/C/0.24860487489486371.png" alt="img"><br> CExample(const CExample&amp; C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种<strong>特殊的****构造函数</strong>，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个<strong>引用变量</strong>。</p>
<h2 id="二、拷贝构造函数的调用时机"><a href="#二、拷贝构造函数的调用时机" class="headerlink" title="二、拷贝构造函数的调用时机"></a><strong>二、拷贝构造函数的调用时机</strong></h2><h3 id="1-当函数的参数为类的对象时"><a href="#1-当函数的参数为类的对象时" class="headerlink" title="1. 当函数的参数为类的对象时"></a>1. 当函数的参数为类的对象时</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">(CExample c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;g_func&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="built_in">g_fun</span>(A);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **调用g_fun()时，会产生以下几个重要步骤：<br>(1).A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。<br>(2).然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);<br>(3).等g_fun()执行完后, 析构掉 C 对象。 </p>
<p>  <img src="/2021/06/27/C/0.8089142535956775.png" alt="img">**</p>
<h3 id="2-函数的返回值是类的对象"><a href="#2-函数的返回值是类的对象" class="headerlink" title="2. 函数的返回值是类的对象"></a>2. 函数的返回值是类的对象</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">     a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">     a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">CExample <span class="title">g_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">g_fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当g_Fun()函数执行到return时，会产生以下几个重要步骤：<br>(1). 先会产生一个临时变量，就叫XXXX吧。<br>(2). 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);<br>(3). 在函数执行到最后先析构temp局部变量。<br>(4). 等g_fun()执行完后再析构掉XXXX对象。<br> <img src="/2021/06/27/C/0.4009268745368213.png" alt="img"></strong></p>
<h3 id="3-对象需要通过另外一个对象进行初始化"><a href="#3-对象需要通过另外一个对象进行初始化" class="headerlink" title="3. 对象需要通过另外一个对象进行初始化"></a>3. 对象需要通过另外一个对象进行初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CExample A(100); CExample B=A;</span><br></pre></td></tr></table></figure>



<h2 id="三、浅拷贝与深拷贝"><a href="#三、浅拷贝与深拷贝" class="headerlink" title="三、浅拷贝与深拷贝"></a>三、浅拷贝与深拷贝</h2><h3 id="1-默认拷贝构造函数"><a href="#1-默认拷贝构造函数" class="headerlink" title="1. 默认拷贝构造函数"></a>1. 默认拷贝构造函数</h3><p>  很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rect::<span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r) </span><br><span class="line">&#123;    </span><br><span class="line">width=r.width;    </span><br><span class="line">height=r.height; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了，让我们来考虑以下一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Rect::count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码对前面的类，加入了一个静态成员，目的是进行计数。</p>
<p>在主函数中，首先创建对象rect1，输出此时的对象个数，然后使用rect1复制出对象rect2，再输出此时的对象个数，按照理解，此时应该有两个对象存在，但实际程序运行时，输出的都是1，反应出只有1个对象。</p>
<p>此外，在销毁对象时，由于会调用销毁两个对象，类的析构函数会调用两次，此时的计数器将变为负数。</p>
<p>说白了，就是拷贝构造函数没有处理静态数据成员。出现这些问题最根本就在于在复制对象时，计数器没有递增，我们重新编写拷贝构造函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">        width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Rect::count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2. 浅拷贝"></a><strong>2. 浅拷贝</strong></h3><p>  所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了，让我们考虑如下一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码运行结束之前，会出现一个运行错误。原因就在于在进行对象复制时，对于动态分配的内容没有进行正确的操作。我们来分析一下：</p>
<p>  在运行定义rect1对象后，由于在构造函数中有一个动态分配的语句，因此执行后的内存情况大致如下：</p>
<p>   <img src="/2021/06/27/C/0.737730505979939.png" alt="img"><br> 在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间，如下图所示：<br>  <img src="/2021/06/27/C/0.6941223025580505.png" alt="img"></p>
<p> 当然，这不是我们所期望的结果，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。</p>
<h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3. 深拷贝"></a><strong>3. 深拷贝</strong></h3><p> 在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间，如上面的例子就应该按照如下的方式进行处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">     width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">        *p=*(r.p);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，在完成对象的复制后，内存的一个大致情况如下：<br>  <img src="/2021/06/27/C/0.41521417522049453.png" alt="img"><br>此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。</p>
<h3 id="3-防止默认拷贝发生"><a href="#3-防止默认拷贝发生" class="headerlink" title="3. 防止默认拷贝发生"></a><strong>3. 防止默认拷贝发生</strong></h3><p>  通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——<strong>声明一个私有拷贝构造函数</strong>。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防止按值传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b) </span><br><span class="line">    &#123; </span><br><span class="line">        a = b; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;creat: &quot;</span>&lt;&lt;a&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//拷贝构造函数，只是声明</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample&amp; C); </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~<span class="built_in">CExample</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;delete: &quot;</span>&lt;&lt;a&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//???? </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;test&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">    <span class="comment">//g_Fun(test);   //按值传递将出错</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>  拷贝有两种：深拷贝，浅拷贝。</p>
<p>   当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但<strong>当数据成员中有指针时</strong>，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。</p>
<p>   深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。<strong>简而言之，当数据成员中有指针时，必须要用深拷贝</strong>。</p>
<h2 id="四、拷贝构造函数的几个细节"><a href="#四、拷贝构造函数的几个细节" class="headerlink" title="四、拷贝构造函数的几个细节"></a>四、拷贝构造函数的几个细节</h2><h3 id="1-为什么拷贝构造函数必须是引用传递，不能是值传递？"><a href="#1-为什么拷贝构造函数必须是引用传递，不能是值传递？" class="headerlink" title="1.为什么拷贝构造函数必须是引用传递，不能是值传递？"></a>1.为什么拷贝构造函数必须是引用传递，不能是值传递？</h3><p>   简单的回答是为了防止递归引用。<br>     具体一些可以这么讲：<br>     当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。</p>
<h3 id="2-拷贝构造函数的作用。"><a href="#2-拷贝构造函数的作用。" class="headerlink" title="2. 拷贝构造函数的作用。"></a><strong>2. 拷贝构造函数的作用。</strong></h3><p>​      作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</p>
<h3 id="3-参数传递过程到底发生了什么？"><a href="#3-参数传递过程到底发生了什么？" class="headerlink" title="3.参数传递过程到底发生了什么？"></a>3.参数传递过程到底发生了什么？</h3><p>​    将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！<br>   i)值传递:<br>​     对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；<br>​     对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用<br>   ii)引用传递:<br>​    无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).</p>
<h3 id="4-在类中有指针数据成员时，拷贝构造函数的使用？"><a href="#4-在类中有指针数据成员时，拷贝构造函数的使用？" class="headerlink" title="4. 在类中有指针数据成员时，拷贝构造函数的使用？"></a>4. 在类中有指针数据成员时，拷贝构造函数的使用？</h3><p>如果不显式声明拷贝构造函数的时候，编译器也会生成一个默认的拷贝构造函数，而且在一般的情况下运行的也很好。但是在遇到类有指针数据成员时就出现问题 了：因为默认的拷贝构造函数是按成员拷贝构造，这导致了两个不同的指针(如ptr1=ptr2)指向了相同的内存。当一个实例销毁时，调用析构函数 free(ptr1)释放了这段内存，那么剩下的一个实例的指针ptr2就无效了，在被销毁的时候free(ptr2)就会出现错误了, 这相当于重复释放一块内存两次。这种情况必须显式声明并实现自己的拷贝构造函数，来为新的实例的指针分配新的内存。</p>
<p>问题1和2回答了为什么拷贝构造函数使用值传递会产生无限递归调用的问题；<br>问题3回答了在类中有指针数据成员时，拷贝构造函数使用值传递等于显式定义了拷贝构造函数，因为默认的拷贝构造函数就是这么干的。</p>
<h3 id="5-拷贝构造函数里能调用private成员变量吗"><a href="#5-拷贝构造函数里能调用private成员变量吗" class="headerlink" title="5. 拷贝构造函数里能调用private成员变量吗?"></a>5. 拷贝构造函数里能调用private成员变量吗?</h3><p>解答：<strong>这个问题是在网上见的，当时一下子有点晕。其时从名子我们就知道拷贝构造函数其时就是一个特殊的</strong>构造函数**，操作的还是自己类的成员变量，所以不受private的限制。</p>
<h3 id="6-以下函数哪个是拷贝构造函数-为什么"><a href="#6-以下函数哪个是拷贝构造函数-为什么" class="headerlink" title="6. 以下函数哪个是拷贝构造函数,为什么?"></a>6. 以下函数哪个是拷贝构造函数,为什么?</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X::X(const X&amp;);   //拷贝构造函数</span><br><span class="line">X::X(X); </span><br><span class="line">X::X(X&amp;, int a=1);   //拷贝构造函数</span><br><span class="line">X::X(X&amp;, int a=1, int b=2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<p>  **<em>*解答：*<em>对于一个类X, 如果一个构造函数的第一个参数是下列之一:<br>  a) X&amp;<br>  b) const X&amp;<br>  c) volatile X&amp;<br>  d) const volatile X&amp;<br>  且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.</em></em></p>
<h3 id="7-一个类中可以存在多于一个的拷贝构造函数吗"><a href="#7-一个类中可以存在多于一个的拷贝构造函数吗" class="headerlink" title="7. 一个类中可以存在多于一个的拷贝构造函数吗?"></a>7. 一个类中可以存在多于一个的拷贝构造函数吗?</h3><p>  解答：**类中可以存在超过一个拷贝构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class X &#123; </span><br><span class="line">public: </span><br><span class="line">  X(const X&amp;); // const 的拷贝构造 </span><br><span class="line">  X(X&amp;); // 非const的拷贝构造 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  注意,如果一个类中只存在一个参数为 X&amp; 的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.<br> 如果一个类中没有定义拷贝构造函数,那么编译器会自动产生一个默认的拷贝构造函数。<br> 这个默认的参数可能为 X::X(const X&amp;)或 X::X(X&amp;),由编译器根据上下文决定选择哪一个。</p>
<p>来源： <a href="https://www.cnblogs.com/alantu2018/p/8459250.html">https://www.cnblogs.com/alantu2018/p/8459250.html</a></p>
<h1 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;拷贝构造\n&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = a.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = a.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;赋值构造\n&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = a.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">int</span> t) &#123;</span><br><span class="line">        x = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">0</span>);</span><br><span class="line">        y = t;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;address: %x, point: %x, value: %d\n&quot;</span>, <span class="keyword">this</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;delete %x\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ret</span> <span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;stack address: %x, point: %x, value: %d\n&quot;</span>, &amp;ret, ret.x, ret.y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.对象以值传递方式从函数返回，且接受返回值的对象已经初始化过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A c;</span><br><span class="line">    c = <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;global address: %x, point: %x, value: %d\n&quot;</span>, &amp;c, c.x, c.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/4ce1da14-4554-44cb-a0be-a56eefe7309a.png" alt="img"></p>
<p>2.对象直接赋值给另一个对象，且接受值的对象已经初始化过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    A c;</span><br><span class="line">    c = a;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;global address: %x, point: %x, value: %d\n&quot;</span>, &amp;c, c.x, c.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/4f4fa877-8c19-42e6-86c9-698319f2197e.png" alt="img"></p>
<p>总结</p>
<p>对象以值传递方式从函数返回时，若接受返回值的对象已经初始化过，则会调用赋值构造函数，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值构造函数，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。</p>
<h1 id="stdcall、-cdcel和-fastcall三者的区别"><a href="#stdcall、-cdcel和-fastcall三者的区别" class="headerlink" title="_stdcall、__cdcel和__fastcall三者的区别"></a>_stdcall、__cdcel和__fastcall三者的区别</h1><blockquote>
<p>__stdcall、__cdecl和__fastcall是三种<mark class="hl-label blue">函数调用协议</mark>  ，函数调用协议会影响函数参数的入栈方式、栈内数据的清除方式、编译器函数名的修饰规则等。 </p>
</blockquote>
<ol>
<li>调用协议常用场合</li>
<li><ol>
<li>__stdcall：Windows API默认的函数调用协议。</li>
<li>__cdecl：C/C++默认的函数调用协议。</li>
<li>__fastcall：适用于对性能要求较高的场合。</li>
</ol>
</li>
<li>函数参数入栈方式</li>
<li><ol>
<li>__stdcall：函数参数由右向左入栈。</li>
<li>__cdecl：函数参数由右向左入栈。</li>
<li>__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。</li>
<li>问题一：__fastcall在寄存器中放入不大于4字节的参数，故性能较高，适用于需要高性能的场合。</li>
</ol>
</li>
<li>栈内数据清除方式</li>
<li><ol>
<li>__stdcall：函数调用结束后由被调用函数清除栈内数据。</li>
<li>__cdecl：函数调用结束后由函数调用者清除栈内数据。</li>
<li>__fastcall：函数调用结束后由被调用函数清除栈内数据。</li>
<li>问题一：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。</li>
<li>问题二：某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。</li>
<li>问题三：由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。</li>
</ol>
</li>
<li>C语言编译器函数名称修饰规则</li>
<li><ol>
<li>__stdcall：编译后，函数名被修饰为“_functionname@number”。</li>
<li>__cdecl：编译后，函数名被修饰为“_functionname”。</li>
<li>__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。</li>
<li>注：“functionname”为函数名，“number”为参数字节数。</li>
<li>注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。</li>
</ol>
</li>
<li>C++语言编译器函数名称修饰规则</li>
<li><ol>
<li>__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。</li>
<li>__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。</li>
<li>__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。</li>
<li>注：“******”为函数返回值类型和参数类型表。</li>
<li>注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。</li>
<li>C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。</li>
</ol>
</li>
</ol>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><p>赋值操作是在两个已经存在的对象间进行的，而<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>是要创建一个新的对象（可以用构造），并且其初值来源于另一个已存在的对象。<br>int a=12 ; //<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>, copy 0X000C to a<br>a =12 ; //赋值, copy 0X000C to a</p>
<p>1、<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态变量</a>在定义时未显式地指定初值，则自动<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>为相应类型的零值（数e799bee5baa6e79fa5e98193e78988e69d8331333361323562值型为0或0.0；字符型为’\0’），即<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态变量</a>能够自动初始化（有称之为隐式初始化），且<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态变量</a>只初始化一次。静态变量定义时显式地指定了值，则其初值为指定的值。定义时无论是否显式地指定了初始值，都只能被初始化一次。但可以通过赋值的方式多次修改静态变量的值。</p>
<p>2、初始化与赋值是不同的概念。</p>
<p>静态变量的初始化是在编译时进行，变量的赋值是在函数或程序运行时进行。静态变量只初始化一次，但可以通过赋值的方式多次修改静态变量的值。</p>
<h1 id="C-中new一个类的指针，有何没有括号有什么区别"><a href="#C-中new一个类的指针，有何没有括号有什么区别" class="headerlink" title="C++中new一个类的指针，有何没有括号有什么区别"></a>C++中new一个类的指针，有何没有括号有什么区别</h1><h2 id="一、-中括号的情况。"><a href="#一、-中括号的情况。" class="headerlink" title="一、 中括号的情况。"></a>一、 中括号的情况。</h2><p>中括号是用来标示申请的是一个对象，还是一组对象。<br>1 没有中括号时，即ptest = new test; 这时ptest得到的是一个对象*ptest， 释放时使用delete ptest;<br>2 带有中括号时，在中括号中需要有一个正整数参数。<br>ptest = new test[N];<br>N可以是变量，也可以是常量。<br>这时申请到的ptest指向的空间是N个连续的对象ptest[0],ptest[1]…ptest[N-1]，即可以当做一个数组使用。<br>释放时需要调用delete [] ptest;</p>
<h2 id="二、小括号的情况。"><a href="#二、小括号的情况。" class="headerlink" title="二、小括号的情况。"></a>二、小括号的情况。</h2><p>小括号是用来指定初始化参数，用于类指针时，就是指定调用哪个构造函数。</p>
<h3 id="1-有小括号时，小括号中可以有若干参数，也可以没有参数。"><a href="#1-有小括号时，小括号中可以有若干参数，也可以没有参数。" class="headerlink" title="1 有小括号时，小括号中可以有若干参数，也可以没有参数。"></a>1 有小括号时，小括号中可以有若干参数，也可以没有参数。</h3><p>比如<br>ptest = new test();  这样在构造时就会调用无参构造test();<br>ptest = new test(1); 就会调用构造函数test(int)，即一个整型参数的构造函数。</p>
<h3 id="2-没有小括号时，默认调用无参构造。"><a href="#2-没有小括号时，默认调用无参构造。" class="headerlink" title="2 没有小括号时，默认调用无参构造。"></a>2 没有小括号时，默认调用无参构造。</h3><p>即<br>ptest = new test;<br>和ptest = new test();是一样的。</p>
<h1 id="浮点数存储"><a href="#浮点数存储" class="headerlink" title="浮点数存储"></a>浮点数存储</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 浮点数存储</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 1.浮点数如何存储：符号位 指数位 尾数位</span></span><br><span class="line"><span class="comment">	 2.如何将十进制浮点数转换成二进制</span></span><br><span class="line"><span class="comment">	 3.将二进制浮点数存储在一组字节中</span></span><br><span class="line"><span class="comment">	 4.如何将浮点数以二进制输出</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//《2》.将十进制整数转换为二进制</span></span><br><span class="line">	<span class="function">bitset&lt;16&gt; <span class="title">myset</span><span class="params">(<span class="number">443</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; myset &lt;&lt; endl;<span class="comment">//0000000110111011</span></span><br><span class="line">	<span class="comment">/*将十进制浮点数转换为二进制</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	以20.5和20.3为例</span></span><br><span class="line"><span class="comment">	浮点数转二进制，先转整数部分(除2)，再转小数部分(乘2)；</span></span><br><span class="line"><span class="comment">	20.5-&gt;20 and 0.5</span></span><br><span class="line"><span class="comment">	20  -&gt; 10100   note:16+4,16-&gt;10000,4-&gt;100</span></span><br><span class="line"><span class="comment">	0.5 -&gt; 0.5*2=1.0 取整数部分1，用结果减去整数部分1=0</span></span><br><span class="line"><span class="comment">		   0  *2=0   取整数部分0，用结果减去整数部分0=0</span></span><br><span class="line"><span class="comment">		   0  *2=0   取整数部分0，用结果减去整数部分0=0</span></span><br><span class="line"><span class="comment">		   ————————————————————</span></span><br><span class="line"><span class="comment">		   0.5-&gt;0.1</span></span><br><span class="line"><span class="comment">	20.5-&gt;10100.1(二进制)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	20.3-&gt;20 and 0.3</span></span><br><span class="line"><span class="comment">	20  -&gt; 10100   note:16+4,16-&gt;10000,4-&gt;100</span></span><br><span class="line"><span class="comment">	0.3 -&gt; 0.3*2=0.6 取整数部分0，用结果减去整数部分0=0.6</span></span><br><span class="line"><span class="comment">	       0.6*2=1.2 取整数部分1，用结果减去整数部分1=0.2</span></span><br><span class="line"><span class="comment">		   0.2*2=0.4 取整数部分0，用结果减去整数部分0=0.4</span></span><br><span class="line"><span class="comment">		   0.4*2=0.8 取整数部分0，用结果减去整数部分0=0.8</span></span><br><span class="line"><span class="comment">		   0.8*2=1.6 取整数部分1，用结果减去整数部分1=0.6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		   0.6*2=1.2 取整数部分1，用结果减去整数部分1=0.2</span></span><br><span class="line"><span class="comment">		   0.2*2=0.4 取整数部分0，用结果减去整数部分0=0.4</span></span><br><span class="line"><span class="comment">		   0.4*2=0.8 取整数部分0，用结果减去整数部分0=0.8</span></span><br><span class="line"><span class="comment">		   0.8*2=1.6 取整数部分1，用结果减去整数部分1=0.6</span></span><br><span class="line"><span class="comment">		   ...无限循环...</span></span><br><span class="line"><span class="comment">		   ————————————————————</span></span><br><span class="line"><span class="comment">		   0.3-&gt;0.010011001...1001</span></span><br><span class="line"><span class="comment">	20.3-&gt;10100.010011001...1001(二进制)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*《3》.将二进制浮点数存储在一组字节中，如float存入4个字节，double存入8个字节</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	20.5-&gt;10100.1-&gt;1.01001E100 (2^4) E表示2的n次方，不是10的n次方了</span></span><br><span class="line"><span class="comment">	存储方式（float）:0-10000011-01001000000000000000000</span></span><br><span class="line"><span class="comment">	移位存储指数位：float 127 double 1023  + 指实际计算的100才是存储的指数位</span></span><br><span class="line"><span class="comment">					127-&gt;01111111   1023-&gt;01111111111</span></span><br><span class="line"><span class="comment">					所以在这的指数位应该是：01111111+100=10000011</span></span><br><span class="line"><span class="comment">					在使用的时候，指数位会减去127，变成实际需要的100(2^4)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	20.3-&gt;10100.010011001...1001-&gt;1.0100010011001...E100</span></span><br><span class="line"><span class="comment">	存储方式（float）:0-10000011-01000100110011001100110</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	float 20.5 == double 20.5 但是 float 20.3 != double 20.3?</span></span><br><span class="line"><span class="comment">	20.5-&gt;10100.1-&gt;1.01001E100 (2^4) </span></span><br><span class="line"><span class="comment">	存储方式（double）:0-10000000011-01001000000000000000000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	20.3-&gt;10100.010011001...1001-&gt;1.0100010011001...E100</span></span><br><span class="line"><span class="comment">	存储方式（double）:0-10000000011-010001001100110011001...1001...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	所以float 20.5==double 20.5 但是 float 20.3 == double 20.3，为什么？</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	在比较的时候对应部分比较，相同的数，不同类型，如float 20.5==double 20.5，</span></span><br><span class="line"><span class="comment">	符号位相同，指数位转换成</span></span><br><span class="line"><span class="comment">	float：00000100</span></span><br><span class="line"><span class="comment">	double：000000000100</span></span><br><span class="line"><span class="comment">	比较的时候前面补0，所以指数位也一样，而尾数位01001后面都是0，不管多少位结果都一样，</span></span><br><span class="line"><span class="comment">	所以float 20.5 == double 20.5 </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	而20.3呢，符号位和指数位相等，但是尾数位不同，一个是010001001一共23位，后面补0，</span></span><br><span class="line"><span class="comment">	而double是010001001一共52位，两者不同，所以float 20.3 != double 20.3</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	double强转float：</span></span><br><span class="line"><span class="comment">	0-10000000011-010001001100110011001...1001...</span></span><br><span class="line"><span class="comment">	0-10000011-01000100110011001100110</span></span><br><span class="line"><span class="comment">	会将指数位先还原成100，再+127，尾数位直接截断</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*《4》 如何将浮点数以二进制输出</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">float</span> v1 = <span class="number">20.5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *n = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(&amp;v1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float 20.5:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*n &gt;&gt; i &amp; <span class="number">1</span>)&lt;&lt;(i==<span class="number">31</span>|| i==<span class="number">23</span> ?<span class="string">&quot;-&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> v2 = <span class="number">20.3</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *m = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(&amp;v2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float 20.3:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*m &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (i == <span class="number">31</span> || i == <span class="number">23</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> v3 = <span class="number">20.5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *k = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *)(&amp;v3);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double 20.5:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*k &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (i == <span class="number">52</span> || i == <span class="number">63</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> v4 = <span class="number">20.3</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *p= (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *)(&amp;v4);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double 20.3:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*p &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (i == <span class="number">52</span> || i == <span class="number">63</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 1 </span></span></span><br></pre></td></tr></table></figure>

<h1 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 0 宽字符</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;C++ 宽字符&quot; &lt;&lt; endl;</span><br><span class="line">	/*</span><br><span class="line">	以前的宽字符：</span><br><span class="line">		wchar_t L</span><br><span class="line">	C++11;</span><br><span class="line">		char16_t u</span><br><span class="line">		char32_t U</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	char c = &#x27;a&#x27;;</span><br><span class="line">	wchar_t c1 = L&#x27;a&#x27;;</span><br><span class="line">	char16_t c2 = u&#x27;a&#x27;;</span><br><span class="line">	char32_t c3 = U&#x27;a&#x27;;</span><br><span class="line">	cout &lt;&lt; &quot;char size = &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;wchar_t size = &quot; &lt;&lt; sizeof(c1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;char16_t size = &quot; &lt;&lt; sizeof(c2) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;char32_t size = &quot; &lt;&lt; sizeof(c3) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;//输出a</span><br><span class="line">	cout &lt;&lt; (int)c &lt;&lt; endl;//输出97，ascii码</span><br><span class="line">	wcout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	char16_t cc = u&#x27;中&#x27;;</span><br><span class="line">	cout &lt;&lt; cc &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;\u4e2d&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	//不能输出中文</span><br><span class="line">	wcout &lt;&lt; cc &lt;&lt; endl;//十进制20013，转为二进制是4e2d</span><br><span class="line">	//wcout &lt;&lt; (wchar_t)cc &lt;&lt; endl;//不会输出</span><br><span class="line">	wcout &lt;&lt; c2 &lt;&lt; endl;//输出97，ascii码</span><br><span class="line">	wcout &lt;&lt; (wchar_t)c2 &lt;&lt; endl;//输出a</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;中各个&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif // 0</span><br></pre></td></tr></table></figure>

<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 0 初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;C++ 初始化&quot; &lt;&lt; endl;</span><br><span class="line">	//C++98 </span><br><span class="line">	float fl(30.5);</span><br><span class="line">	//fl(11.2);不允许</span><br><span class="line">	int i_a = &#123; 1 &#125;;</span><br><span class="line">	cout &lt;&lt; &quot;i_a = &quot; &lt;&lt; i_a &lt;&lt; endl;</span><br><span class="line">	i_a = &#123; 3 &#125;;//允许</span><br><span class="line">	cout &lt;&lt; &quot;i_a = &quot; &lt;&lt; i_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	//C++ 11</span><br><span class="line">	int i_b&#123; 20 &#125;;</span><br><span class="line">	cout &lt;&lt; &quot;i_b = &quot; &lt;&lt; i_b &lt;&lt; endl;</span><br><span class="line">	int i_c&#123;&#125;;//默认值</span><br><span class="line">	cout &lt;&lt; &quot;i_c = &quot; &lt;&lt; i_c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif // 1 </span><br></pre></td></tr></table></figure>

<h1 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#if 0 自动类型转换</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	将一个值赋给某一类型的变量时</span><br><span class="line">	表达式中有多种类型，会自动类型转换为取值范围最大的类型</span><br><span class="line">	当传递参数值到函数或者方法中时</span><br><span class="line">	*/</span><br><span class="line">	short s_v = 20;</span><br><span class="line">	int i_v = 20.3;</span><br><span class="line"></span><br><span class="line">	//传统C语言强制类型转换</span><br><span class="line">	// C++中的强制类型转换</span><br><span class="line">	// 强制类型转换操作符static_cast&lt;typeName&gt;(Var)</span><br><span class="line">	int x = 11;</span><br><span class="line">	char c&#123; (char)x &#125;;//传统C语言强制类型转换</span><br><span class="line">	int y = 98;</span><br><span class="line">	char c1&#123; char(y) &#125;;	// C++中的强制类型转换</span><br><span class="line">	char z = static_cast&lt;char&gt;(x);	// 强制类型转换操作符static_cast&lt;typeName&gt;(Var)</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif // 1 </span><br></pre></td></tr></table></figure>

<h1 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h1><p>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，</p>
<p>但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，</p>
<p>如外部变量。</p>
<h1 id="sizeof-和-strlen-的区别"><a href="#sizeof-和-strlen-的区别" class="headerlink" title="sizeof 和 strlen 的区别"></a>sizeof 和 strlen 的区别</h1><p>sizeof 和 strlen 有以下区别：</p>
<p>1 sizeof 是一个操作符，strlen 是库函数。</p>
<p>2 sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。</p>
<p>3 编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。</p>
<p>4 数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。</p>
<h1 id="typdef和define区别"><a href="#typdef和define区别" class="headerlink" title="typdef和define区别"></a>typdef和define区别</h1><p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<p>typedef (int*) pINT;</p>
<p>#define pINT2 int*</p>
<p>效果相同？实则不同！实践中见差别：pINT a,b;的效果同int *a; int *b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。</p>
<h1 id="malloc-和-new-有以下不同："><a href="#malloc-和-new-有以下不同：" class="headerlink" title="malloc 和 new 有以下不同："></a>malloc 和 new 有以下不同：</h1><p>（1）  new、delete 是操作符，可以重载，只能在 C++中使用。</p>
<p>（2）  malloc对开辟的空间大小严格指定，而new只需要对象名</p>
<p>（2） malloc、free 是函数，可以覆盖，C、C++中都可以使用。</p>
<p>（3） new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。</p>
<p>（4） malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数</p>
<p>（5） new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。</p>
<p>malloc/free是库函数，new/delete是C++运算符。对于非内部数据类型而言，光用malloc/free无法满足动态对象都要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。</p>
<h1 id="引用作为函数参数以及返回值的好处"><a href="#引用作为函数参数以及返回值的好处" class="headerlink" title="引用作为函数参数以及返回值的好处"></a>引用作为函数参数以及返回值的好处</h1><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）</p>
<h2 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h2><p>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，</p>
<p>不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</p>
<h2 id="指针传递："><a href="#指针传递：" class="headerlink" title="指针传递："></a>指针传递：</h2><p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</p>
<h2 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h2><p>形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。什么是</p>
<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。</p>
<p>成因：</p>
<p>1）指针变量没有被初始化</p>
<p>2）指针指向的内存被释放了，但是指针没有置NULL</p>
<p>3）指针超过了变量了的作用范围，比如b[10]，指针b+11</p>
<h1 id="C-的空类有哪些成员函数"><a href="#C-的空类有哪些成员函数" class="headerlink" title="C++的空类有哪些成员函数"></a>C++的空类有哪些成员函数</h1><p> 缺省构造函数。</p>
<p> 缺省拷贝构造函数。</p>
<p> 缺省析构函数。</p>
<p> 缺省赋值运算符。</p>
<h1 id="拷贝构造函数和赋值运算符的认识"><a href="#拷贝构造函数和赋值运算符的认识" class="headerlink" title="拷贝构造函数和赋值运算符的认识"></a>拷贝构造函数和赋值运算符的认识</h1><p>拷贝构造函数和赋值运算符重载有以下两个不同之处：</p>
<p>（1） 拷贝构造函数生成新的类对象，而赋值运算符不能。</p>
<p>（2） 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉</p>
<p>注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</p>
<p>在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但如果用户将拷贝构造函数和赋值运算符定义成私有的（private），则用户不能使用拷贝构造和对象赋值。可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。</p>
<p><strong>注意：拷贝构造函数必须以引用的方式传递参数。这是因为以值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参（创建副本临时变量）。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。</strong></p>
<h1 id="C-中指针和引用的区别"><a href="#C-中指针和引用的区别" class="headerlink" title="C++中指针和引用的区别"></a>C++中指针和引用的区别</h1><p>1、引用概念上是定义一个变量的别名，而指针是存储一个变量的地址。</p>
<p>2、引用在定义时必须要初始化，但是指针没有要求。</p>
<p>3、引用在初始化时引用一个实体后，就不能再引用其他实体，因为其本质是一个指针常量，无法改变指向。而指针可以在任何时候指向任何一个同类型实体。</p>
<p>4、没有NULL引用，但有NULL指针。</p>
<p>5、在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是空地址空间所占字节个数（32位平台下占用4个字节，64位占用8字节）。</p>
<p>6、引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。</p>
<p>7、有多级指针，但是没有多级引用。</p>
<p>8、访问实体方式不同，指针需要显示解引用，引用则由编译器自己处理。</p>
<p>9、引用比指针使用起来相对安全。</p>
<h1 id="结构体struct和共同体union（联合）的区别"><a href="#结构体struct和共同体union（联合）的区别" class="headerlink" title="结构体struct和共同体union（联合）的区别"></a>结构体struct和共同体union（联合）的区别</h1><p>结构体：将不同类型的数据组合成一个整体，是自定义类型</p>
<p>共同体：不同类型的几个变量共同占用一段内存</p>
<p>1）结构体中的每个成员都有自己独立的地址，它们是同时存在的；</p>
<p>共同体中的所有成员占用同一段内存，它们不能同时存在；</p>
<p>2）sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度、</p>
<h1 id="结构体为什么要内存对齐呢？"><a href="#结构体为什么要内存对齐呢？" class="headerlink" title="结构体为什么要内存对齐呢？"></a>结构体为什么要内存对齐呢？</h1><p>1.平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p>
<p>2.硬件原因：</p>
<p>因为大多数处理器并不是按照字节块来存取内存，而是2个字节，4个字节，甚至更多的字节为单位来存取内存</p>
<p>如果没有内存对齐机制，假如有一个int类型的变量存放在地址为1的连续4个字节地址中。当处理器去取数据时，它会先从0地址开始读取4个字节，然后剔除不想要的字节，再从4地址开始，读取4个字节，再剔除不想要的字节，最后再将剩余数据合并</p>
<p>总结：所以内存对齐后可以增加我们访问数据时的效率</p>
<p>在window下：#pragma pack（8）</p>
<p>在linux下：#pragma pack（4）</p>
<h1 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h1><p>1）#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域</p>
<p>2）处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。</p>
<p>3）#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址</p>
<p>4）#define可以定义简单的函数，const不可以定义函数</p>
<p>const修饰类的成员变量，表示常量不可能被修改</p>
<p>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</p>
<p>const函数只能调用const函数，非const函数可以调用const函数</p>
<h1 id="重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"><a href="#重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别" class="headerlink" title="重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"></a>重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别</h1><p>1）overload，将语义相近的几个函数用同一个名字表示，但是参数列表（参数的类型，个数，顺序不同）不同，这就是函数重载，返回值类型可以不同</p>
<p>特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无</p>
<p>2）override，派生类覆盖基类的虚函数，实现接口的重用，返回值类型必须相同</p>
<p>特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）</p>
<p>3）overwrite，派生类屏蔽了其同名的基类函数，返回值类型可以不同</p>
<p>特征：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字</p>
<h1 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h1><p>虚函数：虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数,是C++中多态性的一个重要体现。利用基类指针访问派生类中的虚函数，这种情况下采用的是动态绑定技术。</p>
<p>纯虚函数：纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”.纯虚函数不能实例化对象。</p>
<h2 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h2><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p>（1）抽象类的定义： 称带有纯虚函数的类为抽象类。</p>
<p>（2）抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>（3）使用抽象类时注意：</p>
<p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>抽象类是不能定义对象的。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p>
<p>2、虚函数声明如下：virtual ReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错</p>
<p>3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</p>
<p>4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</p>
<p>5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。</p>
<p>6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p>
<h2 id="纯虚函数的引入，是出于两个目的："><a href="#纯虚函数的引入，是出于两个目的：" class="headerlink" title="纯虚函数的引入，是出于两个目的："></a>纯虚函数的引入，是出于两个目的：</h2><p>1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。</p>
<p>2、为了效率，不是程序执行的效率，而是为了编码的效率。</p>
<p>动态绑定：基类指针是调用派生类的中的成员函数还是调用基类中的成员函数要到程序运行时确定。主要看此时基类指针所指向的对象。这里要涉及一些很重要的概念:静态类型和动态类型，静态绑定和动态绑定。静态绑定和动态绑定。静态绑定是说前期绑定。 所谓对象的静态类型，就是它在程序中被声明的时候采用的类型。 考虑下面的class继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color = Red)</span> <span class="keyword">const</span></span>=<span class="number">0</span>; </span><br><span class="line">...</span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color = Red)</span> <span class="keyword">const</span></span>; </span><br><span class="line">...</span><br><span class="line">... </span><br><span class="line">&#125;；</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape </span><br><span class="line">&#123; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color = Red)</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">现在考虑以下这些指针：</span><br><span class="line">Shape* ps;<span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape*pc =<span class="keyword">new</span> Circle;<span class="comment">//静态类型Shape*</span></span><br><span class="line">Shape*pr = <span class="keyword">new</span> Rectangle;<span class="comment">//静态类型Shape*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在本例中，ps,pc,pr都被声明为Shape<em>类型的，所以它们的静态类型都是Shape</em>。注意：无论它们真正指向什么，它们的静态类型都是Shape*. 所谓的对象的动态类型是指“当前所指对象的类型”。也就是说，动态类型可以表现出一个对象将会有什么行为。根据上面的例子，pc的动态类型是Circle<em>，pr的动态类型是Rectangle</em>。ps没有动态类型，因为它没有指向任何对象。 动态类型一如其名所示，可以在执行过程中改变（通常是经过赋值运算）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps=pc; \\ps的动态类型如今是Circle*</span><br><span class="line">ps=pr; \\ps的动态类型如今是Rectangle*</span><br></pre></td></tr></table></figure>

<p>Virtual函数系动态绑定而来，意思是调用一个virtual函数的时候，究竟调用的是哪一个函数代码，取决于发出调用的那个对象的动态类型。</p>
<p>ps-&gt;draw(); \调用的是Rectangle::draw(Red)</p>
<h1 id="一-多态"><a href="#一-多态" class="headerlink" title="一 . 多态"></a>一 . 多态</h1><p><a href="https://blog.csdn.net/weixin_57023347/article/details/119978550">https://blog.csdn.net/weixin_57023347/article/details/119978550</a></p>
<p>多态的概念</p>
<h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>多态就是当要完成某个行为，当不同的对象去完成时会产生不同的效果。或者是说，不同的对象处理某一件事有不同的方法。</p>
<p>比如：在火车站买票，普通成年人，需要全价买票，学生可以半价买票，军人可以优先买票。</p>
<h2 id="1-2-多态的构成条件"><a href="#1-2-多态的构成条件" class="headerlink" title="1.2 多态的构成条件"></a>1.2 多态的构成条件</h2><p>多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。</p>
<p>条件：</p>
<blockquote>
<p>l 被调用的函数必须是虚函数，并且派生类必须对基类的虚函数进行重写。</p>
<p>l 必须通过基类的指针或者引用调用虚函数</p>
</blockquote>
<p>第一点注意点是：调用的函数只能是虚函数，并且派生类必须对基类的虚函数进行重写。如果不重写，只是继承，实现方法一样。如果基类的不是虚函数，重写函数只是构成隐藏。</p>
<p>第二个注意点就是：必须通过基类的指针或者引用调用虚函数。</p>
<blockquote>
<p><strong>l 满足多态：跟对象的类型无关，跟指向的对象有关，指向哪个对象调用就是它的虚函数。</strong></p>
<p><strong>l 不满足多态：跟调用对象的类型有关，类型是什么就调用谁的虚函数。</strong></p>
</blockquote>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173312206.png" alt="image-20230129173312206"></p>
<p>如果不满足多态条件：</p>
<p>1.不重写虚函数</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173319541.png" alt="image-20230129173319541"></p>
<p>2.不是虚函数，重写</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173326160.png" alt="image-20230129173326160"></p>
<p>3.不用指针或者引用调用</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173353074.png" alt="image-20230129173353074"></p>
<h2 id="1-3-虚函数"><a href="#1-3-虚函数" class="headerlink" title="1.3 虚函数"></a>1.3 虚函数</h2><p>虚函数：被virtual修饰的成员函数称为虚函数。注意：修饰的是成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  //虚函数</span><br><span class="line">  virtual void BuyTicket()</span><br><span class="line">  &#123;</span><br><span class="line">​    cout &lt;&lt; &quot;全价买票&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-虚函数的重写"><a href="#1-4-虚函数的重写" class="headerlink" title="1.4 虚函数的重写"></a>1.4 虚函数的重写</h2><p>虚函数的重写(覆盖)：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类的虚函数的返回值类型，函数名字，参数列表完全相同)，但是函数的实现不同，称派生类重写了基类的虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;全价买票&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚函数重写</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;半价买票&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//注意：在在虚函数重写时，派生类的虚函数不加virtual关键字，也可以构成重写</span></span><br><span class="line">    <span class="comment">//因为继承，将基类的虚函数继承了下来，在派生类依旧保持虚函数的属性。</span></span><br><span class="line">    <span class="comment">//但是这种写法不规范，不建议这样写。</span></span><br><span class="line">    <span class="comment">//void BuyTicket()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;半价买票&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​    <strong>虚函数的重写，需要函数名，参数，返回值类型一样。但是派生类只是继承了函数的接口，接口就是函数名，参数，返回值类型。派生类重写只是实现不同。</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173504034.png" alt="image-20230129173504034"></p>
<h3 id="1-4-1-协变"><a href="#1-4-1-协变" class="headerlink" title="1.4.1 协变"></a>1.4.1 协变</h3><p>派生类重写基类虚函数，与基类虚函数的返回值不同。并且基类虚函数的返回值基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用，称为协变。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173511207.png" alt="image-20230129173511207"></p>
<h3 id="1-4-2-析构函数的重写"><a href="#1-4-2-析构函数的重写" class="headerlink" title="1.4.2 析构函数的重写"></a>1.4.2 析构函数的重写</h3><p>问题：</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173521643.png" alt="image-20230129173521643"></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173527397.png" alt="image-20230129173527397">这里是一个注意点，申请空间为派生类，但是赋值给基类时，需要将析构函数写成虚函数，构成多态。</p>
<h3 id="1-4-3-C-11里的override和final关键字"><a href="#1-4-3-C-11里的override和final关键字" class="headerlink" title="1.4.3 C++11里的override和final关键字"></a>1.4.3 C++11里的override和final关键字</h3><ol>
<li>final：</li>
</ol>
<p>修饰虚函数，表示该虚函数不能被继承，不能进行重写。</p>
<p>修饰类，类不能被继承</p>
<p>   2.override </p>
<p>检查派生类虚函数是否重写了基类的虚函数，如果没有编译错误。</p>
<p>这个只能修饰派生类的虚函数，不能修饰基类虚函数</p>
<p>override关键字最好用来检查派生类虚函数接口(函数名，参数，返回值)是否写错</p>
<h2 id="1-5-抽象类"><a href="#1-5-抽象类" class="headerlink" title="1.5 抽象类"></a>1.5 抽象类</h2><p>在虚函数后面写上=0，这个函数称为纯虚函数。</p>
<p>包含纯虚函数的类叫做抽象类(也叫接口类)，抽象类不能实例化出对象。派生类继承之后也不能实例化出对象，只有重写的纯虚函数，派生类才能实例化出对象。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173705921.png" alt="image-20230129173705921"></p>
<p>只有派生类经过纯虚函数重写才能实例化出对象。但是基类还是抽象类，不能实例化对象。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173724524.png" alt="image-20230129173724524"></p>
<p>纯虚函数的作用：</p>
<p>  <em><strong>1.一定程度上强制了派生类对纯虚函数的重写，如果不重写，派生类就不能实例化对象。</strong></em></p>
<p>  <em><strong>2.表示抽象的类型</strong></em></p>
<p><em><strong>应用场景：</strong></em></p>
<p>  <em><strong>比如：比如，只说一辆车，车是抽象的，是一个很笼统的概念。因为有多车，不知道具体什么车，并且你不会拿车实例化对象，车这个类就可以定义成抽象类，里可以写成员函数，但是不写具体实现。</strong></em></p>
<p>  <em><strong>但是某个品牌的车，比如奔驰，可以继承车这个抽象类，只需要重写纯虚函数，就可以实例化对象。</strong></em></p>
<p>  <em><strong>具体的继承抽象的。</strong></em></p>
<h1 id="二-多态的原理"><a href="#二-多态的原理" class="headerlink" title="二.多态的原理"></a>二.多态的原理</h1><h2 id="2-1-虚函数表"><a href="#2-1-虚函数表" class="headerlink" title="2.1 虚函数表"></a>2.1 虚函数表</h2><p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173815362.png" alt="image-20230129173815362"></p>
<p>通过观察我们发现，对象b是8个字节，除了_num外，还有_vfptr指针。这个指针是我们叫做虚函数表指针，简称虚表指针。一个含有虚函数的类中至少有一个这样的指针。</p>
<p>_vfptr指针变量保存的是虚函数表的起始地址。</p>
<p>虚函数表实际是一个函数指针数组，虚函数表简称虚表。虚表里面保存的都是虚函数的地址。 </p>
<p><strong>2.2</strong> <strong>派生类中的虚表指针</strong></p>
<p> <strong>派生类不重写基类的虚函数。</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173826299.png" alt="image-20230129173826299"></p>
<p>通过上面现象说明一个结论：</p>
<p>派生类会继承基类的虚函数，会继承基类的虚表。但是派生类和基类的_vfptr变量内容不相等，说明两个虚表不是同一种虚表，只是虚表里的内容相同，所以会调用同一个函数。</p>
<p><strong>派生类重写虚函数</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173834891.png" alt="image-20230129173834891"></p>
<p>通过上面现象说明一个结论：</p>
<p>派生类重写基类虚函数，会重写派生类虚函数表里的内容，将对应位置覆盖层重写虚函数的指针。</p>
<p><strong>派生类增加虚函数</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173843091.png" alt="image-20230129173843091"></p>
<p><strong>注意：</strong></p>
<p>​    **1.**<strong>类中有虚函数只是这个类中多一个虚函数表指针，不是将虚函数表保存到类中。</strong></p>
<p>​    *<em>2.<strong><strong>虚函数表最后会以</strong></strong>nullptr</em>*<strong>结尾。</strong></p>
<p>​    **3.**<strong>同类型的对象共用一张虚表，可以理解成一个类的虚表属于这个类的，实例化的对象，都公用这一张虚表。</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173849344.png" alt="image-20230129173849344"></p>
<p>总结派生类虚表的生成：</p>
<p>1.派生类会继承基类的虚表，但是两个虚表并不是一张虚表。派生类先将基表虚表的内容拷贝一份到派生类的虚表中</p>
<p>2.如果虚表重写虚函数，用派生类重写虚函数的地址覆盖掉虚表中对应虚函数的地址。</p>
<p>3.派生类增加虚函数，会在派生类虚表中声明次序增加到虚表的最后。</p>
<h2 id="2-4-多态原理"><a href="#2-4-多态原理" class="headerlink" title="2.4 多态原理"></a>2.4 多态原理</h2><p>多态是基于虚函数的虚函数表。构成多态，跟对象有关。如果是基类对象，会去基类的虚表中找要调用虚函数的地址，去执行虚函数的代码。如果是派生类对象，会去派生类的虚表中找要调用虚函数的地址，去执行虚函数的代码。</p>
<p>派生类虚函数重写之后，可以实现不同的对象，有不同的实现方法，展现不同的效果。</p>
<p>再来段代码理解一下：</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173859792.png" alt="image-20230129173859792"></p>
<p>通过汇编分析，看出满足多态以后函数调用，不是再编译时确定的，是在运行起来后到对象的需表中找的。</p>
<p>不满足多态，是在编译时确定好的。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173910217.png" alt="image-20230129173910217"></p>
<h2 id="2-5-动态绑定和静态绑定"><a href="#2-5-动态绑定和静态绑定" class="headerlink" title="2.5 动态绑定和静态绑定"></a>2.5 动态绑定和静态绑定</h2><blockquote>
<p>l 静态绑定又称为前期绑定，在程序编译期间确定了程序的行为，也称静态多态。比如函数重载。在编译的时候确定了调用的函数。</p>
<p>l 动态绑定也称后期绑定，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称动态多态。就像上面的，运行时在到虚表中找调用函数的地址。</p>
<p>l 多态，多数都是动态绑定。</p>
</blockquote>
<h1 id="三-单继承和多继承的虚函数表"><a href="#三-单继承和多继承的虚函数表" class="headerlink" title="三.单继承和多继承的虚函数表"></a>三.单继承和多继承的虚函数表</h1><h2 id="3-1-单继承中的虚表"><a href="#3-1-单继承中的虚表" class="headerlink" title="3.1 单继承中的虚表"></a>3.1 单继承中的虚表</h2><p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173927542.png" alt="image-20230129173927542"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Person func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Person func2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Student func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Student func3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span><span class="params">()</span></span>;<span class="comment">//声明一个函数指针即 typedef void (*)() VFPTR;</span></span><br><span class="line"><span class="comment">//打印代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVfTable</span><span class="params">(VFPTR *vftable)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vftable[i] != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">		<span class="comment">//打印虚表内容</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;vftable[%d]:%p\n&quot;</span>, i, vftable[i]);</span><br><span class="line">		<span class="comment">//调用这个函数</span></span><br><span class="line">		VFPTR fun = vftable[i];</span><br><span class="line">		<span class="built_in">fun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Student s;</span><br><span class="line">	<span class="comment">//要得到虚表指针的内容，由于这个平台，虚表指针是保存在开始的</span></span><br><span class="line">	<span class="comment">//先得到对象地址，强转成int *得到前四个字节，就是虚表指针的地址</span></span><br><span class="line">	<span class="comment">//再解引用，得到虚表指针的内容</span></span><br><span class="line">	<span class="comment">//再强转成函数二级指针</span></span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)&amp;p);</span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)&amp;s);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173954774.png" alt="image-20230129173954774"></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174004490.png" alt="image-20230129174004490"></p>
<h2 id="3-2-多继承中的虚表"><a href="#3-2-多继承中的虚表" class="headerlink" title="3.2 多继承中的虚表"></a>3.2 多继承中的虚表</h2><p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174035132.png" alt="image-20230129174035132"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base1 : func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base1 : func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2 : func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2 : func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2 : func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deirve</span> :</span><span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deirve : func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deirve : func4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deirve : func5()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span><span class="params">()</span></span>;<span class="comment">//声明一个函数指针即 typedef void (*)() VFPTR;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVfTable</span><span class="params">(VFPTR *vftable)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;虚表地址：%p\n&quot;</span>, vftable);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vftable[i] != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">		<span class="comment">//打印虚表内容</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;vftable[%d]:%p\n&quot;</span>, i, vftable[i]);</span><br><span class="line">		<span class="comment">//调用这个函数</span></span><br><span class="line">		VFPTR fun = vftable[i];</span><br><span class="line">		<span class="built_in">fun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Deirve d;</span><br><span class="line">	<span class="comment">//打印继承Base1的虚表</span></span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)&amp;d);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印继承Base2的虚表</span></span><br><span class="line">	<span class="comment">//加Base1大小的字节数，到Base2的虚表指针。</span></span><br><span class="line">	<span class="comment">//要加先强转成char *，步长为一个字节。不强转的话，步长为Deirve</span></span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)&amp;d + <span class="built_in"><span class="keyword">sizeof</span></span>(Base1)));</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174103295.png" alt="image-20230129174103295"></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174107432.png" alt="image-20230129174107432"></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>1）栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放</p>
<p>堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收</p>
<p>2）因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片</p>
<p>3）对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。</p>
<p>C++内存区域分为5个区域。分别是堆，栈，自由存储区，全局/静态存储区和常量存储区。</p>
<p>栈：由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面通常是局部变量，函数参数等。</p>
<p>堆：由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>自由存储区：由malloc等分配的内存块，和堆十分相似，不过它使用free来结束自己的生命。</p>
<p>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的c语言中。全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存。**<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>常量也是存储在静态存储区**</p>
<p>​    <strong>对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。</strong></p>
<p>常量存储区：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
<h2 id="C-内存区域中堆和栈的区别："><a href="#C-内存区域中堆和栈的区别：" class="headerlink" title="C++内存区域中堆和栈的区别："></a>C++内存区域中堆和栈的区别：</h2><p>管理方式不同：栈是由编译器自动管理，无需我们手工控制；对于堆来说，释放由程序员完成，容易产生内存泄漏。</p>
<p>空间大小不同：一般来讲，在32位系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project–&gt;setting–&gt;link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。</p>
<p>能否产生碎片：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。</p>
<p>生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。</p>
<p>分配方式不同：堆都是动态分配的；栈有静态和动态两种分配方式。静态分配由编译器完成，比如局部变量的分配。动态分配由malloca函数进行、但栈的动态分配和堆是不同的，它的动态分配由编译器进行释放，无需我们手工实现。</p>
<p>分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。</p>
<p>进程内存中的映像，主要有代码区，堆（动态存储区，new/delete的动态数据），栈，静态存储区</p>
<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>char *c=”zhouming”;<br><em>书上说： “zhouming”这个字符串被当作常量而且被放置在此程序的内存静态区。</em><br><em>c为一个字符型指针，若为局部变量，则存储在栈内，该指针变量里面存了个地址，该地址为字符串中第一个字母Z的地址。</em></p>
<p><em>当使用printf()输出时，格式化时选择%s，会输出zhouming，这是printf遇到结尾符号‘\0’即停止显示打印。</em></p>
<p><em>字符串“zhouming”是个常量，存储在一片连续的内存中，末尾有结尾符表示字符串的结束。</em></p>
<p>所有的字符窜常量都被放在静态内存区</p>
<p>因为字符串常量很少需要修改，放在静态内存区会提高效率</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str7 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str8 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str1 == str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str3 == str6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str5 == str6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str7 == str8);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str5 == str8);</span><br></pre></td></tr></table></figure>

<p>结果是：0 0 1 1 1<br>str1,str2,str3,str4是数组变量，它们有各自的内存空间；字符数组作为局部变量被存储在栈区；<br>而str5,str6,str7,str8是指针，它们指向相同的常量区域。，”abcd”被存储在静态数据区，而且是全局的。</p>
<p>问题的引入：<br>看看下面的程序的输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">returnStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;<span class="comment">//一定要初始化，好习惯</span></span><br><span class="line">str=<span class="built_in">returnStr</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在静态数据区，<br>把该字符串常量存放的静态数据区的首地址赋值给了指针，<br>所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p>
<p>但是，下面的就有问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">returnStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> p[]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;<span class="comment">//一定要初始化，好习惯</span></span><br><span class="line">str=<span class="built_in">returnStr</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“hello world!”是一个字符串常量，存放在静态数据区，没错，<br>但是把一个字符串常量赋值给了一个局部变量(char []型数组)，该局部变量存放在栈中，<br>这样就有两块内容一样的内存，也就是说“char p[]=”hello world!”;”这条语句让“hello world!”这个字符串在内存中有两份拷贝，一份在动态分配的栈中，另一份在静态存储区。<strong>这是与前者最本质的区别</strong>，<br>当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，<br>所以这时的函数返回的是一个已被释放的内存地址，所以打印出来的是乱码。</p>
<p>如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型</p>
<h1 id="关键字static的作用"><a href="#关键字static的作用" class="headerlink" title="关键字static的作用"></a>关键字static的作用</h1><p>1）函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值</p>
<p>2）模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内</p>
<p>3）类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝</p>
<p>4）类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量</p>
<p>注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象</p>
<h1 id="C-文件编译与执行的四个阶段"><a href="#C-文件编译与执行的四个阶段" class="headerlink" title="C++文件编译与执行的四个阶段"></a>C++文件编译与执行的四个阶段</h1><p>1）预处理：根据文件中的预处理指令来修改源文件的内容</p>
<p>2）编译：编译成汇编代码</p>
<p>3）汇编：把汇编代码翻译成目标机器指令</p>
<p>4）链接：链接目标代码生成可执行程序</p>
<h1 id="构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因"><a href="#构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因" class="headerlink" title="构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因"></a>构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因</h1><p>1、构造函数不能声明为虚函数</p>
<p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<p>2、析构函数最好声明为虚函数</p>
<p>首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数<strong>（没有发生多态）</strong>，这样就会造成派生类对象析构不完全。</p>
<p>子类析构时，要调用父类的析构函数吗？</p>
<p>析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。</p>
<p>不用显式调用，会自动调用</p>
<h1 id="静态绑定和动态绑定的介绍"><a href="#静态绑定和动态绑定的介绍" class="headerlink" title="静态绑定和动态绑定的介绍"></a>静态绑定和动态绑定的介绍</h1><p>静态绑定和动态绑定是C++多态性的一种特性</p>
<p>1）对象的静态类型和动态类型</p>
<p>静态类型：对象在声明时采用的类型，在编译时确定</p>
<p>动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改</p>
<p>2）静态绑定和动态绑定</p>
<p>静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定</p>
<p>动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定</p>
<p>只有虚函数才使用的是动态绑定，其他的全部是静态绑定</p>
<h1 id="C-中内存泄漏的几种情况"><a href="#C-中内存泄漏的几种情况" class="headerlink" title="C++中内存泄漏的几种情况"></a>C++中内存泄漏的几种情况</h1><p>内存泄漏是指动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2021/07/13/STL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>只有栈和队列没有迭代器（不能遍历），别的都有；栈，队列，链表不支持随机存取</p>
</blockquote>
<p><img src="/2021/07/13/STL/image-20210720220619245.png" alt="image-20210720220619245"></p>
<p><img src="/2021/07/13/STL/image-20210720220633840.png" alt="image-20210720220633840"></p>
<blockquote>
<p>为什么要使用容器提供的迭代器？因为容器有很多，如果对不同容器自定义迭代器，在++和—的时候，这个行为没法统一，为啥？比如vector是连续的，只需要向后跳一个数据类型的长度，而别的不是顺序存储的，可能要跳到别的地方去，++ 操作和—操作行不通，所以要使用容器提供的迭代器。</p>
</blockquote>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote>
<p>“asdfasd”是Char* 不是string</p>
</blockquote>
<p><img src="/2021/07/13/STL/image-20210720221021008.png" alt="image-20210720221021008"></p>
<h2 id="常用函数（下标从0开始）"><a href="#常用函数（下标从0开始）" class="headerlink" title="*常用函数（下标从0开始）*"></a><em><strong>*常用函数（下标从0开始）*</strong></em></h2><p>赋值:  = 构造 assign<br>取值:   []  at()  前者不抛出异常，后者抛</p>
<p>`<img src="/2021/07/13/STL/wps3.jpg" alt="img"></p>
<h4 id="拼接："><a href="#拼接：" class="headerlink" title="*拼接：*"></a><em><strong>*拼接：*</strong></em></h4><p><img src="/2021/07/13/STL/wps4.jpg" alt="img"> </p>
<h4 id="查找和替换："><a href="#查找和替换：" class="headerlink" title="*查找和替换：*"></a><em><strong>*查找和替换：*</strong></em></h4><p><img src="/2021/07/13/STL/wps5.jpg" alt="img"> </p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="*比较：*"></a><em><strong>*比较：*</strong></em></h4><p><img src="/2021/07/13/STL/wps6.jpg" alt="img"> </p>
<h4 id="子串："><a href="#子串：" class="headerlink" title="*子串：*"></a><em><strong>*子串：*</strong></em></h4><p><img src="/2021/07/13/STL/wps7.jpg" alt="img"> </p>
<h4 id="插入删除："><a href="#插入删除：" class="headerlink" title="*插入删除：*"></a><em><strong>*插入删除：*</strong></em></h4><p><img src="/2021/07/13/STL/wps8.jpg" alt="img"></p>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p><img src="/2021/07/13/STL/wps1.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps2.jpg" alt="img"> </p>
<p>Push_back 和pop_back都是在尾部，也就是开口那端操作。</p>
<p><img src="/2021/07/13/STL/wps3-1627199038760.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps4-1627199038760.jpg" alt="img"> </p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="*常用函数*"></a><em><strong>*常用函数*</strong></em></h3><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="*构造函数：*"></a><em><strong>*构造函数：*</strong></em></h4><p><img src="/2021/07/13/STL/wps5-1627199038760.jpg" alt="img"> </p>
<h4 id="赋值："><a href="#赋值：" class="headerlink" title="*赋值：*"></a><em><strong>*赋值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps6-1627199038760.jpg" alt="img"> </p>
<h4 id="取值："><a href="#取值：" class="headerlink" title="*取值：*"></a><em><strong>*取值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps7-1627199038760.jpg" alt="img"> </p>
<h4 id="大小："><a href="#大小：" class="headerlink" title="*大小：*"></a><em><strong>*大小：*</strong></em></h4><p><img src="/2021/07/13/STL/wps8-1627199038760.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps9.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps10.jpg" alt="img"> </p>
<h4 id="插入删除：-1"><a href="#插入删除：-1" class="headerlink" title="*插入删除：*"></a><em><strong>*插入删除：*</strong></em></h4><p><img src="/2021/07/13/STL/wps11.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps12.jpg" alt="img"> </p>
<h4 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h4><p>添加元素，会自动增长，但是删除元素不会自动减少！</p>
<p><img src="/2021/07/13/STL/wps13.jpg" alt="img"> </p>
<h1 id="Deuqe双端队列，两头能进能出"><a href="#Deuqe双端队列，两头能进能出" class="headerlink" title="Deuqe双端队列，两头能进能出"></a>Deuqe双端队列，两头能进能出</h1><p><img src="/2021/07/13/STL/wps14.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps15.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps16.jpg" alt="img"> <img src="/2021/07/13/STL/wps17.jpg" alt="img"></p>
<p>分段连续内存。</p>
<p><img src="/2021/07/13/STL/wps18.jpg" alt="img"> </p>
<h4 id="构造函数：-1"><a href="#构造函数：-1" class="headerlink" title="*构造函数：*"></a><em><strong>*构造函数：*</strong></em></h4><p><img src="/2021/07/13/STL/wps19.jpg" alt="img"> </p>
<h4 id="赋值：-1"><a href="#赋值：-1" class="headerlink" title="*赋值：*"></a><em><strong>*赋值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps20.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps21.jpg" alt="img"> </p>
<h4 id="取值：-1"><a href="#取值：-1" class="headerlink" title="*取值：*"></a><em><strong>*取值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps22.jpg" alt="img"> </p>
<h4 id="大小：-1"><a href="#大小：-1" class="headerlink" title="*大小：*"></a><em><strong>*大小：*</strong></em></h4><p><img src="/2021/07/13/STL/wps23.jpg" alt="img"> </p>
<h4 id="插入删除：-2"><a href="#插入删除：-2" class="headerlink" title="*插入删除：*"></a><em><strong>*插入删除：*</strong></em></h4><p><img src="/2021/07/13/STL/wps24.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps25.jpg" alt="img"> </p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p><img src="/2021/07/13/STL/wps26.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps27.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps28.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps29.jpg" alt="img"> </p>
<p>不提供迭代器，所以不能遍历。</p>
<p>只能先把栈顶的元素取出来之后才能取后面的。</p>
<h4 id="构造函数：-2"><a href="#构造函数：-2" class="headerlink" title="*构造函数：*"></a><em><strong>*构造函数：*</strong></em></h4><p><img src="/2021/07/13/STL/wps30.jpg" alt="img"> </p>
<h4 id="赋值：-2"><a href="#赋值：-2" class="headerlink" title="*赋值：*"></a><em><strong>*赋值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps31.jpg" alt="img"> </p>
<h4 id="存取值："><a href="#存取值：" class="headerlink" title="*存取值：*"></a><em><strong>*存取值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps32.jpg" alt="img"> </p>
<h4 id="大小：-2"><a href="#大小：-2" class="headerlink" title="*大小：*"></a><em><strong>*大小：*</strong></em></h4><p><img src="/2021/07/13/STL/wps33.jpg" alt="img"> </p>
<h1 id="Queue队列，一端插入一端删除"><a href="#Queue队列，一端插入一端删除" class="headerlink" title="Queue队列，一端插入一端删除"></a>Queue队列，一端插入一端删除</h1><p><img src="/2021/07/13/STL/wps34.jpg" alt="img"> </p>
<h4 id="构造函数：-3"><a href="#构造函数：-3" class="headerlink" title="*构造函数：*"></a><em><strong>*构造函数：*</strong></em></h4><p><img src="/2021/07/13/STL/wps35.jpg" alt="img"> </p>
<h4 id="赋值：-3"><a href="#赋值：-3" class="headerlink" title="*赋值：*"></a><em><strong>*赋值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps36.jpg" alt="img"> </p>
<h4 id="存取值：-1"><a href="#存取值：-1" class="headerlink" title="*存取值：*"></a><em><strong>*存取值：*</strong></em></h4><p><img src="/2021/07/13/STL/wps37.jpg" alt="img"> </p>
<h4 id="大小：-3"><a href="#大小：-3" class="headerlink" title="*大小：*"></a><em><strong>*大小：*</strong></em></h4><p><img src="/2021/07/13/STL/wps38.jpg" alt="img"> </p>
<h1 id="List链表"><a href="#List链表" class="headerlink" title="List链表"></a>List链表</h1><p>不支持随机存取</p>
<p><img src="/2021/07/13/STL/wps39.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps40.jpg" alt="img"> <img src="/2021/07/13/STL/wps41.jpg" alt="img"></p>
<p><img src="/2021/07/13/STL/wps42.jpg" alt="img"> </p>
<p>Remove是删除所有。</p>
<p><img src="/2021/07/13/STL/wps43.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps44.jpg" alt="img"> <img src="/2021/07/13/STL/wps45.jpg" alt="img"></p>
<p><img src="/2021/07/13/STL/wps46.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps47.jpg" alt="img"> </p>
<h3 id="Sort"><a href="#Sort" class="headerlink" title="*Sort*"></a><em><strong>*Sort*</strong></em></h3><p>Sort(vector,vector)这是算法</p>
<p>List.sort();这是成员函数，因为list不支持随机访问，所以自己提供了一个。默认从小到大。</p>
<h1 id="Set-multiset"><a href="#Set-multiset" class="headerlink" title="Set/multiset"></a>Set/multiset</h1><p><img src="/2021/07/13/STL/wps48.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps49.jpg" alt="img"> </p>
<p>一个是以红黑树为底层机制，一个是自动排序。因为自动排序所以只有insert()，没有别的函数。</p>
<p>Set不能重复，multiset能重复。</p>
<p><img src="/2021/07/13/STL/wps50.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps51.jpg" alt="img"> </p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="*二叉树*"></a><em><strong>*二叉树*</strong></em></h3><p>二叉树-&gt;二叉搜索树-&gt;平衡二叉树-&gt;红黑树</p>
<p><img src="/2021/07/13/STL/wps52.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps53.jpg" alt="img"> </p>
<p>大的放右边，小的放左边。</p>
<p><img src="/2021/07/13/STL/wps54.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps55.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps56.jpg" alt="img"> </p>
<h3 id="Set常用api"><a href="#Set常用api" class="headerlink" title="Set常用api"></a>Set常用api</h3><p><img src="/2021/07/13/STL/wps57.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps58.jpg" alt="img"> </p>
<p>erase是删除一个（因为自动排序了，只会有一个）,和list的remove对比记忆。</p>
<p><img src="/2021/07/13/STL/wps59.jpg" alt="img"> </p>
<h3 id="Pari对组"><a href="#Pari对组" class="headerlink" title="Pari对组"></a>Pari对组</h3><p><img src="/2021/07/13/STL/wps60.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps61.jpg" alt="img"> </p>
<h3 id="改变默认排序规则（由小到大改为由大到小）"><a href="#改变默认排序规则（由小到大改为由大到小）" class="headerlink" title="*改变默认排序规则（由小到大改为由大到小）*"></a><em><strong>*改变默认排序规则（由小到大改为由大到小）*</strong></em></h3><p><img src="/2021/07/13/STL/wps62.jpg" alt="img"><em><strong>*这不能引用*</strong></em></p>
<p><img src="/2021/07/13/STL/wps63.jpg" alt="img"> </p>
<h3 id="将对象放入set"><a href="#将对象放入set" class="headerlink" title="*将对象放入set*"></a><em><strong>*将对象放入set*</strong></em></h3><p><img src="/2021/07/13/STL/wps64.jpg" alt="img"><img src="/2021/07/13/STL/wps65.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps66.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps67.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps68.jpg" alt="img"> </p>
<p>Find只会根据规则的具体字段来查，比人查找p4，实际上sp里并没有，但是仿函数是按照age建立排序规则的，所以只会查找age，当满足时会返回，需要注意。</p>
<h1 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h1><p><img src="/2021/07/13/STL/wps69.jpg" alt="img"> </p>
<p>自动排序，根据key排序</p>
<p><img src="/2021/07/13/STL/wps70.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps71.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps72.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps73.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps74.jpg" alt="img"> </p>
<h3 id="补充，自定义数据自动排序"><a href="#补充，自定义数据自动排序" class="headerlink" title="*补充，自定义数据自动排序*"></a><em><strong>*补充，自定义数据自动排序*</strong></em></h3><p><img src="/2021/07/13/STL/wps75.jpg" alt="img"></p>
<h1 id="STL容器共性机制"><a href="#STL容器共性机制" class="headerlink" title="STL容器共性机制"></a>STL容器共性机制</h1><p><img src="/2021/07/13/STL/wps76.jpg" alt="img"> </p>
<h1 id="STL的使用时机"><a href="#STL的使用时机" class="headerlink" title="STL的使用时机"></a>STL的使用时机</h1><p><img src="/2021/07/13/STL/wps77.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps78.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps79.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps80.jpg" alt="img"></p>
<h1 id="STL迭代器及迭代器失效问题"><a href="#STL迭代器及迭代器失效问题" class="headerlink" title="STL迭代器及迭代器失效问题"></a>STL迭代器及迭代器失效问题</h1><h2 id="一、迭代器失效的类型"><a href="#一、迭代器失效的类型" class="headerlink" title="一、迭代器失效的类型"></a>一、迭代器失效的类型</h2><p>a.由于插入元素，使得容器元素整体“迁移”导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效。<br>b.由于删除元素使得某些元素次序发生变化使得原本指向某元素的迭代器不再指向希望指向的元素。</p>
<h2 id="二、vector"><a href="#二、vector" class="headerlink" title="二、vector"></a>二、vector</h2><p>内部数据结构：数组<br>随机访问每个元素，所需要的时间为O(1)<br>在末尾增加或删除元素所需时间与元素数目无关，在中间或开头增加或删除元素所需时间随元素数目呈线性变化。<br>可动态增加或减少元素，内存管理自动完成，但程序员可以使用reserve()成员函数来管理内存。<br>vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。</p>
<blockquote>
<p>当把超过capacity()-size()个元素插入vector中时，内存会重新分配，所有的迭代器都将失效；否则，指向当前元素以后的任何元素的迭代器都将失效。<br>当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。<br>说明:<br>当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。<br>当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。<br>当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。</p>
</blockquote>
<h2 id="三、deque"><a href="#三、deque" class="headerlink" title="三、deque"></a>三、deque</h2><blockquote>
<p>内部数据结构：数组<br>随机访问每个元素，所需要的时间为O(1)<br>在开头和末尾增加元素所需时间与元素数目无关，在中间增加或删除元素所需时间随元素数目呈线性变化。<br>可动态增加或减少元素，内存管理自动完成，不提供用于内存管理的成员函数。<br>增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使迭代器失效。在deque的头或尾删除元素时，只有指向该元素的迭代器失效。<br>说明:<br>在deque容器首部或者尾部插入元素不会使得任何迭代器失效。<br>在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。<br>在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。</p>
</blockquote>
<h2 id="四、list"><a href="#四、list" class="headerlink" title="四、list"></a>四、list</h2><blockquote>
<p>内部数据结构：双向环状链表<br>不能随机访问一个元素。<br>可双向遍历。<br>在开头、末尾和中间任何地方增加或删除元素所需时间都为O(1)<br>可动态增加或减少元素，内存管理自动完成。<br>增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。<br>说明:<br>插入操作（insert）和接合操作（splice）不会造成原有的list迭代器失效，这在vector中是不成立的，</p>
<p>因为vector的插入操作可能造成记忆体重新配置，导致所有的迭代器全部失效。<br>list的删除操作（erase）也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。（list目前只发现这一种失效的情况）</p>
</blockquote>
<h2 id="五、slist"><a href="#五、slist" class="headerlink" title="五、slist"></a>五、slist</h2><p>内部数据结构：单向链表<br>不可双向遍历，只能从前到后地遍历。<br>其它的特性同list相似。</p>
<h2 id="六、stack"><a href="#六、stack" class="headerlink" title="六、stack"></a>六、stack</h2><p>适配器，它可以将任意类型的序列容器转换为一个堆栈，一般使用deque作为支持的序列容器。<br>元素只能后进先出（LIFO）。<br>不能遍历整个stack。</p>
<h2 id="七、queue"><a href="#七、queue" class="headerlink" title="七、queue"></a>七、queue</h2><p>适配器，它可以将任意类型的序列容器转换为一个队列，一般使用deque作为支持的序列容器。<br>元素只能先进先出（FIFO）。<br>不能遍历整个queue。</p>
<h2 id="八、priority-queue"><a href="#八、priority-queue" class="headerlink" title="八、priority_queue"></a>八、priority_queue</h2><p>适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用vector作为底层存储方式。<br>只能访问第一个元素，不能遍历整个priority_queue。<br>第一个元素始终是优先级最高的一个元素。</p>
<h2 id="九、set"><a href="#九、set" class="headerlink" title="九、set"></a>九、set</h2><p>键唯一。<br>元素默认按升序排列。<br>如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</p>
<h2 id="十、multiset"><a href="#十、multiset" class="headerlink" title="十、multiset"></a>十、multiset</h2><p>键可以不唯一。<br>其它特点与set相同。</p>
<h2 id="十一、map"><a href="#十一、map" class="headerlink" title="十一、map"></a>十一、map</h2><p>键唯一。<br>元素默认按键的升序排列。<br>如果迭代器所指向的元素被删除，则该迭代器失效。其它任何增加、删除元素的操作都不会使迭代器失效。</p>
<h2 id="十二、multimap"><a href="#十二、multimap" class="headerlink" title="十二、multimap"></a>十二、multimap</h2><p>键可以不唯一。<br>其它特点与map相同。</p>
<h1 id="常用查询算法"><a href="#常用查询算法" class="headerlink" title="常用查询算法"></a>常用查询算法</h1><h3 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h3><p><img src="/2021/07/13/STL/wps81.jpg" alt="img"> </p>
<p>Find基础数据类型</p>
<p><img src="/2021/07/13/STL/wps82.jpg" alt="img"> </p>
<p>Find 类对象</p>
<p><img src="/2021/07/13/STL/wps83.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps84.jpg" alt="img"> </p>
<p>这样写会出错，因为find的时候，是和p1匹配，但是p1是类变量，没法直接比较，</p>
<p><img src="/2021/07/13/STL/wps85.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps86.jpg" alt="img"> </p>
<p>然后在使用find(v1.begin(),v2.end,p1)就可以通过了。</p>
<h3 id="Binary-search-二分查找法"><a href="#Binary-search-二分查找法" class="headerlink" title="Binary_search() 二分查找法"></a>Binary_search() 二分查找法</h3><p><img src="/2021/07/13/STL/wps87.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps88.jpg" alt="img"> </p>
<h3 id="Adjacent-find-相邻重复元素"><a href="#Adjacent-find-相邻重复元素" class="headerlink" title="Adjacent_find() 相邻重复元素"></a>Adjacent_find() 相邻重复元素</h3><p><img src="/2021/07/13/STL/wps89.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps90.jpg" alt="img"> </p>
<h3 id="Find-if-条件查找"><a href="#Find-if-条件查找" class="headerlink" title="Find_if  条件查找"></a>Find_if  条件查找</h3><p><img src="/2021/07/13/STL/wps91.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps92.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps93.jpg" alt="img"> </p>
<h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><p><img src="/2021/07/13/STL/wps94.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps95.jpg" alt="img"> </p>
<h1 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h1><h3 id="for-each-iterator-iterator-fun"><a href="#for-each-iterator-iterator-fun" class="headerlink" title="for_each(iterator,iterator,fun)"></a>for_each(iterator,iterator,fun)</h3><p>为什么会有回调函数？因为容器中可能存放基础数据类型，也有可能存放自定义的数据类型。如果是后者，遍历的时候需要的操作不知道怎么操作，如输出的时候，基础类型它知道怎么输出，自定义的结构体呢，输出什么，输出哪个它不知道，所以需要制定回调函数，自己实现。</p>
<p><img src="/2021/07/13/STL/wps96.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps97.jpg" alt="img"> </p>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p><img src="/2021/07/13/STL/wps98.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps99.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps100.jpg" alt="img"> </p>
<h1 id="常用的排序算法"><a href="#常用的排序算法" class="headerlink" title="常用的排序算法"></a>常用的排序算法</h1><blockquote>
<p>除了merge，sort、random_shuffle、reverse这三个排序算法不能用于不支持随机访问的容器，如栈、队列、链表等。</p>
</blockquote>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><img src="/2021/07/13/STL/wps101.jpg" alt="img"> </p>
<p>只能对有序序列合并（且两个待合并的序列必须是同样的顺序，要么都是从大到小，要么都是从小到大）</p>
<h3 id="Sort-1"><a href="#Sort-1" class="headerlink" title="Sort"></a>Sort</h3><p><img src="/2021/07/13/STL/wps102.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps103.jpg" alt="img"> </p>
<h3 id="Random-shuffle"><a href="#Random-shuffle" class="headerlink" title="Random_shuffle"></a>Random_shuffle</h3><p><img src="/2021/07/13/STL/wps104.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps105.jpg" alt="img"> </p>
<h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p><img src="/2021/07/13/STL/wps106.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps107.jpg" alt="img"> </p>
<h1 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h1><p><img src="/2021/07/13/STL/wps108.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps109.jpg" alt="img"> </p>
<h1 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h1><p><img src="/2021/07/13/STL/wps110.jpg" alt="img"> </p>
<h1 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h1><p><img src="/2021/07/13/STL/wps111.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps112.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps113.jpg" alt="img"> </p>
<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p> 仿函数也叫函数对象，是重载了()的类（结构体）的对象，而谓词具体指某个函数或者重载()的语句。</p>
<h2 id="函数对象（仿函数）的概念"><a href="#函数对象（仿函数）的概念" class="headerlink" title="*函数对象（仿函数）的概念*"></a><em><strong>*函数对象（仿函数）的概念*</strong></em></h2><p><img src="/2021/07/13/STL/wps114.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps115.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps116.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps117.jpg" alt="img"> </p>
<p>解释下什么叫可以保存函数调用的状态，因为仿函数是个类，可以有成员变量，不像函数指针，调用完函数就执行完了。</p>
<p><img src="/2021/07/13/STL/wps118.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps119.jpg" alt="img"> </p>
<p>如果不用仿函数，而用了函数指针，就得按下面的声明全局变量</p>
<p><img src="/2021/07/13/STL/wps120.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps121.jpg" alt="img"> </p>
<h2 id="谓词概念"><a href="#谓词概念" class="headerlink" title="*谓词概念*"></a><em><strong>*谓词概念*</strong></em></h2><p><img src="/2021/07/13/STL/wps122.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps123.jpg" alt="img"> </p>
<h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="*内建函数对象*"></a><em><strong>*内建函数对象*</strong></em></h2><p><img src="/2021/07/13/STL/wps124.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps125.jpg" alt="img"> <img src="/2021/07/13/STL/wps126.jpg" alt="img"></p>
<p><img src="/2021/07/13/STL/wps127.jpg" alt="img"></p>
<h1 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h1><p><img src="/2021/07/13/STL/wps128.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps129.jpg" alt="img"> </p>
<h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="*绑定适配器*"></a><em><strong>*绑定适配器*</strong></em></h3><p>作用是将一个二元函数对象转变成一元函数对象</p>
<p><img src="/2021/07/13/STL/wps130.jpg" alt="img"> <img src="/2021/07/13/STL/wps131.jpg" alt="img"></p>
<p><img src="/2021/07/13/STL/wps132.jpg" alt="img"> </p>
<p>如果想输出的时候+100，在MyPrint里面cout的时候+100，如果+200，在不改变现有MyPrint的情况下，得再新建别的类，我们想把100 200这样的数作为参数传进去，但是for_each是一元函数对象，只能传一个参数，需要绑定适配器。</p>
<p><img src="/2021/07/13/STL/wps133.jpg" alt="img"> <img src="/2021/07/13/STL/wps134.jpg" alt="img"></p>
<p><img src="/2021/07/13/STL/wps135.jpg" alt="img"> <img src="/2021/07/13/STL/wps136.jpg" alt="img"></p>
<h3 id="取反适配器"><a href="#取反适配器" class="headerlink" title="*取反适配器*"></a><em><strong>*取反适配器*</strong></em></h3><p><img src="/2021/07/13/STL/wps137.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps138.jpg" alt="img"> </p>
<p>下面默认从小到大</p>
<p><img src="/2021/07/13/STL/wps139.jpg" alt="img"> </p>
<p>下面取反，转为从大到小</p>
<p><img src="/2021/07/13/STL/wps140.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps141.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps142.jpg" alt="img"> </p>
<p>查找第一个大于5的。</p>
<p><img src="/2021/07/13/STL/wps143.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps144.jpg" alt="img"> </p>
<p>下面取反，查找第一个小于5的。</p>
<p><img src="/2021/07/13/STL/wps145.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps146.jpg" alt="img"> </p>
<h3 id="Ptr-fun"><a href="#Ptr-fun" class="headerlink" title="*Ptr_fun*"></a><em><strong>*Ptr_fun*</strong></em></h3><p>是对上面两个适配器的补充，上面两个适配器都是对函数对象进行绑定的，没办法对普通函数绑定，所以需要ptr_fun()，它的作用就是把普通函数适配成函数对象。</p>
<p><img src="/2021/07/13/STL/wps147.jpg" alt="img"> </p>
<h3 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="*成员函数适配器*"></a><em><strong>*成员函数适配器*</strong></em></h3><p><img src="/2021/07/13/STL/wps148.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps149.jpg" alt="img"> </p>
<p><img src="/2021/07/13/STL/wps150.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv</title>
    <url>/2021/07/13/opencv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="opencv-Mat数据的标准访问方式"><a href="#opencv-Mat数据的标准访问方式" class="headerlink" title="opencv Mat数据的标准访问方式"></a>opencv Mat数据的标准访问方式</h1><h2 id="方式1：-at-i-j-访问"><a href="#方式1：-at-i-j-访问" class="headerlink" title="方式1： at(i,j)访问"></a>方式1： at<type>(i,j)访问</type></h2><p>例:单通道</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ROWS = <span class="number">100</span>; <span class="comment">// height</span></span><br><span class="line"><span class="keyword">int</span> COLS = <span class="number">200</span>; <span class="comment">// width</span></span><br><span class="line"><span class="function">Mat <span class="title">img1</span><span class="params">(ROWS , COLS , CV_32FC1)</span></span>;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROWS ; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COLS ; j++)  </span><br><span class="line">  &#123;  </span><br><span class="line">    img1.at&lt;<span class="keyword">float</span>&gt;(i,j) = <span class="number">3.2f</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>type的对应表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat_&lt;uchar&gt;---------CV_8U   比如CV_8UC3，表示<span class="number">8</span>位，无符号<span class="keyword">char</span>，<span class="number">3</span>通道</span><br><span class="line">Mat&lt;<span class="keyword">char</span>&gt;-----------CV_8S</span><br><span class="line">Nat_&lt;<span class="keyword">short</span>&gt;---------CV_16S</span><br><span class="line">Mat_&lt;ushort&gt;--------CV_16U</span><br><span class="line">Mat_&lt;<span class="keyword">int</span>&gt;-----------CV_32S</span><br><span class="line">Mat_&lt;<span class="keyword">float</span>&gt;----------CV_32F</span><br><span class="line">Mat_&lt;<span class="keyword">double</span>&gt;--------CV_64F</span><br><span class="line">    </span><br><span class="line">bit_depth 比特数，代表 <span class="number">8b</span>it，<span class="number">16b</span>its，<span class="number">32b</span>its，<span class="number">64b</span>it</span><br><span class="line">比如灰度图片，每一个像素点在内存空间所占的空间大小是<span class="number">8b</span>it，对应的就是CV_8</span><br><span class="line">S|U|F 数据类型</span><br><span class="line">S--代表---<span class="keyword">signed</span> <span class="keyword">int</span>---有符号整型</span><br><span class="line">U--代表--<span class="keyword">unsigned</span> <span class="keyword">int</span>--无符号整型</span><br><span class="line">F--代表--<span class="keyword">float</span>---------单精度浮点型</span><br><span class="line">C&lt;number_of_channels&gt; 代表一张图片的通道数,比如:</span><br><span class="line">灰度图片 ----------------------- 单通道图像</span><br><span class="line">RGB彩色图像 ----------------- <span class="number">3</span>通道图像</span><br><span class="line">带Alph通道的RGB图像 ----- <span class="number">4</span>通道图像</span><br></pre></td></tr></table></figure>

<p>例：多通道</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ROWS = <span class="number">100</span>; <span class="comment">// height</span></span><br><span class="line"><span class="keyword">int</span> COLS = <span class="number">200</span>; <span class="comment">// width</span></span><br><span class="line"><span class="function">Mat <span class="title">img1</span><span class="params">(ROWS , COLS , CV_8UC3)</span></span>;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROWS ; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COLS ; j++)  </span><br><span class="line">  &#123;  </span><br><span class="line">    img1.at&lt;vec3b&gt;(i,j)[<span class="number">0</span>]= <span class="number">3.2f</span>;  <span class="comment">// B 通道</span></span><br><span class="line">    img1.at&lt;vec3b&gt;(i,j)[<span class="number">1</span>]= <span class="number">3.2f</span>;  <span class="comment">// G 通道</span></span><br><span class="line">    img1.at&lt;vec3b&gt;(i,j)[<span class="number">2</span>]= <span class="number">3.2f</span>;  <span class="comment">// R 通道</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<p>注意:core.hpp中有关于vec3b等类型的定义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">2</span>&gt; Vec2b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">3</span>&gt; Vec3b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">4</span>&gt; Vec4b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; Vec2i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; Vec3i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt; Vec4i;</span><br></pre></td></tr></table></figure>

<h2 id="方式2：ptr-i-j-方式"><a href="#方式2：ptr-i-j-方式" class="headerlink" title="方式2：ptr(i) [j] 方式"></a>方式2：ptr<type>(i) [j] 方式</type></h2><p>Mat的ptr方法，返回&lt;&gt;中模板指定类型的指针，<br>[]类似于数组访问，得到</p>
<p>例：单通道</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ROWS = <span class="number">100</span>; <span class="comment">// height</span></span><br><span class="line"><span class="keyword">int</span> COLS = <span class="number">200</span>; <span class="comment">// width</span></span><br><span class="line"><span class="function">Mat <span class="title">img1</span><span class="params">(ROWS , COLS , CV_32FC1)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROWS ; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">float</span>* pData1=img5.ptr&lt;<span class="keyword">float</span>&gt;(i);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COLS ; j++)  </span><br><span class="line">  &#123;  </span><br><span class="line">    pData1[j] = <span class="number">3.2f</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例: 多通道</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ROWS = <span class="number">100</span>; <span class="comment">// height</span></span><br><span class="line"><span class="keyword">int</span> COLS = <span class="number">200</span>; <span class="comment">// width</span></span><br><span class="line"><span class="function">Mat <span class="title">img1</span><span class="params">(ROWS , COLS , CV_32FC3)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROWS ; i++)  </span><br><span class="line">&#123;  </span><br><span class="line">  vec3f* pData1=img5.ptr&lt;vec3f&gt;(i);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COLS ; j++)  </span><br><span class="line">  &#123;  </span><br><span class="line">    pData1[j][<span class="number">0</span>] = <span class="number">3.2f</span>;  </span><br><span class="line">    pData1[j][<span class="number">1</span>] = <span class="number">3.2f</span>;  </span><br><span class="line">    pData1[j][<span class="number">2</span>] = <span class="number">3.2f</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="char-转-vector-，opencv-解压"><a href="#char-转-vector-，opencv-解压" class="headerlink" title="char 转 vector ，opencv 解压"></a>char 转 vector ，opencv 解压</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">char</span>&gt;vecData_;</span><br><span class="line">vecData_.<span class="built_in">insert</span>(vecData_.<span class="built_in">end</span>(), Pic, Pic + nSize);</span><br><span class="line">cv::Mat _send = cv::<span class="built_in">imdecode</span>(vecData_, CV_LOAD_IMAGE_COLOR);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::filesystem;</span><br><span class="line"><span class="keyword">namespace</span> newfs = boost::filesystem;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat img_encode;</span><br><span class="line">    img_encode = <span class="built_in">imread</span>(<span class="string">&quot;../res/test.png&quot;</span>, CV_LOAD_IMAGE_COLOR);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//encode image and save to file</span></span><br><span class="line">    std::vector&lt;uchar&gt; data_encode;</span><br><span class="line">    <span class="built_in">imencode</span>(<span class="string">&quot;.png&quot;</span>, img_encode, data_encode);</span><br><span class="line">    <span class="function">std::string <span class="title">str_encode</span><span class="params">(data_encode.begin(), data_encode.end())</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function">path <span class="title">p</span><span class="params">(<span class="string">&quot;../res/imgencode_cplus.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">newfs::ofstream <span class="title">ofs</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(ofs.<span class="built_in">is_open</span>());</span><br><span class="line">    ofs &lt;&lt; str_encode;</span><br><span class="line">    ofs.<span class="built_in">flush</span>();</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//read image encode file and display</span></span><br><span class="line">    <span class="function">newfs::fstream <span class="title">ifs</span><span class="params">(p)</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(ifs.<span class="built_in">is_open</span>());</span><br><span class="line">    std::stringstream sstr;</span><br><span class="line">    <span class="keyword">while</span>(ifs &gt;&gt; sstr.<span class="built_in">rdbuf</span>());</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">    Mat img_decode;</span><br><span class="line">    std::string str_tmp = sstr.<span class="built_in">str</span>();</span><br><span class="line">    <span class="function">std::vector&lt;uchar&gt; <span class="title">data</span><span class="params">(str_tmp.begin(), str_tmp.end())</span></span>;</span><br><span class="line">    img_decode = <span class="built_in">imdecode</span>(data, CV_LOAD_IMAGE_COLOR);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;pic&quot;</span>,img_decode);</span><br><span class="line">    <span class="built_in">cvWaitKey</span>(<span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相机内部结构"><a href="#相机内部结构" class="headerlink" title="相机内部结构"></a>相机内部结构</h1><p><img src="/2021/07/13/opencv/0d965a865f13d3684fc3608041521792.JPEG" alt="img"></p>
<h2 id="成像平面"><a href="#成像平面" class="headerlink" title="成像平面"></a>成像平面</h2><p>像平面是指成像平面，比如你可以理解为用胶片相机拍摄，那个胶卷就是像平面，要是用数码相机拍摄那么像平面就是CCD等感光元件。</p>
<h2 id="光心"><a href="#光心" class="headerlink" title="光心"></a>光心</h2><p><img src="/2021/07/13/opencv/2fdda3cc7cd98d10fdc94c4a283fb80e7bec90a8" alt="img"></p>
<h2 id="光轴"><a href="#光轴" class="headerlink" title="光轴"></a>光轴</h2><p>主光轴：通过两个球面球心的直线。</p>
<p><img src="/2021/07/13/opencv/e850352ac65c10386e04e2deb9119313b07e89b7" alt="img"></p>
<h2 id="像主点"><a href="#像主点" class="headerlink" title="像主点"></a>像主点</h2><p>光点做成像单元垂线，交点为像主点</p>
<h1 id="相机成像原理"><a href="#相机成像原理" class="headerlink" title="相机成像原理"></a>相机成像原理</h1><p><img src="/2021/07/13/opencv/upload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<p>世界坐标系(world coordinate system)：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。是客观三维世界的绝对坐标系，也称客观坐标系。因为数码相机安放在三维空间中，我们需要世界坐标系这个基准坐标系来描述数码相机的位置，并且用它来描述安放在此三维环境中的其它任何物体的位置，用（Xw, Yw, Zw）表示其坐标值。</p>
<p>相机坐标系(camera coordinate system)（光心坐标系）：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位为m。以相机的光心为坐标原点，X 轴和Y 轴分别平行于图像坐标系的 X 轴和Y 轴，相机的光轴为Z 轴，用（Xc, Yc, Zc）表示其坐标值。</p>
<p>图像坐标系(image coordinate system)：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 以CCD 图像平面的中心为坐标原点，X轴和Y 轴分别平行于图像平面的两条垂直边，用( x , y )表示其坐标值。图像坐标系是用物理单位（例如毫米）表示像素在图像中的位置。</p>
<p>像素坐标系(pixel coordinate system)：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。单位为个（像素数目）。以 图像平面的左上角顶点为原点，X 轴和Y 轴分别平行于图像坐标系的 X 轴和Y 轴，用(u , v )表示其坐标值。数码相机采集的图像首先是形成标准电信号的形式，然后再通过模数转换变换为数字图像。每幅图像的存储形式是M × N的数组，M 行 N 列的图像中的每一个元素的数值代表的是图像点的灰度。这样的每个元素叫像素，像素坐标系就是以像素为单位的图像坐标系。</p>
<p><img src="/2021/07/13/opencv/20161210141741307" alt="img">****</p>
<h2 id="世界坐标系与相机坐标系–外参矩阵"><a href="#世界坐标系与相机坐标系–外参矩阵" class="headerlink" title="世界坐标系与相机坐标系–外参矩阵"></a>世界坐标系与相机坐标系–外参矩阵</h2><p><img src="/2021/07/13/opencv/20161210141917167" alt="img"></p>
<p>于是，从世界坐标系到相机坐标系，涉及到旋转和平移（其实所有的运动也可以用旋转矩阵和平移向量来描述）。绕着不同的坐标轴旋转不同的角度，得到相应的旋转矩阵，如下图所示：</p>
<p><img src="/2021/07/13/opencv/20161210142306747" alt="img"></p>
<p>那么从世界坐标系到相机坐标系的转换关系如下所示：</p>
<p><img src="/2021/07/13/opencv/20161210142437060" alt="img"></p>
<h2 id="相机坐标系与图像坐标系–内参矩阵"><a href="#相机坐标系与图像坐标系–内参矩阵" class="headerlink" title="相机坐标系与图像坐标系–内参矩阵"></a>相机坐标系与图像坐标系–内参矩阵</h2><p>从相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。</p>
<p><img src="/2021/07/13/opencv/20161210142740999" alt="img"></p>
<p>此时投影点p的单位还是mm，并不是pixel，需要进一步转换到像素坐标系。</p>
<blockquote>
<p>Oc是光点，p(x,y)所在平面为成像单元。</p>
</blockquote>
<h2 id="图像坐标系与像素坐标系–内参矩阵"><a href="#图像坐标系与像素坐标系–内参矩阵" class="headerlink" title="图像坐标系与像素坐标系–内参矩阵"></a>图像坐标系与像素坐标系–内参矩阵</h2><p>像素坐标系和图像坐标系都在成像平面上，只是各自的原点和度量单位不一样。图像坐标系的原点为相机光轴与成像平面的交点，通常情况下是成像平面的中点或者叫principal point。图像坐标系的单位是mm，属于物理单位，而像素坐标系的单位是pixel，我们平常描述一个像素点都是几行几列。所以这二者之间的转换如下：其中dx和dy表示每一列和每一行分别代表多少mm，即1pixel=dx mm</p>
<p><img src="/2021/07/13/opencv/20161210143514044" alt="img"></p>
<p>那么通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系的。</p>
<p><img src="/2021/07/13/opencv/20161210144703071" alt="img"></p>
<p>上述推导中有一个假设前提，就是相机的感光元件是正方形的，感光元件的安装也是通过光轴中心的，但这不可能，于是会出现以下两个问题：</p>
<blockquote>
<ol>
<li>感光元件的基本单元不是方的，一个方形物体可能最后成像为一个矩形（甚至会有斜切效果，一般可以不考虑斜切因素）；这导致上述表达式中，dx与dy不相等</li>
<li>感光元件的中心与光轴通过的主点不重合，会使得正常投影的图像发生了一点小小的位移。这导致上述表达式中，u0与v0可能并不等于成像传感器长宽尺寸的一半。（理想状态下就是一半）</li>
</ol>
</blockquote>
<p>或者只合并等式右边前两个矩阵，得到下式：</p>
<p><img src="/2021/07/13/opencv/20181014231908158" alt="img"></p>
<p>一般习惯将矩阵：</p>
<p><img src="/2021/07/13/opencv/20181014231925188" alt="img"></p>
<p>称为<strong>内参矩阵</strong>（少了一列0）。</p>
<blockquote>
<p>内参矩阵的参数含义：<br>f：焦距，单位毫米，</p>
<p>dx：像素x方向宽度，单位毫米，1/dx：x方向1毫米内有多少个像素</p>
<p>dy：像素y方向宽度，单位毫米，1/dy：y方向1毫米内有多少个像素</p>
<p><strong>f/dx：使用像素来描述x轴方向焦距的长度</strong></p>
<p><strong>f/dy：使用像素来描述y轴方向焦距的长度</strong></p>
<p><strong>u0,v0,像主点的实际位置，单位也是像素。</strong></p>
<p>一般把后四个参数称为内参</p>
</blockquote>
<p>内参矩阵反应了相机自身的属性，各个相机是一不一样的，需要标定才能知道这些参数。</p>
<p>最后用一幅图来总结从世界坐标系到像素坐标系（不考虑畸变）的转换关系：</p>
<p>​                                                                                          <img src="/2021/07/13/opencv/20190217141619847.png" alt="img"></p>
<h3 id="畸变参数"><a href="#畸变参数" class="headerlink" title="畸变参数"></a>畸变参数</h3><p><img src="/2021/07/13/opencv/20181205142610778.png" alt="img"></p>
<h4 id="径向畸变"><a href="#径向畸变" class="headerlink" title="径向畸变"></a>径向畸变</h4><p>径向畸变（桶形畸变和枕形畸变）产生原因：光线在远离透镜中心的地方偏折更大。矫正公式：</p>
<p><img src="/2021/07/13/opencv/image-20210823161431486.png" alt="image-20210823161431486"></p>
<p><img src="/2021/07/13/opencv/20181205142652925.png" alt="img"></p>
<h4 id="切向畸变"><a href="#切向畸变" class="headerlink" title="切向畸变"></a>切向畸变</h4><p>切向畸变产生原因：透镜不完全平行于图像平面。矫正公式：</p>
<p><img src="/2021/07/13/opencv/image-20210823161503898.png" alt="image-20210823161503898"></p>
<p>由此得到相机的5个畸变参数：D( k1 , k2 , k3 , p1 , p2 ) </p>
<h1 id="双目测距"><a href="#双目测距" class="headerlink" title="双目测距"></a>双目测距</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="视差"><a href="#视差" class="headerlink" title="视差"></a>视差</h3><p>在谈到双目成像时，首先出现的一个概念就是视差，网上有人用过一个很简单的形式来描述视差，即将人眼想象成双目相机，竖起一根手指放在前方作为目标，分别闭上左眼或右眼去观察目标，我们发现目标在不同成像平面中的位置移动了，这个像素位置的差异值就是视差。</p>
<p><img src="/2021/07/13/opencv/81b8d621f00afa4ea655a67f442add0c.png" alt="img"></p>
<p>在上面这张图中，左右两幅图分别表示左右相机的成像平面，假设一个目标在左视图的成像点落在第二列蓝色区域，在右视图的成像点落在第五列蓝色区域，视差值即为3。</p>
<h3 id="极点、极线、极平面"><a href="#极点、极线、极平面" class="headerlink" title="极点、极线、极平面"></a>极点、极线、极平面</h3><p><img src="/2021/07/13/opencv/731648eca31c226a4aead3acc6a8ad3b.png" alt="img"></p>
<p>假设空间一点P投影到左视图像平面上，成像点PL；投影到右视图像平面上，成像点PR。两个相机光心的连线CL-CR与像平面的交点eL和eR称为极点。物点P与左右相机光心CL、CR组成的平面称为极平面。而极平面与相机的像平面交线称为极线。</p>
<h3 id="极线约束"><a href="#极线约束" class="headerlink" title="极线约束"></a>极线约束</h3><p>指三维空间中一点P，当投影到左视图P’位置后，必然能在右视图的极线上匹配到该点。该约束将二维空间中的逐点搜索降维到一维直线上的搜索，减少了算法耗时并提高匹配精度。</p>
<h2 id="双目测距原理"><a href="#双目测距原理" class="headerlink" title="双目测距原理"></a>双目测距原理</h2><p><img src="/2021/07/13/opencv/v2-b071eefd97d760021666cbd9b0d443ba_720w.jpg" alt="img"></p>
<blockquote>
<p>左成像点：PL</p>
<p>右成像点：PR</p>
<p>左光心 OL</p>
<p>右光心 OR</p>
<p>景物点 P</p>
<p>基线b：两个摄像头光圈中心之间的距离</p>
<p>左侧像主点与左侧成像点距离 uL</p>
<p>右侧像主点与右侧成像点距离 |uR|：uR为负数，但是经过取绝对值后，就变成了整数</p>
<p>景物点与光心的距离 z</p>
<p>焦距f：像主点与光心的距离</p>
<p>视差d ：uL+|uR|</p>
<p>两个三角形 P-PL-PR 与 P-OL-OR</p>
<p>两个三角形之间是相似三角形关系</p>
<p>(b-uL-uR)/b=(z-f)/z 可推导出：z=fb/d 从而得出深度z</p>
</blockquote>
<p><img src="/2021/07/13/opencv/20180109101831618" alt="img"></p>
<p>上图中的人和椰子树，人在前，椰子树在后，最下方是双目相机中的成像。其中，右侧相机成像中人在树的左侧，左侧相机成像中人在树的右侧，这是因为双目的角度不一样。再通过对比两幅图像就可以知道人眼观察树的时候视差小，而观察人时视差大。因为树的距离远，人的距离近。这就是双目三角测距的原理。双目系统对目标物体距离感知是一种绝对的测量，而非估算。</p>
<h3 id="理想双目相机成像模型"><a href="#理想双目相机成像模型" class="headerlink" title="理想双目相机成像模型"></a>理想双目相机成像模型</h3><p><img src="/2021/07/13/opencv/20180109202525718" alt="img"></p>
<p><img src="/2021/07/13/opencv/20180109130121074" alt="img"></p>
<p>根据上述推导，<strong>要求得空间点P离相机的距离（深度）z</strong>，必须知道：<br>1、相机焦距f，左右相机基线b（可以通过先验信息或者相机标定得到）。<br>2、视差 ：<img src="/2021/07/13/opencv/20180109204250788" alt="img">，即左相机像素点(xl, yl)和右相机中对应点(xr, yr)的关系，这是双目视觉的核心问题。</p>
<h3 id="非理想情况"><a href="#非理想情况" class="headerlink" title="非理想情况"></a>非理想情况</h3><p>上面是两相机共面且光轴平行，参数相同的理想情况，当相机O1，O2不是在同一直线上怎么办呢？事实上，这种情况非常常见，因为有些场景下两个相机需要独立固定，很难保证光心完全水平，即使固定在同一个基板上也会由于装配的原因导致光心不完全水平，如下图所示：两个相机的极线不平行，并且不共面。</p>
<p><img src="/2021/07/13/opencv/20190528200527830.png" alt="img"></p>
<p>这种情况下拍摄的两张左右图片，如下图所示。</p>
<p>左图中三个十字标志的点，右图中对应的极线是右图中的三条白色直线，也就是对应的搜索区域。我们看到这三条直线并不是水平的，如果进行逐点搜索效率非常低。</p>
<p><img src="/2021/07/13/opencv/20180109130819436" alt="img"></p>
<h4 id="图像矫正技术"><a href="#图像矫正技术" class="headerlink" title="图像矫正技术"></a>图像矫正技术</h4><p>图像矫正包括畸变校正和立体校正两个过程。</p>
<p>图像的畸变校正通过张正友标定法计算出相机的4个内参fx，fy，cx，cy和5个畸变系数k1，k2，k3，p1，p2，进一步解决相机的枕形畸变和桶形畸变。</p>
<p>立体校正的过程是利用两颗相机之间的外参即旋转平移矩阵以及透视投影矩阵，对两幅图像进行极线校正，将图象平面重投影到平行于光心线的公共平面上，如下图所示，将原始的灰色像平面纠正到黄色位置。</p>
<p><img src="/2021/07/13/opencv/20180109130653942" alt="img"></p>
<p>经过图像矫正后，左图中的像素点只需要沿着水平的极线方向搜索对应点就可以了。从下图中我们可以看到三个点对应的视差（红色双箭头线段）是不同的，越远的物体视差越小，越近的物体视差越大。</p>
<p><img src="/2021/07/13/opencv/20180109130913869" alt="img"></p>
<p><img src="/2021/07/13/opencv/20180109224858677" alt="img"></p>
<p>上面的主要工作是在极线上寻找匹配点，但是由于要保证两个相机参数完全一致是不现实的，并且外界光照变化和视角不同的影响，使得单个像素点鲁棒性很差。所以匹配工作是一项很重要的事情，这也关系着双目视觉测距的准确性。</p>
<h4 id="对上述校准必要性的解释"><a href="#对上述校准必要性的解释" class="headerlink" title="对上述校准必要性的解释"></a>对上述校准必要性的解释</h4><p><img src="/2021/07/13/opencv/20180927142535616" alt="img"></p>
<p>图中可以得出的结论<br>1.深度变化(EG*EF/(AB+CD)或者H到EF的距离)，会导致AB,CD和AB+CD的变化，这里不过多强调AB,CD的变化，只讨论AB+CD，这个原因后边会提到。当深度变大时，AB+CD逐渐变小。<br>从公式（公式看不懂没关系，它只是我推导的，大家也可以自己推一下，推导是三角形的比例关系）<br>AC=EF-AB-DC<br>设Z为深度<br>那么AC/EF=(Z-EG)/Z<br>这样就可以推导出来了。<br><img src="/2021/07/13/opencv/2018092714340048" alt="img"></p>
<p>从这个图我们就可以明显看出只要我们的深度不变，那么我们的AB+CD也就不会改变，可以看出，深度和单独的AB与CD没有直接关系，而只与两者的和有关。</p>
<p>AB+CD 与同一距离的 视差 是想等的。  </p>
<p>AB + DC = XR - XT  </p>
<p>注意此处 AB DC 用向量相加  （AB + DC =  =  (Bx-Ax）+ (Cx - Dx)   【Bx 为左图像的中点x, Dx为右图像的中点x  Ax,Cx为两幅图同一特征点的x坐标】</p>
<p>XR - XT = XRx - XTx  (XRx 与 XTx 分别是两幅图同一特征点的x坐标)</p>
<h2 id="双目测距操作流程"><a href="#双目测距操作流程" class="headerlink" title="双目测距操作流程"></a>双目测距操作流程</h2><blockquote>
<p>双目测距实际操作分4个步骤：相机标定——双目校正——双目匹配——计算深度信息。</p>
</blockquote>
<p><strong>相机标定（得到内外参数）：</strong>摄像头由于光学透镜的特性使得成像存在着径向畸变，可由三个参数k1,k2,k3确定；由于装配方面的误差，传感器与光学镜头之间并非完全平行，因此成像存在切向畸变，可由两个参数p1,p2确定。单个摄像头的定标主要是计算出摄像头的内参（焦距f和成像原点cx,cy、五个畸变参数（一般只需要计算出k1,k2,p1,p2，对于鱼眼镜头等径向畸变特别大的才需要计算k3））以及外参（标定物的世界坐标）。而双目摄像头定标不仅要得出每个摄像头的内部参数，还需要通过标定来测量两个摄像头之间的相对位置（即右摄像头相对于左摄像头的旋转矩阵R、平移向量t）。</p>
<p><strong>双目校正（通过内参做畸变校正和立体校正将两张图片转换到同一平面）：</strong>双目校正是根据摄像头定标后获得的单目内参数据（焦距、成像原点、畸变系数）和双目相对位置关系（旋转矩阵和平移向量），分别对左右视图进行消除畸变和行对准，使得左右视图的成像原点坐标一致（CV_CALIB_ZERO_DISPARITY标志位设置时发生作用）、两摄像头光轴平行、左右成像平面共面、对极线行对齐。这样一幅图像上任意一点与其在另一幅图像上的对应点就必然具有相同的行号，只需在该行进行一维搜索即可匹配到对应点。</p>
<p><strong>双目匹配（对校正后的两张图片根据极线约束进行像素配准）：</strong>双目匹配的作用是把同一场景在左右视图上对应的像点匹配起来，这样做的目的是为了得到视差图。双目匹配被普遍认为是立体视觉中最困难也是最关键的问题。得到视差数据，通过上述原理中的公式就可以很容易的计算出深度信息。</p>
<p><strong>计算深度信息：</strong>根据配准结构计算每个像素的深度从而获得深度图</p>
<h3 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h3><p>相机标定的目的和意义<br>我们所处的世界是三维的，而照片是二维的，这样我们可以把相机认为是一个函数，输入量是一个场景，输出量是一幅灰度图。这个从三维到二维的过程的函数是不可逆的。</p>
<p>​                                  <img src="/2021/07/13/opencv/20190217111704113.png" alt="img"></p>
<p>相机标定的目标是我们找一个合适的数学模型，求出这个模型的参数，这样我们能够近似这个三维到二维的过程，使这个三维到二维的过程的函数找到反函数。</p>
<p><img src="/2021/07/13/opencv/20190217111736474.png" alt="img"></p>
<p>相机标定就是确定相机的内部参数和外部参数。就是从世界坐标系转换为相机坐标系，再由相机坐标系转换为图像坐标系的过程，也就是求最终的投影矩阵P的过程。</p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>对环境光照非常敏感。双目立体视觉法依赖环境中的自然光线采集图像，而由于光照角度变化、光照强度变化等环境因素的影响，拍摄的两张图片亮度差别会比较大，这会对匹配算法提出很大的挑战。</p>
<p><img src="/2021/07/13/opencv/20180110112507683" alt="img"></p>
<p><img src="/2021/07/13/opencv/20180110112525720" alt="img"></p>
<p>不适用于单调缺乏纹理的场景。由于双目立体视觉法根据视觉特征进行图像匹配，所以对于缺乏视觉特征的场景（如天空、白墙、沙漠等）会出现匹配困难，导致匹配误差较大甚至匹配失败。</p>
<p><img src="/2021/07/13/opencv/20180110112551527" alt="img"></p>
<p>计算复杂度高。该方法需要逐像素匹配；又因为上述多种因素的影响，为保证匹配结果的鲁棒性，需要在算法中增加大量的错误剔除策略，因此对算法要求较高，想要实现可靠商用难度大，计算量较大。</p>
<p>相机基线限制了测量范围。测量范围和基线（两个摄像头间距）关系很大：基线越大，测量范围越远；基线越小，测量范围越近。所以基线在一定程度上限制了该深度相机的测量范围。</p>
]]></content>
      <categories>
        <category>opencv 相机</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2021/07/13/python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p>10进制，</p>
<p>2进制，</p>
<p>0b10 -&gt;2</p>
<p>0b11 -&gt;3</p>
<p>8进制，</p>
<p>0o10 -&gt;8</p>
<p>0o11 -&gt;9</p>
<p>16进制</p>
<p>0x10 -&gt;16</p>
<p>0x11 -&gt;17</p>
<p>0x1F -&gt;1*16^1+15=31</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>转2进制</p>
<p>​    bin(XX)</p>
<p>转十进制</p>
<p>​    int float(python没有double)</p>
<p>转16进制</p>
<p>​    hex(XX)</p>
<p>转8进制</p>
<p>​    oct(XX)</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Number：int float bool </p>
<p>complex 复数:j  -&gt; 36j</p>
<p>序列：list tuple str</p>
<p>集合：set</p>
<p>字典：dict</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p>单双引号作用一样，三引号的作用是输出的时候回车</p>
</blockquote>
<p>转义字符：\ </p>
<p>原始字符串：r”XXX”</p>
<p>下标取字符</p>
<p><img src="/2021/07/13/python/image-20210814200710023.png" alt="image-20210814200710023"></p>
<p><img src="/2021/07/13/python/image-20210814200858992.png" alt="image-20210814200858992"></p>
<blockquote>
<p>字符串取某个范围内的值，[X:Y)，不包括结束的字符</p>
<p>[X:]，从索引为X开始后面所有的都输出</p>
<p>[:X]，从开始到索引为X的都输出</p>
</blockquote>
<p><img src="/2021/07/13/python/image-20210814201237177.png" alt="image-20210814201237177"></p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="列表list-有序-内存连续"><a href="#列表list-有序-内存连续" class="headerlink" title="列表list(有序-内存连续)"></a>列表list(有序-内存连续)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="元组tuple-有序-内存连续"><a href="#元组tuple-有序-内存连续" class="headerlink" title="元组tuple(有序-内存连续)"></a>元组tuple(有序-内存连续)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="序列的操作方式"><a href="#序列的操作方式" class="headerlink" title="序列的操作方式"></a>序列的操作方式</h3><p>内部元素均可支持不同类型</p>
<p>均可下标随机访问、切片访问</p>
<p>内容不会自动排序</p>
<p>均可执行+ 和 ×（+是追加，×是重复若干次）</p>
<blockquote>
<p>空列表：[]</p>
<p>空元组：()</p>
</blockquote>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>][<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;hello world,hello world &quot;</span>[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line"><span class="string">&#x27;hello &#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="not-in-、-in"><a href="#not-in-、-in" class="headerlink" title="not in 、 in"></a>not in 、 in</h3><p><img src="/2021/07/13/python/image-20210814202934878.png" alt="image-20210814202934878"></p>
<h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>长度</p>
<h3 id="max-min"><a href="#max-min" class="headerlink" title="max() min()"></a>max() min()</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="set-无序-内存不连续"><a href="#set-无序-内存不连续" class="headerlink" title="set(无序-内存不连续)"></a>set(无序-内存不连续)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">set</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>不重复（相当于key唯一）</p>
<h3 id="集合的操作方式"><a href="#集合的操作方式" class="headerlink" title="集合的操作方式"></a>集合的操作方式</h3><p>无序，没有索引，所以不支持切片访问和下标随机访问（这里的序指的是物理地址不是顺序的，但是内容是按大小顺序存放）</p>
<p>值会自动排序</p>
<p>支持-（剔除某个集合中的所有元素）</p>
<p>支持&amp;（求交集）</p>
<p>支持|（求并集）</p>
<blockquote>
<p>空集合：set()</p>
</blockquote>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="dict-key-value"><a href="#dict-key-value" class="headerlink" title="dict key-value"></a>dict key-value</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;key1:value1,key2:value2,key3:value3&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;c&quot;</span>:<span class="number">3</span>&#125;)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>不支持下标随机访问</p>
<p>key不会自动排序</p>
<p>不支持重复key</p>
<p>支持key访问（类似map）</p>
<p>支持不同类型的key同时存在，value可以是python的任何类型任何序列集合字典，但是key必须是不可变类型，比如int，str，tuple</p>
<blockquote>
<p>空字典：{}</p>
</blockquote>
<p><img src="/2021/07/13/python/image-20210814221659940.png" alt="image-20210814221659940"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">47</span>&#125; 集合</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">47</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">47</span>] 列表</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">47</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">24</span>:<span class="number">8</span>,<span class="number">8</span>:<span class="number">5</span>,<span class="number">3</span>:<span class="number">2</span>,<span class="number">4</span>:<span class="number">47</span>&#125; 字典</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">24</span>: <span class="number">8</span>, <span class="number">8</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">47</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/13/python/image-20210814224056565.png" alt="image-20210814224056565"></p>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="普通可变参数列表"><a href="#普通可变参数列表" class="headerlink" title="普通可变参数列表"></a>普通可变参数列表</h2><p><img src="/2021/07/13/python/image-20210814230439227.png" alt="image-20210814230439227"></p>
<p>tuple要用下面的关键字可变参数列表</p>
<h2 id="关键字可变参数列表"><a href="#关键字可变参数列表" class="headerlink" title="关键字可变参数列表"></a>关键字可变参数列表</h2><p><img src="/2021/07/13/python/image-20210814231026930.png" alt="image-20210814231026930"></p>
<p><img src="/2021/07/13/python/image-20210814231204548.png" alt="image-20210814231204548"></p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>局部变量变成全局变量</p>
<p><img src="/2021/07/13/python/image-20210814231842067.png" alt="image-20210814231842067"></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><img src="/2021/07/13/python/image-20210819195718719.png" alt="image-20210819195718719"></p>
<h3 id="实例变量，类变量，实例方法，类方法，静态方法"><a href="#实例变量，类变量，实例方法，类方法，静态方法" class="headerlink" title="实例变量，类变量，实例方法，类方法，静态方法"></a>实例变量，类变量，实例方法，类方法，静态方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="comment"># 类变量calcsum</span></span><br><span class="line">    private calcsum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化函数（构造函数）  self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value,score=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="comment"># 实例变量self.name</span></span><br><span class="line">        self.name = value</span><br><span class="line">        self.score = score</span><br><span class="line">        Student.calcsum+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 类成员函数,实例方法调用实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printftext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">        self.printftext1()<span class="comment">#类内部调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类成员函数,实例方法调用类变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printftext1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(Student.calcsum)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__.calcsum)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#类方法,@装饰器</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plus_sum</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (cls.calcsum)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#静态方法,@装饰器,不用传任何self或cls，只传需要的参数就行</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;静态方法可以访问类变量：&quot;</span>+<span class="built_in">str</span>(Student.calcsum)+<span class="string">&quot;,静态方法不可以访问实例变量：&quot;</span>)<span class="comment">#self.name</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line"><span class="comment"># -------------------------------------------------</span></span><br><span class="line">student1 = Student(<span class="string">&quot;A&quot;</span>,<span class="number">80</span>)  <span class="comment"># 实例变量，描述对象的变量，类外部调用</span></span><br><span class="line">student2 = Student(<span class="string">&quot;B&quot;</span>,<span class="number">90</span>)  <span class="comment"># 实例变量，描述对象的变量，类外部调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象访问实例变量:&quot;</span> + <span class="built_in">str</span>(student1.name))  <span class="comment"># 实例变量，描述对象的变量，类外部调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象访问实例变量:&quot;</span> + <span class="built_in">str</span>(student2.name))  <span class="comment"># 实例变量，描述对象的变量，类外部调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;类访问类变量:&quot;</span> + <span class="built_in">str</span>(Student.calcsum))  <span class="comment"># 类变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;类调用类方法:&quot;</span> + <span class="built_in">str</span>(Student.plus_sum()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象调用类方法:&quot;</span> + <span class="built_in">str</span>(student1.plus_sum()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;类调用静态方法:&quot;</span> + <span class="built_in">str</span>(Student.add(<span class="number">1</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象调用静态方法:&quot;</span> + <span class="built_in">str</span>(student1.add(<span class="number">1</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对象访问实例变量:A</span><br><span class="line">对象访问实例变量:B</span><br><span class="line">-------------------------------------</span><br><span class="line">类访问类变量:<span class="number">2</span></span><br><span class="line">-------------------------------------</span><br><span class="line">类调用类方法:<span class="number">2</span></span><br><span class="line">对象调用类方法:<span class="number">2</span></span><br><span class="line">-------------------------------------</span><br><span class="line">静态方法可以访问类变量：<span class="number">2</span>,静态方法不可以访问实例变量：</span><br><span class="line">类调用静态方法:<span class="number">3</span></span><br><span class="line">静态方法可以访问类变量：<span class="number">2</span>,静态方法不可以访问实例变量：</span><br><span class="line">对象调用静态方法:<span class="number">3</span></span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="comment"># 初始化函数（构造函数）  self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text=<span class="string">&quot;Enter object label&quot;</span></span>):</span></span><br><span class="line">        <span class="comment"># 实例变量self.name,和类相关，抽象化属于对象才有的应该存成实例变量</span></span><br><span class="line">        self.name = text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类成员函数，实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printftext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __________________________________________________</span></span><br><span class="line">student1 = Student(<span class="string">&quot;A&quot;</span>)  <span class="comment"># 实例变量，描述对象的变量</span></span><br><span class="line">student2 = Student(<span class="string">&quot;B&quot;</span>)  <span class="comment"># 实例变量，描述对象的变量</span></span><br><span class="line"><span class="built_in">print</span>(student1.name)  <span class="comment"># 实例变量，描述对象的变量</span></span><br><span class="line"><span class="built_in">print</span>(student2.name)  <span class="comment"># 实例变量，描述对象的变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname.__dict__</span><br><span class="line"><span class="comment">#对象或类的参数列表</span></span><br></pre></td></tr></table></figure>

<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="comment"># 类变量calcsum</span></span><br><span class="line">    calcsum = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化函数（构造函数）  self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="comment"># 实例变量self.name</span></span><br><span class="line">        self.name = value</span><br><span class="line">        self.__score = <span class="number">0</span><span class="comment">#self.__score私有变量，外部不能访问</span></span><br><span class="line">        Student.calcsum+=<span class="number">1</span></span><br><span class="line">    <span class="comment"># 类成员函数,实例方法调用实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">marking</span>(<span class="params">self,score</span>):</span></span><br><span class="line">        <span class="keyword">if</span> score&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;不能打负分&quot;</span>)</span><br><span class="line">        self.__score=score <span class="comment">#self.__score私有变量，外部不能访问</span></span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&quot;同学本次考试得分为：&quot;</span>+<span class="built_in">str</span>(self.__score))</span><br><span class="line"><span class="comment"># -------------------------------------------------</span></span><br><span class="line">student1 = Student(<span class="string">&quot;A&quot;</span>)  <span class="comment"># 实例变量，描述对象的变量，类外部调用</span></span><br><span class="line">student1.marking(<span class="number">80</span>)</span><br><span class="line">student1.__score=-<span class="number">1</span> <span class="comment">#在这里并不是对私有变量__score赋值，而是通过.运算符动态在对象student1中新增了一个参数__score</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象内部列表：&quot;</span>+ <span class="built_in">str</span>(student1.__dict__))<span class="comment">#_Student__score是对象内的私有变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象内私有变量为：&quot;</span>+<span class="built_in">str</span>(student1.__score))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------------------&quot;</span>)</span><br><span class="line">student2 = Student(<span class="string">&quot;B&quot;</span>)  <span class="comment"># 实例变量，描述对象的变量，类外部调用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象内部列表：&quot;</span>+ <span class="built_in">str</span>(student2.__dict__))<span class="comment">#_Student__score是对象内的私有变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;对象内私有变量为：&quot;</span>+<span class="built_in">str</span>(student2.__score)) <span class="comment">#在这里直接输出私有变量__score的值，发现无法访问</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A同学本次考试得分为：<span class="number">80</span></span><br><span class="line">对象内部列表：&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;_Student__score&#x27;</span>: <span class="number">80</span>, <span class="string">&#x27;__score&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line">对象内私有变量为：-<span class="number">1</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">对象内部列表：&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;_Student__score&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:\pythonProject\main.py&quot;</span>, line <span class="number">24</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;对象内私有变量为：&quot;</span>+<span class="built_in">str</span>(student2.__score)) <span class="comment">#在这里直接输出私有变量__score的值，发现无法访问</span></span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__score&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>():</span></span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name,score</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is parent class&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_homework</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is parent do_homework&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">People</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, school,name,score</span>):</span></span><br><span class="line">        self.school=school</span><br><span class="line">        <span class="comment">#父类的构造顺序由自己决定！下面两种方式都可以调用父类构造函数</span></span><br><span class="line">        <span class="comment"># People.__init__(self, name,score)</span></span><br><span class="line">        <span class="built_in">super</span>(Student,self).__init__(name,score)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is son class&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_homework</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Student, self).do_homework()</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;this is son do_homework&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过子类调用父类类变量：&quot;</span>+ <span class="built_in">str</span>(Student.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------------------&quot;</span>)</span><br><span class="line">student1 = Student(<span class="string">&quot;qd&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过对象调用父类类变量：&quot;</span>+<span class="built_in">str</span>(student1.<span class="built_in">sum</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过对象调用父类实例变量：&quot;</span>+<span class="built_in">str</span>(student1.name))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过对象调用父类实例变量：&quot;</span>+<span class="built_in">str</span>(student1.score))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过对象调用父类实例方法：&quot;</span>+<span class="built_in">str</span>(student1.getname()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------------------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过对象调用子类实例方法：&quot;</span>+<span class="built_in">str</span>(student1.do_homework()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过子类调用父类类变量：<span class="number">0</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">this <span class="keyword">is</span> parent <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">this</span> <span class="title">is</span> <span class="title">son</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">通过对象调用父类类变量：0</span></span><br><span class="line"><span class="class">通过对象调用父类实例变量：<span class="title">A</span></span></span><br><span class="line"><span class="class">通过对象调用父类实例变量：90</span></span><br><span class="line"><span class="class">-------------------------------------------------</span></span><br><span class="line"><span class="class">通过对象调用父类实例方法：<span class="title">A</span></span></span><br><span class="line"><span class="class">-------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="title">this</span> <span class="title">is</span> <span class="title">parent</span> <span class="title">do_homework</span></span></span><br><span class="line"><span class="class">通过对象调用子类实例方法：<span class="title">this</span> <span class="title">is</span> <span class="title">son</span> <span class="title">do_homework</span></span></span><br></pre></td></tr></table></figure>



<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>定义类成员函数，也就是实例方法（需要手动传入self的函数）的时候需要显式的填入self字段</p>
<p>在调用实例方法的时候，不需要传入self字段，类似于this指针</p>
<p>只和对象有关，和类没有关系，在调用的时候传入的是自身</p>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot=[]</span><br><span class="line">line=[]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;plot_306.txt&quot;</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line">    <span class="keyword">for</span> contents <span class="keyword">in</span> file_obj:</span><br><span class="line">        line=contents.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="comment"># print(line)</span></span><br><span class="line">        plot.append(line)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(plot))</span><br></pre></td></tr></table></figure>

<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;tianjin.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="comment"># 若是&#x27;wb&#x27;就表示写二进制文件</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> plot:</span><br><span class="line">    f.write(line)</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h1><h2 id="接收组播"><a href="#接收组播" class="headerlink" title="接收组播"></a>接收组播</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">SENDERIP = <span class="string">&#x27;192.168.30.251&#x27;</span></span><br><span class="line">MYPORT = <span class="number">10254</span></span><br><span class="line">MYGROUP = <span class="string">&#x27;239.192.43.78&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiver</span>():</span></span><br><span class="line">    <span class="comment"># create a UDP socket</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)</span><br><span class="line">    <span class="comment"># allow multiple sockets to use the same PORT number</span></span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Bind to the port that we know will receive multicast data</span></span><br><span class="line">    sock.bind((SENDERIP, MYPORT))</span><br><span class="line">    <span class="comment"># tell the kernel that we are a multicast socket</span></span><br><span class="line">    <span class="comment"># sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255)</span></span><br><span class="line">    <span class="comment"># Tell the kernel that we want to add ourselves to a multicast group</span></span><br><span class="line">    <span class="comment"># The address for the multicast group is the third param</span></span><br><span class="line">    status = sock.setsockopt(socket.IPPROTO_IP,</span><br><span class="line">                             socket.IP_ADD_MEMBERSHIP,</span><br><span class="line">                             socket.inet_aton(MYGROUP) + socket.inet_aton(SENDERIP));</span><br><span class="line"></span><br><span class="line">    sock.setblocking(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># ts = time.time()</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Receive data!&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;FROM: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    receiver()</span><br></pre></td></tr></table></figure>

<h2 id="代码查找进程并杀死"><a href="#代码查找进程并杀死" class="headerlink" title="代码查找进程并杀死"></a>代码查找进程并杀死</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line">pids=psutil.pids()</span><br><span class="line">lastpid=-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> pids:</span><br><span class="line">    p=psutil.Process(pid)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(<span class="string">&#x27;要查找的关键字&#x27;</span>) <span class="keyword">in</span> <span class="string">&#x27;,&#x27;</span>.join(p.cmdline()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cmd = &#x27;</span>,p.cmdline(),<span class="string">&#x27;,pid=&#x27;</span>,pid)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">        <span class="keyword">if</span> lastpid!=-<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">int</span>(lastpid)&lt;<span class="built_in">int</span>(pid):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.kill(lastpid,signal.SIGKILL)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;kill pid=&#x27;</span>,lastpid,<span class="string">&#x27;please wait 5 mins&#x27;</span>)</span><br><span class="line">                sys.stdout.flush()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">except</span> OSError.e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;No this Pid&#x27;</span>)</span><br><span class="line">        lastpid=pid</span><br><span class="line">time.sleep(<span class="number">5</span>)                    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="批处理，设置启动python脚本"><a href="#批处理，设置启动python脚本" class="headerlink" title="批处理，设置启动python脚本"></a>批处理，设置启动python脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span></span><br><span class="line">__conda_setup=<span class="string">&quot;<span class="subst">$(&#x27;/home/dell/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$__conda_setup</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;/home/dell/anaconda3/etc/profile.d/conda.sh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">&quot;/home/dell/anaconda3/etc/profile.d/conda.sh&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">&quot;/home/dell/anaconda3/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"># conda启动虚拟环境</span></span><br><span class="line">conda activate yolov5</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找进程并kill</span></span><br><span class="line"><span class="built_in">kill</span> -9 $(ps -ef | grep detect_202_uniview.py | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">kill</span> -9 $(ps -ef | grep detect_202_hikvision.py | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找服务启动脚本 </span></span><br><span class="line">CUDA_VISIBLE_DEVICES=1 python video_yolov5/detect_202_uniview.py &amp;                                     </span><br><span class="line">CUDA_VISIBLE_DEVICES=1 python video_yolov5/detect_202_hikvision.py </span><br></pre></td></tr></table></figure>

<h2 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件中的标准框，若无文件可省略此步骤，指定标注框</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop</span>(<span class="params">img,Points</span>):</span>    </span><br><span class="line">    <span class="comment"># 坐标点points</span></span><br><span class="line">    pts = np.array([Points])</span><br><span class="line">    <span class="comment"># 和原始图像一样大小的0矩阵，作为mask</span></span><br><span class="line">    mask = np.zeros(np.shape(img)[:<span class="number">2</span>], np.uint8)</span><br><span class="line">    <span class="comment"># 在mask上将多边形区域填充为白色</span></span><br><span class="line">    cv2.polylines(mask, pts, <span class="number">1</span>, <span class="number">255</span>)    <span class="comment"># 描绘边缘</span></span><br><span class="line">    cv2.fillPoly(mask, pts, <span class="number">255</span>)    <span class="comment"># 填充</span></span><br><span class="line">    <span class="comment"># 逐位与，得到裁剪后图像，此时是黑色背景</span></span><br><span class="line">    dst = cv2.bitwise_and(img, img, mask=mask)</span><br><span class="line">    <span class="comment"># 添加白色背景</span></span><br><span class="line">    bg = np.ones_like(img, np.uint8) * <span class="number">255</span></span><br><span class="line">    cv2.bitwise_not(bg, bg, mask=mask)  <span class="comment"># bg的多边形区域为0，背景区域为255</span></span><br><span class="line">    dst_white = bg + dst</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># cv2.imwrite(&quot;mask.jpg&quot;, mask)</span></span><br><span class="line">    <span class="comment"># cv2.imwrite(&quot;dst.jpg&quot;, dst)</span></span><br><span class="line">    cv2.imwrite(<span class="string">&quot;dst_white.jpg&quot;</span>, dst_white)</span><br><span class="line">    <span class="keyword">return</span> dst_white</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;1.png&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.shape(img))</span><br><span class="line">pts = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">327</span>, <span class="number">0</span>], [<span class="number">327</span>, <span class="number">249</span>], [<span class="number">200</span>, <span class="number">249</span>], [<span class="number">0</span>, <span class="number">110</span>]])</span><br><span class="line">crop(img,pts)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="字节bytes转16进制输出"><a href="#字节bytes转16进制输出" class="headerlink" title="字节bytes转16进制输出"></a>字节bytes转16进制输出</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字节列表以16进制格式打印数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_bytes_hex</span>(<span class="params">data</span>):</span></span><br><span class="line">    lin = [<span class="string">&#x27;%02X&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(lin))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试字节列表，这也是网络传输收到的原始类型</span></span><br><span class="line">arr = [<span class="number">0x4B</span>, <span class="number">0x43</span>, <span class="number">0x09</span>, <span class="number">0xA1</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0xAB</span>, <span class="number">0x4A</span>, <span class="number">0x43</span>]</span><br><span class="line">print_bytes_hex(arr)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">控制台输出：</span></span><br><span class="line"><span class="string">4B 43 09 A1 01 02 AB 4A 43</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="字符串转16进制输出"><a href="#字符串转16进制输出" class="headerlink" title="字符串转16进制输出"></a>字符串转16进制输出</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串或字符列表以16进制格式打印数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_string_hex</span>(<span class="params">data</span>):</span></span><br><span class="line">    lin = [<span class="string">&#x27;%02X&#x27;</span> % <span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(lin))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试字符串类型</span></span><br><span class="line">arr = <span class="string">&#x27;Work&#x27;</span></span><br><span class="line">print_string_hex(arr)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">控制台输出：</span></span><br><span class="line"><span class="string">57 6F 72 6B</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="字节byte转char"><a href="#字节byte转char" class="headerlink" title="字节byte转char"></a>字节byte转char</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_ascii</span>(<span class="params">h</span>):</span></span><br><span class="line">    list_s = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(h), <span class="number">2</span>):</span><br><span class="line">        list_s.append(<span class="built_in">chr</span>(<span class="built_in">int</span>(h[i:i+<span class="number">2</span>], <span class="number">16</span>)))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(list_s)</span><br></pre></td></tr></table></figure>

<h1 id="根据exe中起始和终止位置，替换字符串"><a href="#根据exe中起始和终止位置，替换字符串" class="headerlink" title="根据exe中起始和终止位置，替换字符串"></a>根据exe中起始和终止位置，替换字符串</h1><p><a href="https://blog.csdn.net/zh_YJ29/article/details/106043989">https://blog.csdn.net/zh_YJ29/article/details/106043989</a></p>
<p>需要先确定exe要替换的字符串在什么位置，可以通过在线工具查找文本的16进制，在notpad中搜索16进制所在的位置，计算长度，然后再输入</p>
<p><img src="/2021/07/13/python/软件安装包\notepad_二进制\运行.jpg" alt="运行"></p>
<p><img src="/2021/07/13/python/Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231201113332286.png" alt="image-20231201113332286"></p>
<p><img src="/2021/07/13/python/Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231201113444945.png" alt="image-20231201113444945"></p>
<p><img src="/2021/07/13/python/Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231201113501220.png" alt="image-20231201113501220"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*- </span></span><br><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"><span class="comment">#print(sys.argv)</span></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>]==<span class="string">&quot;-help&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[filepath] [start] [end] [strings]&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    FilePath=<span class="string">&#x27;/&#x27;</span>.join(sys.argv[<span class="number">1</span>].split(<span class="string">&#x27;\\&#x27;</span>))</span><br><span class="line">    Start=<span class="built_in">int</span>(sys.argv[<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">    End=<span class="built_in">int</span>(sys.argv[<span class="number">3</span>],<span class="number">16</span>)</span><br><span class="line">    OriStrLen=End-Start+<span class="number">1</span></span><br><span class="line">    Strings=sys.argv[<span class="number">4</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    StrLen=<span class="built_in">len</span>(Strings)</span><br><span class="line">    <span class="comment">#print(FilePath,Start,End,Strings)</span></span><br><span class="line">    NewFilePath=os.path.abspath(<span class="string">&#x27;.&#x27;</span>)+<span class="string">&quot;\\new.&quot;</span>+FilePath.split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#print(NewFilePath)</span></span><br><span class="line">    <span class="comment">#print(StrLen,OriStrLen)</span></span><br><span class="line">    <span class="keyword">if</span> StrLen &lt; OriStrLen:</span><br><span class="line">        f1=<span class="built_in">open</span>(FilePath,<span class="string">&quot;rb+&quot;</span>)</span><br><span class="line">        f2=<span class="built_in">open</span>(NewFilePath,<span class="string">&quot;wb+&quot;</span>)</span><br><span class="line">        s=f1.read()</span><br><span class="line">        f2.write(s)</span><br><span class="line">        f1.close()</span><br><span class="line">        f2.close()</span><br><span class="line">        f=<span class="built_in">open</span>(NewFilePath,<span class="string">&quot;rb+&quot;</span>)</span><br><span class="line">        f.seek(Start,<span class="number">0</span>)</span><br><span class="line">        FillStrings=sys.argv[<span class="number">4</span>]+<span class="string">&quot; &quot;</span>*(OriStrLen-StrLen)</span><br><span class="line">        bytes_FillStrings=FillStrings.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        f.write(bytes_FillStrings) </span><br><span class="line">        f.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eroor&quot;</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="struct包，类型对应"><a href="#struct包，类型对应" class="headerlink" title="struct包，类型对应"></a>struct包，类型对应</h1><table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">C Type</th>
<th align="left">Python 类型</th>
<th align="left">标准大小</th>
<th align="left">註解</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x</code></td>
<td align="left">填充字节</td>
<td align="left">无</td>
<td align="left"></td>
<td align="left">(7)</td>
</tr>
<tr>
<td align="left"><code>c</code></td>
<td align="left">char</td>
<td align="left">长度为 1 的字节串</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">signed char</td>
<td align="left">整数</td>
<td align="left">1</td>
<td align="left">(1), (2)</td>
</tr>
<tr>
<td align="left"><code>B</code></td>
<td align="left">unsigned char</td>
<td align="left">整数</td>
<td align="left">1</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">_Bool</td>
<td align="left">bool</td>
<td align="left">1</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>h</code></td>
<td align="left">short</td>
<td align="left">整数</td>
<td align="left">2</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>H</code></td>
<td align="left">unsigned short</td>
<td align="left">整数</td>
<td align="left">2</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>i</code></td>
<td align="left">int</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>I</code></td>
<td align="left">unsigned int</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left">long</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">unsigned long</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left">long long</td>
<td align="left">整数</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">unsigned long long</td>
<td align="left">整数</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>n</code></td>
<td align="left"><code>ssize_t</code></td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>N</code></td>
<td align="left"><code>size_t</code></td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>e</code></td>
<td align="left">(6)</td>
<td align="left">float</td>
<td align="left">2</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>f</code></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">char[]</td>
<td align="left">字节串</td>
<td align="left"></td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>p</code></td>
<td align="left">char[]</td>
<td align="left">字节串</td>
<td align="left"></td>
<td align="left">(8)</td>
</tr>
<tr>
<td align="left"><code>P</code></td>
<td align="left">void*</td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(5)</td>
</tr>
</tbody></table>
<p><em>在 3.3 版的變更:</em> 新增 <code>&#39;n&#39;</code> 與 <code>&#39;N&#39;</code> 格式的支援。</p>
<p><em>在 3.6 版的變更:</em> 新增 <code>&#39;e&#39;</code> 格式的支援。</p>
<p>註解：</p>
<ol>
<li><p><code>&#39;?&#39;</code> 转换码对应于 C99 对应的 _Bool 类型。 如此此类型不可用，则使用 char 来模块。 在标准模式下，它总是以一个字节表示。</p>
</li>
<li><p>当尝试使用任何整数转换码打包一个非整数时，如果该非整数具有 <a href="https://docs.python.org/zh-tw/dev/reference/datamodel.html#object.__index__"><code>__index__()</code></a> 方法，则会在打包之前将参数转换为一个整数。</p>
<p><em>在 3.2 版的變更:</em> 增加了用于非整数的 <a href="https://docs.python.org/zh-tw/dev/reference/datamodel.html#object.__index__"><code>__index__()</code></a> 方法。</p>
</li>
<li><p><code>&#39;n&#39;</code> 和 <code>&#39;N&#39;</code> 转换码仅对本机大小可用（选择为默认或使用 <code>&#39;@&#39;</code> 字节顺序字符）。 对于标准大小，你可以使用适合你的应用的任何其他整数格式。</p>
</li>
<li><p>对于 <code>&#39;f&#39;</code>, <code>&#39;d&#39;</code> 和 <code>&#39;e&#39;</code> 转换码，打包表示形式将使用 IEEE 754 binary32, binary64 或 binary16 格式 (分别对应于 <code>&#39;f&#39;</code>, <code>&#39;d&#39;</code> 或 <code>&#39;e&#39;</code>)，无论平台使用何种浮点格式。</p>
</li>
<li><p><code>&#39;P&#39;</code> 格式字符仅对本机字节顺序可用（选择为默认或使用 <code>&#39;@&#39;</code> 字节顺序字符）。 字节顺序字符 <code>&#39;=&#39;</code> 选择使用基于主机系统的小端或大端排序。 struct 模块不会将其解读为本机排序，因此 <code>&#39;P&#39;</code> 格式将不可用。</p>
</li>
<li><p>IEEE 754 binary16 “半精度” 类型是在 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision">IEEE 754 标准</a> 的 2008 修订版中引入的。 它包含一个符号位，5 个指数位和 11 个精度位（明确存储 10 位），可以完全精确地表示大致范围在 <code>6.1e-05</code> 和 <code>6.5e+04</code> 之间的数字。 此类型并不被 C 编译器广泛支持：在一台典型的机器上，可以使用 unsigned short 进行存储，但不会被用于数学运算。 请参阅维基百科页面 <a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half-precision floating-point format</a> 了解详情。</p>
</li>
<li><p>在打包时，<code>&#39;x&#39;</code> 会插入一个 NUL 字节。</p>
</li>
<li><p><code>&#39;p&#39;</code> 格式字符用于编码“Pascal 字符串”，即存储在由计数指定的 <em>固定长度字节</em> 中的可变长度短字符串。 所存储的第一个字节为字符串长度或 255 中的较小值。 之后是字符串对应的字节。 如果传入 <a href="https://docs.python.org/zh-tw/dev/library/struct.html#struct.pack"><code>pack()</code></a> 的字符串过长（超过计数值减 1），则只有字符串前 <code>count-1</code> 个字节会被存储。 如果字符串短于 <code>count-1</code>，则会填充空字节以使得恰好使用了 count 个字节。 请注意对于 <a href="https://docs.python.org/zh-tw/dev/library/struct.html#struct.unpack"><code>unpack()</code></a>，<code>&#39;p&#39;</code> 格式字符会消耗 <code>count</code> 个字节，但返回的字符串永远不会包含超过 255 个字节。</p>
</li>
<li><p>对于 <code>&#39;s&#39;</code> 格式字符，计数会被解读为字节的长度，而不是像其他格式字符那样的重复计数；例如，<code>&#39;10s&#39;</code> 表示一个与特定的 Python 字节串互相映射的长度为 10 的字节数据，而 <code>&#39;10c&#39;</code> 则表示个 10 个与十个不同的 Python 字节对象互相映射的独立的一字节字符元素 (如 <code>cccccccccc</code>)。 (其中的差别的具体演示请参见 <a href="https://docs.python.org/zh-tw/dev/library/struct.html#struct-examples">範例</a>。) 如果未给出计数，则默认值为 1。 对于打包操作，字节串会被适当地截断或填充空字节以符合尺寸要求。 对于解包操作，结果字节对象总是会恰好具有指定数量的字节。 作为特例，<code>&#39;0s&#39;</code> 表示单个空字节串 (而 <code>&#39;0c&#39;</code> 表示 0 个字符)。</p>
</li>
</ol>
<p>格式字符之前可以带有整数重复计数。 例如，格式字符串 <code>&#39;4h&#39;</code> 的含义与 <code>&#39;hhhh&#39;</code> 完全相同。</p>
<p>格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。</p>
<p>当使用某一种整数格式 (<code>&#39;b&#39;</code>, <code>&#39;B&#39;</code>, <code>&#39;h&#39;</code>, <code>&#39;H&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;I&#39;</code>, <code>&#39;l&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;q&#39;</code>, <code>&#39;Q&#39;</code>) 打包值 <code>x</code> 时，如果 <code>x</code> 在该格式的有效范围之外则将引发 <a href="https://docs.python.org/zh-tw/dev/library/struct.html#struct.error"><code>struct.error</code></a>。</p>
<p><em>在 3.1 版的變更:</em> 在之前版本中，某些整数格式包装了超范围的值并会引发 <a href="https://docs.python.org/zh-tw/dev/library/exceptions.html#DeprecationWarning"><code>DeprecationWarning</code></a> 而不是 <a href="https://docs.python.org/zh-tw/dev/library/struct.html#struct.error"><code>struct.error</code></a>。</p>
<p>对于 <code>&#39;?&#39;</code> 格式字符，返回值为 <a href="https://docs.python.org/zh-tw/dev/library/constants.html#True"><code>True</code></a> 或 <a href="https://docs.python.org/zh-tw/dev/library/constants.html#False"><code>False</code></a>。 在打包时将会使用参数对象的逻辑值。 以本机或标准 bool 类型表示的 0 或 1 将被打包，任何非零值在解包时将为 <code>True</code>。</p>
<h1 id="读取C-的dll"><a href="#读取C-的dll" class="headerlink" title="读取C++的dll"></a>读取C++的dll</h1><p>见Example下的python-&gt;ReadDll 或者  RTSP2UDP-&gt;RTSP 接收两路，python调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dll中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetMemByName</span><span class="params">(<span class="keyword">char</span> * schedual,<span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;------------start decode!file is &quot;</span>&lt;&lt;schedual;</span><br><span class="line">    </span><br><span class="line">    QString path = QString::<span class="built_in">fromStdString</span>(schedual);</span><br><span class="line">    QByteArray out = DataManager::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">loadData</span>(path);</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;&quot;---------------return size is &quot;&lt;&lt;out.size()&lt;&lt;ByteArrayToHexString(out);</span></span><br><span class="line">    *size = out.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;return size is &quot;</span>&lt;&lt;out.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes.util <span class="keyword">import</span> find_library</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_bytes_hex</span>(<span class="params">data</span>):</span></span><br><span class="line">    lin = [<span class="string">&#x27;%02X&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(lin))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dll_file = <span class="string">r&quot;decode_dll.dll&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(dll_file):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dll文件不存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    TZData = CDLL(dll_file, winmode=<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">    path = <span class="built_in">bytes</span>(<span class="string">&quot;./wind_20231213_00.Tz&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回值</span></span><br><span class="line">    TZData.GetMemByName.restype = POINTER(c_char_p)</span><br><span class="line">    <span class="comment"># TZData.GetMemByName.restype = c_void_p #这个也可以</span></span><br><span class="line">    <span class="comment">#参数</span></span><br><span class="line">    TZData.GetMemByName.argtypes = [c_char_p,POINTER(c_int)]</span><br><span class="line"></span><br><span class="line">    size = c_int(<span class="number">0</span>)</span><br><span class="line">    data= TZData.GetMemByName(path,byref(size))</span><br><span class="line">    b=string_at(data,size)</span><br><span class="line">    <span class="comment"># b = np.frombuffer(b,np.uint8)</span></span><br><span class="line">    <span class="comment"># print(size)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Get size is &quot;</span>,size.value,<span class="string">&quot;,data size is &quot;</span>,<span class="built_in">len</span>(b))</span><br><span class="line"></span><br><span class="line">    jdW=<span class="built_in">float</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">0</span>:<span class="number">2</span>])[<span class="number">0</span>])/<span class="number">100</span></span><br><span class="line">    jdH=<span class="built_in">float</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">2</span>:<span class="number">4</span>])[<span class="number">0</span>])/<span class="number">100</span></span><br><span class="line">    h=<span class="built_in">int</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">4</span>:<span class="number">6</span>])[<span class="number">0</span>])</span><br><span class="line">    maxlat=<span class="built_in">int</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">6</span>:<span class="number">8</span>])[<span class="number">0</span>])</span><br><span class="line">    minlat=<span class="built_in">int</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">8</span>:<span class="number">10</span>])[<span class="number">0</span>])</span><br><span class="line">    minlon=<span class="built_in">int</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">10</span>:<span class="number">12</span>])[<span class="number">0</span>])</span><br><span class="line">    maxlon=<span class="built_in">int</span>(struct.unpack(<span class="string">&quot;h&quot;</span>,b[<span class="number">12</span>:<span class="number">14</span>])[<span class="number">0</span>])</span><br><span class="line">    rowCount=<span class="built_in">int</span>((maxlon-minlon)/jdW+<span class="number">1</span>)</span><br><span class="line">    columnCount=<span class="built_in">int</span>((maxlat-minlat)/jdH+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------------header----------------------\n&quot;</span>,jdW,jdH,h,maxlat,minlat,maxlon,minlon,rowCount,columnCount,<span class="string">&quot;\n---------------------header----------------------\n&quot;</span>)</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;result.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) </span><br><span class="line">    b=b[<span class="number">14</span>:size.value]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(&quot;data size is &quot;,len(b),&quot;,need size is &quot;,rowCount*columnCount*8)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(b) == rowCount*columnCount*<span class="number">8</span> ):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,rowCount*columnCount):</span><br><span class="line">            <span class="comment"># print(index)</span></span><br><span class="line">            xx=<span class="built_in">float</span>(struct.unpack(<span class="string">&quot;f&quot;</span>,b[index*<span class="number">8</span>:index*<span class="number">8</span>+<span class="number">4</span>])[<span class="number">0</span>])*-<span class="number">1</span></span><br><span class="line">            yy=<span class="built_in">float</span>(struct.unpack(<span class="string">&quot;f&quot;</span>,b[index*<span class="number">8</span>+<span class="number">4</span>:index*<span class="number">8</span>+<span class="number">8</span>])[<span class="number">0</span>])*-<span class="number">1</span></span><br><span class="line">            f.write(<span class="built_in">str</span>(xx)+<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span>((index+<span class="number">1</span>) % columnCount == <span class="number">0</span>):</span><br><span class="line">                f.write(<span class="built_in">str</span>(yy)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f.write(<span class="built_in">str</span>(yy)+<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;data size is not right, data size is &quot;</span>,<span class="built_in">len</span>(b),<span class="string">&quot;,need size is &quot;</span>,rowCount*columnCount*<span class="number">8</span>)</span><br><span class="line">    f.close()   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="c语言支持的类型转换成python"><a href="#c语言支持的类型转换成python" class="headerlink" title="c语言支持的类型转换成python"></a>c语言支持的类型转换成python</h2><p><img src="/2021/07/13/python/image-20231218164630026.png" alt="image-20231218164630026"></p>
<h2 id="FileNotFoundError-Could-not-find-module-‘xxx-dll’-Try-using-the-full-path-with-constructor-syntax-调用ctypes库中dll报错问题解决、以及winerr-126找不到指定模块"><a href="#FileNotFoundError-Could-not-find-module-‘xxx-dll’-Try-using-the-full-path-with-constructor-syntax-调用ctypes库中dll报错问题解决、以及winerr-126找不到指定模块" class="headerlink" title="FileNotFoundError: Could not find module ‘xxx.dll’. Try using the full path with constructor syntax. 调用ctypes库中dll报错问题解决、以及winerr 126找不到指定模块"></a><a href="https://www.cnblogs.com/weixinyu98/p/17610972.html">FileNotFoundError: Could not find module ‘xxx.dll’. Try using the full path with constructor syntax. 调用ctypes库中dll报错问题解决、以及winerr 126找不到指定模块</a></h2><p><img src="/2021/07/13/python/1490994-20230807111508412-1960304852.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dumpbin /DEPENDENTS D:\sofeware\anaconda\envs\python38\Lib\site-packages\PySmartCard\ReaderLib_64.dll</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/13/python/1490994-20230807111723918-1058420167.png" alt="img"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2021/06/19/TCP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP–UDP"><a href="#TCP–UDP" class="headerlink" title="TCP–UDP"></a>TCP–UDP</h1><p>​        TCP提供了一个完全可靠的，面向连接的，全双工的（包含两个独立且方向相反的连接）流传输服务，允许两个应用程序建立一个连接，并在全双工的方向上发送数据，然后终止连接。每一个TCP连接都可靠的简历连接并完善的终止，在终止发生前，所有数据都会被可靠地传送。<br>​        TCP通信的客户端和服务端每次通信都会有3次握手的过程，这3次握手，确保数据能够准确地发送到对方。TCP通信是分为客户端和服务端的。</p>
<span id="more"></span>

<h2 id="TCP-Server-构建流程"><a href="#TCP-Server-构建流程" class="headerlink" title="TCP Server 构建流程"></a>TCP Server 构建流程</h2><p><img src="/2021/06/19/TCP/image-20210620150516236.png" alt="image-20210620150516236"></p>
<h2 id="TCP-client-构建流程"><a href="#TCP-client-构建流程" class="headerlink" title="TCP client 构建流程"></a>TCP client 构建流程</h2><p><img src="/2021/06/19/TCP/image-20210620150550615.png" alt="image-20210620150550615"></p>
<h2 id="Windows下API简介"><a href="#Windows下API简介" class="headerlink" title="Windows下API简介"></a>Windows下API简介</h2><h3 id="1-WSAStartup"><a href="#1-WSAStartup" class="headerlink" title="1 . WSAStartup"></a>1 . WSAStartup</h3><p>该函数用于初始化Ws2_32.dll动态链接库，在使用socket之前，一定要初始化该链接库。<br>初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData)<span class="comment">//第一个参数表示winsock的版本，本例使用的是winsock2.2版本。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-socket"><a href="#2-socket" class="headerlink" title="2 . socket"></a>2 . socket</h3><p>创建一个socket</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//af:一个地址家族，通常为AF_INET</span></span><br><span class="line"><span class="comment">//type:套接字类型，SOCK_STREAM表示创建面向流连接的套接字。为SOCK_DGRAM，表示创建面向无连接的数据包套接字。为SOCK_RAW，表示创建原始套接字</span></span><br><span class="line">    <span class="comment">//SOCK_STREAM Tcp 连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输</span></span><br><span class="line">    <span class="comment">//SOCK_DGRAM 支持 UDP 连接（无连接状态的消息）</span></span><br><span class="line">    <span class="comment">//SOCK_SEQPACKET 序列化包，提供一个序列化的、可靠的、双向的基本连接的数据传输通道，数据长度定常。每次调用读系统调用时数据需要将全部数据读出</span></span><br><span class="line">    <span class="comment">//SOCK_RAW RAW 类型，提供原始网络协议访问</span></span><br><span class="line">    <span class="comment">//SOCK_RDM 提供可靠的数据报文，不过可能数据会有乱序</span></span><br><span class="line">    <span class="comment">//SOCK_PACKET 这是一个专用类型，不能呢过在通用程序中使用</span></span><br><span class="line"><span class="comment">//返回值就是一个socket</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-bind"><a href="#3-bind" class="headerlink" title="3 . bind"></a>3 . bind</h3><p>该函数用于将套接字绑定到指定的端口和地址。<br>第一个参数为socket，第二个参数是一个结构指针，它包含了端口和IP地址信息，第三个参数表示缓冲区长度。需要说明的是，第二个参数在API中表示为：const struct sockaddr FAR*,这个语法结构我还没见过，网上说这是远指针，win16时期的产物，算是长见识了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line"> addrSrv.sin_family = AF_INET;</span><br><span class="line"> addrSrv.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>); <span class="comment">//1024以上的端口号</span></span><br><span class="line"> addrSrv.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//IP地址</span></span><br><span class="line"> <span class="built_in">bind</span>(sockSrv, (LPSOCKADDR)&amp;addrSrv, <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR_IN));</span><br></pre></td></tr></table></figure>

<h3 id="4-listen"><a href="#4-listen" class="headerlink" title="4 . listen"></a>4 . listen</h3><p>将socket设置为监听模式，服务端的socket特有。必须将服务端的socket设置为监听模式才能和服务端简历连接。<br>里面有两个参数，第一个参数为socket，第二个参数为等待连接最大队列的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen(sockSrv,10)</span><br></pre></td></tr></table></figure>

<h3 id="5-accept"><a href="#5-accept" class="headerlink" title="5 . accept"></a>5 . accept</h3><p>服务端socket接收客户端的连接请求，连接成功，则返回一个socket，该socket可以在服务端发送和接收数据。第一个参数为socket，第二个参数为包含客户端端口IP信息的sockaddr_in结构指针，第三个参数为接收参数addr的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR);</span><br><span class="line"><span class="built_in">accept</span>(sockSrv, (SOCKADDR *) &amp;addrClient, &amp;len);</span><br></pre></td></tr></table></figure>

<h3 id="6-closesocket"><a href="#6-closesocket" class="headerlink" title="6 . closesocket"></a>6 . closesocket</h3><p>关闭socket，里面的唯一的一个参数就是要关闭的socket。<br>7 . connect函数：客户端socket发送连接请求的函数，第一个参数是客户端的socket，第二个参数是一个结构体指针，里面包括连接主机的地址和ip，第三个参数为缓冲区的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockClient, (struct  sockaddr*)&amp;addrSrv, <span class="built_in"><span class="keyword">sizeof</span></span>(addrSrv));</span><br></pre></td></tr></table></figure>

<h3 id="8-htons"><a href="#8-htons" class="headerlink" title="8 . htons"></a>8 . htons</h3><p>将一个16位无符号短整型数据由主机排列方式转化为网络排列方式，htonl函数的作用恰好相反。</p>
<h3 id="9-recv"><a href="#9-recv" class="headerlink" title="9 . recv"></a>9 . recv</h3><p>接收数据，第一个参数为socket，第二个参数为接收数据缓冲区，第三个参数为缓冲区的长度，第四个参数为函数的调用方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">recv</span>(sockClient, buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="10-send"><a href="#10-send" class="headerlink" title="10 . send"></a>10 . send</h3><p>发送数据，里面的参数基本和recv（）一样。</p>
<h3 id="11-ioctlsocket"><a href="#11-ioctlsocket" class="headerlink" title="11 . ioctlsocket()"></a>11 . ioctlsocket()</h3><p>设置 socket 的模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctlsocket</span><span class="params">( <span class="keyword">int</span> s, <span class="keyword">long</span> cmd, u_long * argp)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//s：一个标识套接口的描述字。 </span></span><br><span class="line"><span class="comment">//cmd：对套接口 s 的操作命令。 </span></span><br><span class="line"><span class="comment">//argp：指向 cmd 命令所带参数的指针。</span></span><br><span class="line"></span><br><span class="line">cmd参数：</span><br><span class="line"></span><br><span class="line">	FIONBIO： </span><br><span class="line">	允许或禁止套接口 s 的非阻塞模式。argp 指向一个无符号长整型，如允许非阻塞模式则非零，如禁止非阻塞模式则为零。当创建一个套接口时，它就处于阻塞模式（也就是说非阻塞模式被禁止）。这与 BSD 套接口是一致的。<span class="built_in">WSAAsyncSelect</span> () 函数将套接口自动设置为非阻塞模式。如果已对一个套接口进行了 <span class="built_in">WSAAsyncSelect</span> () 操作，则任何用 <span class="built_in">ioctlsocket</span> () 来把套接口] 重新设置成阻塞模式的试图将以 WSAEINVAL 失败。为了把套接口重新设置成阻塞模式，应用程序必须首先用 <span class="built_in">WSAAsyncSelect</span> () 调用（IEvent 参数置为 <span class="number">0</span>）来禁止 <span class="built_in">WSAAsyncSelect</span> ()。 </span><br><span class="line">    </span><br><span class="line">    FIONREAD：</span><br><span class="line">	确定套接口 s 自动读入的数据量。argp 指向一个无符号长整型，其中存有 <span class="built_in">ioctlsocket</span> () 的返回值。如果 s 是 SOCKET_STREAM 类型，则 FIONREAD 返回在一次 <span class="built_in">recv</span> () 中所接收的所有数据量。这通常与套接口中排队的数据总量相同。如果 S 是 SOCK_DGRAM 型，则 FIONREAD 返回套接口上排队的第一个数据报大小。 </span><br><span class="line">    </span><br><span class="line">    SIOCATMARK：</span><br><span class="line">	确认是否所有的带外数据都已被读入。这个命令仅适用于 SOCK_STREAM 类型的套接口，且该套接口已被设置为可以在线接收带外数据（SO_OOBINLINE）。如无带外数据等待读入，则该操作返回 TRUE 真。否则的话返回 FALSE 假，下一个 <span class="built_in">recv</span> () 或 <span class="built_in">recvfrom</span> () 操作将检索 “标记” 前一些或所有数据。应用程序可用 SIOCATMARK 操作来确定是否有数据剩下。如果在 “紧急”（带外）数据 [前有常规数据，则按序接收这些数据（请注意，<span class="built_in">recv</span> () 和 <span class="built_in">recvfrom</span> () 操作不会在一次调用中混淆常规数据与带外数] 据）。argp 指向一个 BOOL 型数，<span class="built_in">ioctlsocket</span> () 在其中存入返回值。 </span><br></pre></td></tr></table></figure>

<p>设置非阻塞： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">u_long mode = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">ioctlsocket</span>(sockfd, FIONBIO, &amp;mode);<span class="comment">//设置非阻塞</span></span><br></pre></td></tr></table></figure>

<h3 id="12-端口复用"><a href="#12-端口复用" class="headerlink" title="12.端口复用"></a>12.端口复用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> optval = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">setsockopt</span>(pudp_recv-&gt;udp_recv_sd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;optval , <span class="built_in"><span class="keyword">sizeof</span></span>(optval)) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(pudp_recv-&gt;s_message,<span class="string">&quot;SetSocketOption:setsockopt(SO_REUSEADDR) error!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QAbstractSocket::bind</span><span class="params">(<span class="keyword">const</span> QHostAddress &amp;address, quint16 port = <span class="number">0</span>, BindMode mode = DefaultForPlatform)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QAbstractSocket::bind</span><span class="params">(quint16 port = <span class="number">0</span>, BindMode mode = DefaultForPlatform)</span></span></span><br><span class="line"><span class="function">    设置mode 为 QAbstractSocket::ReuseAddressHint即可</span></span><br></pre></td></tr></table></figure>

<h3 id="13-组播"><a href="#13-组播" class="headerlink" title="13.组播"></a>13.组播</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span><span class="comment">/*本机IP加入广播组*/</span></span><br><span class="line">mreq.imr_multiaddr.s_addr = <span class="built_in">inet_addr</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;AISNAVIP&quot;</span>).<span class="built_in">c_str</span>());<span class="comment">//广播地址</span></span><br><span class="line">mreq.imr_interface.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//网络接口为默认</span></span><br><span class="line"><span class="comment">/*将本机加入广播组*/</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">setsockopt</span>(sockClient, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="keyword">char</span>*)&amp;mreq, <span class="built_in"><span class="keyword">sizeof</span></span>(mreq));</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//QMessageBox::warning(NULL, &quot;Tip&quot;, QString::fromLocal8Bit(&quot;加入广播组错误！&quot;));</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*退出广播组*/</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="built_in">setsockopt</span>(sockClient, IPPROTO_IP, IP_DROP_MEMBERSHIP, (<span class="keyword">char</span>*)&amp;mreq, <span class="built_in"><span class="keyword">sizeof</span></span>(mreq));</span><br></pre></td></tr></table></figure>

<h4 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString listernIp, <span class="keyword">int</span> listernPort, QString destinationIp, <span class="keyword">int</span> destinationPort;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看是在什么情况下构造的，在线程中构造，需要在线程中释放，即以槽函数响应slot_deleteThread，否则，直接调用slot_deleteThread</span></span><br><span class="line">m_socket = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(m_listernIp.<span class="built_in">toString</span>().<span class="built_in">length</span>()&gt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ip_addr3_int =m_listernIp.<span class="built_in">toString</span>().<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">if</span>(ip_addr3_int&gt;=<span class="number">224</span> &amp;&amp; ip_addr3_int&lt;=<span class="number">239</span>)<span class="comment">//ip地址前3个数为224~239则为组播  224.0.0.0-239.255.255.255</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_socket-&gt;<span class="built_in">bind</span>(m_listernIp, m_listernPort ,QUdpSocket::ShareAddress))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_listernIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_listernPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_listernIp:&quot;</span>&lt;&lt;m_listernIp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">joinMulticastGroup</span>(<span class="built_in">QHostAddress</span>(m_listernIp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;joinMulticastGroup error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_listernIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_listernPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_listernIp:&quot;</span>&lt;&lt;m_listernIp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">bind</span>(m_listernIp, m_listernPort ,QUdpSocket::ShareAddress))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_listernIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_listernPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_listernIp:&quot;</span>&lt;&lt;m_listernIp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;m_myIp error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装TCPServer–Qt-C"><a href="#封装TCPServer–Qt-C" class="headerlink" title="封装TCPServer–Qt+C++"></a>封装TCPServer–Qt+C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore/QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QtCore/QThread&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//没有下面这句，所有的通讯函数都将报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//必须链接这个库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCP_C_Server</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TCP_C_Server</span>(<span class="keyword">const</span> QString &amp;hostName, <span class="keyword">int</span> port, QString tcpname, QObject *parent=<span class="literal">NULL</span>);</span><br><span class="line">    ~<span class="built_in">TCP_C_Server</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//外部调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="comment">//线程接收client消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recv_thread</span><span class="params">(QByteArray &amp;v)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> m_run = <span class="literal">true</span>;<span class="comment">//是否退出</span></span><br><span class="line">    vector&lt;vector&lt;QString&gt;&gt; m_socket;<span class="comment">//最多支持8个连接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_hostName;</span><br><span class="line">    quint16 m_port;</span><br><span class="line"></span><br><span class="line">    QString m_connName;<span class="comment">//当前TCP的名称</span></span><br><span class="line">    <span class="keyword">int</span> m_connectCnt = <span class="number">0</span>;<span class="comment">//连接状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd=<span class="number">-1</span>;<span class="comment">//TCP</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//内部中转，用线程发出去</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMessage</span><span class="params">(QByteArray str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部client数据发送给外部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_TCPreceive</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="comment">//日志发送外部显示</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendlog</span><span class="params">(string)</span></span>;</span><br><span class="line">    <span class="comment">//连接状态发送外部显示，个数+名称</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendConStatus</span><span class="params">(<span class="keyword">int</span>, QString)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//内部中转，用线程发出去</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_sendMsg</span><span class="params">(QByteArray array)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TCP_C_Server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在一个新的线程里面接收数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">void</span>  *param,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCP_C_Server *ptr = (TCP_C_Server *)param;</span><br><span class="line">    <span class="keyword">int</span> sockConn = ptr-&gt;m_socket[index][<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="keyword">char</span> *recvBuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;m_socket[index][<span class="number">0</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ptr-&gt;m_run)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(recvBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuf));</span><br><span class="line">        <span class="comment">//      //接收数据</span></span><br><span class="line">        ret = <span class="built_in">recv</span>(sockConn, recvBuf, <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ptr-&gt;<span class="built_in">recv_thread</span>(<span class="built_in">QByteArray</span>(recvBuf, ret));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;index = %d\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []recvBuf;</span><br><span class="line">    emit ptr-&gt;<span class="built_in">signal_sendlog</span>(<span class="string">&quot;break&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;break ,index = %d\n&quot;</span>, index);</span><br><span class="line">    <span class="built_in">closesocket</span>(sockConn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCP_C_Server::<span class="built_in">TCP_C_Server</span>(<span class="keyword">const</span> QString &amp;hostName, <span class="keyword">int</span> port, QString tcpname, QObject *parent):<span class="built_in">QThread</span>()</span><br><span class="line">&#123;</span><br><span class="line">    qRegisterMetaType&lt;std::string&gt;(<span class="string">&quot;std::string&quot;</span>);</span><br><span class="line">    m_hostName = hostName;</span><br><span class="line">    <span class="keyword">if</span> (m_hostName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        m_hostName = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_port = port;</span><br><span class="line">    m_connName = tcpname;</span><br><span class="line"></span><br><span class="line">    m_socket.<span class="built_in">resize</span>(<span class="number">8</span>, vector&lt;QString&gt;(<span class="number">3</span>,<span class="string">&quot;-1&quot;</span>));</span><br><span class="line">    <span class="comment">//构造函数中run</span></span><br><span class="line">    <span class="comment">//    start();</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;TCP_C_Server:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCP_C_Server::~<span class="built_in">TCP_C_Server</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_socket.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(m_socket[i][<span class="number">0</span>].<span class="built_in">toInt</span>());</span><br><span class="line">        m_socket[i][<span class="number">0</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        m_socket[i][<span class="number">1</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        m_socket[i][<span class="number">2</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">    sockfd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//构造函数中run</span></span><br><span class="line">    <span class="comment">//    this-&gt;quit();</span></span><br><span class="line">    <span class="comment">//	this-&gt;wait();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCP_C_Server::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;slot_startThread:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="comment">//内部中转，用线程发出去</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_sendMessage</span>(QByteArray)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_sendMsg</span>(QByteArray)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    WSADATA wsa;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa) != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsa.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsa.wVersion) != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">signal_sendlog</span><span class="params">(m_connName.toStdString() + <span class="string">&quot; Tcp socket error\n&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRecvBuf = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//设置为1MB</span></span><br><span class="line">    <span class="keyword">int</span> setoptret = <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;nRecvBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    setoptret = <span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;nRecvBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == setoptret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">signal_sendlog</span><span class="params">(m_connName.toStdString() + <span class="string">&quot; Tcp setsockopt SO_RCVBUF fail!\n&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;peeraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr_in));</span><br><span class="line">    peeraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//注意：linux要bind组播地址,而不是自己网卡的地址</span></span><br><span class="line">    peeraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(m_hostName.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>());<span class="comment">// htonl(INADDR_ANY); //inet_addr(udpReturnSrcIp);//inet_addr(config_file.udpReturnSrcIp);//htonl(INADDR_ANY); //inet_addr(&quot;192.168.1.153&quot;); //htonl(INADDR_ANY);</span></span><br><span class="line">    peeraddr.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bindRet = ::<span class="built_in">bind</span>(sockfd, (struct sockaddr *)(&amp;peeraddr), <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bindRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">signal_sendlog</span><span class="params">(m_connName.toStdString() + <span class="string">&quot; Tcp bind port error INADDR_ANY&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bindRet = <span class="built_in">listen</span>(sockfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (bindRet == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">signal_sendlog</span><span class="params">(m_connName.toStdString() + <span class="string">&quot; Tcp listen error&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">emit <span class="title">signal_sendlog</span><span class="params">(m_connName.toStdString() + <span class="string">&quot; wait Tcp for client linked in  &quot;</span> + std::to_string(m_port) + <span class="string">&quot;,&quot;</span> + m_hostName.toStdString())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lenaccept = <span class="built_in"><span class="keyword">sizeof</span></span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">c_address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m_run)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_socket[i][<span class="number">0</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> _soc= <span class="built_in">accept</span>(sockfd, (sockaddr *)(&amp;c_address), &amp;lenaccept);</span><br><span class="line">                <span class="keyword">if</span> (_soc &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_socket[i][<span class="number">0</span>] = QString::<span class="built_in">number</span>(_soc);</span><br><span class="line">                    m_socket[i][<span class="number">1</span>] = QString::<span class="built_in">fromLocal8Bit</span>(<span class="built_in">inet_ntoa</span>(c_address.sin_addr));</span><br><span class="line">                    m_socket[i][<span class="number">2</span>] = QString::<span class="built_in">number</span>(<span class="built_in">htons</span>(c_address.sin_port));</span><br><span class="line">                    <span class="function">emit <span class="title">signal_sendlog</span><span class="params">( m_connName.toStdString() +<span class="string">&quot; tcp &quot;</span> + m_socket[i][<span class="number">1</span>].toStdString() + <span class="string">&quot;:&quot;</span> + m_socket[i][<span class="number">2</span>].toStdString() + <span class="string">&quot; init success&quot;</span>)</span></span>;</span><br><span class="line">                    <span class="function">emit <span class="title">signal_sendConStatus</span><span class="params">(++m_connectCnt, m_connName)</span></span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//新开线程接收数据</span></span><br><span class="line">                    <span class="function">std::thread <span class="title">second</span><span class="params">(Fun, <span class="keyword">this</span>, i)</span></span>;</span><br><span class="line">                    second.<span class="built_in">detach</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCP_C_Server::sendMessage</span><span class="params">(QByteArray v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;sendMessage:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="keyword">if</span> (!m_run) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_socket.<span class="built_in">size</span>() != <span class="number">8</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">signal_sendMessage</span><span class="params">(v)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCP_C_Server::recv_thread</span><span class="params">(QByteArray&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;recv_thread &quot;</span> &lt;&lt; v&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="function">emit <span class="title">signal_TCPreceive</span><span class="params">(v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCP_C_Server::slot_sendMsg</span><span class="params">(QByteArray data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;slot_sendMsg:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="keyword">if</span> (!m_run) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*recvBuf = data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">int</span> len = data.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_socket[i][<span class="number">0</span>] != <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">send</span>(m_socket[i][<span class="number">0</span>].<span class="built_in">toInt</span>(), (<span class="keyword">char</span> *)recvBuf, len, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">emit <span class="title">signal_sendlog</span><span class="params">(m_connName.toStdString() + <span class="string">&quot; tcp &quot;</span> + m_socket[i][<span class="number">1</span>].toStdString() + <span class="string">&quot;:&quot;</span> + m_socket[i][<span class="number">2</span>].toStdString() + <span class="string">&quot;disconnected&quot;</span>)</span></span>;</span><br><span class="line">                m_socket[i][<span class="number">0</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">                m_socket[i][<span class="number">1</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">                m_socket[i][<span class="number">2</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">                <span class="function">emit <span class="title">signal_sendConStatus</span><span class="params">(--m_connectCnt, m_connName)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPSERVERCTEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPSERVERCTEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TCP_C_Server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServerCTest</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPServerCTest</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QThread *m_thread=<span class="literal">NULL</span>;</span><br><span class="line">    TCP_C_Server *m_pTCPmanager_ais=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//模拟退出</span></span><br><span class="line">    QTimer *m_timer=<span class="literal">NULL</span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMsg</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_deleteThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_UDPreceive</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPSERVERCTEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TCPServerCTest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">TCPServerCTest::<span class="built_in">TCPServerCTest</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    m_pTCPmanager_ais = <span class="keyword">new</span> <span class="built_in">TCP_C_Server</span>(<span class="string">&quot;192.168.30.251&quot;</span>, <span class="number">1547</span>,<span class="string">&quot;ais&quot;</span>);</span><br><span class="line">    m_pTCPmanager_ais-&gt;<span class="built_in">moveToThread</span>(m_thread);</span><br><span class="line">    <span class="built_in">connect</span>(m_pTCPmanager_ais, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_TCPreceive</span>(QByteArray)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_UDPreceive</span>(QByteArray)));</span><br><span class="line">    <span class="built_in">connect</span>(m_thread, <span class="built_in">SIGNAL</span>(<span class="built_in">started</span>()), m_pTCPmanager_ais, <span class="built_in">SLOT</span>(<span class="built_in">start</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(m_thread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), m_thread, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line">    m_thread-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟发送</span></span><br><span class="line">    m_timer=<span class="keyword">new</span> QTimer;</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">update</span>()));</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;test:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServerCTest::slot_UDPreceive</span><span class="params">(QByteArray value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;QString::<span class="built_in">fromStdString</span>(value.<span class="built_in">toStdString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServerCTest::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="function">QByteArray <span class="title">test</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    m_pTCPmanager_ais-&gt;<span class="built_in">sendMessage</span>(test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt++ &gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放</span></span><br><span class="line">        m_thread-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        m_thread-&gt;<span class="built_in">wait</span>();</span><br><span class="line">        <span class="keyword">delete</span> m_pTCPmanager_ais;</span><br><span class="line">        m_pTCPmanager_ais=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="封装TCPServer-–-Qt"><a href="#封装TCPServer-–-Qt" class="headerlink" title="封装TCPServer – Qt"></a>封装TCPServer – Qt</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcpclientsocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;structheader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tcpserver界面显示当前连接属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetMes</span>&#123;</span></span><br><span class="line">    qintptr m_description=<span class="number">-1</span>;</span><br><span class="line">    QString m_clientIP=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m_clientPort=<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> :</span> <span class="keyword">public</span> QTcpServer</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TCPServer</span>(QString hostName, <span class="keyword">int</span> port,QObject *parent=<span class="literal">NULL</span>);</span><br><span class="line">    ~<span class="built_in">TCPServer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QList&lt;TcpClientSocket*&gt; m_socket_list;</span><br><span class="line">    QList&lt;NetMes&gt; m_signalLlist;</span><br><span class="line">    QString m_hostName;</span><br><span class="line">    quint16 m_port;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//client连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incomingConnection</span><span class="params">(qintptr  socketDescriptor)</span></span>;<span class="comment">//只要出现一个新的连接，就会自动调用这个函数</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//接收client数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_getMessage</span><span class="params">(QByteArray,QString,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">//client主动断开连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_clientdisconnect</span><span class="params">(qintptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外部向client发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_sendMessage</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="comment">//外部向某个client发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_sendMessage</span><span class="params">(QByteArray,QString,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">//外部断开监听</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_Disconnected</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//server主动断开连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_Serverdisconnect</span><span class="params">(QString,QString)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//发送至外部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_TCPreceive</span><span class="params">(QByteArray,QString,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">//连接状态发送界面显示</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_ServerStatus</span><span class="params">(QList&lt;NetMes&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getclinetcount</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_socket_list.<span class="built_in">size</span>();&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPSERVER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TCPServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TCPServer::<span class="built_in">TCPServer</span>(QString hostName, <span class="keyword">int</span> port,QObject *parent):<span class="built_in">QTcpServer</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;&quot;TCPServer:&quot;&lt;&lt;QThread::currentThreadId();</span></span><br><span class="line">    m_hostName = hostName;</span><br><span class="line">    <span class="keyword">if</span>(m_hostName.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        m_hostName=QHostAddress::Any;</span><br><span class="line">    &#125;</span><br><span class="line">    m_port = port;</span><br><span class="line">    <span class="built_in">listen</span>(<span class="built_in">QHostAddress</span>(m_hostName), m_port); <span class="comment">//监听</span></span><br><span class="line">    qRegisterMetaType&lt;qintptr&gt;(<span class="string">&quot;qintptr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPServer::~<span class="built_in">TCPServer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::incomingConnection</span><span class="params">(qintptr  socketDescriptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;&quot;incomingConnection:&quot;&lt;&lt;QThread::currentThreadId();</span></span><br><span class="line">    TcpClientSocket *tcpclientsocket = <span class="keyword">new</span> <span class="built_in">TcpClientSocket</span>();<span class="comment">//只要有新的连接就生成一个新的通信套接字</span></span><br><span class="line">    <span class="comment">//将新创建的通信套接字描述符指定为参数socketdescriptor</span></span><br><span class="line">    tcpclientsocket-&gt;<span class="built_in">setSocketDescriptor</span>(socketDescriptor);</span><br><span class="line">    tcpclientsocket-&gt;m_description=socketDescriptor;</span><br><span class="line">    tcpclientsocket-&gt;m_clientIP = tcpclientsocket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>();</span><br><span class="line">    tcpclientsocket-&gt;m_clientPort=tcpclientsocket-&gt;<span class="built_in">peerPort</span>();</span><br><span class="line">    <span class="comment">//将这个套接字加入客户端套接字列表中</span></span><br><span class="line">    m_socket_list.<span class="built_in">append</span>(tcpclientsocket);</span><br><span class="line"></span><br><span class="line">    NetMes _net;</span><br><span class="line">    _net.m_description=socketDescriptor;</span><br><span class="line">    _net.m_clientIP = tcpclientsocket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>();</span><br><span class="line">    _net.m_clientPort=tcpclientsocket-&gt;<span class="built_in">peerPort</span>();</span><br><span class="line">    m_signalLlist.<span class="built_in">append</span>(_net);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收到tcpclientsocket发送过来的信号</span></span><br><span class="line">    <span class="built_in">connect</span>(tcpclientsocket, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_sendMessage</span>(QByteArray,QString,<span class="keyword">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_getMessage</span>(QByteArray,QString,<span class="keyword">int</span>)));</span><br><span class="line">    <span class="built_in">connect</span>(tcpclientsocket, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_clientdisconnected</span>(qintptr)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_clientdisconnect</span>(qintptr)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">signal_ServerStatus</span><span class="params">(m_signalLlist)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;A Client connect!&quot;</span>&lt;&lt;socketDescriptor&lt;&lt;<span class="string">&quot;,current list size is &quot;</span>&lt;&lt;m_socket_list.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::slot_getMessage</span><span class="params">(QByteArray msg,QString ip,<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;&quot;slot_getMessage:&quot;&lt;&lt;msg.size();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将这个信号发送给外部</span></span><br><span class="line">    <span class="function">emit <span class="title">signal_TCPreceive</span><span class="params">(msg ,ip,port)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在list中移除，销毁实际是在 TcpSocket 中触发销毁的时候就已经销毁了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::slot_clientdisconnect</span><span class="params">(qintptr descriptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;slot_clientdisconnect:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_socket_list.<span class="built_in">count</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        TcpClientSocket *item = m_socket_list.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;m_description == descriptor)</span><br><span class="line">        &#123;</span><br><span class="line">            m_socket_list[i]-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">            m_socket_list[i]-&gt;<span class="built_in">close</span>();</span><br><span class="line">            m_socket_list[i]-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">            m_socket_list.<span class="built_in">removeAt</span>(i);<span class="comment">//如果有客户端断开连接， 就将列表中的套接字删除</span></span><br><span class="line">            m_signalLlist.<span class="built_in">removeAt</span>(i);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;A Client disconnect!&quot;</span>&lt;&lt;descriptor&lt;&lt;<span class="string">&quot;,current list size is &quot;</span>&lt;&lt;m_socket_list.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">signal_ServerStatus</span><span class="params">(m_signalLlist)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::slot_Serverdisconnect</span><span class="params">(QString IP,QString port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_socket_list.<span class="built_in">count</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        TcpClientSocket *item = m_socket_list.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;m_clientIP == IP &amp;&amp; item-&gt;m_clientPort == port.<span class="built_in">toInt</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_socket_list[i]-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::slot_sendMessage</span><span class="params">(QByteArray value, QString ip , <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_socket_list.<span class="built_in">count</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QTcpSocket *item = m_socket_list.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;<span class="built_in">isValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(item-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>()==ip &amp;&amp; item-&gt;<span class="built_in">peerPort</span>()==port)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;dengdadsfasf=&quot;</span>&lt;&lt;QString::<span class="built_in">fromLocal8Bit</span>(value)&lt;&lt;m_socket_list.<span class="built_in">count</span>();</span><br><span class="line">                item-&gt;<span class="built_in">write</span>(value);</span><br><span class="line">                item-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">                item-&gt;<span class="built_in">flush</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i = 0; i &lt; m_socket_list.count(); i++)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        TcpClientSocket *item = m_socket_list.at(i);</span></span><br><span class="line"><span class="comment">//        if(item-&gt;m_clientIP == ip &amp;&amp; item-&gt;m_clientPort==port)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            qDebug()&lt;&lt;&quot;dengdadsfasf=&quot;&lt;&lt;QString::fromLocal8Bit(value);</span></span><br><span class="line"><span class="comment">//            item-&gt;write(value);</span></span><br><span class="line"><span class="comment">//            item-&gt;waitForBytesWritten();</span></span><br><span class="line"><span class="comment">//            item-&gt;flush();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::slot_sendMessage</span><span class="params">(QByteArray msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;&quot;slot_sendMessage:&quot;&lt;&lt;QThread::currentThreadId();</span></span><br><span class="line">    <span class="comment">//将收到的信息发送给每个客户端,从套接字列表中找到需要接收的套接字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_socket_list.<span class="built_in">count</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QTcpSocket *item = m_socket_list.<span class="built_in">at</span>(i);</span><br><span class="line">        item-&gt;<span class="built_in">write</span>(msg);</span><br><span class="line">        item-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">        item-&gt;<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServer::slot_Disconnected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;slot_Disconnected:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">    <span class="comment">//取消侦听</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接后会响应slot_clientdisconnect槽函数自动删除，所以不用在这删除了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_socket_list.<span class="built_in">count</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        QTcpSocket *item = m_socket_list.<span class="built_in">at</span>(i);</span><br><span class="line">        item-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">        item-&gt;<span class="built_in">close</span>();</span><br><span class="line">        item-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用来通信的类TcpClientSocket，用来保存客户端，有几个客户端就需要在server里创建几个，而且客户端的断开需要发送给服务端</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPCLIENTSOCKET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCLIENTSOCKET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpClientSocket</span> :</span> <span class="keyword">public</span> QTcpSocket</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT <span class="comment">//添加这个宏是为了实现信号和槽的通信</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TcpClientSocket</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMessage</span><span class="params">(QByteArray)</span></span>;<span class="comment">//用来告诉tcpserver接收的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_clientdisconnected</span><span class="params">(qintptr)</span></span>; <span class="comment">//告诉server有客户端断开连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    qintptr m_description=<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPCLIENTSOCKET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcpclientsocket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TcpClientSocket::<span class="built_in">TcpClientSocket</span>(QObject *parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//客户端发送数据过来就会触发readyRead信号</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;QTcpSocket::readyRead, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        emit <span class="built_in">signal_sendMessage</span>(<span class="built_in">readAll</span>());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;QTcpSocket::disconnected, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; m_description;</span><br><span class="line">        <span class="comment">//调用销毁信号，但是看实际情况，调用这个的时候就销毁了，会导致获取到的描述符为-1， 但是不会影响到其他地方</span></span><br><span class="line">        emit <span class="built_in">signal_clientdisconnected</span>(m_description);        <span class="comment">// 获取socket描述符</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="怎么使用-1"><a href="#怎么使用-1" class="headerlink" title="怎么使用"></a>怎么使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPSERVERTEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPSERVERTEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TCPServer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tcpserver界面显示当前连接属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetMes</span>&#123;</span></span><br><span class="line">    qintptr m_description=<span class="number">-1</span>;</span><br><span class="line">    QString m_clientIP=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m_clientPort=<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServerTest</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPServerTest</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    QThread *m_thread=<span class="literal">NULL</span>;</span><br><span class="line">    TCPServer *m_tcpServer=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//模拟退出</span></span><br><span class="line">    QTimer *m_timer=<span class="literal">NULL</span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMsg</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_deleteThread</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//外部向某个client发送数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMessage</span><span class="params">(QByteArray,QString,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">//server主动断开连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_Serverdisconnect</span><span class="params">(QString,QString)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_UDPreceive</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">     <span class="comment">//server连接状态接收并发送界面显示</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_ServerStatus</span><span class="params">(QList&lt;NetMes&gt;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPSERVERTEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TCPServerTest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TCPServerTest::<span class="built_in">TCPServerTest</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//    在线程中访问</span></span><br><span class="line">    m_thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    m_tcpServer= <span class="keyword">new</span> <span class="built_in">TCPServer</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">14521</span>);</span><br><span class="line">    m_tcpServer-&gt;<span class="built_in">moveToThread</span>(m_thread);</span><br><span class="line">    m_thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="built_in">connect</span>(m_tcpServer, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_TCPreceive</span>(QByteArray)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_UDPreceive</span>(QByteArray)));</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_sendMsg</span>(QByteArray)), m_tcpServer, <span class="built_in">SLOT</span>(<span class="built_in">slot_sendMessage</span>(QByteArray)));</span><br><span class="line">    qRegisterMetaType&lt;QList&lt;NetMes&gt;&gt;(<span class="string">&quot;QList&lt;NetMes&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_tcpServer, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_ServerStatus</span>(QList&lt;NetMes&gt;)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_ServerStatus</span>(QList&lt;NetMes&gt;)));</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_sendMessage</span>(QByteArray,QString,<span class="keyword">int</span>)), m_tcpServer, <span class="built_in">SLOT</span>(<span class="built_in">slot_sendMessage</span>(QByteArray,QString,<span class="keyword">int</span>)));</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_Serverdisconnect</span>(QString,QString)), m_tcpServer, <span class="built_in">SLOT</span>(<span class="built_in">slot_Serverdisconnect</span>(QString,QString)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟发送</span></span><br><span class="line">    m_timer=<span class="keyword">new</span> QTimer;</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">update</span>()));</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;test:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServerTest::slot_ServerStatus</span><span class="params">(QList&lt;NetMes&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    qDebug()&lt;&lt;&quot;---------------------------&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">count</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NetMes _net= t.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;++++++++++++++++++==&quot;</span>&lt;&lt;_net.m_clientIP+<span class="string">&quot;:&quot;</span>+QString::<span class="built_in">number</span>(_net.m_clientPort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//emit signal_ServerStatus(t);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServerTest::slot_UDPreceive</span><span class="params">(QByteArray value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;QString::<span class="built_in">fromStdString</span>(value.<span class="built_in">toStdString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPServerTest::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="function">QByteArray <span class="title">test</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">emit <span class="title">signal_sendMsg</span><span class="params">(test)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt++ &gt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        在线程中释放</span></span><br><span class="line">        <span class="function">emit <span class="title">signal_deleteThread</span><span class="params">()</span></span>;</span><br><span class="line">        m_thread-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        m_thread-&gt;<span class="built_in">wait</span>();</span><br><span class="line">        <span class="keyword">delete</span> m_tcpServer;</span><br><span class="line">        m_tcpServer=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="封装TCPClient-–-Qt"><a href="#封装TCPClient-–-Qt" class="headerlink" title="封装TCPClient – Qt"></a>封装TCPClient – Qt</h2><p> <a href="G:\MyC-Example\TCP_UDP_Example\tcp_thread.zip">tcp_thread.zip</a> </p>
<p>支持断线重连</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPMANAGER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPMANAGER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE_PTR(PTR) &#123;<span class="meta-keyword">if</span>(PTR)&#123;delete PTR;PTR = nullptr;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tcpmanager</span>:</span><span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tcpmanager</span>(<span class="keyword">const</span> QString &amp;hostName, quint16 port, QObject *parent = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">tcpmanager</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRunOn</span><span class="params">(<span class="keyword">bool</span> run)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_send</span><span class="params">(QByteArray str)</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newConnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readMessage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_disconnect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_connected</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayError</span><span class="params">(QAbstractSocket::SocketError)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_timeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_sendMessage</span><span class="params">(QByteArray str)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//说明：接受函数触发槽</span></span><br><span class="line">    <span class="comment">//参数：返回字节流。m_Msgdata</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_TCPreceive</span><span class="params">(QByteArray&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMessage</span><span class="params">(QByteArray str)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_stopTCP</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_status</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTcpSocket *m_tcp=<span class="literal">nullptr</span>;</span><br><span class="line">    QString m_hostName;</span><br><span class="line">    quint16 m_port;</span><br><span class="line">    QTimer* m_time=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">bool</span> isConnect=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> m_RunOn=<span class="literal">true</span>;<span class="comment">//是否无视模式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPMANAGER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcpmanager.h&quot;</span></span></span><br><span class="line">tcpmanager::<span class="built_in">tcpmanager</span>(<span class="keyword">const</span> QString &amp;hostName, quint16 port, QObject *parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">moveToThread</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-tcpmanager thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    m_hostName = hostName;</span><br><span class="line">    m_port = port;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tcpmanager::~<span class="built_in">tcpmanager</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-~tcpmanager thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;m_hostName&lt;&lt;<span class="string">&quot; has delete!&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">quit</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::setRunOn</span><span class="params">(<span class="keyword">bool</span> run)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_RunOn=run;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::readMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-readMessage thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QByteArray all = m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="keyword">if</span>(all.<span class="built_in">length</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//        qDebug()&lt;&lt;QString::fromLocal8Bit(all);</span></span><br><span class="line">        <span class="keyword">if</span>(m_RunOn)</span><br><span class="line">            <span class="function">emit <span class="title">signal_TCPreceive</span><span class="params">(all)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::slot_sendMessage</span><span class="params">(QByteArray str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-slot_sendMessage thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="keyword">if</span>(isConnect)</span><br><span class="line">    &#123;</span><br><span class="line">        m_tcp-&gt;<span class="built_in">write</span>(str,str.<span class="built_in">length</span>());</span><br><span class="line">        m_tcp-&gt;<span class="built_in">waitForBytesWritten</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::slot_send</span><span class="params">(QByteArray str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-slot_send thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="function">emit <span class="title">signal_sendMessage</span><span class="params">(str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::slot_disconnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-slot_disconnect thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;slot_disconnect&quot;</span>;<span class="comment">//输出错误信息</span></span><br><span class="line">    isConnect = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">emit <span class="title">signal_status</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::slot_connected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-Connected thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected OK.&quot;</span>;</span><br><span class="line">    isConnect = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">emit <span class="title">signal_status</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::displayError</span><span class="params">(QAbstractSocket::SocketError)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-displayError thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;m_tcp-&gt;<span class="built_in">errorString</span>();<span class="comment">//输出错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::slot_timeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-slot_timeout thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="keyword">if</span>(!isConnect)&#123;</span><br><span class="line">        m_tcp-&gt;<span class="built_in">abort</span>();<span class="comment">//取消之前的链接</span></span><br><span class="line">        <span class="comment">//查找地址和端口，建立连接</span></span><br><span class="line">        m_tcp-&gt;<span class="built_in">connectToHost</span>(m_hostName,m_port);</span><br><span class="line">        m_tcp-&gt;<span class="built_in">waitForConnected</span>(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::newConnect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-newConnect thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="keyword">if</span>(isConnect==<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m_tcp)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_tcp;</span><br><span class="line">        m_tcp=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_tcp = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>();</span><br><span class="line">    qRegisterMetaType&lt;QAbstractSocket::SocketError&gt;(<span class="string">&quot;QAbstractSocket::SocketError&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,<span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">readMessage</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,<span class="built_in">SIGNAL</span>(<span class="built_in">error</span>(QAbstractSocket::SocketError)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">displayError</span>(QAbstractSocket::SocketError)));</span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,<span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_disconnect</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(m_tcp,<span class="built_in">SIGNAL</span>(<span class="built_in">connected</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_connected</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,<span class="built_in">SIGNAL</span>(<span class="built_in">signal_sendMessage</span>(QByteArray)),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_sendMessage</span>(QByteArray)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcpmanager::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tcp-run thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="built_in">newConnect</span>();</span><br><span class="line">    m_time = <span class="keyword">new</span> <span class="built_in">QTimer</span>();</span><br><span class="line">    <span class="built_in">connect</span>(m_time, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_timeout</span>()),Qt::DirectConnection);</span><br><span class="line">    m_time-&gt;<span class="built_in">start</span>(<span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;m_hostName&lt;&lt;<span class="string">&quot; m_time has delete!&quot;</span>;</span><br><span class="line">    m_time-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">delete</span> m_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_tcp)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;m_hostName&lt;&lt;<span class="string">&quot; TCP disconnectFromHost!&quot;</span>;</span><br><span class="line">        m_tcp-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;m_hostName&lt;&lt;<span class="string">&quot; TCP close!&quot;</span>;</span><br><span class="line">        m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;m_hostName&lt;&lt;<span class="string">&quot; TCP delete!&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_tcp;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;m_hostName&lt;&lt;<span class="string">&quot; TCP nullptr!&quot;</span>;</span><br><span class="line">        m_tcp = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="怎么使用-2"><a href="#怎么使用-2" class="headerlink" title="怎么使用"></a>怎么使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcpmanager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">    tcpmanager *m_HDTTcp= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//模拟退出</span></span><br><span class="line">    QTimer *m_timer=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMsg</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_TCPreceive</span><span class="params">(QByteArray&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟发送</span></span><br><span class="line">    m_timer=<span class="keyword">new</span> QTimer;</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">update</span>()));</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::slot_TCPreceive</span><span class="params">(QByteArray &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;MainWindow-slot_TCPreceive thread is &quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;MainWindow::slot_TCPreceive:&quot;</span>&lt;&lt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_HDTTcp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="function">QByteArray <span class="title">test</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    m_HDTTcp-&gt;<span class="built_in">slot_send</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_HDTTcp = <span class="keyword">new</span> <span class="built_in">tcpmanager</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">5672</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_HDTTcp, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_TCPreceive</span>(QByteArray&amp;)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_TCPreceive</span>(QByteArray&amp;)), Qt::DirectConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> m_HDTTcp;</span><br><span class="line">    m_HDTTcp=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="封装UDP-Qt"><a href="#封装UDP-Qt" class="headerlink" title="封装UDP-Qt"></a>封装UDP-Qt</h2><p> <a href="TCP%5Cudpmanage.cpp">udpmanage.cpp</a> </p>
<p> <a href="TCP%5Cudpmanage.h">udpmanage.h</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UDPMANAGE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDPMANAGE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QUdpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// UDP 接收端 ， 服务端  监听</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UDPmanage</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//说明：构造函数自动开启监听。 </span></span><br><span class="line">	<span class="comment">//参数： 监听IP,监听端口,发送IP,发送端口。</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UDPmanage</span><span class="params">(QString myip, <span class="keyword">int</span> myport,  QString groupIP=<span class="string">&quot;&quot;</span> ,QString sendip=<span class="string">&quot;&quot;</span>, <span class="keyword">int</span> senport=<span class="number">10000</span>, QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">UDPmanage</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRunOn</span><span class="params">(<span class="keyword">bool</span> run)</span></span>;</span><br><span class="line">    QHostAddress m_groupIP=QHostAddress::Null;</span><br><span class="line">    QHostAddress m_myIp;</span><br><span class="line">    quint16 m_myPort;</span><br><span class="line">    QHostAddress m_Sendip;</span><br><span class="line">    quint16  m_Senport;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//  接收报文</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myreceive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(QByteArray array)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_deleteudp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">	<span class="comment">//说明：接受函数触发槽</span></span><br><span class="line">    <span class="comment">//参数：返回字节流。m_Msgdata</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_UDPreceive</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sig_deleteudp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	QUdpSocket* m_socket;</span><br><span class="line"></span><br><span class="line">    QByteArray m_Msgdata;    <span class="comment">//接受报文内容</span></span><br><span class="line">    <span class="keyword">bool</span> m_RunOn=<span class="literal">false</span>;<span class="comment">//是否无视模式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UDPMANAGE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;udpmanage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QNetworkAddressEntry&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line">UDPmanage::<span class="built_in">UDPmanage</span>(QString myip, <span class="keyword">int</span> myport,QString groupIP ,QString sendip<span class="comment">/*=&quot;&quot;*/</span>, <span class="keyword">int</span> senport<span class="comment">/*=1000*/</span>, QObject *parent <span class="comment">/*= 0*/</span>):<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_socket = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!myip.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//        myip = Cfg::get()-&gt;valS(&quot;LocalIP&quot;).c_str();</span></span><br><span class="line">        <span class="function">QHostAddress <span class="title">Ip</span><span class="params">(myip)</span></span>;</span><br><span class="line">        m_myIp = Ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m_myIp = QHostAddress::Any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(groupIP!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_groupIP=<span class="built_in">QHostAddress</span>(groupIP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_myPort = myport;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sendip.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QHostAddress <span class="title">Ip</span><span class="params">(sendip)</span></span>;</span><br><span class="line">        m_Sendip = Ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m_Sendip = QHostAddress::Any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;UDPmanage&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; endl;</span><br><span class="line">    m_Senport = senport;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,<span class="built_in">SIGNAL</span>(<span class="built_in">sig_deleteudp</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_deleteudp</span>()),Qt::QueuedConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UDPmanage::~<span class="built_in">UDPmanage</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_socket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;~UDPmanage&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; endl;</span><br><span class="line">        m_socket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">        m_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">delete</span> m_socket;</span><br><span class="line">        m_socket = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::slot_deleteudp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::setRunOn</span><span class="params">(<span class="keyword">bool</span> run)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_RunOn = run;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_socket == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_socket = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>()&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ip_addr3_int =m_groupIP.<span class="built_in">toString</span>().<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span>(m_groupIP!=QHostAddress::Null)<span class="comment">//ip地址前3个数为224~239则为组播  224.0.0.0-239.255.255.255</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!m_socket-&gt;<span class="built_in">bind</span>(m_groupIP, m_myPort ,QUdpSocket::ReuseAddressHint))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m_socket-&gt;<span class="built_in">setSocketOption</span>(QAbstractSocket::MulticastLoopbackOption,<span class="number">0</span>);</span><br><span class="line">                QList&lt;QNetworkInterface&gt; list = QNetworkInterface::<span class="built_in">allInterfaces</span>(); <span class="comment">//获取系统里所有的网络接口</span></span><br><span class="line">                foreach(QNetworkInterface intf, list)&#123; <span class="comment">//遍历所有接口</span></span><br><span class="line">                    <span class="comment">//intf.addressEntries()返回此接口拥有的IP地址列表及其相关的网掩码和广播地址。</span></span><br><span class="line">                    foreach(QNetworkAddressEntry entry, intf.<span class="built_in">addressEntries</span>())&#123;</span><br><span class="line">                        <span class="built_in">qDebug</span>()&lt;&lt;entry.<span class="built_in">ip</span>().<span class="built_in">toString</span>();</span><br><span class="line">                        <span class="keyword">if</span> (entry.<span class="built_in">broadcast</span>() != QHostAddress::Null &amp;&amp; entry.<span class="built_in">ip</span>() == m_myIp &amp;&amp; entry.<span class="built_in">ip</span>().<span class="built_in">protocol</span>() == QAbstractSocket::IPv4Protocol)&#123;</span><br><span class="line">                            m_socket-&gt;<span class="built_in">setMulticastInterface</span>(intf);</span><br><span class="line">                            <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">joinMulticastGroup</span>(<span class="built_in">QHostAddress</span>(m_groupIP),intf))</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;joinMulticastGroup error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">bind</span>(m_myIp, m_myPort ,QUdpSocket::ReuseAddressHint))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;m_myIp error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::myreceive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m_socket-&gt;<span class="built_in">hasPendingDatagrams</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//         qDebug()&lt;&lt;&quot;hasPendingDatagrams!&quot;&lt;&lt;endl;</span></span><br><span class="line">        m_Msgdata.<span class="built_in">resize</span>(m_socket-&gt;<span class="built_in">pendingDatagramSize</span>());</span><br><span class="line">        QHostAddress getIp;</span><br><span class="line">        quint16 getPort;</span><br><span class="line"></span><br><span class="line">        m_socket-&gt;<span class="built_in">readDatagram</span>(m_Msgdata.<span class="built_in">data</span>() ,m_Msgdata.<span class="built_in">size</span>() , &amp;getIp , &amp;getPort );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//         qDebug()&lt;&lt;&quot;hasPendingDatagrams!&quot;&lt;&lt;m_Msgdata&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//            if(m_RunOn)&#123;</span></span><br><span class="line">        <span class="function">emit <span class="title">signal_UDPreceive</span><span class="params">(m_Msgdata)</span></span>;</span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::sendMsg</span><span class="params">(QByteArray array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_socket-&gt;<span class="built_in">writeDatagram</span>(array , m_Sendip , m_Senport );</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;sendip&quot;&lt;&lt;m_Sendip.toString()&lt;&lt;&quot;port&quot;&lt;&lt;m_Senport;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;udpmanage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;qapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;CustomConfig.h&gt;</span></span></span><br><span class="line">UDPmanage::<span class="built_in">UDPmanage</span>(QString myip, <span class="keyword">int</span> myport ,QString sendip<span class="comment">/*=&quot;&quot;*/</span>, <span class="keyword">int</span> senport<span class="comment">/*=1000*/</span>, QObject *parent <span class="comment">/*= 0*/</span>):<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_socket = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!myip.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        myip = Cfg::get()-&gt;valS(&quot;LocalIP&quot;).c_str();</span></span><br><span class="line">        <span class="function">QHostAddress <span class="title">Ip</span><span class="params">(myip)</span></span>;</span><br><span class="line">        m_myIp = Ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m_myIp = QHostAddress::Any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m_myPort = myport;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sendip.<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QHostAddress <span class="title">Ip</span><span class="params">(sendip)</span></span>;</span><br><span class="line">        m_Sendip = Ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m_Sendip = QHostAddress::Any;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;UDPmanage&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; endl;</span><br><span class="line">    m_Senport = senport;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,<span class="built_in">SIGNAL</span>(<span class="built_in">sig_deleteudp</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_deleteudp</span>()),Qt::QueuedConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UDPmanage::~<span class="built_in">UDPmanage</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_socket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;~UDPmanage&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>()&lt;&lt; endl;</span><br><span class="line">        m_socket-&gt;<span class="built_in">disconnectFromHost</span>();</span><br><span class="line">        m_socket-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">delete</span> m_socket;</span><br><span class="line">        m_socket = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::slot_deleteudp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::setRunOn</span><span class="params">(<span class="keyword">bool</span> run)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_RunOn = run;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_socket == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_socket = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>()&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ip_addr3_int =m_myIp.<span class="built_in">toString</span>().<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span>(ip_addr3_int&gt;=<span class="number">224</span> &amp;&amp; ip_addr3_int&lt;=<span class="number">239</span>)<span class="comment">//ip地址前3个数为224~239则为组播  224.0.0.0-239.255.255.255</span></span><br><span class="line">            &#123;</span><br><span class="line">                string ip= Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;LocalIP&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(!m_socket-&gt;<span class="built_in">bind</span>(<span class="built_in">QHostAddress</span>(QString::<span class="built_in">fromStdString</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;LocalIP&quot;</span>))), m_myPort ,QAbstractSocket::ReuseAddressHint))</span><br><span class="line">                &#123;</span><br><span class="line">                    Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;bind error! ip is&quot;</span> + m_myIp.<span class="built_in">toString</span>().<span class="built_in">toStdString</span>());</span><br><span class="line">                    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">joinMulticastGroup</span>(<span class="built_in">QHostAddress</span>(m_myIp)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;joinMulticastGroup error!&quot;</span>);</span><br><span class="line">                    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;joinMulticastGroup error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">bind</span>(m_myIp, m_myPort ,QUdpSocket::ReuseAddressHint))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;m_myIp error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::myreceive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(m_socket-&gt;<span class="built_in">hasPendingDatagrams</span>() )</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//         qDebug()&lt;&lt;&quot;hasPendingDatagrams!&quot;&lt;&lt;endl;</span></span><br><span class="line">        m_Msgdata.<span class="built_in">resize</span>(m_socket-&gt;<span class="built_in">pendingDatagramSize</span>());</span><br><span class="line">        QHostAddress getIp;</span><br><span class="line">        quint16 getPort;</span><br><span class="line"></span><br><span class="line">        m_socket-&gt;<span class="built_in">readDatagram</span>(m_Msgdata.<span class="built_in">data</span>() ,m_Msgdata.<span class="built_in">size</span>() , &amp;getIp , &amp;getPort );</span><br><span class="line"></span><br><span class="line"><span class="comment">//         qDebug()&lt;&lt;&quot;hasPendingDatagrams!&quot;&lt;&lt;m_Msgdata&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;DataSource&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="function">emit <span class="title">signal_UDPreceive</span><span class="params">(m_Msgdata)</span></span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_RunOn)&#123;</span><br><span class="line">                emit <span class="built_in">signal_UDPreceive</span>(m_Msgdata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPmanage::sendMsg</span><span class="params">(QByteArray array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_socket-&gt;<span class="built_in">writeDatagram</span>(array , m_Sendip , m_Senport );</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;sendip&quot;&lt;&lt;m_Sendip.toString()&lt;&lt;&quot;port&quot;&lt;&lt;m_Senport;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="怎么使用-3"><a href="#怎么使用-3" class="headerlink" title="怎么使用"></a>怎么使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UDPManager.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">test</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//线程中使用</span></span><br><span class="line">    UDPManager *m_udpThread = <span class="literal">NULL</span>;</span><br><span class="line">    QThread *m_thread=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//主线程使用</span></span><br><span class="line">    UDPManager *m_udpSingle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//模拟退出</span></span><br><span class="line">    QTimer *m_timer=<span class="literal">NULL</span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_sendMsg</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal_deleteThread</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_UDPreceive</span><span class="params">(QByteArray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMetaType&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QByteArray&gt;</span></span></span><br><span class="line"></span><br><span class="line">test::<span class="built_in">test</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    在线程中访问</span></span><br><span class="line">    m_thread = <span class="keyword">new</span> QThread;</span><br><span class="line">    m_udpThread= <span class="keyword">new</span> <span class="built_in">UDPManager</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1452</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">5521</span>);</span><br><span class="line">    m_udpThread-&gt;<span class="built_in">moveToThread</span>(m_thread);</span><br><span class="line">    <span class="built_in">connect</span>(m_thread, <span class="built_in">SIGNAL</span>(<span class="built_in">started</span>()), m_udpThread, <span class="built_in">SLOT</span>(<span class="built_in">slot_startThread</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(m_thread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), m_thread, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line">    m_thread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="built_in">connect</span>(m_udpThread, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_UDPreceive</span>(QByteArray)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_UDPreceive</span>(QByteArray)));</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_sendMsg</span>(QByteArray)), m_udpThread, <span class="built_in">SLOT</span>(<span class="built_in">slot_sendMsg</span>(QByteArray)));</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signal_deleteThread</span>()), m_udpThread, <span class="built_in">SLOT</span>(<span class="built_in">slot_deleteThread</span>()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    直接调用</span></span><br><span class="line"><span class="comment">//    m_udpSingle= new UDPManager(&quot;127.0.0.1&quot;,1452,&quot;127.0.0.1&quot;,5521);</span></span><br><span class="line"><span class="comment">//    connect(m_udpSingle, SIGNAL(signal_UDPreceive(QByteArray)), this, SLOT(slot_UDPreceive(QByteArray)));</span></span><br><span class="line"><span class="comment">//    connect(this, SIGNAL(signal_sendMsg(QByteArray)), m_udpSingle, SLOT(slot_sendMsg(QByteArray)));</span></span><br><span class="line"><span class="comment">//    m_udpSingle-&gt;slot_startThread();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟发送</span></span><br><span class="line">    m_timer=<span class="keyword">new</span> QTimer;</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">update</span>()));</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;test:&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThreadId</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test::slot_UDPreceive</span><span class="params">(QByteArray value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;QString::<span class="built_in">fromStdString</span>(value.<span class="built_in">toStdString</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="function">QByteArray <span class="title">test</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">emit <span class="title">signal_sendMsg</span><span class="params">(test)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt++ &gt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        在线程中释放</span></span><br><span class="line">        <span class="function">emit <span class="title">signal_deleteThread</span><span class="params">()</span></span>;</span><br><span class="line">        m_thread-&gt;<span class="built_in">quit</span>();</span><br><span class="line">        m_thread-&gt;<span class="built_in">wait</span>();</span><br><span class="line">        <span class="keyword">delete</span> m_udpThread;</span><br><span class="line">        m_udpThread=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        直接释放</span></span><br><span class="line"><span class="comment">//        delete m_udpSingle;</span></span><br><span class="line"><span class="comment">//        m_udpSingle=NULL;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP函数-C"><a href="#UDP函数-C" class="headerlink" title="UDP函数-C++"></a>UDP函数-C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2ipdef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">splitWithStl</span><span class="params">(<span class="keyword">const</span> std::string &amp;str,<span class="keyword">const</span> std::string &amp;pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; resVec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span> == str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> resVec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方便截取最后一段数据</span></span><br><span class="line">    std::string strs = str + pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    <span class="keyword">size_t</span> size = strs.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string x = strs.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">        resVec.<span class="built_in">push_back</span>(x);</span><br><span class="line">        strs = strs.<span class="built_in">substr</span>(pos+<span class="number">1</span>,size);</span><br><span class="line">        pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resVec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载套接字库</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);<span class="comment">//错误会返回WSASYSNOTREADY</span></span><br><span class="line"><span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">1</span> ||     <span class="comment">//低字节为主版本</span></span><br><span class="line">   <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">1</span>)      <span class="comment">//高字节为副版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server is operating!\n\n&quot;</span>);</span><br><span class="line"><span class="comment">//创建用于监听的套接字</span></span><br><span class="line">sockSrv = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,<span class="number">0</span>);<span class="comment">//失败会返回 INVALID_SOCKET</span></span><br><span class="line"><span class="comment">//printf(&quot;Failed. Error Code : %d&quot;,WSAGetLastError())//显示错误信息</span></span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addrSrv;     <span class="comment">//定义sockSrv接收数据包的地址</span></span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(m_listernIp.<span class="built_in">data</span>());</span><br><span class="line">addrSrv.sin_family = AF_INET;</span><br><span class="line">addrSrv.sin_port = <span class="built_in">htons</span>(m_listernPort);</span><br><span class="line"></span><br><span class="line">addrClient.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(m_destinationIp.<span class="built_in">data</span>());<span class="comment">//输入你想通信的她（此处是本机内部）</span></span><br><span class="line">addrClient.sin_family = AF_INET;</span><br><span class="line">addrClient.sin_port = <span class="built_in">htons</span>(m_destinationPort);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否加入多播组</span></span><br><span class="line"><span class="keyword">bool</span> _inMember=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(m_listernIp.<span class="built_in">length</span>()&gt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">splitWithStl</span>(m_listernIp,<span class="string">&quot;.&quot;</span>).<span class="built_in">size</span>()!=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;m_myIp error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ip_addr3_int =<span class="built_in">atoi</span>(<span class="built_in">splitWithStl</span>(m_listernIp,<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>].<span class="built_in">data</span>());</span><br><span class="line">        <span class="keyword">if</span>(ip_addr3_int&gt;=<span class="number">224</span> &amp;&amp; ip_addr3_int&lt;=<span class="number">239</span>)<span class="comment">//ip地址前3个数为224~239则为组播  224.0.0.0-239.255.255.255</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//绑定套接字, 绑定到端口</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">bind</span>(sockSrv,(SOCKADDR*)&amp;addrSrv,<span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR))&lt;<span class="number">0</span>)<span class="comment">//会返回一个SOCKET_ERROR</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_listernIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_listernPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_listernIp:&quot;</span>&lt;&lt;m_listernIp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span><span class="comment">/*本机IP加入广播组*/</span></span><br><span class="line">            mreq.imr_multiaddr.s_addr = <span class="built_in">inet_addr</span>(m_listernIp.<span class="built_in">data</span>());<span class="comment">//广播地址</span></span><br><span class="line">            mreq.imr_interface.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//网络接口为默认</span></span><br><span class="line">            <span class="comment">/*将本机加入广播组*/</span></span><br><span class="line">            <span class="keyword">int</span> err = <span class="built_in">setsockopt</span>(sockSrv, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="keyword">char</span>*)&amp;mreq, <span class="built_in"><span class="keyword">sizeof</span></span>(mreq));</span><br><span class="line">            <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;joinMulticastGroup error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_listernIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_listernPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_listernIp:&quot;</span>&lt;&lt;m_listernIp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _inMember=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//绑定套接字, 绑定到端口</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">bind</span>(sockSrv,(SOCKADDR*)&amp;addrSrv,<span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR)) &lt; <span class="number">0</span>)<span class="comment">//会返回一个SOCKET_ERROR</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_listernIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_listernPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_listernIp:&quot;</span>&lt;&lt;m_listernIp;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m_myIp error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addrClient;   <span class="comment">//用来接收客户端的地址信息</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(SOCKADDR);</span><br><span class="line"><span class="keyword">char</span> recvBuf[<span class="number">1500</span>];    <span class="comment">//收</span></span><br><span class="line"><span class="keyword">char</span> sendBuf[<span class="number">1500</span>];    <span class="comment">//发</span></span><br><span class="line"><span class="keyword">char</span> tempBuf[<span class="number">1500</span>];    <span class="comment">//存储中间信息数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待并数据</span></span><br><span class="line">    <span class="built_in">recvfrom</span>(sockSrv,recvBuf,<span class="number">100</span>,<span class="number">0</span>,(SOCKADDR*)&amp;addrClient,&amp;len);</span><br><span class="line">    cout&lt;&lt;recvBuf&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input data: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span>(sendBuf);</span><br><span class="line">    <span class="built_in">sendto</span>(sockSrv,sendBuf,<span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>,<span class="number">0</span>,(SOCKADDR*)&amp;addrClient,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//****************************释放************************************</span></span><br><span class="line"><span class="keyword">if</span>(_inMember)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span><span class="comment">/*本机IP加入广播组*/</span></span><br><span class="line">    mreq.imr_multiaddr.s_addr = <span class="built_in">inet_addr</span>(m_listernIp.<span class="built_in">data</span>());<span class="comment">//广播地址</span></span><br><span class="line">    mreq.imr_interface.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//网络接口为默认</span></span><br><span class="line">    <span class="comment">/*退出广播组*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setsockopt</span>(sockSrv, IPPROTO_IP, IP_DROP_MEMBERSHIP, (<span class="keyword">char</span>*)&amp;mreq, <span class="built_in"><span class="keyword">sizeof</span></span>(mreq)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; leave membership error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">closesocket</span>(sockSrv);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br></pre></td></tr></table></figure>

<h1 id="多网卡下，C-UDP指定源组播收不到流"><a href="#多网卡下，C-UDP指定源组播收不到流" class="headerlink" title="多网卡下，C++UDP指定源组播收不到流"></a>多网卡下，C++UDP指定源组播收不到流</h1><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><ul>
<li><p>1、检查Linux系统是否接收到组播数据<br>使用tcpdump工具，检查源或者目的地址239.1.1.1:9001的数据包<br>tcpdump -i ens33 host 239.1.1.1 port 9001</p>
</li>
<li><p>2、关闭防火墙<br>暂时关闭：<br>systemctl stop firewalld<br>service iptables stop<br>永久关闭：<br>systemctl disable firewalld<br>chkconfig iptables off</p>
</li>
<li><p>3、修改/etc/sysctl.conf 文件中的 net.ipv4.conf.all.rp_filter 设置成0<br>sysctl -w net.ipv4.conf.all.rp_filter=0<br>echo “0”&gt;/proc/sys/net/ipv4/conf/all/rp_filter</p>
</li>
<li><p>4、添加组播地址路由：<br>route add -net 239.1.1.1 netmask 255.255.255.255 dev ens33</p>
</li>
</ul>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><ul>
<li>首先，指定源组播，linux 和windows编程稍微有些不同：</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">windows：bind的是接收网卡的地址（local_ip）和组播端口</span><br><span class="line">Linux：bind的是组播地址和组播端口</span><br></pre></td></tr></table></figure>

</blockquote>
<ul>
<li><p>对于一个网卡收流，其他网卡不用收流</p>
<pre><code>      现象1）：组播收不到流。
          原因：&quot;本地网卡的地址&quot;的IP地址是any了，如果默认IP不是要收组播的网卡IP，就会收不到流。
</code></pre>
<p>​              解决方法：把srcMreq.imr_interface.s_addr 改成本地IP，即可收到流。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq_source</span> <span class="title">srcMreq</span>;</span></span><br><span class="line">srcMreq.imr_multiaddr.s_addr = <span class="built_in">inet_addr</span>(muticast_ip.<span class="built_in">c_str</span>());<span class="comment">//组播地址</span></span><br><span class="line">srcMreq.imr_interface.s_addr = <span class="built_in">inet_addr</span>(local_ip.<span class="built_in">c_str</span>());<span class="comment">//本地网卡的地址</span></span><br><span class="line">srcMreq.imr_sourceaddr.s_addr = <span class="built_in">inet_addr</span>(src_ip.<span class="built_in">c_str</span>());<span class="comment">//组播的指定源地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; <span class="built_in">setsockopt</span>(h_sock, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP, (<span class="keyword">char</span>*)&amp;srcMreq, <span class="built_in"><span class="keyword">sizeof</span></span>(srcMreq)))</span><br><span class="line">&#123;undefined</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;setsockopt IP_ADD_SOURCE_MEMBERSHIP failed, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                现象2) ：可以收到组播流，但是接收一段时间，就收不到了。时间一般是路由器配置查询器的时间的2倍。            </p>
<p>​                            原因：网卡未添加组播路由，所以没有持续发IGMP包，所以路由器查询后，发现没有端口收流，就不继续往端口发流了            </p>
<p>​                                解决方法：route add -net 0.0.0.0 netmask 0.0.0.0 dev eth0 </p>
<ul>
<li><p>其次：对于要多网卡收流</p>
<pre><code>    现象描述：
                网卡1（192.168.100.71） ：可以收到组播地址的流（source 192.168.100.150）；网卡2（192.168.1.171）：收不到组播地址的流（source 192.168.100.150）
</code></pre>
<p>​                    原因： 网卡2发送不了IGMP的包，原因1.171不知道里没有100.150的路由，所以不知道往哪里发送，解决方法：route add -net 192.168.100.150 netmask 255.255.255.255 dev enp1s0f2，这样网卡2可以收到组播包，但是网卡1收不到组播包了。</p>
<p>因此要想多网卡都接收组播流，配置路由就不行了。</p>
<p>​        我还尝试了 sysctl -w net.ipv4.conf.all.rp_filter=2，当把所有网卡的的内核参数都设置2后，网卡enp1s0f2可以收到流了，但是收一段时间后，流就停了，用tcpdump -i enp1s0f2 igmp  -l -n -vv 观察，enp1s0f2仅仅收到交换机发送的igmp查询包，却没有enp1s0f2发送的IGMP的包（只有刚开始加入组的时候有两个IGMP的包，正常情况应该是加入的时候发送两个IGMP包，然后每隔一段时间，再发送一个IGMP包）。</p>
<p>​        后来运行下面的命令，就可以多网卡收流：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.conf.all.rp_filter=<span class="number">0</span></span><br><span class="line">cat /proc/sys/net/ipv4/conf/all/rp_filter</span><br><span class="line"></span><br><span class="line">切记：有几个网卡，就要执行几次sysctl -w net.ipv4.conf.网卡名.rp_filter=<span class="number">0</span>，每个网卡执行一下</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rp_filter参数详细介绍</span><br><span class="line">    rp_filter参数有三个值，<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>，具体含义：</span><br><span class="line">    <span class="number">0</span>：不开启源地址校验。</span><br><span class="line">    <span class="number">1</span>：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，  则直接丢弃该数据包。</span><br><span class="line">    <span class="number">2</span>：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不同，则直接丢弃该数据包</span><br></pre></td></tr></table></figure>


<p>​         如上所示，数据包发到了eth1网卡，如果这时候开启了rp_filter参数，并配置为1，则系统会严格校验数据包的反向路径。从路由表中可以看出，返回响应时数据包要从eth0网卡出，即请求数据包进的网卡和响应数据包出的网卡不是同一个网卡，这时候系统会判断该反向路径不是最佳路径，而直接丢弃该请求数据包。（业务进程也收不到该请求数据包）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTIxODA4Ny8yMDE3MDgvMTIxODA4Ny0yMDE3MDgyOTIwMDYyODQwNS0xMDI5NjkxNDgxLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    解决办法：</span><br><span class="line">    <span class="number">1.</span>修改路由表，使响应数据包从eth1出，即保证请求数据包进的网卡和响应数据包出的网卡为同一个网卡。</span><br><span class="line">    <span class="number">2.</span>关闭rp_filter参数。（注意all和<span class="keyword">default</span>的参数都要改）</span><br><span class="line">    <span class="number">1</span>)修改/etc/sysctl.conf文件，然后sysctl -p刷新到内存。</span><br><span class="line">    <span class="number">2</span>)使用sysctl -w直接写入内存：sysctl -w net.ipv4.conf.all.rp_filter=<span class="number">0</span></span><br><span class="line">    <span class="number">3</span>)修改/proc文件系统： echo <span class="string">&quot;0&quot;</span>&gt;/proc/sys/net/ipv4/conf/all/<span class="built_in">rp_filter</span>(需要进入root)</span><br><span class="line">rp_filters参数介绍来自 https:<span class="comment">//www.cnblogs.com/lipengxiang2009/p/7446388.html</span></span><br><span class="line">多网卡收同一个组播流，当rp_filter=<span class="number">0</span>时，每个网卡上收到两份数据</span><br></pre></td></tr></table></figure>

<pre><code>  把socket绑定网卡，让socket接收到该网卡的网络包
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">Ifreq</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(Ifreq.ifr_name, <span class="string">&quot;eth0&quot;</span>); <span class="comment">//这里指定使用那块网卡拉流 参数为网卡名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">setsockopt</span>(h_sock, SOL_SOCKET, SO_BINDTODEVICE, (<span class="keyword">char</span> *)&amp;Ifreq, <span class="built_in"><span class="keyword">sizeof</span></span>(Ifreq)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;<span class="function">undefined</span></span><br><span class="line"><span class="function">    <span class="title">perror</span><span class="params">(<span class="string">&quot;setsockopt():SO_BINDTODEVICE&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Qt（Linux）"><a href="#Qt（Linux）" class="headerlink" title="Qt（Linux）"></a>Qt（Linux）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( m_socket == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_socket = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>()&gt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ip_addr3_int =m_groupIP.<span class="built_in">toString</span>().<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>].<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_groupIP!=QHostAddress::Null)<span class="comment">//ip地址前3个数为224~239则为组播  224.0.0.0-239.255.255.255</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!m_socket-&gt;<span class="built_in">bind</span>(m_groupIP, m_myPort ,QUdpSocket::ShareAddress))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_socket-&gt;<span class="built_in">setSocketOption</span>(QAbstractSocket::MulticastLoopbackOption,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//绑定到具体的网卡</span></span><br><span class="line">            QList&lt;QNetworkInterface&gt; list = QNetworkInterface::<span class="built_in">allInterfaces</span>(); <span class="comment">//获取系统里所有的网络接口</span></span><br><span class="line">            foreach(QNetworkInterface intf, list)&#123; <span class="comment">//遍历所有接口</span></span><br><span class="line">                <span class="comment">//intf.addressEntries()返回此接口拥有的IP地址列表及其相关的网掩码和广播地址。</span></span><br><span class="line">                foreach(QNetworkAddressEntry entry, intf.<span class="built_in">addressEntries</span>())&#123;</span><br><span class="line">                    <span class="built_in">qDebug</span>()&lt;&lt;entry.<span class="built_in">ip</span>().<span class="built_in">toString</span>();</span><br><span class="line">                    <span class="keyword">if</span> (entry.<span class="built_in">broadcast</span>() != QHostAddress::Null &amp;&amp; entry.<span class="built_in">ip</span>() == m_myIp &amp;&amp; entry.<span class="built_in">ip</span>().<span class="built_in">protocol</span>() == QAbstractSocket::IPv4Protocol)&#123;</span><br><span class="line">                        m_socket-&gt;<span class="built_in">setMulticastInterface</span>(intf);</span><br><span class="line">                        <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">joinMulticastGroup</span>(<span class="built_in">QHostAddress</span>(m_groupIP),intf))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;joinMulticastGroup error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_socket-&gt;<span class="built_in">bind</span>(m_myIp, m_myPort ,QUdpSocket::ShareAddress))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">connect</span>(m_socket , <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()) , <span class="keyword">this</span>  , <span class="built_in">SLOT</span>(<span class="built_in">myreceive</span>())) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bind error!&quot;</span>&lt;&lt;<span class="string">&quot;IP:&quot;</span>&lt;&lt;m_myIp&lt;&lt;<span class="string">&quot;,PORT:&quot;</span>&lt;&lt;m_myPort&lt;&lt;<span class="string">&quot;,ip_addr3_int:&quot;</span>&lt;&lt;ip_addr3_int&lt;&lt;<span class="string">&quot;,m_myIp.toString():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>()&lt;&lt;<span class="string">&quot;,m_myIp.toString().length():&quot;</span>&lt;&lt;m_myIp.<span class="built_in">toString</span>().<span class="built_in">length</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;m_myIp error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">SENDERIP = <span class="string">&#x27;192.168.30.10&#x27;</span></span><br><span class="line">MYPORT = <span class="number">5684</span></span><br><span class="line">MYGROUP = <span class="string">&#x27;239.192.43.78&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiver</span>():</span></span><br><span class="line">    <span class="comment"># create a UDP socket</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)</span><br><span class="line">    <span class="comment"># allow multiple sockets to use the same PORT number</span></span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Bind to the port that we know will receive multicast data</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#windows</span></span><br><span class="line">    sock.bind((SENDERIP, MYPORT))</span><br><span class="line">    <span class="comment">#Linux</span></span><br><span class="line">    <span class="comment"># sock.bind((MYGROUP, MYPORT))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># tell the kernel that we are a multicast socket</span></span><br><span class="line">    <span class="comment"># sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255)</span></span><br><span class="line">    <span class="comment"># Tell the kernel that we want to add ourselves to a multicast group</span></span><br><span class="line">    <span class="comment"># The address for the multicast group is the third param</span></span><br><span class="line">    status = sock.setsockopt(socket.IPPROTO_IP,</span><br><span class="line">                             socket.IP_ADD_MEMBERSHIP,</span><br><span class="line">                             socket.inet_aton(MYGROUP) + socket.inet_aton(SENDERIP));</span><br><span class="line"></span><br><span class="line">    sock.setblocking(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># ts = time.time()</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Receive data!&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;FROM: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    receiver()</span><br></pre></td></tr></table></figure>

<h1 id="Qt与Python发送图片"><a href="#Qt与Python发送图片" class="headerlink" title="Qt与Python发送图片"></a>Qt与Python发送图片</h1><h2 id="Qt发送"><a href="#Qt发送" class="headerlink" title="Qt发送"></a>Qt发送</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString pic=<span class="string">&quot;图片路径&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> QImage vedioimg;</span><br><span class="line">vedioimg.<span class="built_in">load</span>(pic);</span><br><span class="line"></span><br><span class="line">QByteArray ba;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;ba)</span></span>;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">vedioimg.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;PNG&quot;</span>);</span><br><span class="line"></span><br><span class="line">QString sstr = <span class="string">&quot;video,&quot;</span>+::<span class="built_in">number</span>(ba.<span class="built_in">size</span>())+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">m_udp2-&gt;<span class="built_in">sendMsg</span>(sstr.<span class="built_in">toLocal8Bit</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=ba.<span class="built_in">size</span>()/<span class="number">40000</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ba.<span class="built_in">size</span>()-i*<span class="number">40000</span>&lt;<span class="number">40000</span>)&#123;</span><br><span class="line">        m_udp2-&gt;<span class="built_in">sendMsg</span>(ba.<span class="built_in">right</span>(ba.<span class="built_in">size</span>()-i*<span class="number">40000</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>()-&gt;<span class="built_in">msleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_udp2-&gt;<span class="built_in">sendMsg</span>(ba.<span class="built_in">mid</span>(i*<span class="number">40000</span>,<span class="number">40000</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>()-&gt;<span class="built_in">msleep</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="python接收"><a href="#python接收" class="headerlink" title="python接收"></a>python接收</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> imwrite</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">&#x27;192.168.30.10&#x27;</span>, <span class="number">17546</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2image</span>(<span class="params">byte_data</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    byte转为图片</span></span><br><span class="line"><span class="string">    byte_data: 二进制</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(io.BytesIO(byte_data))</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_visual_data</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;udp接收可见光图片线程&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;可见光图片接收线程已开启&quot;</span>)</span><br><span class="line">    cnt=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----------------------------------------------------&quot;</span>)</span><br><span class="line">        rec_data,addr = sock.recvfrom(<span class="number">50000</span>)  <span class="comment"># rec_data:接收到的数据、addr:发送数据的人的IP地址</span></span><br><span class="line">        <span class="keyword">if</span>  <span class="string">&quot;video&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">in</span> rec_data:</span><br><span class="line">            head_str = rec_data.decode()</span><br><span class="line">            head_list = head_str.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            head_type = head_list[<span class="number">0</span>]</span><br><span class="line">            data_size = <span class="built_in">int</span>(head_list[<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">print</span>(head_type + <span class="string">&quot;,&quot;</span> + <span class="built_in">str</span>(data_size))</span><br><span class="line">            data_total = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            recvd_size = <span class="number">0</span></span><br><span class="line">            rec_time = time.time()</span><br><span class="line">            <span class="keyword">if</span> head_type == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;ddddddd&quot;</span>)</span><br><span class="line">                <span class="keyword">while</span> recvd_size &lt; data_size:</span><br><span class="line">                    data,addr  = sock.recvfrom(<span class="number">40000</span>)</span><br><span class="line">                    <span class="keyword">if</span>  <span class="string">&quot;video&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">in</span> data:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;接收到不正确的flag-video&#x27;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">len</span>(data))</span><br><span class="line">                    recvd_size += <span class="built_in">len</span>(data)</span><br><span class="line">                    data_total += data</span><br><span class="line">                    <span class="keyword">if</span>  recvd_size == data_size:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;接收到了一张图片&#x27;</span>)</span><br><span class="line">                        cnt+=<span class="number">1</span></span><br><span class="line">                        rec_img = byte2image(data_total)</span><br><span class="line">                        rec_img.save(<span class="string">&quot;video&quot;</span>+ <span class="built_in">str</span>(cnt)+<span class="string">&quot;.png&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    receive_visual_data()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt</title>
    <url>/2021/06/27/Qt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="qt临时存储库"><a href="#qt临时存储库" class="headerlink" title="qt临时存储库"></a>qt临时存储库</h1><p><a href="https://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/windows_x86/root/qt/">https://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/windows_x86/root/qt/</a></p>
<p><a href="mailto:&#x7a;&#119;&#108;&#57;&#51;&#x31;&#x30;&#50;&#53;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;">&#x7a;&#119;&#108;&#57;&#51;&#x31;&#x30;&#50;&#53;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;</a>  Zhai123</p>
<h1 id="QT中QString-格式化-arg前面自动补0"><a href="#QT中QString-格式化-arg前面自动补0" class="headerlink" title="QT中QString 格式化 arg前面自动补0"></a>QT中QString 格式化 arg前面自动补0</h1><p>如这样的字符串： 00：01：23</p>
<p>将3个int转化为字符串时，使用arg的其它参数；</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString str = QString(&quot;%1:%2:%3&quot;).arg(0,2,10,QLatin1Char(&#x27;0&#x27;)).arg(1,2,10,QLatin1Char(&#x27;0&#x27;)) .arg(23,2,10,QLatin1Char(&#x27;0&#x27;));</span><br></pre></td></tr></table></figure>

<p>arg中第二个参数表示字符串的位数，第三个参数表示int的进制，第4个参数表示自动补全的字符；</p>
<p>如，改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString str = QString(&quot;%1:%2:%3&quot;).arg(0,4,10,QLatin1Char(&#x27;x&#x27;)).arg(1,2,10,QLatin1Char(&#x27;0&#x27;)) .arg(23,2,10,QLatin1Char(&#x27;0&#x27;));</span><br></pre></td></tr></table></figure>

<p>则输出为：xxx0:01:23</p>
<h1 id="手动生成moc"><a href="#手动生成moc" class="headerlink" title="手动生成moc"></a>手动生成moc</h1><p>Qt 程序在交由标准编译器编译之前，先要使用 moc 分析 C++ 源文件。如果它发现在一个头文件中包含了宏 Q_OBJECT，则会生成另外一个 C++ 源文件。这个源文件中包含了 Q_OBJECT 宏的实现代码。这个新的文件名字将会是原文件名前面加上 moc_ 构成。这个新的文件同样将进入编译系统，最终被链接到二进制代码中去。因此我们可以知道，这个新的文件不是“替换”掉旧的文件，而是与原文件一起参与编译。</p>
<p>vs2010集成Qt后，编译无法生成moc文件，此时可以采用手动方式生成：</p>
<p>在命令行下输入moc yourfilename.h -o moc_youfilename.cpp生成不带Q_OBJENT的源文件。</p>
<p> 下面给出例子手动生成moc的例子：</p>
<p>1、首先在运行窗口中输入cmd</p>
<p><img src="/2021/06/27/Qt/0.06866217441539683.png" alt="img"></p>
<p>2、在cmd中输入：cd  C:\Qt\4.7.4\bin进入Qt安装目录，如下图：</p>
<p><img src="/2021/06/27/Qt/0.5271939532118008.png" alt="img"></p>
<p>3、输入：moc “E:\03 Code\QUnitTest\DlgFindDialog.h” -o “E:\03 Code\QUnitT</p>
<p>est\moc_DlgFindDialog.cpp” 后回车</p>
<p><img src="/2021/06/27/Qt/0.20485906613358248.png" alt="img"></p>
<p>4、打开E:\03 Code\QUnitTest，moc_DlgFindDialog.cpp已经生成</p>
<p><img src="/2021/06/27/Qt/0.6527109725512811.png" alt="img"></p>
<p>5、到此moc文件已经生成完毕。</p>
<h1 id="编译rcc"><a href="#编译rcc" class="headerlink" title="编译rcc"></a>编译rcc</h1><p>资源修改步骤<br>1，在项目里加入resource.qrc使用，增加资源放开注释<br>RESOURCES += <br>    resource/resource.qrc<br>2，添加并正常使用资源<br>3，更新资源二进制文件resource.rcc，在resource文件夹里cmd执行<br>rcc –binary resource.qrc -o resource.rcc<br>4，在项目中删除resource.qrc，注释掉，重新编译项目</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pro中注释</span><br><span class="line">#RESOURCES += resource/resource.qrc</span><br><span class="line">程序的main文件中加：</span><br><span class="line">QResource::<span class="built_in">registerResource</span>(<span class="string">&quot;./resource/resource.rcc&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="qimage-创建背景色透明"><a href="#qimage-创建背景色透明" class="headerlink" title="qimage 创建背景色透明"></a>qimage 创建背景色透明</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> QImage _image(m_pImgProvider-&gt;img.<span class="built_in">size</span>(),m_pImgProvider-&gt;img.format());</span><br><span class="line">QImage  mask = _image.<span class="built_in">createMaskFromColor</span>((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),Qt::MaskOutColor);</span><br><span class="line">_image.<span class="built_in">setAlphaChannel</span>(mask);</span><br></pre></td></tr></table></figure>

<h1 id="QPainter-设置线形，填充，笔帽，圆点"><a href="#QPainter-设置线形，填充，笔帽，圆点" class="headerlink" title="QPainter 设置线形，填充，笔帽，圆点"></a>QPainter 设置线形，填充，笔帽，圆点</h1><p><img src="/2021/06/27/Qt/1da2b7ee-dc93-48cd-ae1f-33428210c629.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> QPen pen1;</span><br><span class="line">pen1.<span class="built_in">setCapStyle</span>(Qt::PenCapStyle::RoundCap);</span><br><span class="line">pen1.<span class="built_in">setColor</span>(Qt::red);</span><br><span class="line">pen1.<span class="built_in">setWidth</span>(<span class="number">20</span>);</span><br><span class="line">painter.<span class="built_in">setPen</span>(pen1);</span><br><span class="line">painter.<span class="built_in">drawPoint</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h1 id="随鼠标进入现实图片放大"><a href="#随鼠标进入现实图片放大" class="headerlink" title="随鼠标进入现实图片放大"></a>随鼠标进入现实图片放大</h1><p>.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHOWICONWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOWICONWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowIconWidget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ShowIconWidget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPixmap</span><span class="params">(<span class="keyword">const</span> QPixmap&amp; map)</span></span>;</span><br><span class="line">    ~<span class="built_in">ShowIconWidget</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line">signals:</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel m_MaxMap;</span><br><span class="line">    QPixmap m_map;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHOWICONWIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ShowIconWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDesktopWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line">ShowIconWidget::<span class="built_in">ShowIconWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br><span class="line">    m_MaxMap.<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_MaxMap.<span class="built_in">setWindowFlag</span>(Qt::Tool);</span><br><span class="line">    m_MaxMap.<span class="built_in">setWindowFlag</span>(Qt::FramelessWindowHint);</span><br><span class="line">    m_MaxMap.<span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::setPixmap</span><span class="params">(<span class="keyword">const</span> QPixmap &amp;map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_map = map;</span><br><span class="line">    m_MaxMap.<span class="built_in">setPixmap</span>(m_map);</span><br><span class="line">    m_MaxMap.<span class="built_in">setFixedSize</span>(m_map.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line">ShowIconWidget::~<span class="built_in">ShowIconWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> QPainter p;</span><br><span class="line">    p.<span class="built_in">begin</span>(<span class="keyword">this</span>);</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>-&gt;<span class="built_in">width</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">height</span>(),m_map);</span><br><span class="line">    p.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::enterEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect screenRect = QApplication::<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenGeometry</span>();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">if</span>(screenRect.<span class="built_in">height</span>()-<span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">y</span>()&gt;m_MaxMap.<span class="built_in">height</span>())&#123;</span><br><span class="line">        y = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">y</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">y</span>()-m_MaxMap.<span class="built_in">height</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(screenRect.<span class="built_in">width</span>()-<span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">x</span>()&gt;m_MaxMap.<span class="built_in">width</span>())&#123;</span><br><span class="line">        x = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">x</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">x</span>()-m_MaxMap.<span class="built_in">width</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    m_MaxMap.<span class="built_in">move</span>(x,y);</span><br><span class="line">    m_MaxMap.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::leaveEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_MaxMap.<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ShowIconWidget *w=new ShowIconWidget;</span><br><span class="line">w-&gt;setFixedSize(100,100);</span><br><span class="line">w-&gt;setPixmap(map);</span><br><span class="line">ui-&gt;horizontalLayout_28-&gt;addWidget(w);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui-&gt;horizontalLayout_28 是ScrollArea里面的Layout</span><br></pre></td></tr></table></figure>

<h1 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QMenu* m_menu=nullptr;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_menu = new QMenu(this);</span><br><span class="line">QAction *act1 = new QAction(QStringLiteral(&quot;保存图片&quot;),m_menu);</span><br><span class="line">connect(act1,SIGNAL(triggered()),this,SLOT(slot_menuSave()));</span><br><span class="line">m_menu-&gt;addAction(act1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_menu-&gt;move(event-&gt;globalX(),event-&gt;globalY());</span><br><span class="line">m_menu-&gt;exec();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="QT—5种标准对话框"><a href="#QT—5种标准对话框" class="headerlink" title="QT—5种标准对话框"></a>QT—5种标准对话框</h1><p><img src="/2021/06/27/Qt/image-20231213170140063.png" alt="image-20231213170140063"></p>
<h2 id="QFileDialog文件对话框"><a href="#QFileDialog文件对话框" class="headerlink" title="QFileDialog文件对话框"></a>QFileDialog文件对话框</h2><p>文件对话框可以通过调用QFileDialog::getOpenFileName方法实现，方法的第一个参数指定窗体的父窗体、第二个参数指定窗体的标题、第三个参数指定窗体的打开目录、第四个参数用于限定打开的文件类型，有多个类型时中间用;;隔开。下面程序演示了当用户点击按钮后会弹出文件对话框，之后将用户选择的文件路劲显示在文本框中。</p>
<p><img src="/2021/06/27/Qt/a782bba90e64491cbfa26bebbd96f7bf.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件对话框</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowFileDlg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开文件对话框</span></span><br><span class="line">    <span class="comment">//函数返回打开的路径</span></span><br><span class="line">    QString sPath = QFileDialog::<span class="built_in">getOpenFileName</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//指定父窗口</span></span><br><span class="line">                <span class="string">&quot;标准文件对话框&quot;</span>,<span class="comment">//打开文件对话框的标题</span></span><br><span class="line">                <span class="string">&quot;.&quot;</span>,<span class="comment">//打开目录，&quot;.&quot; 表示当前目录</span></span><br><span class="line">                <span class="string">&quot;C++ files(*.cpp);;&quot;</span></span><br><span class="line">                 <span class="string">&quot;C files(*.c);;&quot;</span></span><br><span class="line">                <span class="string">&quot;Header files(*.h)&quot;</span><span class="comment">//设置文件过滤器，有多个条件时中间以两个;;隔开</span></span><br><span class="line">                );</span><br><span class="line">    m_fileEdit-&gt;<span class="built_in">setText</span>(sPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QColorDialog颜色对话框"><a href="#QColorDialog颜色对话框" class="headerlink" title="QColorDialog颜色对话框"></a>QColorDialog颜色对话框</h2><p>颜色对话框可以通过调用QColorDialog::getColor方法实现，方法的第一个参数表示默认选择的颜色。该方法会返回一个颜色类。</p>
<p><img src="/2021/06/27/Qt/5d553be71dac4627ab1ac8237839404c.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowColorDlg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QColor color = QColorDialog::<span class="built_in">getColor</span>(</span><br><span class="line">                Qt::yellow<span class="comment">//默认选择的颜色</span></span><br><span class="line">                );</span><br><span class="line">    <span class="comment">//判断颜色选择是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(color.<span class="built_in">isValid</span>())&#123;</span><br><span class="line">        <span class="comment">//设置边宽颜色</span></span><br><span class="line">        m_colorFrame-&gt;<span class="built_in">setPalette</span>(<span class="built_in">QPalette</span>(color));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QFontDialog字体对话框"><a href="#QFontDialog字体对话框" class="headerlink" title="QFontDialog字体对话框"></a>QFontDialog字体对话框</h2><p>字体对话框可以通过调用QFontDialog::getFont方法实现，该方法需要传入一个<strong>bool类型的参数</strong>用来接收函数是否成功执行，方法会返回一个字体字体类。</p>
<p><img src="/2021/06/27/Qt/4dffdf93ee3f46c99a7562dce3d6591e.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字体对话框</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowFontDlg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;<span class="comment">//接收函数是否执行成功</span></span><br><span class="line">    QFont font = QFontDialog::<span class="built_in">getFont</span>(</span><br><span class="line">                    &amp;ok<span class="comment">//接收函数是否执行成功</span></span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        <span class="comment">//设置字体</span></span><br><span class="line">        m_fontEdit-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QInputDialog输入对话框"><a href="#QInputDialog输入对话框" class="headerlink" title="QInputDialog输入对话框"></a>QInputDialog输入对话框</h2><p><img src="/2021/06/27/Qt/f8aa363b765540f9a88b4ff3fd49b873.gif" alt="img"></p>
<p>设置姓名，可以调用的是QInputDialog::getText( )方法用来获取输入的单行文本。方法的第一个参数指定父窗体，第二个参数指定对话框的标题，第三个参数指定对话框显示的内容，第四个参数纸档输入框的模式，第五个参数指定默认值，第六个参数是一个bool类型用来接收函数是否执行成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文本输入对话框</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDlg::editName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    QString strName = QInputDialog::<span class="built_in">getText</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//指定父窗体</span></span><br><span class="line">                <span class="string">&quot;标准文本输入对话框&quot;</span>,<span class="comment">//指定对话框标题</span></span><br><span class="line">                <span class="string">&quot;请编辑姓名&quot;</span>,<span class="comment">//提示字符串</span></span><br><span class="line">                QLineEdit::Normal,<span class="comment">//输入框显示模式</span></span><br><span class="line">                m_nameLabel-&gt;<span class="built_in">text</span>(),<span class="comment">//输入框的默认文本</span></span><br><span class="line">                &amp;ok<span class="comment">//接收函数调用是否成功</span></span><br><span class="line">                <span class="comment">//最后一个参数表示窗体风格，这里采用默认的</span></span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">if</span>(ok &amp;&amp; !strName.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        m_nameLabel-&gt;<span class="built_in">setText</span>(strName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置性别，可以调用的是QInputDialog::getItem( ) 方法用来获取用户从下拉列表选择的值。QInputDialog第三个参数用来设置下拉列表框，要传入一个QStringList类型的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条目输入对话框</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDlg::editSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QStringList sexList;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    sexList&lt;&lt;<span class="string">&quot;男&quot;</span>&lt;&lt;<span class="string">&quot;女&quot;</span>&lt;&lt;<span class="string">&quot;未知&quot;</span>;</span><br><span class="line">    <span class="comment">//可选项是QString 类型，接收也是QString</span></span><br><span class="line">    QString strSex = QInputDialog::<span class="built_in">getItem</span>(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                <span class="string">&quot;标准条目输入对话框&quot;</span>,<span class="comment">//指定对话框标题</span></span><br><span class="line">                <span class="string">&quot;请选择性别&quot;</span>,    <span class="comment">//指定显示内容</span></span><br><span class="line">                sexList,<span class="comment">//设置可选项，可选项是一个QStringList类型</span></span><br><span class="line">                <span class="number">0</span>,<span class="comment">//设置默认选选项</span></span><br><span class="line">                <span class="literal">false</span>,<span class="comment">//是否可编辑</span></span><br><span class="line">                &amp;ok<span class="comment">//接收函数是否调用成功</span></span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">if</span>(ok &amp;&amp; !strSex.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        m_sexLabel-&gt;<span class="built_in">setText</span>(strSex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置年龄，可以调用QInputDialog::getInt方法用来获取用户填入的整数值。getInt方法的第四个参数和第五个参数分别用来设置整数的最小值和最大值，第六个参数用来设置步长，即点击增加按钮时每次增加的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDlg::editAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    <span class="keyword">int</span> age = QInputDialog::<span class="built_in">getInt</span>(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                <span class="string">&quot;标注int数据类型输入对话框&quot;</span>,<span class="comment">//对话框标题</span></span><br><span class="line">                <span class="string">&quot;请编辑年龄&quot;</span>,<span class="comment">//对话框显示的内容</span></span><br><span class="line">                m_ageLabel-&gt;<span class="built_in">text</span>().<span class="built_in">toInt</span>(),<span class="comment">//默认值</span></span><br><span class="line">                <span class="number">0</span>,<span class="comment">//最小值</span></span><br><span class="line">                <span class="number">120</span>,<span class="comment">//最大值</span></span><br><span class="line">                <span class="number">1</span>,<span class="comment">//步长</span></span><br><span class="line">                &amp;ok<span class="comment">//接收函数是否调用成功</span></span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        m_ageLabel-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(age));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置分数，可以调用QInputDialog::getDouble方法用来获取用户填入的浮点数值。getDouble方法的第四个参数和第五个参数分别用来设置整数的最小值和最大值，第六个参数用来设置精度，即点数据的小数位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDlg::editScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    <span class="keyword">double</span> score = QInputDialog::<span class="built_in">getDouble</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//设置父窗体</span></span><br><span class="line">                <span class="string">&quot;标准double数据类型输入对话框&quot;</span>,<span class="comment">//对话框标题</span></span><br><span class="line">                <span class="string">&quot;请编辑分数&quot;</span>,<span class="comment">//对话框显示的内容</span></span><br><span class="line">                m_scoreLabel-&gt;<span class="built_in">text</span>().<span class="built_in">toDouble</span>(),<span class="comment">//默认值</span></span><br><span class="line">                <span class="number">0</span>,<span class="comment">//最小值</span></span><br><span class="line">                <span class="number">100</span>,<span class="comment">//最大值</span></span><br><span class="line">                <span class="number">1</span>,<span class="comment">//精度</span></span><br><span class="line">                &amp;ok<span class="comment">//接收函数是否执行成功</span></span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        m_scoreLabel-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(score));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QMessageBox消息框</p>
<p><img src="/2021/06/27/Qt/3f49502b96e94515ad5abf64e8bc945e.gif" alt="img"></p>
<p>问题消息框，可以调用QMessageBox::question() 显示问题消息框，问题消息框可设置要显示的按钮，方法会返回一个枚举类型表示用户所点击的按钮。这里设置的是“确定”和“取消”按钮。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MsgBoxDlg::showQuestionMsgDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;问题消息框&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> res = QMessageBox::<span class="built_in">question</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//指定父窗体</span></span><br><span class="line">                <span class="string">&quot;问题消息框&quot;</span>,<span class="comment">//指定标题</span></span><br><span class="line">                <span class="string">&quot;已打开问题消息框，是否关闭？&quot;</span>,<span class="comment">//显示的文本</span></span><br><span class="line">                QMessageBox::Ok|QMessageBox::Cancel,<span class="comment">//标注按钮</span></span><br><span class="line">                QMessageBox::Ok<span class="comment">//默认选择的按钮</span></span><br><span class="line">                );</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (res) &#123;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Ok:</span><br><span class="line">        m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;问题消息框 - 确定&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Cancel:</span><br><span class="line">        m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;问题消息框 - 取消&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信息消息框，可以调用QMessageBox::information( )方法实现，信息消息框的作用是给用户展示一段消息，无需用户做出操作，函数参数也比较简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MsgBoxDlg::showInformationMsgDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;信息消息框&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//父窗体</span></span><br><span class="line">                <span class="string">&quot;信息提示框&quot;</span>,<span class="comment">//标题</span></span><br><span class="line">                <span class="string">&quot;这是个信息提示框&quot;</span><span class="comment">//文本内容</span></span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>警告消息框，可以调用QMessageBox::waring方法，警告消息框同样可以设置消息框的按钮，方法会一个枚举类型表示用户的操作。这里设置的是“保存”、“忽视”和“取消”按钮。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MsgBoxDlg::showWarningMsgDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;警告消息框&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> res = QMessageBox::<span class="built_in">warning</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//父窗体</span></span><br><span class="line">                <span class="string">&quot;警告消息框&quot;</span>,<span class="comment">//标题</span></span><br><span class="line">                <span class="string">&quot;有为保存的文件&quot;</span>,<span class="comment">//警告内容</span></span><br><span class="line">                QMessageBox::Save|QMessageBox::Discard|QMessageBox::Cancel,</span><br><span class="line">                QMessageBox::Save<span class="comment">//默认选择的按钮</span></span><br><span class="line">                );</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (res) &#123;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Save:</span><br><span class="line">        m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;警告提示框 - 保存&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Discard:</span><br><span class="line">        m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;警告提示框 - 忽视&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Cancel:</span><br><span class="line">        m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;警告提示框 - 取消&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误消息框，可以调用QMessageBox::critical方法，错误消息框也相当于一种消息提醒，会比信息消息框的效果显目，调用方法和信息消息框类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MsgBoxDlg::showCriticalMsgDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;错误消息框&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">critical</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//父窗体</span></span><br><span class="line">                <span class="string">&quot;错误消息框&quot;</span>,<span class="comment">//标题</span></span><br><span class="line">                <span class="string">&quot;发生重大错误！！&quot;</span><span class="comment">//显示内容</span></span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于消息框，调用QMessageBox::about方法，关于消息框也是一种消息提醒，调用方法与信息消息框类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MsgBoxDlg::showAboutMsgDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关于消息框&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//父窗体</span></span><br><span class="line">                <span class="string">&quot;关于消息框&quot;</span>,<span class="comment">//标题</span></span><br><span class="line">                <span class="string">&quot;这是个关于休斯顿的信息&quot;</span><span class="comment">//显示内容</span></span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于QT消息框，调用QMessageBox::aboutQt方法，关于QT消息框会弹出一个有关QT的信息。其他功能暂无。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MsgBoxDlg::showAboutQtMsgDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_tipLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关于QT消息框&quot;</span>);</span><br><span class="line">    QMessageBox::<span class="built_in">aboutQt</span>(</span><br><span class="line">                <span class="keyword">this</span>,<span class="comment">//父窗体</span></span><br><span class="line">                <span class="string">&quot;关于QT消息框&quot;</span><span class="comment">//标题</span></span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QMessageBox消息框"><a href="#QMessageBox消息框" class="headerlink" title="QMessageBox消息框"></a>QMessageBox消息框</h2><p>Qt 提供了 6 种通用的 QMessageBox 消息对话框，通过调用 QMessageBox 类中的 6 个静态成员方法，可以直接在项目中使用它们。</p>
<ol>
<li>information消息对话框<br>information 对话框常用于给用户提示一些关键的信息，它的外观如下图所示：</li>
</ol>
<p><img src="/2021/06/27/Qt/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Jab5a6a6LCU55qE54yrNzA4MQ==,size_7,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>在项目中使用 information 消息对话框，直接调用 QMessageBox 类中的 information() 静态成员方法即可，该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">QMessageBox::information</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">const</span> QString &amp;title,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">const</span> QString &amp;text,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Jab5a6a6LCU55qE54yrNzA4MQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>例如，使用 information() 函数实现图 2 所示的对话框，实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox::StandardButton result = QMessageBox::<span class="built_in">information</span>(&amp;widget, <span class="string">&quot;Title&quot;</span>,<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>critical消息对话框<br>critical 消息对话框常用于给用户提示“操作错误”或“运行失败”的信息，它的外观如下图所示：</li>
</ol>
<p><img src="/2021/06/27/Qt/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Jab5a6a6LCU55qE54yrNzA4MQ==,size_6,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>项目中使用 critical 消息对话框，直接调用 QMessageBox 类提供的 critical() 静态成员方法即可，该方法的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">QMessageBox::critical</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> QString &amp;title,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> QString &amp;text,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<p> 例如，使用 critical() 函数实现图 3 所示的对话框，实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox::StandardButton result=QMessageBox::<span class="built_in">critical</span>(&amp;widget, <span class="string">&quot;Title&quot;</span>,<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>question消息对话框<br>question 对话框常用于向用户提出问题并接收用户的答案，它的外观如下图所示：</li>
</ol>
<p><img src="/2021/06/27/Qt/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Jab5a6a6LCU55qE54yrNzA4MQ==,size_9,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>项目中使用 question 对话框，可以直接调用 QMessageBox 类的 question() 静态成员方法，该方法的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">QMessageBox::question</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> QString &amp;title,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> QString &amp;text,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StandardButtons buttons = StandardButtons( Yes | No ),</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<p> 例如，使用 question() 函数实现图 4 所示的对话框，实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox::StandardButton result=QMessageBox::<span class="built_in">question</span>(&amp;widget, <span class="string">&quot;Title&quot;</span>,<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>warning消息对话框<br>warining 对话框常用于向用户显示一些警告信息，它的外观如下图所示：</li>
</ol>
<p><img src="/2021/06/27/Qt/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Jab5a6a6LCU55qE54yrNzA4MQ==,size_5,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p> 项目中使用 warning 对话框，可以直接调用 QMessageBox 类的 warning() 静态成员方法，该方法的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">QMessageBox::warning</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> QString &amp;title,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> QString &amp;text,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StandardButtons buttons = Ok,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>

<p>例如，使用 warning() 函数实现图 5 所示的对话框，实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox::StandardButton result=QMessageBox::<span class="built_in">warning</span>(&amp;widget, <span class="string">&quot;Title&quot;</span>,<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>about和aboutQt对话框<br>about 对话框常常作为介绍某个产品或某项功能的临时窗口，它的外观如下图所示：</li>
</ol>
<p><img src="/2021/06/27/Qt/9374a12d25774ef3ae9726f03b79bafe.png" alt="img"></p>
<p>项目中使用 about 对话框，直接调用 QMessageBox 类提供的 about() 静态成员方法即可，该方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QMessageBox::about</span><span class="params">(QWidget *parent, <span class="keyword">const</span> QString &amp;title, <span class="keyword">const</span> QString &amp;text)</span></span></span><br></pre></td></tr></table></figure>

<p>项目中使用 aboutQt 对话框，直接调用 QMessageBox 类提供的 aboutQt() 静态成员方法即可，该函数的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QMessageBox::aboutQt</span><span class="params">(QWidget *parent, <span class="keyword">const</span> QString &amp;title = QString())</span></span></span><br></pre></td></tr></table></figure>



<h2 id="自定义消息框"><a href="#自定义消息框" class="headerlink" title="自定义消息框"></a>自定义消息框</h2><p>自定义消息框设置了一个图标和三个按钮，其中两个按钮采用自定义形式，另一个按钮采用标准形式，当用户点击按钮后，从对话框中获取用户点击的按钮，然后显示出对应的文本。</p>
<p><img src="/2021/06/27/Qt/8531033c2a3d4bfb8dde95317c1ed0cf.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义消息框</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dialog::ShowCustomDlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_customLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;自定义消息框&quot;</span>);</span><br><span class="line">    QMessageBox customMsgBox;</span><br><span class="line">    customMsgBox.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自定义消息框&quot;</span>);</span><br><span class="line">    <span class="comment">//返回一个按钮对象</span></span><br><span class="line">    <span class="comment">//自定义按钮</span></span><br><span class="line">    QPushButton *yes = customMsgBox.<span class="built_in">addButton</span>(</span><br><span class="line">                <span class="string">&quot;真的吗？&quot;</span>,<span class="comment">//指定文本</span></span><br><span class="line">                QMessageBox::ActionRole<span class="comment">//指定角色</span></span><br><span class="line">                );</span><br><span class="line">    <span class="comment">//自定义按钮</span></span><br><span class="line">    QPushButton *no = customMsgBox.<span class="built_in">addButton</span>(</span><br><span class="line">                <span class="string">&quot;假的&quot;</span>,<span class="comment">//指定文本</span></span><br><span class="line">                QMessageBox::ActionRole<span class="comment">//指定角色</span></span><br><span class="line">                );</span><br><span class="line">    <span class="comment">//标准按钮</span></span><br><span class="line">    QPushButton *cancel = customMsgBox.<span class="built_in">addButton</span>(</span><br><span class="line">                QMessageBox::Cancel);</span><br><span class="line">    <span class="comment">//设置图标</span></span><br><span class="line">    customMsgBox.<span class="built_in">setIconPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;msg.jpg&quot;</span>));</span><br><span class="line">    customMsgBox.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="keyword">if</span>(customMsgBox.<span class="built_in">clickedButton</span>()==yes)&#123;</span><br><span class="line">        m_customLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;点了“真的吗？”&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(customMsgBox.<span class="built_in">clickedButton</span>()==no)&#123;</span><br><span class="line">        m_customLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;点了“假的   ”&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(customMsgBox.<span class="built_in">clickedButton</span>()==cancel)&#123;</span><br><span class="line">        m_customLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;点了“取消”&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="重写QLabel，提升UI部件，调用PaintEvent"><a href="#重写QLabel，提升UI部件，调用PaintEvent" class="headerlink" title="重写QLabel，提升UI部件，调用PaintEvent"></a>重写QLabel，提升UI部件，调用PaintEvent</h1><p>.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYQLABEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYQLABEL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQLabel</span> :</span> <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQLabel</span>(QWidget  *parent=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wheelEvent</span><span class="params">(QWheelEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYQLABEL_H</span></span></span><br></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyQLabel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line">MyQLabel::<span class="built_in">MyQLabel</span>(QWidget  *parent):</span><br><span class="line">       <span class="built_in">QLabel</span>(parent)<span class="comment">//注意这里，不能写QWidget，否则ui.h文件会报错</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyQLabel::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QImage img;</span><br><span class="line">    img.<span class="built_in">load</span>(<span class="string">&quot;E:\\Projects\\SpxFrame\\radarFrame\\asdfa.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> QPainter painter;</span><br><span class="line">    painter.<span class="built_in">begin</span>(<span class="keyword">this</span>);</span><br><span class="line">    painter.<span class="built_in">drawImage</span>(<span class="built_in">QRectF</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>-&gt;<span class="built_in">width</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">height</span>()),img);</span><br><span class="line">    painter.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyQLabel::mousePressEvent</span><span class="params">(QMouseEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCursor</span>(Qt::ClosedHandCursor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyQLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyQLabel::wheelEvent</span><span class="params">(QWheelEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ui文件</p>
<p><img src="/2021/06/27/Qt/041e2433-0fe9-4b23-b224-9e29be08f00c.png" alt="img"></p>
<p>然后在使用这个部件的类里面就可以通过ui.MyQLabel这样的方式访问重写的类中的函数和变量了，比如传递图片进去调用PaintEvent等等，这样在PaintEvent中就可以在this画布上直接draw，不用在外部set静态的图片了。</p>
<h1 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QThread *thread = <span class="keyword">new</span> <span class="built_in">QThread</span>( );</span><br><span class="line"> Task    *task   = <span class="keyword">new</span> <span class="built_in">Task</span>();</span><br><span class="line"> task-&gt;<span class="built_in">moveToThread</span>(thread);</span><br><span class="line"> <span class="built_in">connect</span>( thread, <span class="built_in">SIGNAL</span>(<span class="built_in">started</span>()), task, <span class="built_in">SLOT</span>(<span class="built_in">doWork</span>()) );</span><br><span class="line"> <span class="built_in">connect</span>( task, <span class="built_in">SIGNAL</span>(<span class="built_in">workFinished</span>()), thread, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()) );<span class="comment">//从Qt4.4开始，qthreads-no-longer-abstract，run 默认调用 QThread::exec(),即启动消息队列</span></span><br><span class="line"> <span class="comment">//automatically delete thread and task object when work is done:</span></span><br><span class="line"> <span class="built_in">connect</span>( thread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), task, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()) );</span><br><span class="line"> <span class="built_in">connect</span>( thread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), thread, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()) );</span><br><span class="line"> thread-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line"> &#123;</span><br><span class="line"> Q_OBJECT</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Task</span>();</span><br><span class="line">      ~<span class="built_in">Task</span>();</span><br><span class="line">  <span class="keyword">public</span> slots:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">  signals:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">workFinished</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A *a = <span class="keyword">new</span> A;</span><br><span class="line">QThread *t = <span class="keyword">new</span> QThread;</span><br><span class="line">a-&gt;<span class="built_in">moveToThread</span>(t);</span><br><span class="line"><span class="built_in">connect</span>(t, <span class="built_in">SIGNAL</span>(<span class="built_in">started</span>()), a, <span class="built_in">SLOT</span>(<span class="built_in">start</span>()));</span><br><span class="line"><span class="built_in">connect</span>(a, <span class="built_in">SIGNAL</span>(<span class="built_in">finish</span>()), a, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line"><span class="built_in">connect</span>(a, <span class="built_in">SIGNAL</span>(<span class="built_in">destroyed</span>()), t, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line"><span class="built_in">connect</span>(t, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), t, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line">a在销毁后是会发出<span class="built_in">destroyed</span>()信号的，a完成后可以先让a销毁，然后a发出销毁的信号后t再退出，t退出完毕后销毁。这样就可以了。</span><br></pre></td></tr></table></figure>

<h1 id="QCoreApplication和QApplication的区别"><a href="#QCoreApplication和QApplication的区别" class="headerlink" title="QCoreApplication和QApplication的区别"></a>QCoreApplication和QApplication的区别</h1><p>\1. QCoreApplication用于non-GUI的应用程序（不需要依赖QtGui库），QApplication用于包含GUI的应用程序（需要用到QtGui库）。</p>
<p>\2. QApplication继承了QGuiApplication类，而QGuiApplication继承了QCoreApplication类，而QCoreApplication又继承QObject的，而QObject就是QT中最基本的基类，也就是QT的根基。</p>
<h1 id="pro文件相关"><a href="#pro文件相关" class="headerlink" title="pro文件相关"></a>pro文件相关</h1><p><strong>Qt</strong>程序一般使用Qt提供的<strong>qmake</strong>工具来编译。</p>
<p>qmake工具可以使用与平台无关的.pro文件生成与平台相关的<strong>makefile</strong>。该工具包含了调用Qt内置代码生成工具（<strong>moc</strong>，<strong>uic</strong>，<strong>rcc</strong>）的必要逻辑规则。</p>
<p>可以在命令行下，输入<strong>qmake -project</strong>来生成平台无关的pro文件。</p>
<p>工程文件pro主要分为三种：app（单独的应用程序），lib（静态和动态库），subdirs（递归编译）。工程类型可以使用<strong>TEMPLATE</strong>变量来指定。</p>
<p>如： TEMPLATE = app(默认不指定的情况下是app工程)</p>
<p>对于app工程或者lib工程，有以下这些经常使用的变量：</p>
<p><strong>HEADERS</strong>：指定C++头文件</p>
<p><strong>SOURCES</strong>：指定C++实现文件</p>
<p><strong>FORMS</strong>：指定需要uic处理的ui文件</p>
<p><strong>RESOURCES</strong>：指定需要rcc处理的qrc文件</p>
<p><strong>DEFINES</strong>：指定预定义预处理器符号</p>
<p><strong>INCLUDEPATH</strong>：指定C++编译器搜索头文件路径</p>
<p><strong>LIBS</strong>：指定工程要链接的库</p>
<p><strong>CONFIG</strong>：指定工程配置和编译参数</p>
<p><strong>QT</strong>：指定工程所要使用的Qt模块</p>
<p><strong>VERSION</strong>：指定目标库版本号</p>
<p><strong>TARGET</strong>：指定可执行文件或库的基本文件名，默认为当前目录名</p>
<p><strong>DESTDIR</strong>：指定可执行文件放置的目录</p>
<p><strong>DLLDESTDIR</strong>：指定目标库文件放置的目录</p>
<p>模板变量<strong>TEMPLATE</strong>规定qmake为应用程序生成哪种makefile。下面是可供使用的选择：</p>
<table>
<thead>
<tr>
<th>TEMPLATE的宏</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>app</td>
<td>应用程序</td>
</tr>
<tr>
<td>lib</td>
<td>库dll</td>
</tr>
<tr>
<td>subdirs</td>
<td>子项目</td>
</tr>
<tr>
<td>vcapp</td>
<td>应用的visual studio项目</td>
</tr>
<tr>
<td>vclib</td>
<td>库的visual studio项目</td>
</tr>
<tr>
<td>aux</td>
<td>创建一个 Makefile 但不进行构建。</td>
</tr>
</tbody></table>
<p><strong>CONFIG</strong>：指定工程配置和编译参数</p>
<p>CONFIG配置工程和编译器的设置，以下取值定义了所要连编的库/应用程序的类型：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>release</td>
<td>配置项目为发布模式。如果同时指定了 debug，则最后的配置项生效。</td>
</tr>
<tr>
<td>debug</td>
<td>配置项目为调试模式。</td>
</tr>
<tr>
<td>debug_and_release</td>
<td>配置项目为调试和发布模式。同时创建调试和发布项目。</td>
</tr>
<tr>
<td>debug_and_release_target</td>
<td>此项为默认设置。如果配置了 debug_and_release，调试和发布项目将在属于自己的文件目录生成。</td>
</tr>
<tr>
<td>build_all</td>
<td>如果配置了 debug_and_release，将默认生成调试和发布项目。</td>
</tr>
<tr>
<td>autogen_precompile_source</td>
<td>自动生成包含在 .pro 文件中指定的预编译头文件和</td>
</tr>
<tr>
<td>ordered</td>
<td>当模板指定为 subdirs 时，此配置项会根据 .pro 文件的顺序进行编译处理。注意：不鼓励使用此项。应按照 SUBDIRS  说明文档中的变量指定依赖项。</td>
</tr>
<tr>
<td>precompile_header</td>
<td>增加预编译头文件支持。</td>
</tr>
<tr>
<td>precompile_header_c (MSVC only)</td>
<td>增加对 C 文件的预编译头文件支持。</td>
</tr>
<tr>
<td>warn_on</td>
<td>编译器尽可能多的输出警告信息。如果同时配置了 warn_off，则最后的配置项生效。</td>
</tr>
<tr>
<td>warn_off</td>
<td>编译器尽可能少的输出警告信息。</td>
</tr>
<tr>
<td>exceptions</td>
<td>启用异常支持配置。默认设置。</td>
</tr>
<tr>
<td>exceptions_off</td>
<td>停用异常支持配置。</td>
</tr>
<tr>
<td>ltcg</td>
<td>启用链接时进行代码生成配置。默认关闭。</td>
</tr>
<tr>
<td>rtti</td>
<td>启用 RTTI 支持配置。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>rtti_off</td>
<td>停用 RTTI 支持配置。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>stl</td>
<td>启用 STL 支持配置。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>stl_off</td>
<td>停用 STL 支持配置。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>thread</td>
<td>启用线程支持配置。当 CONFIG 配置项中包含 qt 时默认启用。</td>
</tr>
<tr>
<td>utf8_source</td>
<td>明确项目源文件使用 UTF-8 进行编码。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>hide_symbols</td>
<td>将二进制文件中符号的默认可见性设置为隐藏。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>c99</td>
<td>启用 C99 编译支持。如果编译器不支持 C99 或无法选择 C 标准，则此选项无效。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>c11</td>
<td>启用 C11 编译支持。如果编译器不支持 C11 或无法选择 C 标准，则此选项无效。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>strict_c</td>
<td>停用对 C 编译器扩展支持。默认情况扩展支持处于启用状态。</td>
</tr>
<tr>
<td>c++11</td>
<td>启用 C++11 编译支持。如果编译器不支持 C++11 或无法选择 C++ 标准，则此选项无效。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>c++14</td>
<td>启用 C++14 编译支持。如果编译器不支持 C++14 或无法选择 C++ 标准，则此选项无效。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>c++1z</td>
<td>启用 C++17 编译支持。如果编译器不支持 C++17 或无法选择 C++ 标准，则此选项无效。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>c++17</td>
<td>与 c++1z 相同。</td>
</tr>
<tr>
<td>c++2a</td>
<td>启用 C++2a 编译支持。如果编译器不支持 C++2a 或无法选择 C++ 标准，则此选项无效。默认情况使用编译器默认值。</td>
</tr>
<tr>
<td>c++latest</td>
<td>启用编译器对最新的 C++ 语言标准的支持。默认情况下，此选项处于停用状态。</td>
</tr>
<tr>
<td>strict_c++</td>
<td>停用对 C++ 编译器扩展支持。默认情况下扩展支持处于启用状态。</td>
</tr>
<tr>
<td>depend_includepath</td>
<td>启用自动追加 INCLUDEPATH 到 DEPENDPATH。默认配置。</td>
</tr>
<tr>
<td>lrelease</td>
<td>对 TRANSLATIONS 和 EXTRA_TRANSLATIONS 中列出的所有文件执行 lrelease。如果未配置  embed_translations，则需要将生成的 .qm 文件装载至 QM_FILES_INSTALL_PATH 中。使用  QMAKE_LRELEASE_FLAGS 向 lrelease 调用添加选项。默认不配置。</td>
</tr>
<tr>
<td>embed_translations</td>
<td>根据 QM_FILES_RESOURCE_PREFIX 设置，将 lrelease 生成的翻译文件嵌入可执行文件中。此外还需要配置  lrelease。默认不配置。</td>
</tr>
<tr>
<td>create_libtool</td>
<td>在当前构建的库创建一个 libtool 类型的 .la 文件。</td>
</tr>
<tr>
<td>create_pc</td>
<td>在当前构建的库创建一个 pkg-config 类型的 .pc 文件。</td>
</tr>
<tr>
<td>no_batch</td>
<td>NMake only：关闭 NMake 批处理规则或推理规则的生成。</td>
</tr>
<tr>
<td>skip_target_version_ext</td>
<td>在 Windows 环境中，禁止自动将版本号附加到 DLL 文件名中。</td>
</tr>
<tr>
<td>suppress_vcproj_warnings</td>
<td>禁止 VS 项目生成器的警告。</td>
</tr>
<tr>
<td>windeployqt</td>
<td>链接后自动调用windeployqt，并将输出添加为部署项。</td>
</tr>
<tr>
<td>dont_recurse</td>
<td>禁止 qmake 在子项目递归执行。</td>
</tr>
<tr>
<td>no_include_pwd</td>
<td>当前目录不添加至 INCLUDEPATHS。</td>
</tr>
<tr>
<td>compile_included_sources</td>
<td>默认情况下，qmake 不编译包含在其他源文件的源文件。默认不配置此项。</td>
</tr>
</tbody></table>
<p><strong>常用qmake函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>在General Messages输出</td>
</tr>
<tr>
<td>message($$(PATH))</td>
<td>输出环境变量</td>
</tr>
<tr>
<td>log</td>
<td>输出信息(不换行)</td>
</tr>
<tr>
<td>include</td>
<td>一般用于包含pri文件</td>
</tr>
<tr>
<td>greaterThan</td>
<td>常用于判断Qt版本(greaterThan(QT_MAJOR_VERSION, 4): QT += widgets)</td>
</tr>
<tr>
<td>error</td>
<td>报警信息</td>
</tr>
</tbody></table>
<p>pro文件里，访问环境变量的用法是：$(varName)</p>
<p>pro文件里，访问Qt配置参数的用法：$$[varName]</p>
<p>在不同的编译平台上编译时，需要设定条件。如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">win32&#123;</span><br><span class="line"> SOURCES += <span class="number">1</span><span class="selector-class">.cpp</span></span><br><span class="line">&#125;else&#123;</span><br><span class="line"> SOURCES += <span class="number">2</span><span class="selector-class">.cpp</span></span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">win32：SOURCES += <span class="number">3</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure>

<p>pro文件常用代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">RC_ICONS = ruler<span class="selector-class">.ico</span></span><br><span class="line">DESTDIR = bin #用于指定可执行文件或库文件的生成路径。</span><br><span class="line">UI_DIR = $$compiled/ui  # 存放ui_mainwindow<span class="selector-class">.h</span>之类文件</span><br><span class="line">MOC_DIR = $$compiled/moc   # 存放moc文件</span><br><span class="line">OBJECTS_DIR = $$compiled/obj    # 存放<span class="selector-class">.o</span>文件</span><br><span class="line">RCC_DIR = $$compiled/res # 存放资源文件</span><br><span class="line">INCLUDEPATH += INCLUDEPATH \</span><br><span class="line">               INCLUDEPATH \</span><br><span class="line">LIBS += -L folderPath  //引入的lib文件的路径  -L：引入路径</span><br><span class="line">Release:LIBS += -L folderPath // release 版引入的lib文件路径</span><br><span class="line">Debug:LIBS += -L folderPath // Debug 版引入的lib 文件路径</span><br><span class="line">#引入的lib文件,用于引入动态链接库</span><br><span class="line">LIBS += qaxcontainer.lib</span><br><span class="line">#工程中包含的资源文件</span><br><span class="line">RESOURCES   = Scintilla.qrc</span><br><span class="line">BINLIB = ../../bin ../../xercesc/lib</span><br><span class="line">QMAKE_LIBDIR = $$&#123;BINLIB&#125;</span><br></pre></td></tr></table></figure>

<p> Qt 基础模块分为以下几个：</p>
<ul>
<li> Qt Core，提供核心的非 GUI  功能，所有模块都需要这个模块。这个模块的类包括了动画框架、定时器、各个容器类、时间日期类、事件、IO、JSON、插件机制、智能指针、图形（矩形、路径等）、线程、XML 等。所有这些类都可以通过 <QtCore> 头文件引入。</QtCore></li>
<li> Qt Gui，提供 GUI 程序的基本功能，包括与窗口系统的集成、事件处理、OpenGL 和 OpenGL ES 集成、2D 图像、字体、拖放等。这些类一般由  Qt 用户界面类内部使用，当然也可以用于访问底层的 OpenGL ES 图像 API。Qt Gui  模块提供的是所有图形用户界面程序都需要的通用功能。</li>
<li> Qt Multimedia，提供<strong>视频、音频、收音机以及摄像头</strong>等功能。这些类可以通过 <QtMultimedia> 引入，而且需要在 pro 文件中添加 QT += multimedia。</QtMultimedia></li>
<li> Qt Network，提供跨平台的网络功能。这些类可以通过 <QtNetwork> 引入，而且需要在 pro 文件中添加 QT += network。</QtNetwork></li>
<li> Qt Qml，提供供 <strong>QML</strong>（一种脚本语言，也提供 JavaScript 的交互机制） 使用的 C++ API。这些类可以通过 <QtQml> 引入，而且需要在 pro 文件中添加 QT += qml。</QtQml></li>
<li> Qt Quick，允许在 Qt/C++ 程序中嵌入 Qt Quick（一种基于 Qt 的高度动画的用户界面，<strong>适合于移动平台开发</strong>）。这些类可以通过 <QtQuick> 引入，而且需要在 pro 文件中添加 QT += quick。</QtQuick></li>
<li> Qt SQL，允许使用 SQL 访问<strong>数据库</strong>。这些类可以通过 <QtSql> 引入，而且需要在 pro 文件中添加 QT += sql。</QtSql></li>
<li> Qt Test，提供 Qt 程序的<strong>单元测试</strong>功能。这些类可以通过 <QtTest> 引入，而且需要在 pro 文件中添加 QT += testlib。</QtTest></li>
<li> Qt Webkit，基于 WebKit2 的实现以及一套全新的 QML API（顺便说一下，Qt 4.8 附带的是 QtWebkit 2.2）。</li>
</ul>
<h1 id="ui-创建widget并放大图片-dock停靠"><a href="#ui-创建widget并放大图片-dock停靠" class="headerlink" title="ui 创建widget并放大图片,dock停靠"></a>ui 创建widget并放大图片,dock停靠</h1><blockquote>
<p>MyExample-》DisplayBigLabel</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ShowIconWidget *w=<span class="keyword">new</span> ShowIconWidget;</span><br><span class="line">w-&gt;<span class="built_in">setFixedSize</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">w-&gt;<span class="built_in">setPixmap</span>(map);</span><br><span class="line">ui-&gt;horizontalLayout_28-&gt;<span class="built_in">addWidget</span>(w);</span><br><span class="line"></span><br><span class="line">ui-&gt;horizontalLayout_28 是ScrollArea里面的Layout</span><br></pre></td></tr></table></figure>

<p> .h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHOWICONWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOWICONWIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowIconWidget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ShowIconWidget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPixmap</span><span class="params">(<span class="keyword">const</span> QPixmap&amp; map)</span></span>;</span><br><span class="line">    ~<span class="built_in">ShowIconWidget</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel m_MaxMap;</span><br><span class="line">    QPixmap m_map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHOWICONWIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ShowIconWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDesktopWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line">ShowIconWidget::<span class="built_in">ShowIconWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br><span class="line">    m_MaxMap.<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_MaxMap.<span class="built_in">setWindowFlag</span>(Qt::Tool);</span><br><span class="line">    m_MaxMap.<span class="built_in">setWindowFlag</span>(Qt::FramelessWindowHint);</span><br><span class="line">    m_MaxMap.<span class="built_in">setAttribute</span>(Qt::WA_TranslucentBackground);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::setPixmap</span><span class="params">(<span class="keyword">const</span> QPixmap &amp;map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_map = map;</span><br><span class="line">    m_MaxMap.<span class="built_in">setPixmap</span>(m_map);</span><br><span class="line">    m_MaxMap.<span class="built_in">setFixedSize</span>(m_map.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowIconWidget::~<span class="built_in">ShowIconWidget</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> QPainter p;</span><br><span class="line">    p.<span class="built_in">begin</span>(<span class="keyword">this</span>);</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">this</span>-&gt;<span class="built_in">width</span>(),<span class="keyword">this</span>-&gt;<span class="built_in">height</span>(),m_map);</span><br><span class="line">    p.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::enterEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect screenRect = QApplication::<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenGeometry</span>();</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">if</span>(screenRect.<span class="built_in">height</span>()-<span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">y</span>()&gt;m_MaxMap.<span class="built_in">height</span>())&#123;</span><br><span class="line">        y = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">y</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">y</span>()-m_MaxMap.<span class="built_in">height</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(screenRect.<span class="built_in">width</span>()-<span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">x</span>()&gt;m_MaxMap.<span class="built_in">width</span>())&#123;</span><br><span class="line">        x = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">x</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x = <span class="built_in">cursor</span>().<span class="built_in">pos</span>().<span class="built_in">x</span>()-m_MaxMap.<span class="built_in">width</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    m_MaxMap.<span class="built_in">move</span>(x,y);</span><br><span class="line">    m_MaxMap.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowIconWidget::leaveEvent</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_MaxMap.<span class="built_in">hide</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="拖放配置文件到一个exe，打开该exe"><a href="#拖放配置文件到一个exe，打开该exe" class="headerlink" title="拖放配置文件到一个exe，打开该exe"></a>拖放配置文件到一个exe，打开该exe</h1><p>拖放文件到一个exe时<br>文件的路径会作为命令行参数传递给应用程序<br>可以根据这个参数作处理</p>
<p><strong>main的原型函数是：</strong><br>*<em>main(int argc, char *<em>argv)</em></em><br><strong>其中：</strong><br><strong>argc 表示接收的命令个数</strong><br><strong>argv 传入的命令内容</strong></p>
<p><strong>argc == 1 就是说参数的个数为1.</strong> </p>
<p>*<em>argv是字符串数组,存的是参数,定义为char*<em>或者char* argv[]</em></em></p>
<p><strong>【举例】</strong> </p>
<p><strong>比如你编译好的程序为my.exe</strong> </p>
<p><strong>（1）在命令行执行 my.exe</strong> </p>
<p><strong>则：此时argc就是1，接受参数是1个，即参数argv[0]是”my.exe”</strong> </p>
<p><strong>（2）在命令行执行 my.exe 1 2 3</strong> </p>
<p><strong>则：此时argc就是4，接受参数是4个，即参数argv[0]是”my.exe”，argv[1]是”1”，argv[2]是”2”，argv[3]是”3”;</strong></p>
<p>if (argc &gt;= 2)</p>
<p>  Cfg::get()-&gt;setConfigPath(argv[1]);</p>
<h1 id="程序每次只能有一个实例运行"><a href="#程序每次只能有一个实例运行" class="headerlink" title="程序每次只能有一个实例运行"></a>程序每次只能有一个实例运行</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_Use96Dpi);</span><br><span class="line">    <span class="built_in">qputenv</span>(<span class="string">&quot;QT_SCALE_FACTOR&quot;</span>,QString::<span class="built_in">number</span>(<span class="number">1.0</span>).<span class="built_in">toLatin1</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Q_INIT_RESOURCE</span>(MapControl_qrc);</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于确保只有一个实例在运行的共享内存键值</span></span><br><span class="line">    <span class="keyword">const</span> QString sharedMemoryKey = <span class="string">&quot;MySingleApplicationKey1&quot;</span>;</span><br><span class="line">    <span class="comment">//尝试创建共享内存，如果创建失败，则表示已有一个实例在运行</span></span><br><span class="line">    <span class="function">QSharedMemory <span class="title">sharedMemory</span><span class="params">(sharedMemoryKey)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!sharedMemory.<span class="built_in">create</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 已有实例在运行，向现有实例发送消息（文件路径）</span></span><br><span class="line">        QLocalSocket socket;</span><br><span class="line">        socket.<span class="built_in">connectToServer</span>(sharedMemoryKey);</span><br><span class="line">        <span class="keyword">if</span> (socket.<span class="built_in">waitForConnected</span>(<span class="number">500</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获取命令行参数</span></span><br><span class="line">            QStringList args = QCoreApplication::<span class="built_in">arguments</span>();</span><br><span class="line">            <span class="keyword">if</span> (args.<span class="built_in">count</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 第二个参数是文件路径</span></span><br><span class="line">                QString filePath = args.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 发送文件路径给现有实例</span></span><br><span class="line">                socket.<span class="built_in">write</span>(filePath.<span class="built_in">toUtf8</span>());</span><br><span class="line">                socket.<span class="built_in">flush</span>();</span><br><span class="line">                socket.<span class="built_in">waitForBytesWritten</span>(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建本地服务器用于接收其他实例传递的文件路径</span></span><br><span class="line">    QLocalServer localServer;</span><br><span class="line">    <span class="keyword">if</span> (!localServer.<span class="built_in">listen</span>(sharedMemoryKey)) &#123;</span><br><span class="line">        <span class="comment">// 本地服务器监听失败</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;(<span class="string">&quot;Failed to start local server.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QResource::<span class="built_in">registerResource</span>(<span class="string">&quot;./resource.rcc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    MainWindow w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理新的文件路径</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;localServer, &amp;QLocalServer::newConnection, [&amp;]() &#123;</span><br><span class="line">        QLocalSocket *clientConnection = localServer.<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">        <span class="keyword">if</span> (clientConnection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientConnection-&gt;<span class="built_in">waitForReadyRead</span>(<span class="number">1000</span>)) &#123;</span><br><span class="line">                <span class="comment">// 读取文件路径</span></span><br><span class="line">                QByteArray data = clientConnection-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">                QString filePath = QString::<span class="built_in">fromUtf8</span>(data);</span><br><span class="line">                <span class="comment">// 处理文件路径</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 示例：显示文件路径</span></span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;(<span class="string">&quot;File Path&quot;</span>+filePath);</span><br><span class="line">                w.<span class="built_in">decompression</span>(filePath);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//                w.resize(Cfg::get()-&gt;valI(&quot;width&quot;),Cfg::get()-&gt;valI(&quot;height&quot;));</span></span><br><span class="line">                <span class="comment">//                w.move(Cfg::get()-&gt;valI(&quot;X&quot;),Cfg::get()-&gt;valI(&quot;Y&quot;));</span></span><br><span class="line">                <span class="comment">//                w.show();</span></span><br><span class="line">                w.<span class="built_in">resize</span>(rect.<span class="built_in">width</span>(),rect.<span class="built_in">height</span>());</span><br><span class="line">                w.<span class="built_in">move</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                w.<span class="built_in">showMaximized</span>();</span><br><span class="line">                w.<span class="built_in">resizeLabel</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            clientConnection-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">2</span>)</span><br><span class="line">        w.<span class="built_in">decompression</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    w.<span class="built_in">showMaximized</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="文件后缀关联应用程序，双击文件打开对应程序"><a href="#文件后缀关联应用程序，双击文件打开对应程序" class="headerlink" title="文件后缀关联应用程序，双击文件打开对应程序"></a>文件后缀关联应用程序，双击文件打开对应程序</h1><p><a href="https://blog.csdn.net/qq_43058397/article/details/113917992">https://blog.csdn.net/qq_43058397/article/details/113917992</a></p>
<p><a href="https://blog.csdn.net/Albert_weiku/article/details/127652571">https://blog.csdn.net/Albert_weiku/article/details/127652571</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">* 注册文件关联</span></span><br><span class="line"><span class="comment">*       className    // 自定义的类别</span></span><br><span class="line"><span class="comment">*       appPath      // 关联的程序目录</span></span><br><span class="line"><span class="comment">*       ext          // 关联的文件类型</span></span><br><span class="line"><span class="comment">*       extDes       // 该文件类型描述</span></span><br><span class="line"><span class="comment">*       iconPath     // 图标目录</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerFileRelation</span><span class="params">(<span class="keyword">const</span> QString&amp; className, <span class="keyword">const</span> QString&amp; appPath, <span class="keyword">const</span> QString&amp; ext, <span class="keyword">const</span> QString&amp; extDes, <span class="keyword">const</span> QString&amp; iconPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取注册表项的值,存在则不写入</span></span><br><span class="line">    <span class="function">QSettings <span class="title">settings</span><span class="params">(<span class="string">&quot;HKEY_CURRENT_USER\\Software\\Classes\\&quot;</span>+className+<span class="string">&quot;\\DefaultIcon\\&quot;</span>, QSettings::NativeFormat)</span></span>;</span><br><span class="line">    QVariant value = settings.<span class="built_in">value</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">// 例如，读取 &quot;29&quot; 键对应的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value.<span class="built_in">isValid</span>() &amp;&amp; value.<span class="built_in">toString</span>() == iconPath) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Value read from registry:&quot;</span> &lt;&lt; value.<span class="built_in">toString</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Registry value not found.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册表中不存在，要写入</span></span><br><span class="line">    <span class="function">QString <span class="title">baseUrl</span><span class="params">(<span class="string">&quot;HKEY_CURRENT_USER\\Software\\Classes&quot;</span>)</span></span>;    <span class="comment">// 要添加的顶层目录</span></span><br><span class="line">    <span class="function">QSettings <span class="title">settingClasses</span><span class="params">(baseUrl,QSettings::NativeFormat)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在...Classes\类别下创建一个新的类别，并设置该类别打开文件时的调用参数</span></span><br><span class="line">    settingClasses.<span class="built_in">setValue</span>(<span class="string">&quot;/&quot;</span> + className + <span class="string">&quot;/Shell/Open/Command/.&quot;</span>,<span class="string">&quot;\&quot;&quot;</span> + appPath + <span class="string">&quot;\&quot; \&quot;%1\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件类型描述</span></span><br><span class="line">    settingClasses.<span class="built_in">setValue</span>(<span class="string">&quot;/&quot;</span> + className + <span class="string">&quot;/.&quot;</span>,extDes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置该类别的默认图标默认图标</span></span><br><span class="line">    settingClasses.<span class="built_in">setValue</span>(<span class="string">&quot;/&quot;</span> + className + <span class="string">&quot;/DefaultIcon/.&quot;</span>,iconPath );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联ext 和 类别</span></span><br><span class="line">    settingClasses.<span class="built_in">setValue</span>(<span class="string">&quot;/&quot;</span> + ext + <span class="string">&quot;/OpenWithProgIds/&quot;</span> + className,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即保存该修改</span></span><br><span class="line">    settingClasses.<span class="built_in">sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制刷新注册表</span></span><br><span class="line">    QSettings::<span class="built_in">setDefaultFormat</span>(QSettings::NativeFormat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知系统刷新图标缓存</span></span><br><span class="line">    ::<span class="built_in">SHChangeNotify</span>(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_Use96Dpi);</span><br><span class="line">    <span class="built_in">qputenv</span>(<span class="string">&quot;QT_SCALE_FACTOR&quot;</span>,QString::<span class="built_in">number</span>(<span class="number">1.0</span>).<span class="built_in">toLatin1</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Q_INIT_RESOURCE</span>(MapControl_qrc);</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">className</span><span class="params">(<span class="string">&quot;MyTZP&quot;</span>)</span></span>;                              <span class="comment">// 自定义的类别</span></span><br><span class="line">    <span class="function">QString <span class="title">appPath</span><span class="params">(argv[<span class="number">0</span>])</span></span>;                                <span class="comment">// 关联的程序目录</span></span><br><span class="line">    <span class="function">QString <span class="title">ext</span><span class="params">(<span class="string">&quot;.TZP&quot;</span>)</span></span>;                                     <span class="comment">// 关联的文件类型</span></span><br><span class="line">    <span class="function">QString <span class="title">extDes</span><span class="params">(<span class="string">&quot;TZQX&quot;</span>)</span></span>;                                  <span class="comment">// 该文件类型描述</span></span><br><span class="line">    QString iconPath=QApplication::<span class="built_in">applicationDirPath</span>()+<span class="string">&quot;/logo.ico&quot;</span>;<span class="comment">// 该文件类型描述</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">registerFileRelation</span>(className,appPath,ext,extDes,iconPath);</span><br><span class="line">    QDir::<span class="built_in">setCurrent</span>(QApplication::<span class="built_in">applicationDirPath</span>());</span><br><span class="line"></span><br><span class="line">    QResource::<span class="built_in">registerResource</span>(<span class="string">&quot;./resource.rcc&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.<span class="built_in">showMaximized</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Qt-调用其他exe"><a href="#Qt-调用其他exe" class="headerlink" title="Qt 调用其他exe"></a>Qt 调用其他exe</h1><h2 id="传递参数1"><a href="#传递参数1" class="headerlink" title="传递参数1"></a>传递参数1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QProcess *myProcess=<span class="keyword">new</span> <span class="built_in">QProcess</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//QString program = &quot;..\\camera\\HCN_PTZControl\\release\\HCN_PTZControl.exe&quot;;</span></span><br><span class="line">QString program = <span class="string">&quot;.\\camera\\HCN\\HCN_PTZControl.exe&quot;</span>;<span class="comment">//&quot;./camera\\HCN\\HCN_PTZControl.exe&quot;;</span></span><br><span class="line">QStringList arguments;</span><br><span class="line"><span class="comment">//qDebug()&lt;&lt;&quot;-------------------------------------------------------------------------------------&quot;;</span></span><br><span class="line"><span class="comment">//TCPPort,camIP,camPort,camuser,camPass,video,UDPIP,UDPPort,boardUDPPort</span></span><br><span class="line">arguments&lt;&lt;QString::<span class="built_in">number</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;LeftTCPPort&quot;</span>))</span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(ipport[<span class="number">0</span>])</span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(ipport[<span class="number">1</span>])</span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(ipport[<span class="number">2</span>])</span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(ipport[<span class="number">3</span>])</span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;LeftvideoAddress&quot;</span>))<span class="comment">//可见光视频流</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;LeftredAddress&quot;</span>))<span class="comment">//红外视频流</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;LeftDetectIP&quot;</span>))<span class="comment">//检测IP</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">number</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;LeftDetectPort&quot;</span>)) <span class="comment">//检测Port</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">number</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;LeftSortPort&quot;</span>)) <span class="comment">//跟踪Port</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">number</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;LeftBoard&quot;</span>)) <span class="comment">//标牌Port</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;LeftControlIP&quot;</span>))<span class="comment">//控制红外切换</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">number</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;LeftControlPort&quot;</span>))<span class="comment">//控制红外切换</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromStdString</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valS</span>(<span class="string">&quot;MessSendIp&quot;</span>))<span class="comment">//状态发送</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">number</span>(Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">valI</span>(<span class="string">&quot;MessSendPort&quot;</span>))<span class="comment">//状态发送</span></span><br><span class="line">    &lt;&lt;QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;Left&quot;</span>);</span><br><span class="line"><span class="comment">//            qDebug()&lt;&lt;&quot;-------------------------------------------------------------------------------------&quot;&lt;&lt;arguments;</span></span><br><span class="line">myProcess-&gt;<span class="built_in">start</span>(program,arguments);</span><br></pre></td></tr></table></figure>

<h2 id="传递参数2"><a href="#传递参数2" class="headerlink" title="传递参数2"></a>传递参数2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QProcess p;</span><br><span class="line">p.<span class="built_in">start</span>(<span class="string">&quot;cmd&quot;</span>, <span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;/c&quot;</span>&lt;&lt;QDir::<span class="built_in">currentPath</span>()+<span class="string">&quot;/readpdf/readpdf.exe --file &quot;</span>+filename);</span><br><span class="line">p.<span class="built_in">waitForStarted</span>();</span><br><span class="line">p.<span class="built_in">waitForFinished</span>();</span><br><span class="line">QString strTemp=QString::<span class="built_in">fromLocal8Bit</span>(p.<span class="built_in">readAllStandardOutput</span>());</span><br></pre></td></tr></table></figure>

<h2 id="带dos界面"><a href="#带dos界面" class="headerlink" title="带dos界面"></a>带dos界面</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QProcess m_process;</span><br><span class="line">m_process.<span class="built_in">setWorkingDirectory</span>(<span class="string">&quot;E:/Projects/SpxFrame/212/TZweatherDisplay/Main/release/RouteOptimization/setUp/&quot;</span>);</span><br><span class="line">m_process.<span class="built_in">start</span>(<span class="string">&quot;cmd.exe&quot;</span>);                                                                                                     </span><br><span class="line">m_process.<span class="built_in">write</span>(<span class="string">&quot;start E:/Projects/SpxFrame/212/TZweatherDisplay/Main/release/RouteOptimization/setUp/setUp.exe\n&quot;</span>);            </span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/image-20240115090347335.png" alt="image-20240115090347335"></p>
<h2 id="不带dos界面"><a href="#不带dos界面" class="headerlink" title="不带dos界面"></a>不带dos界面</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QProcess m_process;</span><br><span class="line">m_process.<span class="built_in">setWorkingDirectory</span>(<span class="string">&quot;E:/Projects/SpxFrame/212/TZweatherDisplay/Main/release/RouteOptimization/setUp/&quot;</span>);</span><br><span class="line">m_process.<span class="built_in">start</span>(<span class="string">&quot;E:/Projects/SpxFrame/212/TZweatherDisplay/Main/release/RouteOptimization/setUp/setUp.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/image-20240115090236827.png" alt="image-20240115090236827"></p>
<h1 id="Qt使用HTTP通信（以调用百度翻译api为例）"><a href="#Qt使用HTTP通信（以调用百度翻译api为例）" class="headerlink" title="Qt使用HTTP通信（以调用百度翻译api为例）"></a>Qt使用HTTP通信（以调用百度翻译api为例）</h1><p>Qt使用HTTP主要用到以下三个类：</p>
<p>QNetworkAccessManager 该类允许应用发送网络请求并接收响应。</p>
<p>QNetworkRequest 该类包含了一个由QNetworkAccessManager发送的请求。</p>
<p>QNetworkReply 该类包含接收到的数据部分和QNetworkAccessManager发送请求的头部。</p>
<p>1.工程文件.pro里必须有network</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QT       += core gui network</span><br></pre></td></tr></table></figure>

<p>2.阅读百度翻译api帮助文档，定义请求体各段内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString MainWindow::API = <span class="string">&quot;http://api.fanyi.baidu.com/api/trans/vip/translate?&quot;</span>;</span><br><span class="line">QString MainWindow::from = <span class="string">&quot;en&quot;</span>;</span><br><span class="line">QString MainWindow::to = <span class="string">&quot;zh&quot;</span>;</span><br><span class="line">QString MainWindow::appid=输入你申请的id;</span><br><span class="line">QString MainWindow::salt=<span class="string">&quot;1435660288&quot;</span>;</span><br><span class="line">QString MainWindow::password = 输入你申请的password;</span><br></pre></td></tr></table></figure>

<p>3.定义请求成功后的槽函数并在cpp文件中自行实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replyFinished</span><span class="params">(QNetworkReply *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>4.拼接百度翻译pai请求内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString url;</span><br><span class="line">QString str1 = appid + transwordFrom + salt + password;</span><br><span class="line">str1 = str1.<span class="built_in">toUtf8</span>();</span><br><span class="line">QString sign;</span><br><span class="line">QByteArray ba, bb;</span><br><span class="line"><span class="function">QCryptographicHash <span class="title">md</span><span class="params">(QCryptographicHash::Md5)</span></span>;</span><br><span class="line">ba.<span class="built_in">append</span>(str1);</span><br><span class="line">md.<span class="built_in">addData</span>(ba);</span><br><span class="line">bb = md.<span class="built_in">result</span>();</span><br><span class="line">sign.<span class="built_in">append</span>(bb.<span class="built_in">toHex</span>());</span><br><span class="line">url = API + <span class="string">&quot;q=&quot;</span> + transwordFrom + <span class="string">&quot;&amp;from=&quot;</span> + from + <span class="string">&quot;&amp;to=&quot;</span> + to + <span class="string">&quot;&amp;appid=&quot;</span> + appid + <span class="string">&quot;&amp;salt=&quot;</span> + salt + <span class="string">&quot;&amp;sign=&quot;</span> + sign;</span><br></pre></td></tr></table></figure>

<p>5.本来通过manager-&gt;<em>get</em>(QNetworkRequest(QUrl(url)));//发送请求</p>
<p>就可以等待槽函数响应了，但是会出现读取日文的while会阻塞主线程，槽函数响应不及时，所以需要不经过槽函数，就有了下面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QEventLoop temp_loop;</span><br><span class="line">QNetworkReply *reply = manager-&gt;*get*(<span class="built_in">QNetworkRequest</span>(<span class="built_in">QUrl</span>(url)));<span class="comment">//发送请求</span></span><br><span class="line"><span class="built_in">connect</span>(reply, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), &amp;temp_loop, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">temp_loop.<span class="built_in">exec</span>();</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">replyFinished</span>(Donttransword,reply);</span><br></pre></td></tr></table></figure>

<p><strong>//QNetworkAccessManager不使用信号/槽机制来获得QNetworkReply的解决办法</strong></p>
<p><strong>//<a href="https://blog.csdn.net/sheldon0227/article/details/50170437">https://blog.csdn.net/sheldon0227/article/details/50170437</a></strong></p>
<p>6.replyFinished函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JanToChn::replyFinished</span><span class="params">(QString Donttransword, QNetworkReply *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString mean = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    QTextCodec * codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;Shift-JIS&quot;</span>);</span><br><span class="line">    QString all = reply-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; all;</span><br><span class="line">    QJsonParseError jsonError;</span><br><span class="line">    QJsonDocument json = QJsonDocument::<span class="built_in">fromJson</span>(all.<span class="built_in">toUtf8</span>(), &amp;jsonError);</span><br><span class="line">    <span class="keyword">if</span> (jsonError.error == QJsonParseError::NoError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (json.<span class="built_in">isObject</span>()) &#123;</span><br><span class="line">            QJsonObject rootObj = json.<span class="built_in">object</span>();</span><br><span class="line">            <span class="keyword">if</span> (rootObj.<span class="built_in">contains</span>(<span class="string">&quot;trans_result&quot;</span>)) &#123;</span><br><span class="line">                QJsonValue resultValue = rootObj.<span class="built_in">value</span>(<span class="built_in">QString</span>(<span class="string">&quot;trans_result&quot;</span>));</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; resultValue;</span><br><span class="line">            </span><br><span class="line">                QJsonArray array = resultValue.<span class="built_in">toArray</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    QJsonObject explains = array.<span class="built_in">at</span>(i).<span class="built_in">toObject</span>();</span><br><span class="line">                    <span class="keyword">if</span> (explains.<span class="built_in">contains</span>(<span class="string">&quot;dst&quot;</span>)) &#123;</span><br><span class="line">                        QJsonValue dst = explains.<span class="built_in">value</span>(<span class="built_in">QString</span>(<span class="string">&quot;dst&quot;</span>));</span><br><span class="line">                        <span class="built_in">qDebug</span>() &lt;&lt; dst.<span class="built_in">toString</span>();</span><br><span class="line">                        mean = mean + dst.<span class="built_in">toString</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                QByteArray encodedString = codec-&gt;<span class="built_in">fromUnicode</span>(mean);</span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; mean; <span class="comment">//mean.toUtf8();//输出翻译结果</span></span><br><span class="line">                <span class="comment">//ui.textEditTransed-&gt;append(mean);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reply-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    Donttransword = Donttransword + <span class="string">&quot;;&quot;</span> + mean;</span><br><span class="line">    ui.textEditTransed-&gt;<span class="built_in">append</span>(Donttransword);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TextEdit中显示日文"><a href="#TextEdit中显示日文" class="headerlink" title="TextEdit中显示日文"></a>TextEdit中显示日文</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置文件路径</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(m_sOpenPath.toUtf8())</span></span>;</span><br><span class="line">    <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text))</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;打开文件&quot;</span>), QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;打开文件失败！&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件流</span></span><br><span class="line">    <span class="function">QTextStream <span class="title">ts</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件中的数据</span></span><br><span class="line">    QString str_get;</span><br><span class="line">    <span class="comment">//就这句就这句，改变编码！！！！！！！！！！！！</span></span><br><span class="line">    ts.<span class="built_in">setCodec</span>(<span class="string">&quot;Shift-JIS&quot;</span>);</span><br><span class="line">    <span class="comment">//QTextCodec * codec = QTextCodec::codecForName(&quot;UTF-8&quot;);</span></span><br><span class="line">    <span class="comment">//循环文档数据至结尾</span></span><br><span class="line">    <span class="keyword">while</span> (!ts.<span class="built_in">atEnd</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将全部数据绑定str_get</span></span><br><span class="line">        str_get = ts.<span class="built_in">readLine</span>();</span><br><span class="line">        ui.textEdit-&gt;<span class="built_in">append</span>(str_get);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文档</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">TextEdit中是Unicode编码，可以直接显示日文，只要能读出来日文就行</span><br></pre></td></tr></table></figure>

<h1 id="qt多显示器获取不同显示器的分辨率和位置"><a href="#qt多显示器获取不同显示器的分辨率和位置" class="headerlink" title="qt多显示器获取不同显示器的分辨率和位置"></a><a href="https://blog.csdn.net/x85371169/article/details/79351999">qt多显示器获取不同显示器的分辨率和位置</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QDesktopWidget *desktop = QApplication::<span class="built_in">desktop</span>();</span><br><span class="line"><span class="comment">//QRect screen1=desktop-&gt;screenGeometry(0);//主显示器</span></span><br><span class="line"><span class="comment">//QRect screen2=desktop-&gt;screenGeometry(1);//扩展显示器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得当前程序所在屏幕的编号</span></span><br><span class="line"><span class="keyword">int</span> curWidgetScreenNum=desktop-&gt;<span class="built_in">screenNumber</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//当前程序所在屏幕的编号获取屏幕分辨率</span></span><br><span class="line">QRect rect = desktop-&gt;<span class="built_in">availableGeometry</span>(curWidgetScreenNum);</span><br><span class="line"><span class="built_in">move</span>(rect.<span class="built_in">x</span>(),rect.<span class="built_in">y</span>());</span><br><span class="line"><span class="built_in">resize</span>(rect.<span class="built_in">width</span>(), rect.<span class="built_in">height</span>());</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> QRect <span class="title">QDesktopWidget::screenGeometry</span><span class="params">(<span class="keyword">int</span> screen = <span class="number">-1</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//其中的参数就是显示器的id，默认是-1，如果是多个显示器，则显示器编号依次为0（主显示器）,1,2,3...，这个编号和你在设置里看到的编号没一点关系</span></span></span><br></pre></td></tr></table></figure>

<p>desktop-&gt;screenGeometry(1)会把任务栏也算上，如果不想要任务栏的rect，可以使用availableGeometry函数</p>
<p>在没创建widget的时候就想要获取一个分辨率信息用于初始化或者别的作用，可以通过 int curMonitor = desktop-&gt;primaryScreen(); 初始化显示器编号为主显示器的编号并由此获取主显示器的相关信息。curMonitor初始化为-1的时候获取到的也始终是主显示器的大小。</p>
<h1 id="QPainter旋转"><a href="#QPainter旋转" class="headerlink" title="QPainter旋转"></a>QPainter旋转</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以pt1为基准,坐标原点在左下角（m_lastX，m_lastY，m_curX，m_curY坐标原点在左上角）</span></span><br><span class="line"><span class="function">QPointF <span class="title">c</span><span class="params">(m_lastX, <span class="keyword">this</span>-&gt;height()-m_lastY)</span></span>;<span class="comment">//交点</span></span><br><span class="line"><span class="function">QPointF <span class="title">pt1</span><span class="params">(m_lastX, <span class="keyword">this</span>-&gt;height()-m_lastY+<span class="number">10</span>)</span></span>;<span class="comment">//基准轴某一点</span></span><br><span class="line"><span class="function">QPointF <span class="title">pt2</span><span class="params">(m_curX, <span class="keyword">this</span>-&gt;height()-m_curY)</span></span>;<span class="comment">//目标点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重新计算角度和距离</span></span><br><span class="line"><span class="keyword">float</span> theta = <span class="built_in">getAngelOfTwoVector</span>(pt1,pt2,c);</span><br><span class="line"><span class="comment">//设定旋转中心点，把（0,0）点设置在(m_curX,m_curY)</span></span><br><span class="line">painter.<span class="built_in">translate</span>(m_curX,m_curY);</span><br><span class="line"><span class="comment">//旋转theta度，顺时针，正北为0度</span></span><br><span class="line">painter.<span class="built_in">rotate</span>(theta);</span><br><span class="line"><span class="comment">//绘制图标</span></span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(<span class="number">-45</span>,<span class="number">-45</span>,<span class="number">90</span>,<span class="number">90</span>, MouseArraw);</span><br><span class="line"><span class="comment">//恢复旋转中心</span></span><br><span class="line">painter.<span class="built_in">resetTransform</span>();</span><br></pre></td></tr></table></figure>

<h2 id="任务栏隐藏图标"><a href="#任务栏隐藏图标" class="headerlink" title="任务栏隐藏图标"></a>任务栏隐藏图标</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其实很简单，只要对窗口对象，设置一个父窗口就行。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QApplication::<span class="built_in">setQuitOnLastWindowClosed</span>(<span class="literal">false</span>);</span><br><span class="line">    QWidget* parent = <span class="keyword">new</span> QWidget;</span><br><span class="line">    Demo *pDemo = <span class="keyword">new</span> <span class="built_in">Demo</span>(parent);</span><br><span class="line">    pDemo-&gt;<span class="built_in">show</span>();</span><br><span class="line">    pDemo-&gt;<span class="built_in">activateWindow</span>();</span><br><span class="line">    <span class="keyword">int</span> ret = a.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="keyword">delete</span> parent;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h1><p><a href="https://www.cnblogs.com/dissun/p/10505007.html">https://www.cnblogs.com/dissun/p/10505007.html</a></p>
<h2 id="mosquitto-sub"><a href="#mosquitto-sub" class="headerlink" title="mosquitto_sub"></a>mosquitto_sub</h2><p>command：订阅主题，接收到消息时打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mosquitto_sub [-c] [-d] [-h hostname] [-i client_id] [-I client id prefix] [-k keepalive time] [-p port number] [-q message QoS] [--quiet] [-v] [ -u username [-Ppassword] ] [ --will-topic topic [--will-payload payload] [--will-qos qos] [--will-retain] ] -t message topic ...  </span><br></pre></td></tr></table></figure>

<p>options：<br>-c, –disable-clean-session：禁止’clean session’选项，即如果客户端断开连接，这个订阅仍然保留来接收随后到的QoS为1和2的消息，当改客户端重新连接之后，它将接收到已排在队列中的消息。建议使用此选项时，客户端id选项设为–id</p>
<p>-d, –debug：开启debug选项</p>
<p>-h, –host：说明所连接到的域名，默认是localhost</p>
<p>-i, –id：客户端的ID号，如果没有指定，默认是mosquitto_pub_加上客户端的进程id，不能和–id_prefix同时使用。</p>
<p>-I, –id-prefix：指定客户端ID的前缀，与客户端的进程ID连接组成客户端的ID，不能喝–id同时使用。</p>
<p>-k, –keepalive：给代理发送PING命令（目的在于告知代理该客户端连接保持且在正常工作）的间隔时间，默认是60s</p>
<p>-p, –port：说明客户端连接到的端口，默认是1883</p>
<p>-P, –pw：指定密码用于代理认证，使用此选项时必须有有效的用户名。</p>
<p>-q, –qos：指定消息的服务质量，可以为0,1,2，默认是0.</p>
<p>–quiet：如果指定该选项，则不会有任何错误被打印，当然，这排除了无效的用户输入所引起的错误消息。</p>
<p>-t, –topic：指定订阅的消息主题，允许同时订阅到多个主题</p>
<p>-u, –username：指定用户名用于代理认证。</p>
<p>-v, –verbose：冗长地打印收到的消息。若指定该选项，打印消息时前面会打印主题名——“主题 消息内容”，否则，只打印消息内容</p>
<p>–will-payload：如果指定该选项，则万一客户端意外和代理服务器断开，则该消息将被保留在服务端并发送出去，该选项必须同时用–will-topic指定主题。</p>
<p>–will-qos：指定Will的服务质量，默认是0.必须和选项 –will-topic同时使用.</p>
<p>–will-retain：如果指定该选项，则万一客户端意外断开，已被发送的消息将被当做retained消息。必须和选项 –will-topic同时使用.</p>
<p>–will-topic：指定客户端意外断开时，Will消息发送到的主题。</p>
<h2 id="mosquitto-pub"><a href="#mosquitto-pub" class="headerlink" title="mosquitto_pub"></a>mosquitto_pub</h2><p>command：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mosquitto_pub [-d] [-h hostname] [-i client_id] [-I client id prefix] [-p port number] [-q message QoS] [--quiet] [-r] &#123; -f file | -l | -m message | -n | -s&#125; [-u username [-P password] ] [ --will-topic topic [--will-payload payload] [--will-qos qos] [--will-retain] ] -t message-topic</span><br></pre></td></tr></table></figure>

<p>options：<br>-d, –debug ：开启debug选项</p>
<p>-f, –file：把一个文件的内容做为消息的内容发送。经测试，支持txt文件，不支持doc等其他形式文件。</p>
<p>-h, –host：说明所连接到的域名，默认是localhost</p>
<p>-i, –id：客户端的ID号，如果没有指定，默认是mosquitto_pub_加上客户端的进程id，不能和–id_prefix同时使用。</p>
<p>-I, –id-prefix ：指定客户端ID的前缀，与客户端的进程ID连接组成客户端的ID，不能和–id同时使用。</p>
<p>-l, –stdin-line：从总段读取输入发送消息，一行为一条消息，空白行不会被发送。</p>
<p>-m, –message：从命令行发送一条消息，-m后面跟发送的消息内容。</p>
<p>-n, –null-message：发送一条空消息。</p>
<p>-p, –port：连接的端口号，默认是1883.</p>
<p>-P, –pw：指定密码用于代理认证，使用此选项时必须有有效的用户名。</p>
<p>-q, –qos：指定消息的服务质量，可以为0,1,2，默认是0.</p>
<p>–quiet：如果指定该选项，则不会有任何错误被打印，当然，这排除了无效的用户输入所引起的错误消息。</p>
<p>-r, –retain：如果指定该选项，该条消息将被保留做为最后一条收到的消息。下一个订阅消息者将能至少收到该条消息。</p>
<p>-s, –stdin-file：从标准输入接收传输的消息内容，所有输入做为一条消息发送。</p>
<p>-t, –topic：指定消息所发布到哪个主题。</p>
<p>-u, –username：指定用户名用于代理认证。</p>
<p>–will-payload：如果指定该选项，则万一客户端意外和代理服务器断开，则该消息将被保留在服务端并发送出去，该选项必须同时用–will-topic指定主题。</p>
<p>–will-qos：指定Will的服务质量，默认是0.必须和选项 –will-topic同时使用.</p>
<p>–will-retain：如果指定该选项，则万一客户端意外断开，已被发送的消息将被当做retained消息。必须和选项 –will-topic同时使用.</p>
<p>–will-topic：指定客户端意外断开时，Will消息发送到的主题。</p>
<h2 id="mosquito-conf-配置"><a href="#mosquito-conf-配置" class="headerlink" title="mosquito.conf 配置"></a>mosquito.conf 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#设置不允许匿名登录</span><br><span class="line">allow_anonymous false</span><br><span class="line">#设置账户密码文件位置为C:\MosquittoTest\pwfile.example</span><br><span class="line">password_file C:/Program Files/mosquitto/pwfile.example</span><br><span class="line">#监听的本机IP和端口</span><br><span class="line">listener 1883 192.168.30.251</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用户文件配置"><a href="#用户文件配置" class="headerlink" title="用户文件配置"></a>用户文件配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mosquitto_passwd -c /MosquittoTest/pwfile.example zwl</span><br><span class="line">（使用-c 参数会导致清空密码文件，重新插入用户，但是不使用-c在Windows下没有成功）</span><br></pre></td></tr></table></figure>

<h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mosquitto.exe -c mosquitto.conf -v</span><br></pre></td></tr></table></figure>

<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mosquitto_sub.exe -h 192.168.30.251 -p 1883 -u zwl -P iscas -i test1 -v -t first</span><br><span class="line">mosquitto_sub.exe -h 192.168.30.251 -p 1883 -u zwl -P iscas -i test2 -v -t second</span><br></pre></td></tr></table></figure>

<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mosquitto_pub.exe -h 192.168.30.251 -p 1883 -u zwl -P iscas -t first -m hello</span><br></pre></td></tr></table></figure>

<h2 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line">qmqttauthenticationproperties.h:33: error: C1083: 无法打开包括文件: “QtMqtt/qmqttglobal.h”: No such file or directory</span><br><span class="line">打开 qmqttauthenticationproperties.h 文件，发现有这么两句：</span><br><span class="line">#include &lt;QtMqtt/qmqttglobal.h&gt;</span><br><span class="line">#include &lt;QtMqtt/qmqtttype.h&gt;</span><br><span class="line">在 Qt 的 include 目录下新建一个 QtMqtt 文件夹（注意 x86 和 x64 所在的目录不一样），把 头文件都复制一份到这个目录。</span><br><span class="line">再编译就不报这个错误了。</span><br><span class="line">2.</span><br><span class="line">下一个错误是：qmqttconnection.cpp:169: error: C2039: “errorOccurred”: 不是“QAbstractSocket”的成员</span><br><span class="line">qmqttconnection.cpp 中 168行有这么一句：</span><br><span class="line">connect(socket, &amp;QAbstractSocket::errorOccurred, this, &amp;QMqttConnection::transportError);</span><br><span class="line">就是这句出了问题。查帮助文档或者源代码都可以发现 QAbstractSocket 没有 errorOccurred 这个 信号。有的那个信号叫：</span><br><span class="line">void error(QAbstractSocket::SocketError socketError)</span><br><span class="line">所以要改写成：</span><br><span class="line">connect(socket, static_cast&lt;void(QAbstractSocket::*)(QAbstractSocket::SocketError)&gt; (&amp;QAbstractSocket::error), </span><br><span class="line">            this, static_cast&lt;void(QMqttConnection::*)(QAbstractSocket::SocketError)&gt;(&amp;QMqttConnection::transportError) );</span><br><span class="line">3.</span><br><span class="line">再次编译。还有错误：</span><br><span class="line">qmqtttopicname.cpp:148: error: C2039: “KeepEmptyParts”: 不是“Qt”的成员</span><br><span class="line">qmqtttopicname.cpp 148 行代码是这样的：</span><br><span class="line">return d-&gt;name.split(QLatin1Char(&#x27;/&#x27;), Qt::KeepEmptyParts);</span><br><span class="line">改写成：</span><br><span class="line">return d-&gt;name.split(QLatin1Char(&#x27;/&#x27;), QString::KeepEmptyParts);</span><br><span class="line">4.</span><br><span class="line">再次编译，还有最后一个错误：</span><br><span class="line">qmqtttopicname.cpp:189: error: call to &#x27;qHash&#x27; is ambiguous</span><br><span class="line">qmqtttopicname.cpp 189行是：</span><br><span class="line">return qHash(name.d-&gt;name, seed);</span><br><span class="line">改为：</span><br><span class="line">return qHash(static_cast&lt;QString&gt;(name.d-&gt;name), static_cast&lt;uint&gt;(seed));</span><br><span class="line">5.</span><br><span class="line">类似的还有：</span><br><span class="line">return qHash(filter.d-&gt;filter, seed);</span><br><span class="line">改为：</span><br><span class="line">return qHash(static_cast&lt;QString&gt;(filter.d-&gt;filter), static_cast&lt;uint&gt;(seed));</span><br><span class="line"></span><br><span class="line">6.</span><br><span class="line">QList .resize()的问题</span><br><span class="line">	m_receiveAliases.resize(m_clientPrivate-&gt;m_serverConnectionProperties.maximumTopicAlias());</span><br><span class="line">	m_publishAliases.resize(m_clientPrivate-&gt;m_connectionProperties.maximumTopicAlias());</span><br><span class="line">QList 没有resize()函数</span><br><span class="line">转到m_publishAliases定义处：</span><br><span class="line">    QList&lt;QMqttTopicName&gt; m_receiveAliases;</span><br><span class="line">    QList&lt;QMqttTopicName&gt; m_publishAliases;</span><br><span class="line">改成：</span><br><span class="line"></span><br><span class="line">	QVector&lt;QMqttTopicName&gt; m_receiveAliases;</span><br><span class="line">    QVector&lt;QMqttTopicName&gt; m_publishAliases;</span><br><span class="line"></span><br><span class="line">7.</span><br><span class="line">error: ‘QStringView’ was not declared in this scope</span><br><span class="line">	QStringView root = QStringView&#123;d-&gt;filter&#125;.left(d-&gt;filter.size() - 1);</span><br><span class="line">改成：</span><br><span class="line"></span><br><span class="line">	QString root = QString&#123;d-&gt;filter&#125;.left(d-&gt;filter.size() - 1);</span><br><span class="line">没用过QStringView 也没见过，但通过函数功能看，类似QString，替换后还真可以了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Ubuntu下，Qt-调用bash执行python脚本"><a href="#Ubuntu下，Qt-调用bash执行python脚本" class="headerlink" title="Ubuntu下，Qt 调用bash执行python脚本"></a>Ubuntu下，Qt 调用bash执行python脚本</h1><p>调用方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  CondaInitialize    <span class="meta-string">&quot;__conda_setup=\&quot;$(&#x27;/home/iscas/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)\&quot;\n&quot;</span> \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;if [ $? -eq 0 ]; then \n&quot;</span>      \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;    eval \&quot;$__conda_setup\&quot; \n&quot;</span>\</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;else \n                        &quot;</span>\</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;    if [ -f \&quot;/home/iscas/anaconda3/etc/profile.d/conda.sh\&quot; ]; then \n&quot;</span>   \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;        . \&quot;/home/iscas/anaconda3/etc/profile.d/conda.sh\&quot; \n&quot;</span>             \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;    else \n&quot;</span>   \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;        export PATH=\&quot;/home/iscas/anaconda3/bin:$PATH\&quot; \n&quot;</span>                \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;    fi \n&quot;</span>     \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;fi \n&quot;</span>         \</span></span><br><span class="line"><span class="meta">                            <span class="meta-string">&quot;unset __conda_setup \n&quot;</span>    \</span></span><br><span class="line"><span class="meta">                            </span></span><br><span class="line">OneAlgorithmForm *temp1=<span class="keyword">new</span> <span class="built_in">OneAlgorithmForm</span>(<span class="string">&quot;Video&quot;</span>,<span class="string">&quot;/home/iscas/video_yolov5/&quot;</span>,</span><br><span class="line">                                                 <span class="string">&quot;cd /home/iscas/video_yolov5/ \n&quot;</span></span><br><span class="line">                                                 CondaInitialize</span><br><span class="line">                                                 <span class="string">&quot;conda activate yolov5 \n&quot;</span></span><br><span class="line">                                                 <span class="string">&quot;python detect_202_hikvision.py --VideoPosition 右侧 --source_v udp://192.168.30.61:15843 --source_inf udp://192.168.30.61:15844 --local_port 5679 --out_port 43902 \n&quot;</span></span><br><span class="line">                                                 );</span><br></pre></td></tr></table></figure>

<p>需要注意，这种方式下，需要python文件的输出不能有缓冲，否则，只有当bash全部输出之后才会响应readyReadStandardOutput信号，python不缓冲输出可以在print后接一句sys.stdout.flush()</p>
<p>.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONEALGORITHMFORM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONEALGORITHMFORM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QProcess&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneAlgorithmForm</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneAlgorithmForm</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">OneAlgorithmForm</span><span class="params">(QString name,QString path,QString parm,QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">OneAlgorithmForm</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_readoutput</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_readerror</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::OneAlgorithmForm *ui;</span><br><span class="line">    QString m_name;</span><br><span class="line">    QString m_path;</span><br><span class="line">    QString m_parm;</span><br><span class="line">    QProcess* process=<span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONEALGORITHMFORM_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;OneAlgorithmForm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_OneAlgorithmForm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QProcess&gt;</span></span></span><br><span class="line"></span><br><span class="line">OneAlgorithmForm::<span class="built_in">OneAlgorithmForm</span>(QString name,QString path,QString parm,QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::OneAlgorithmForm)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_name=name;</span><br><span class="line">    m_path=path;</span><br><span class="line">    m_parm=parm;</span><br><span class="line"></span><br><span class="line">    ui-&gt;groupBox-&gt;<span class="built_in">setTitle</span>(m_name);</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(m_path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OneAlgorithmForm::~<span class="built_in">OneAlgorithmForm</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneAlgorithmForm::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(process==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        process = <span class="keyword">new</span> <span class="built_in">QProcess</span>(<span class="keyword">this</span>);<span class="comment">//创建进程对象</span></span><br><span class="line">        <span class="built_in">connect</span>(process , <span class="built_in">SIGNAL</span>(<span class="built_in">readyReadStandardOutput</span>()) , <span class="keyword">this</span> , <span class="built_in">SLOT</span>(<span class="built_in">on_readoutput</span>()));</span><br><span class="line">        <span class="built_in">connect</span>(process , <span class="built_in">SIGNAL</span>(<span class="built_in">readyReadStandardError</span>()) , <span class="keyword">this</span> , <span class="built_in">SLOT</span>(<span class="built_in">on_readerror</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;pushButton-&gt;<span class="built_in">text</span>()==<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        process-&gt;<span class="built_in">start</span>(<span class="string">&quot;bash&quot;</span>); <span class="comment">//启动终端(Windows下改为cmd)</span></span><br><span class="line">        process-&gt;<span class="built_in">waitForStarted</span>(); <span class="comment">//等待启动完成</span></span><br><span class="line">        process-&gt;<span class="built_in">write</span>(m_parm.<span class="built_in">toUtf8</span>()); <span class="comment">//向终端写入“ls”命令，注意尾部的“\n”不可省略</span></span><br><span class="line"></span><br><span class="line">        ui-&gt;plainTextEdit-&gt;<span class="built_in">appendPlainText</span>(<span class="string">&quot;start bash with :&quot;</span> + m_parm);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ui-&gt;pushButton-&gt;<span class="built_in">text</span>()==<span class="string">&quot;stop&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        process-&gt;<span class="built_in">close</span>();</span><br><span class="line">        process-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        process-&gt;<span class="built_in">waitForFinished</span>();</span><br><span class="line">        ui-&gt;plainTextEdit-&gt;<span class="built_in">appendPlainText</span>(<span class="string">&quot;stop bash with :&quot;</span> + m_parm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneAlgorithmForm::on_readoutput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;plainTextEdit-&gt;<span class="built_in">blockCount</span>()&gt;<span class="number">1000</span>)</span><br><span class="line">        ui-&gt;plainTextEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    ui-&gt;plainTextEdit-&gt;<span class="built_in">appendPlainText</span>(QString::<span class="built_in">fromUtf8</span>(process-&gt;<span class="built_in">readAllStandardOutput</span>().<span class="built_in">data</span>())); <span class="comment">//将输出信息读取到编辑框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OneAlgorithmForm::on_readerror</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="number">0</span>, <span class="string">&quot;Error&quot;</span>, process-&gt;<span class="built_in">readAllStandardError</span>().<span class="built_in">data</span>()); <span class="comment">//弹出信息框提示错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Qt-发送图片"><a href="#Qt-发送图片" class="headerlink" title="Qt 发送图片"></a>Qt 发送图片</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">QByteArray ba;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;ba)</span></span>;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">vedioimg.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;PNG&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=ba.<span class="built_in">size</span>()/<span class="number">40000</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ba.<span class="built_in">size</span>()-i*<span class="number">40000</span>&lt;<span class="number">40000</span>)&#123;</span><br><span class="line">        m_udp2-&gt;<span class="built_in">sendMsg</span>(ba.<span class="built_in">right</span>(ba.<span class="built_in">size</span>()-i*<span class="number">40000</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>()-&gt;<span class="built_in">msleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_udp2-&gt;<span class="built_in">sendMsg</span>(ba.<span class="built_in">mid</span>(i*<span class="number">40000</span>,<span class="number">40000</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">thread</span>()-&gt;<span class="built_in">msleep</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch);</span><br></pre></td></tr></table></figure>

<h1 id="Qt-发邮件"><a href="#Qt-发邮件" class="headerlink" title="Qt 发邮件"></a>Qt 发邮件</h1><p> <a href="example.zip">example.zip</a> </p>
<p> <a href="%E8%AF%B4%E6%98%8E.txt">说明.txt</a> </p>
<p><img src="/2021/06/27/Qt/image-20231201164858897.png" alt="image-20231201164858897"></p>
<p>1.开启发送邮箱的smtp服务</p>
<p>2.用户名和发件人都是1的邮箱名，密码不是邮箱密码，是smtp的授权码</p>
<p>3.注意使用的smtp服务器（<a href="https://blog.51cto.com/u_12528551/5900477%E3%80%81https://www.kkidc.com/about/detail/hcid/196/id/2000/%EF%BC%89">https://blog.51cto.com/u_12528551/5900477、https://www.kkidc.com/about/detail/hcid/196/id/2000/）</a></p>
<h2 id="附-常用邮箱SMTP服务器地址大全"><a href="#附-常用邮箱SMTP服务器地址大全" class="headerlink" title="附:常用邮箱SMTP服务器地址大全"></a>附:常用邮箱SMTP服务器地址大全</h2><p>　1. Gmail</p>
<p>　　POP服务器地址: pop.gmail.com</p>
<p>　　SMTP服务器地址: smtp.gmail.com</p>
<p>　　2. Outlook</p>
<p>　　POP服务器地址: outlook.office365.com</p>
<p>　　SMTP服务器地址: smtp.office365.com</p>
<p>　　3. Yahoo</p>
<p>　　POP服务器地址: pop.yahoo.com</p>
<p>　　SMTP服务器地址: smtp.mail.yahoo.com</p>
<p>　　4. 163邮箱</p>
<p>　　POP服务器地址: pop.163.com</p>
<p>　　SMTP服务器地址: smtp.163.com</p>
<p>　　5. QQ邮箱</p>
<p>　　POP服务器地址: pop.qq.com</p>
<p>　　SMTP服务器地址: smtp.qq.com</p>
<h2 id="SMTP服务器的作用"><a href="#SMTP服务器的作用" class="headerlink" title="SMTP服务器的作用"></a>SMTP服务器的作用</h2><p>SMTP服务器是一种用于发送和接收电子邮件的服务器。SMTP是Simple Mail Transfer Protocol的缩写，它是一种用于电子邮件传输的标准协议。SMTP服务器的作用是将电子邮件从发送者的计算机发送到接收者的计算机。</p>
<p>SMTP服务器的工作原理是通过TCP/IP协议将邮件从发送者的计算机传输到接收者的计算机。当发送者发送一封电子邮件时，邮件客户端会将邮件发送到SMTP服务器。SMTP服务器会将邮件传输到接收者的SMTP服务器，然后接收者的邮件客户端会从SMTP服务器中接收邮件。</p>
<p>SMTP服务器的作用不仅仅是传输电子邮件，它还可以对邮件进行过滤和检查。SMTP服务器可以检查邮件的内容和附件，以确保邮件不包含病毒或垃圾邮件。SMTP服务器还可以对邮件进行加密，以保护邮件的安全性。</p>
<p>SMTP服务器的配置非常重要，因为它直接影响到邮件的传输速度和可靠性。如果SMTP服务器配置不正确，邮件可能会被拒绝或延迟传输。因此，SMTP服务器的配置需要根据具体的需求进行调整。</p>
<h1 id="stylesheet"><a href="#stylesheet" class="headerlink" title="stylesheet"></a>stylesheet</h1><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p>Qt 4.8 UI Design with Qt : <a href="https://doc.qt.io/archives/qt-4.8/qt-gui-concepts.html">https://doc.qt.io/archives/qt-4.8/qt-gui-concepts.html</a>  -&gt;可以选择Qt Style Sheets查看样式表相关</p>
<p>Qt 5 stylesheet :<a href="https://doc.qt.io/qt-5/qtmodules.html">https://doc.qt.io/qt-5/qtmodules.html</a> -》可以跳转<a href="https://doc.qt.io/qt-5/qtwidgets-index.html">Qt Widgets</a>，然后找QStyles</p>
<p>Qt翻译的中文网站: <a href="https://blog.csdn.net/qq_24571549/article/details/64131396">https://blog.csdn.net/qq_24571549/article/details/64131396</a></p>
<p>属性列表 : <a href="https://blog.csdn.net/WL0616/article/details/129118087">https://blog.csdn.net/WL0616/article/details/129118087</a></p>
<p>对于不理解的地方可以参考CSS：[CSS参考手册（里面有测试）  <a href="https://www.w3school.com.cn/cssref/pr_background-clip.asp">https://www.w3school.com.cn/cssref/pr_background-clip.asp</a></p>
<p><img src="/2021/06/27/Qt/image-20231212111224516.png" alt="image-20231212111224516"></p>
<p><img src="/2021/06/27/Qt/image-20231212111210217.png" alt="image-20231212111210217"></p>
<p><em>Qt的样式/颜色机制主要有两个体系，一个是用调色板(QPalette) 另一个是样式表Style Sheets。在Qt4之前 Qt的图形化组件的各种颜色(前景色、背景色、文本色、选中色、非选中色等)有不同的函数，例如setBackgroundColor函数。但在Qt4之后这些函数不在使用，而是由QPalette调色板管理，当然样式表(Style Sheets)也是可以的，在Qt4.5以后Qt样式表已经完美支持Mac系统了，所有也是个不错的选择，特别是对有CSS使用经验的人来说。</em></p>
<h2 id="打印树结构"><a href="#打印树结构" class="headerlink" title="打印树结构"></a>打印树结构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCalendarWidget *calendar = ui-&gt;dateEdit-&gt;<span class="built_in">calendarWidget</span>();</span><br><span class="line"><span class="built_in">dumpStructure</span>(calendar, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalendarWidget::dumpStructure</span><span class="params">(<span class="keyword">const</span> QObject *obj, <span class="keyword">int</span> spaceCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;%1 %2 : %3&quot;</span>)</span><br><span class="line">                .<span class="built_in">arg</span>(<span class="string">&quot;&quot;</span>, spaceCount)</span><br><span class="line">                .<span class="built_in">arg</span>(obj-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>())</span><br><span class="line">                .<span class="built_in">arg</span>(obj-&gt;<span class="built_in">objectName</span>());</span><br><span class="line"> </span><br><span class="line">    QObjectList list = obj-&gt;<span class="built_in">children</span>();</span><br><span class="line"> </span><br><span class="line">    foreach(QObject *child, list)&#123;</span><br><span class="line">        <span class="built_in">dumpStructure</span>(child, spaceCount + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="box-model"><a href="#box-model" class="headerlink" title="box model"></a>box model</h2><p><img src="/2021/06/27/Qt/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTEyMzI1,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<p>使用样式表时，每个widget都被视为包含<code>四个同心矩形的框</code>：<strong>边距矩形（margin rectangle）、边框矩形（border rectangle）、填充矩形（padding rectangle）和内容矩形（content rectangle）</strong>。<a href="https://so.csdn.net/so/search?q=%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">盒子模型</a>如上图所示：</p>
<p>边距（margin）、边框（border）宽度和填充（padding）属性都默认为零。在这种情况下，所有四个矩形(边距、边框、填充和内容)完全重合。</p>
<p>可以使用<em>background-image</em>（背景图片）属性指定<em>widget</em>的背景。默认情况下，仅为边框内的区域绘制背景图像，但是可以通过background-clip（背景剪裁）属性进行更改。可以使用<em>background-repeat</em>（背景重复）和<em>background-origin</em>（背景原点）来控制背景图像的重复和原点。</p>
<p><strong>背景图像不随widget的大小缩放。</strong>要实现随 widget 大小缩放的“皮肤”或背景，必须使用<em>border-image</em>（边框图像）。由于 border-image 属性提供了备用背景，因此在指定border-image 时不需要指定 background-image。当两者都被设置时，border-image 绘制在 background-image 上。</p>
<p>此外，图像属性可用于在 border-image 上绘制图像。当指定的图像大小与 widget 的大小不匹配时，图像不会平铺（tile）或拉伸（stretch），需要使用image-position属性指定其对齐方式。与background-image和border-image不同，您可以在 image 属性中指定SVG，在这种情况下，图像会根据 widget 的大小自动缩放。</p>
<p>Qt 的绘制的步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为整个渲染操作设置剪辑(border-radius)。</span><br><span class="line">绘制背景(background-image)。</span><br><span class="line">绘制边框(border-image，border)。</span><br><span class="line">绘制叠加图像(image)。</span><br></pre></td></tr></table></figure>

<h3 id="附-盒子模型支持的组件"><a href="#附-盒子模型支持的组件" class="headerlink" title="附 盒子模型支持的组件"></a>附 盒子模型支持的组件</h3><table>
<thead>
<tr>
<th>QCheckBox</th>
<th>支持盒子模型。检查指示器可以使用::indicator子控件样式化。默认情况下，指示器被放置在左边。spacing属性指定检查指示器和文本之间的间距。</th>
</tr>
</thead>
<tbody><tr>
<td>QColumnView</td>
<td>可以使用image属性进行样式化。箭头指示器可以使用  ::left-arrow子控件和 ::right-arrow 子控件进行样式化</td>
</tr>
<tr>
<td>QComboBox</td>
<td>combobox周围的框架可以使用box  model设置样式。下拉按钮可以使用::drop-down子控件设置样式。默认情况下，下拉按钮放置在小部件的内边距矩形的右边。下拉按钮内的箭头标记可以使用::down-arrow子控件设置样式。默认情况下，箭头放置在下拉子控件的内容矩形的中心。</td>
</tr>
<tr>
<td>QDateEdit</td>
<td>看QSpinBox</td>
</tr>
<tr>
<td>QDateTimeEdit</td>
<td>看QSpinBox</td>
</tr>
<tr>
<td>QDialog</td>
<td>QDialog继承于QWidget，看QWidget</td>
</tr>
<tr>
<td>QDialogButtonBox</td>
<td>可以使用button-layout属性更改按钮的布局。</td>
</tr>
<tr>
<td>QDockWidget</td>
<td>停靠时支持标题栏和标题栏按钮的样式化。可以使用border属性对dock小部件边框进行样式化。::title子控件可用于自定义标题栏。关闭和浮动按钮分别使用::close按钮和::float按钮相对于::title子控件进行定位。当标题栏垂直时，设置:vertical伪类。另外，根据QDockWidget::DockWidgetFeature，设置了:closable，:floatable和:movable伪状态。</td>
</tr>
<tr>
<td>QDoubleSpinBox</td>
<td>看QSpinBox</td>
</tr>
<tr>
<td>QFrame</td>
<td>支持box  model。从4.3开始，在QLabel上设置样式表会自动将QFrame:: framstyle属性设置为QFrame::StyledPanel。</td>
</tr>
<tr>
<td>QGroupBox</td>
<td>支持box  model。标题可以使用::title子控件设置样式。默认情况下，标题的放置取决于QGroupBox::textAlignment。在可选QGroupBox的情况下，标题包括检查指示器。指示器使用::indicator子控件设置样式。spacing属性可以用来控制文本和指示符之间的间距。</td>
</tr>
<tr>
<td>QHeaderView</td>
<td>支持box  model。头视图的部分使用::section子控件进行样式化。子控件部分支持:middle、:first、:last、:only-one、:next-selected、:previous-selected、:selected和:checked伪状态。排序指示器可以使用::up-arrow和  ::down-arrow 子控件进行样式化。</td>
</tr>
<tr>
<td>QLabel</td>
<td>支持box  model。不支持:hover伪状态。从4.3开始，在QLabel上设置样式表会自动将QFrame::  framstyle属性设置为QFrame::StyledPanel。</td>
</tr>
<tr>
<td>QLineEdit</td>
<td>支持box  model。选中项的颜色和背景分别使用selection-color和selection-background-color设置样式。可以使用lineedit-password-character属性设置密码字符的样式。可以使用lineedit-password-mask-delay更改密码掩码延迟。</td>
</tr>
<tr>
<td>QListView</td>
<td>支持box  model。启用交替行颜色后，可以使用属性alternative  -background-color设置交替行颜色的样式。选中项的颜色和背景分别使用selection-color和selection-background-color设置样式。选择行为由show-decoration-selected属性控制。使用::item子控件对QListView中的项进行更细的控制。</td>
</tr>
<tr>
<td>QListWidget</td>
<td>看QListView</td>
</tr>
<tr>
<td>QMainWindow</td>
<td>支持分隔符的样式化。使用QDockWidget时，QMainWindow中的分隔符使用::separator子控件进行样式化。</td>
</tr>
<tr>
<td>QMenu</td>
<td>单个项目使用::item子控件设置样式。除了通常支持的伪状态外，item子控件还支持:selected、:default、:exclusive和  :non-exclusive伪状态。可选菜单项的指示符使用::indicator子控件设置样式。分隔符使用::separator子控件设置样式。对于子菜单项，箭头标记使用::right-arrow  和::left-arrow设置样式。使用::scroller对滚动条进行样式化。撕裂式使用::tearoff。</td>
</tr>
<tr>
<td>QMenuBar</td>
<td>spacing属性指定菜单项之间的间距。使用::item子控件对单个项进行样式化。</td>
</tr>
<tr>
<td>QMessageBox</td>
<td>message -  box-text-interaction-flags属性可用于更改与消息框中的文本的交互。</td>
</tr>
<tr>
<td>QProgressBar</td>
<td>进度条的块可以使用::chunk子控件设置样式。该块显示在小部件的内容矩形上。如果进度条显示文本，请使用text-align属性来定位文本。不确定进度条有:Indeterminate伪状态设置。</td>
</tr>
<tr>
<td>QPushButton</td>
<td>支持:default、:flat、:checked伪状态。从5.15开始，icon属性可以被设置为覆盖按钮图标。对于带有菜单的QPushButton，菜单指示器使用::menu-indicator子控件样式化。可检查按钮的外观可以使用:open和:closed伪状态定制。警告：如果你只在一个QPushButton上设置了背景色，背景可能不会出现，除非你设置了border属性为某个值。这是因为，在默认情况下，QPushButton绘制了一个与背景色完全重叠的本机边框。例如：</td>
</tr>
<tr>
<td>QRadioButton</td>
<td>检查指示器可以使用::indicator子控件样式化。默认情况下，指示器被放置在小部件Contents矩形的左上角。spacing属性指定检查指示器和文本之间的间距。</td>
</tr>
<tr>
<td>QScrollBar</td>
<td>窗口组件的内容矩形被认为是滑块移动的槽。QScrollBar的范围(即宽度或高度，取决于方向)分别使用width或height属性设置。要确定方向，可以使用:horizontal和:vertical伪状态。可以使用::handle子控件设置滑块的样式。设置min-width或min-height可以根据方向为滑块提供尺寸约束。      ::add-line子控件可用于设置按钮的样式以添加行。默认情况下，add-line子控件放置在小部件边框矩形的右上角，取决于::right-arrow  或 ::down-arrow. 。默认情况下，箭头放置在添加行子控件的Contents矩形的中心。     :: subline子控件可用于设置按钮的样式以减去一行。默认情况下，subline子控件放置在小部件边框矩形的右下角，取决于::left-arrow  或 ::up-arrow。默认情况下，箭头放置在子行子控件的Contents矩形的中心。::  subpage子控件可用于设置滑块减去页面的区域的样式。::add-page子控件可用于设置添加页面的滑块区域的样式。</td>
</tr>
<tr>
<td>QSizeGrip</td>
<td>支持 width、height和image 属性。</td>
</tr>
<tr>
<td>QSlider</td>
<td>对于水平滑动，必须提供 min-width和  height属性。对于垂直滑块，必须提供min-height和width属性。滑块的凹槽采用::groove样式。默认情况下，凹槽位于小部件的内容矩形中。滑块的头部使用::handle子控件设置样式。子控件在槽子控件的内容矩形中移动。</td>
</tr>
<tr>
<td>QSpinBox</td>
<td>向上按钮和箭头可以使用::up-button和::up-arrow子控件设置样式。默认情况下，向上按钮放置在小部件的内边距矩形的右上角。如果没有明确的尺寸，它将占据其参考矩形高度的一半。向上箭头放置在向上按钮的内容矩形的中心。可以使用::down-button和::down-arrow子控件为down按钮和箭头设置样式。默认情况下，down按钮放置在小部件的内边距矩形的右下角。如果没有明确的尺寸，它将占据其参考矩形高度的一半。底部箭头放置在底部按钮的内容矩形的中心。</td>
</tr>
<tr>
<td>QSplitter</td>
<td>分割器的句柄使用::handle子控件进行样式化</td>
</tr>
<tr>
<td>QStatusBar</td>
<td>只支持background属性。可以使用::item子控件对单个项的框架进行样式化。</td>
</tr>
<tr>
<td>QTabBar</td>
<td>单个选项卡可以使用::tab子控件设置样式。选项卡支持:only-one、:first、:last、:middle、:previous–selected、:next-selected、:selected等伪状态。:top、:left、:right、:bottom伪状态取决于选项卡的方向。选择状态的重叠制表符可以使用负边距或绝对位置模式创建。QTabBar的撕裂指示器使用::tear子控件进行样式设置。QTabBar为它的滚动条使用了两个QToolButton，可以使用QTabBar  QToolButton选择器设置样式。要指定滚动按钮的宽度，可以使用::scroller子控件。QTabBar中选项卡的对齐方式使用alignment属性设置样式。要更改QTabBar在QTabWidget中的位置，请使用tab-bar子控件(并设置subcontrol-position)。</td>
</tr>
<tr>
<td>QTabWidget</td>
<td>选项卡部件的框架使用::pane子控件设置样式。左角和右角分别使用::left-corner和::right-corner设置样式。tab  bar的位置由::tab-bar子控件控制。默认情况下，子控件具有QTabWidget在QWindowsStyle中的位置。要将QTabBar放在中间，请设置tab-bar子控件的subcontrol-position。:top、:left、:right、:bottom伪状态取决于选项卡的方向。.</td>
</tr>
<tr>
<td>QTableView</td>
<td>启用交替行颜色后，可以使用属性alternative-background-color设置交替行颜色的样式。选中项的颜色和背景分别使用selection-color和selection-background-color设置样式。QTableView中的拐角部件是作为QAbstractButton实现的，可以使用“QTableView  QTableCornerButton::section”选择器设置样式。     警告：如果你只在QTableCornerButton上设置了背景色，背景可能不会出现，除非你设置border属性为某个值。这是因为，在默认情况下，QTableCornerButton绘制了一个完全重叠背景色的本机边框。网格的颜色可以使用gridline-color属性指定。</td>
</tr>
</tbody></table>
<h2 id="Palette"><a href="#Palette" class="headerlink" title="Palette"></a>Palette</h2><p><strong>没有继承关系</strong>！！！</p>
<p>调色板顾名思义就是设置好颜色在要求的地方进行填充。调色板有两个最重要的函数：setBrush 和 setColor</p>
<h3 id="1-1-setBrush"><a href="#1-1-setBrush" class="headerlink" title="1.1 setBrush"></a>1.1 setBrush</h3><p>void QPalette::setBrush ( ColorGroup group, ColorRole role, const QBrush &amp; brush );</p>
<p>setBrush 即为画刷，就是设置好刷墙的刷子，它要设置三个问题：1.什么时候刷，2.在哪刷，3.刷成什么样？</p>
<h4 id="1-1-1-什么时候刷QPalette-ColorGroup"><a href="#1-1-1-什么时候刷QPalette-ColorGroup" class="headerlink" title="1.1.1 什么时候刷QPalette::ColorGroup"></a>1.1.1 什么时候刷QPalette::ColorGroup</h4><p>QPalette::Disabled<br>QPalette::Active<br>QPalette::Inactive<br>QPalette::NormalActive<br>大部分情况下QPalette::Active就可以。</p>
<h4 id="1-1-2-在哪刷QPalette-ColorRole"><a href="#1-1-2-在哪刷QPalette-ColorRole" class="headerlink" title="1.1.2 在哪刷QPalette::ColorRole"></a>1.1.2 在哪刷QPalette::ColorRole</h4><p>这个是最重要的参数，就是决定是刷背景色还是前景色，还是文本色等等，Assistant中有详细介绍，下面略作说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QPalette::Window   通常指窗口部件的背景色;   </span><br><span class="line">QPalette::Background</span><br><span class="line">QPalette::WindowText   通常指窗口不见的前景色;</span><br><span class="line">QPalette::Foreground</span><br><span class="line">QPalette::Base         指文本输入窗口部件(比如QTxtEdit,QLinedit等)的背景色.</span><br><span class="line">QPalette::AlternateBase</span><br><span class="line">QPalette::ToolTipBase</span><br><span class="line">QPalette::ToolTipText</span><br><span class="line">QPalette::Text        与QPalette::Base一块使用,指文本输入窗口部件的前景色;</span><br><span class="line">QPalette::Button  指按钮窗口部件的背景色;</span><br><span class="line">QPalette::ButtonText  指按钮窗口部件的前景色.</span><br><span class="line">QPalette::BrightText </span><br></pre></td></tr></table></figure>



<h4 id="1-1-3-刷成什么样QBrush"><a href="#1-1-3-刷成什么样QBrush" class="headerlink" title="1.1.3 刷成什么样QBrush"></a>1.1.3 刷成什么样QBrush</h4><p>画刷QBrush 也是个功能强大的东东，鉴于你可能不怎么使用，你只知道能设置颜色就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注意要先调用setAutoFillBackground</span><br><span class="line">textEdit-&gt;setAutoFillBackground(true);</span><br><span class="line">QPalette palette;</span><br><span class="line">//设置QTextEdit文字颜色</span><br><span class="line">palette.setBrush(QPalette::Active, QPalette::Text, QBrush(Qt::yellow));</span><br><span class="line">//设置QTextEdit背景色</span><br><span class="line">palette.setBrush(QPalette::Active, QPalette::Base, QBrush(Qt::red));</span><br><span class="line">textEdit-&gt;setPalette(palette);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-setColor"><a href="#1-2-setColor" class="headerlink" title="1.2 setColor"></a>1.2 setColor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void  QPalette::setColor ( ColorGroup group, ColorRole role, const QColor &amp; color );</span><br></pre></td></tr></table></figure>


<p>虽然setColor参数和setBrush差不多，只是最后一个参数更简洁，直接设置好颜色就行。</p>
<p>1.3说明这就是调色板QPalette 的实现了，特别说明的一点是在QTextEdit使用是遇到了点小问题。初始化时使用了上面的那段代码，但想中途改变QTextEdit的背景色时，在调用同样方式确没有效果，多次测试没找到原因（难道是bug？），所有采用了下面这种方法：样式表(Style Sheets)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调色板设置背景颜色</span></span><br><span class="line"><span class="built_in">setAutoFillBackground</span>(<span class="literal">true</span>);    <span class="comment">// 这句要加上, 否则可能显示不出背景图.</span></span><br><span class="line">QPalette pal =<span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line">pal.<span class="built_in">setBrush</span>(QPalette::Background,m_BackgroundColor);</span><br><span class="line"><span class="built_in">setPalette</span>(pal);</span><br></pre></td></tr></table></figure>

<h2 id="Style-Sheets"><a href="#Style-Sheets" class="headerlink" title="Style Sheets"></a>Style Sheets</h2><h3 id="样式规则"><a href="#样式规则" class="headerlink" title="样式规则"></a>样式规则</h3><p>  样式表由一系列的样式规则组成。一条样式规则由一个<a href="https://so.csdn.net/so/search?q=%E9%80%89%E6%8B%A9%E5%99%A8&spm=1001.2101.3001.7020">选择器</a>和一个声明语句组成，选择器指明了哪个（或者说是哪种）部件将会受规则影响，而声明语句则指明了哪些属性会设置到这个（这些）部件.</p>
<p>举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton &#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>

<p>  在上面的样式规则中，QPushBbutton就是选择器，而{ color： red}则是声明语句。该规则指明了QPushButton和它的子类（如：MyPushButton）应该使用红色作为它们的前景色。Qt样式表通常是不区分大小写的（比如：color, Color, COLOR, 和 cOloR 都是表示同一个属性）。当然也有区分大小写的，类名、对象名、Qt属性名（与color这些属性不是一回事，后面详细解释）这几个都是需要区分大小写的。</p>
<p>  几个选择器可以指定同样的声明语句，使用(,)来隔开不同的选择器，举个例子，如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton, QLineEdit, QComboBox &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure>

<p>  与下面三个规则是等价的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">QLineEdit &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">QComboBox &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure>

<p>  样式规则的声明语句部分是一个属性:值对列表，由({})包闭，由分号作为分割，举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton &#123; <span class="attribute">color</span>: red; <span class="attribute">background-color</span>: white &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  查看更多由Qt widgets提供的<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#list-of-properties">属性列表</a></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>Qt样式表支持所有的<a href="http://www.w3.org/TR/REC-CSS2/selector.html#q1">CSS2定义的选择器</a>。下表总结了几种最常用的选择器类型。</p>
<table>
<thead>
<tr>
<th><span style="display:inline-block;width: 180px"> 选择器</span></th>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>通用选择器</td>
<td>*</td>
<td>匹配所有的widget</td>
</tr>
<tr>
<td>类型选择器</td>
<td>QPushButton</td>
<td>匹配所有的QPushButton实例和继承于它的子类</td>
</tr>
<tr>
<td>属性选择器</td>
<td>QPushButton[flat=”false”]</td>
<td>匹配所有非flat的QPushButton(通常情况下，使用Q_PROPERTY宏来声明你的属性，比如此例中的flat),并且要注意，你的属性类型要受  QVariant::toString()支持(查看toString()方法的帮助文档以获取更详细的解释).  这个选择器类型也可以用来判断动态属性，要了解更多使用自定义动态属性的细节，请参考使用自定义动态属性 。  除了使用=，你还可以使用~=来判断一个QStringList中是否包含给定的QString。  警告：如果在设置了样式表后，相应的属性值发生了改变(如：flat变成了”true”)，则有必要重新加载样式表，一个有效的方法是，取消样式表，再重新设置一次,下面的代码是其中一种方式：  style()-&gt;unpolish(this); style()-&gt;polish(this);// force a stylesheet  recomputation</td>
</tr>
<tr>
<td>类选择器</td>
<td>.QPushButton</td>
<td>匹配所有的QPushButton实例，但不包括它的子类，与*[class~=”QPushButton”]是等价的。</td>
</tr>
<tr>
<td>ID选择器</td>
<td>QPushButton#okButton</td>
<td><a href="http://doc.qt.io/qt-4.8/qobject.html#objectName-prop">匹配所有object name为”okButton”的QPushButton实例。</a></td>
</tr>
<tr>
<td>后裔选择器</td>
<td>QDialog QPushButton</td>
<td>匹配所有继承于QDialog(包括其所有子孙)的QPushButton实例。</td>
</tr>
<tr>
<td>子选择器</td>
<td>QDialog &gt; QPushButton</td>
<td>匹配所有直接继承与QDialog的QPushButton实例。</td>
</tr>
</tbody></table>
<h4 id="1-类型选择器"><a href="#1-类型选择器" class="headerlink" title="1 类型选择器"></a><strong>1 类型选择器</strong></h4><p>使用控件类名作为选择器</p>
<p>例如：</p>
<p>QPushButton{background-color:white;}</p>
<p>设置QPushButton及其子类的背景颜色为白色。</p>
<p>在ui中拖入一个QFrame，再拖入一个QLabel和一个QComboBox到QFrame中</p>
<p><img src="/2021/06/27/Qt/v2-68b18549ccce7d0e12ab4d5b00f4fd7d_720w.webp" alt="img"></p>
<p>选中QFrame，右键“改变样式表”，输入如下内容</p>
<p><img src="/2021/06/27/Qt/v2-dbce326bc04652cfc01004db1643cd72_720w.webp" alt="img"></p>
<p>点击ok</p>
<p><img src="/2021/06/27/Qt/v2-047c19165a139cad01c622a35f06eff8_720w.webp" alt="img"></p>
<p>因为只设置了QFrame的背景颜色，所以QFrame的背景颜色被改变，QLabel是控件树中QFrame的儿子，背景颜色也改变。</p>
<h4 id="2-通用选择器"><a href="#2-通用选择器" class="headerlink" title="2 通用选择器"></a><strong>2 通用选择器</strong></h4><p>通用选择器使用“*”，匹配所有控件。</p>
<p>*{color:blue;}</p>
<p>将刚才的样式表内容改成如下内容：</p>
<p><img src="/2021/06/27/Qt/v2-d8066825bdfd34d6715c612e491d478b_720w.webp" alt="img"></p>
<p>点击ok</p>
<p><img src="/2021/06/27/Qt/v2-d63e7a9ddf07cd58169e6dcc73507577_720w.webp" alt="img"></p>
<p>所有的控件样式都改变了。</p>
<h4 id="3-组选择器"><a href="#3-组选择器" class="headerlink" title="3 组选择器"></a><strong>3 组选择器</strong></h4><p>如果想要为多种类型的控件设置同样的样式，则可以使用组选择器，类型之间使用逗号隔开</p>
<p><img src="/2021/06/27/Qt/v2-602afbf031e44f9d75d4042b546d4258_720w.webp" alt="img"></p>
<p>点击ok</p>
<p><img src="/2021/06/27/Qt/v2-98b2e6ef4c965cd879f576044b8704c8_720w.webp" alt="img"></p>
<p>为QLabel和QComboBox设置了样式</p>
<h4 id="4-后代选择器"><a href="#4-后代选择器" class="headerlink" title="4 后代选择器"></a><strong>4 后代选择器</strong></h4><p>有时，用户希望选择器匹配控件树中另一个控件的后代(例如，“匹配由QFrame包含的QComboBox”)。祖先与后代之间用空格隔开。</p>
<p>QGroupBox QComboBox{background-color:red;}</p>
<p>QGroupBox是祖先，QComboBox是后代，QComboBox包含在QGroupBox控件中。</p>
<p>清空ui，在UI中入一个QComboBox和一个QGroupBox，再拖入一个QComboBox到QGroupBox中。</p>
<p><img src="/2021/06/27/Qt/v2-5d4ab303c8e9e30a2d623071160d936c_720w.webp" alt="img"></p>
<p>选择最外层的QWidget，改变样式表</p>
<p><img src="/2021/06/27/Qt/v2-0f8162732df1cbb6ab9b807d0b0ad9a4_720w.webp" alt="img"></p>
<p>点击ok，运行程序</p>
<p><img src="/2021/06/27/Qt/v2-79acf48f06088f845a180b70718984e5_720w.webp" alt="img"></p>
<p>设置一般的QComboBox的背景颜色为蓝色，但是被QGroupBox包含的QComboBox背景颜色设置成了橘色。因为QComboBox是QGroupBox的后代。</p>
<p>注意 后代选择器用空格隔开，组选择器是用逗号隔开。</p>
<h4 id="5-子选择器"><a href="#5-子选择器" class="headerlink" title="5 子选择器"></a><strong>5 子选择器</strong></h4><p>如果只想设置某个控件的儿子的样式，而不是其所有子孙后代，则可以使用子选择器。父亲与儿子之间用大于号“&gt;”隔开。</p>
<p>按下图拖入控件，这里的控件树排列顺序为QGroupBox是父亲，QTabWidget和QComboBox1是儿子 QComboBox2是孙子</p>
<p><img src="/2021/06/27/Qt/v2-7849ed5b2b2aed8a113789a7f5c8d896_720w.webp" alt="img"></p>
<p>选择最外层的QWidget，改变样式表为</p>
<p><img src="/2021/06/27/Qt/v2-49e8ff300f9f34d29d63c0292305ee26_720w.webp" alt="img"></p>
<p>点击ok</p>
<p><img src="/2021/06/27/Qt/v2-bfd1c49bbc666e3444bbd46f93767623_720w.webp" alt="img"></p>
<p>因为QComboBox1是QGroupBox的儿子，所以样式被改变。QComboBox2是QGroupBox的孙子，所以样式不会被改变。</p>
<p>如果去掉子选择器（&gt;）则变成了后代选择器，两个QComboBox样式都被改变，因为它们都是QGroupBox的后代。</p>
<p><img src="/2021/06/27/Qt/v2-7f0cfab1c46cb1f790616514be1a7158_720w.webp" alt="img"></p>
<p><img src="/2021/06/27/Qt/v2-06ba1bbcf47c8b56bdbb7ece814cdf8c_720w.webp" alt="img"></p>
<p>后代选择器和子选择器的区别相信大家弄清楚了吧。</p>
<h4 id="6-属性选择器"><a href="#6-属性选择器" class="headerlink" title="6 属性选择器"></a><strong>6 属性选择器</strong></h4><p>属性选择符有四种匹配方式，属性值必须是标识符或字符串:</p>
<p>属性匹配[att]</p>
<p>当控件设置“att”属性时匹配，无论该属性的值是多少。</p>
<p>完全匹配[att = val]</p>
<p>当控件的“att”属性值完全为“val”时匹配。</p>
<p>部分值匹配[att ~ = val]</p>
<p>当控件的“att”属性值是空格分隔的“单词”列表时，其中一个就是“val”时就可匹配。如果使用此选择器，则该值中的单词必须不包含空格(因为它们是由空格分隔的)。</p>
<p>[att | = val]</p>
<p>当控件的“att”属性值是一个连字符(“-”)分隔的“单词”列表时，以“val”开头。匹配总是从属性值的开始处开始。</p>
<p>清空ui，拖入如下控件，其中第二行的QPushButton的flat属性设置为true（使用属性编辑器设置）</p>
<p><img src="/2021/06/27/Qt/v2-76f1138abb4ae89e8d71a3bf22b2cd21_720w.webp" alt="img"></p>
<p>选择最外层的QWidget，右键改变样式表</p>
<p><img src="/2021/06/27/Qt/v2-4c1e08e52345bb192d2ae50fa25ce71d_720w.webp" alt="img"></p>
<p>点击ok</p>
<p><img src="/2021/06/27/Qt/v2-74f1d7d1e4d15da1d362dc27ddb40e2c_720w.webp" alt="img"></p>
<p>重点解释第三行控件，因为</p>
<p>第一个QLineEdit的属性值为hello，刚好和qss中的属性值相等，所以匹配。</p>
<p>第二个QLineEdit的属性值为helloworld，hello并不是单词（两边没有空格），与qss中的不相等，所以不匹配。</p>
<p>第三个QLineEdit的属性值为my hello kity，hello是一个单词（两边有空格），所以匹配。</p>
<p>再解释下第四行，凡是等于“my”或以“my-”开头的都会匹配。</p>
<h4 id="7-动态属性选择器"><a href="#7-动态属性选择器" class="headerlink" title="7 动态属性选择器"></a><strong>7 动态属性选择器</strong></h4><p>Qt中的动态属性也可以作为选择器。</p>
<p>例如，当填写一个表单时，为了向用户表明该字段是强制性的，一个有效的解决方案是使用黄色作为这些字段的背景颜色。</p>
<p>清空ui，拖入如下控件，QLineEdit分别命名为lineEdit_user, lineEdit_passwd, lineEdit_describe</p>
<p><img src="/2021/06/27/Qt/v2-e602e945409cdc408d3835173a51ac79_720w.webp" alt="img"></p>
<p>在QssSelector的构造函数中输入如下代码</p>
<p><img src="/2021/06/27/Qt/v2-066f60d101323f3478c49d3c91f1d54a_720w.webp" alt="img"></p>
<p>编译运行程序</p>
<p><img src="/2021/06/27/Qt/v2-de419743bab608bb2437421efc2eea5f_720w.webp" alt="img"></p>
<p>需要用户必须填写的内容就被设置成了黄色背景。</p>
<h4 id="8-点号类型选择器"><a href="#8-点号类型选择器" class="headerlink" title="8 点号类型选择器"></a><strong>8 点号类型选择器</strong></h4><p>点号选择器类似于属性选择器的“[att~=val]”，例如</p>
<p>.QPushButton等同于*[class~=”QPushButton”]</p>
<h4 id="9-id选择器"><a href="#9-id选择器" class="headerlink" title="9 id选择器"></a><strong>9 id选择器</strong></h4><p>如果只想为某个单一的控件设置样式，则可以使用id选择器，“#”号后面跟上这个控件的ObjectName即可。</p>
<p>QPushButton#okButton</p>
<p>再在之前的ui中拖入两个QPushButton，并修改objectName为okButton和cancelButton</p>
<p><img src="/2021/06/27/Qt/v2-976d192d9c635c17593c1be145cb24ee_720w.webp" alt="img"></p>
<p>再在构造函数中，输入如下代码：</p>
<p><img src="/2021/06/27/Qt/v2-dec10d900ba1214f94036908daeb9531_720w.webp" alt="img"></p>
<p>运行程序，指定的ok按钮变成了浅蓝色</p>
<p><img src="/2021/06/27/Qt/v2-dd487266e75cbeab86bfff2c362bcab4_720w.webp" alt="img"></p>
<h3 id="Sub-Controls"><a href="#Sub-Controls" class="headerlink" title="Sub-Controls"></a>Sub-Controls</h3><p>  为了样式化你的复杂widget，很有必要使用widget的subcontrol，比如QComboBox的drop-down 部分或者是QSpinBox的上和下箭头。选择器也许会包含subcontrols用于限制widget的subcontrols，举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QComboBox::drop-down &#123; image: <span class="built_in">url</span>(<span class="string">dropdown.png</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>  上述规则样式化所有QComboBox的drop-down部分，虽然双冒号(::)让人联想到CSS3的伪元素语法，但是Qt的 Sub-Controls 跟它是不一样的。</p>
<p>  Sub-Controls始终相对于另一个元素来定位–一个参考元素。这个参考元素可以是一个Widget又或者是另一个Sub-Control。举个例子，QComboBox的<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#drop-down-sub">::drop-down</a>默认被放置于QComboBox的Padding rectangle(<a href="http://doc.qt.io/qt-4.8/stylesheet-customizing.html#the-box-model">盒子模型</a>)的右上角。::drop-down默认会被放置于另一个::drop-down Sub-Control的中心。查看<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#list-of-stylable-widgets">可样式化的Widget列表</a>以了解更多使用Sub-Control来样式化Widget和初始化其位置的内容。</p>
<p>  源rectangle可以使用<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#subcontrol-origin-prop">subcontrol-origin</a>来改变。举个例子，如果我们想要把drop-down放置于QComboBox的margin rectangle而不是默认的Padding rectangle，我们可以像下面这样指定：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QComboBox &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QComboBox::drop-down &#123;</span><br><span class="line">    subcontrol-origin: margin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  drop-down在Margin rectangle内的排列方式可以由<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#subcontrol-position-prop">subcontrol-position</a>来改变.<br>  <a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#width-prop">width</a>和<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#height-prop">height</a>属性可以用来控制Sub-control的size.需要注意的是，设置了<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#image-prop">image</a>就隐式的设置了Sub-control的size了。</p>
<p>  相对定位方案（position:relative）,允许Sub-Control的位置从它的初始化位置作出偏移。举个例子，当QComboBox的drop-down按钮被pressed时，我们也许想要那个箭头作出位移以显示一种“pressed”的效果，为了达到目标，我们可以像下面那样指定：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QComboBox::down-arrow &#123;</span><br><span class="line">    image: <span class="built_in">url</span>(<span class="string">down_arrow.png</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox::down-arrow:pressed &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1px</span>; <span class="attribute">left</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  绝对定位方案(position : absolute)，使得Sub-control的position和size基于其参考元素而改变。</p>
<p>  一旦定位，它们将会与widget同等对待并且可以使用<a href="http://doc.qt.io/qt-4.8/stylesheet-customizing.html#box-model">盒子模型</a>来样式化。</p>
<p>  查看<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#list-of-sub-controls">Sub-Control列表</a>以了解那些sub-control是被支持的，并且可以查看<a href="http://doc.qt.io/qt-4.8/stylesheet-examples.html#customizing-the-qpushbutton-s-menu-indicator-sub-control">自定义QPushButton的菜单指示器Sub-Control</a>来了解一个实际的使用例子。</p>
<p>  注意：像QComboBox和QScrollBar这样的复杂部件，如果sub-control的一项属性是自定义的，那么其他所有的属性跟sub-control也都应该自定义。</p>
<h4 id="附-子控件列表"><a href="#附-子控件列表" class="headerlink" title="附  子控件列表"></a>附  子控件列表</h4><p>子控件是双冒号”::”<code> 对于一些复杂的部件修改样式，可能需要访问它们的子部件，如[QComboBox](https://so.csdn.net/so/search?q=QComboBox&amp;spm=1001.2101.3001.7020)的下拉按钮，QSpinBox的向上、向下箭头灯。 如：下拉按钮设置图片属性：</code>QComboBox::drop-down{image:url(dropdown.png)}</p>
<table>
<thead>
<tr>
<th>子控件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>::add-line</td>
<td>在QScrollBar中跳转下一行的按钮</td>
</tr>
<tr>
<td>::add-page</td>
<td>在QScrollBar中滑动条和add-line之间的区域</td>
</tr>
<tr>
<td>::branch</td>
<td>在QTreeView中的分支指示器</td>
</tr>
<tr>
<td>::chunk</td>
<td>在QProgressBar中的进度块</td>
</tr>
<tr>
<td>::close-button</td>
<td>在QDockWidget或QTabBar选项卡的关闭按钮</td>
</tr>
<tr>
<td>::corner</td>
<td>在QAbstractScrollArea中两个滚动条之间的角落</td>
</tr>
<tr>
<td>::down-arrow</td>
<td>在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向下箭头</td>
</tr>
<tr>
<td>::down-button</td>
<td>在QScrollBar或QSpinBox中的向下按钮</td>
</tr>
<tr>
<td>::drop-down</td>
<td>在QComboBox中的下拉框</td>
</tr>
<tr>
<td>::float-button</td>
<td>在QDockWidget中的浮动按钮</td>
</tr>
<tr>
<td>::groove</td>
<td>在QSlider中的滑动槽</td>
</tr>
<tr>
<td>::indicator</td>
<td>在QAbstractItemVIew、QCheckBox、QRadioButton、可选中的菜单项或可选中的QGroupBox中的指示器</td>
</tr>
<tr>
<td>::handle</td>
<td>在QScrollBar、QSplitter和QSlider中的操作条(滑动条)</td>
</tr>
<tr>
<td>::icon</td>
<td>在QAbstractItemVIew或QMenu中的图标</td>
</tr>
<tr>
<td>::item</td>
<td>在QAbstractItemVIew、QMenuBar、QMenu或QStatuBar中的一项</td>
</tr>
<tr>
<td>::left-arrow</td>
<td>在QScrollBar中的向左箭头</td>
</tr>
<tr>
<td>::left-corner</td>
<td>在QTabWidget中的左上角</td>
</tr>
<tr>
<td>::menu-arrow</td>
<td>带有菜单的QToolButton中的箭头</td>
</tr>
<tr>
<td>::menu-button</td>
<td>在QToolButton中的菜单按钮</td>
</tr>
<tr>
<td>::menu-indicator</td>
<td>在QPushButton中的菜单指示器</td>
</tr>
<tr>
<td>::right-arrow</td>
<td>在QMenu或QScrollBar中的向右箭头</td>
</tr>
<tr>
<td>::pane</td>
<td>在QTabWidget中的边或框</td>
</tr>
<tr>
<td>::right-corner</td>
<td>在QTabWidget中的右上角</td>
</tr>
<tr>
<td>::scroller</td>
<td>在QMenu或QTabBar中的滚动条</td>
</tr>
<tr>
<td>::section</td>
<td>在QHeaderView中的区块</td>
</tr>
<tr>
<td>::separator</td>
<td>在QMenu或QMainWIndow中分隔条</td>
</tr>
<tr>
<td>::sub-line</td>
<td>在QScrollBar中跳转上一行的按钮</td>
</tr>
<tr>
<td>::sub-page</td>
<td>在QScrollBar中滑动条和sub-line之间的区域</td>
</tr>
<tr>
<td>::tab</td>
<td>在QTabBar或QToolBox中选项卡</td>
</tr>
<tr>
<td>::tab-bar</td>
<td>在QTabWidget中的选项卡栏</td>
</tr>
<tr>
<td>::tear</td>
<td>在QTabBar中的tear指示器</td>
</tr>
<tr>
<td>::tearoff</td>
<td>在QMenu中的tear-off指示器</td>
</tr>
<tr>
<td>::text</td>
<td>在QAbstractItemView中的文本</td>
</tr>
<tr>
<td>::title</td>
<td>在QGroupBox或QDockWidget中的标题栏</td>
</tr>
<tr>
<td>::up-arrow</td>
<td>在QComboBox、QHeaderView(排序指示器)、QScrollBar或QSpinBox的向上箭头</td>
</tr>
<tr>
<td>::up-button</td>
<td>在QScrollBar或QSpinBox中的向上按钮</td>
</tr>
</tbody></table>
<h3 id="伪状态"><a href="#伪状态" class="headerlink" title="伪状态"></a>伪状态</h3><p>  选择器也许会包含基于widget的state的程序限制规则的伪状态。伪状态以冒号(:)作为分隔紧跟着选择器。举个例子，下面的规则在鼠标悬浮在QPushButton的上方时生效：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: white &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  伪状态可以使用感叹号进行取反，下面一条规则在鼠标没有悬浮在QRadioButton上方时生效：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QRadioButton:!hover &#123; color: red &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  伪状态可以链接，在这样的情况下，隐式地包含了逻辑与。举个例子，下面一条规则在鼠标悬浮到一个已check的QCheckBox上时生效：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:checked</span> &#123; <span class="attribute">color</span>: white &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  伪状态的取反也可以出现在伪状态链中，举个例子，下面的规则在鼠标悬浮到一个没有被press的QPushButton上时生效：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span>:!pressed &#123; color: blue; &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  如果有需要，可以使用逗号来表示逻辑或:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span>, QCheckBox<span class="selector-pseudo">:checked</span> &#123; <span class="attribute">color</span>: white &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  伪状态可以与subcontrol组合使用，举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QComboBox::drop-down:hover &#123; image: <span class="built_in">url</span>(<span class="string">dropdown_bright.png</span>) &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>查看由Qt widgets提供的<a href="http://doc.qt.io/qt-4.8/stylesheet-reference.html#list-of-pseudo-states">伪状态列表</a>章节</p>
<h4 id="附-伪状态列表"><a href="#附-伪状态列表" class="headerlink" title="附 伪状态列表"></a>附 伪状态列表</h4><p>伪状态使用单冒号”:”</p>
<ol>
<li><p>选择器可以使用状态来限制在部件的指定状态上的应用。伪状态在选择器之后，用冒号隔离。如：</p>
<p>鼠标悬停在按钮上时其按钮的颜色为白色：QPushButton:hover{color:white}</p>
<p>鼠标不悬停在按钮上时其按钮的颜色为l蓝色(!表否定)：QPushButton:!hover{color:blue}</p>
</li>
<li><p>伪状态可多个连用，达到逻辑与效果。如：鼠标悬停在一个被选中的QCheckBox部件上时才应用规则：QCheckBox:hover:checked{color:white}</p>
</li>
<li><p>伪状态可通过逗号达到逻辑或效果。如：QCheckBox:hover,checked{color:white}</p>
</li>
<li><p>伪状态和子部件联合使用。如：QComboBox::drop-down:hover{image:url(dropdown_bright.png)}</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>伪状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:active</td>
<td>此状态在小部件驻留在活动窗口时设置</td>
</tr>
<tr>
<td>:adjoins-item</td>
<td>此状态在QTreeView的::branch与一个item相邻时设置</td>
</tr>
<tr>
<td>:alternate</td>
<td>当QAbstractItemView::alternatingRowColors()设置为真时，在绘制QAbstractItemView的行时，为每个交替行设置此状态</td>
</tr>
<tr>
<td>:bottom</td>
<td>此item位于底部。例如，QTabBar有位于底部的选项卡</td>
</tr>
<tr>
<td>:checked</td>
<td>此item被选中。例如，QAbstractButton的checked状态</td>
</tr>
<tr>
<td>:closable</td>
<td>此item可以被关闭。例如，QDockWidget的QDockWidget::DockWidgetClosable特性开启时</td>
</tr>
<tr>
<td>:closed</td>
<td>此item处于关闭状态。例如，QTreeView中未展开的item</td>
</tr>
<tr>
<td>:default</td>
<td>此item的默认状态。例如，一个default的QPushButton或QMenu中的一个默认动作</td>
</tr>
<tr>
<td>:disabled</td>
<td>此item被禁用时的状态</td>
</tr>
<tr>
<td>:editable</td>
<td>如QComboBox是可编辑的</td>
</tr>
<tr>
<td>:edit-focus</td>
<td>此item具有编辑焦点(参考QStyle::State_HasEditFocus)。此状态仅对Qt扩展应用程序可用</td>
</tr>
<tr>
<td>:enabled</td>
<td>此item已启用</td>
</tr>
<tr>
<td>:exclusive</td>
<td>此item是一个独占项组的一部分。例如，独占QActionGroup中的菜单项</td>
</tr>
<tr>
<td>:first</td>
<td>此item是列表中的第一项。例如，QTabBar中的第一个选项卡</td>
</tr>
<tr>
<td>:flat</td>
<td>此item是平的。例如，一个扁平的QPushButton</td>
</tr>
<tr>
<td>:floatable</td>
<td>此item可以浮动。例如，QDockWidget的QDockWidget::DockWidgetFloatable的特性开启时</td>
</tr>
<tr>
<td>:focus</td>
<td>此item具有输入焦点</td>
</tr>
<tr>
<td>:has-children</td>
<td>此item具有子对象。例如，QTreeView中具有子项的项</td>
</tr>
<tr>
<td>:has-sibling</td>
<td>此item具有兄弟对象。例如，QTreeView中与之相邻的项</td>
</tr>
<tr>
<td>:horizontal</td>
<td>此item处于水平方向</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标悬浮在此item上</td>
</tr>
<tr>
<td>:indeterminate</td>
<td>此item处于不确定状态。例如，QCheckBox或QRadioButton被部分选中</td>
</tr>
<tr>
<td>:last</td>
<td>此item是列表中的最后一项。例如，QTabBar中的最后一个选项卡</td>
</tr>
<tr>
<td>:left</td>
<td>此item位于左侧。例如，QTabBar有位于左侧的选项卡</td>
</tr>
<tr>
<td>:maximized</td>
<td>此item处于最大化状态。例如，一个最大化的QMdiSubWindow</td>
</tr>
<tr>
<td>:middle</td>
<td>此item是列表中的中间一项。例如，一个不在QTabBar中的开头或结尾的选项卡</td>
</tr>
<tr>
<td>:minimized</td>
<td>此item处于最小化状态。例如，一个最小化的QMdiSubWindow</td>
</tr>
<tr>
<td>:movable</td>
<td>此item可以被移动。例如， QDockWidget的QDockWidget::DockWidgetMovable特性开启时</td>
</tr>
<tr>
<td>:no-frame</td>
<td>此item没有边框。例如，没有边框的QSpinBox或QLineEdit</td>
</tr>
<tr>
<td>:non-exclusive</td>
<td>此item是一个非独占项组的一部分。例如，非独占QActionGroup中的菜单项</td>
</tr>
<tr>
<td>:off</td>
<td>对可以切换的items，这适用于处于off状态的item</td>
</tr>
<tr>
<td>:on</td>
<td>对可以切换的items，这适用于处于on状态的widget</td>
</tr>
<tr>
<td>:only-one</td>
<td>此item是列表中的唯一的一项。例如，一个在QTabBar中单独的选项卡</td>
</tr>
<tr>
<td>:open</td>
<td>此item处于打开状态。例如，QTreeView中的展开项，或带有菜单的QComboBox或QPushButton</td>
</tr>
<tr>
<td>:next-selected</td>
<td>此item是列表中的下一个被选中的项。例如，在QTabBar中当前选项卡的下一个要选中的选项卡</td>
</tr>
<tr>
<td>:pressed</td>
<td>鼠标正在按压在此item上</td>
</tr>
<tr>
<td>:previous-selected</td>
<td>此item是列表中的上一个被选中的项。例如，在QTabBar中当前选项卡的上一个要选中的选项卡</td>
</tr>
<tr>
<td>:read-only</td>
<td>此item处于只读或不可编辑状态。例如，一个只读QLineEdit或不可编辑的QComboBox</td>
</tr>
<tr>
<td>:right</td>
<td>此item位于右侧。例如，QTabBar有位于右侧的选项卡</td>
</tr>
<tr>
<td>:selected</td>
<td>此item处于选中状态。例如，一个在QTabBar中被选中的选项卡或一个在菜单中被选中的菜单项</td>
</tr>
<tr>
<td>:top</td>
<td>此item位于顶部。例如，QTabBar有位于顶部的选项卡</td>
</tr>
<tr>
<td>:unchecked</td>
<td>此item处于未被选中状态</td>
</tr>
<tr>
<td>:vertical</td>
<td>此item处于垂直方向</td>
</tr>
<tr>
<td>:window</td>
<td>小部件是一个窗口(例如，一个顶层小部件)</td>
</tr>
</tbody></table>
<h3 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h3><p><a href="https://doc.qt.io/qt-6/stylesheet-reference.html">QSS官方参考</a><br>对于不理解的地方可以参考CSS：<a href="https://www.w3school.com.cn/cssref/pr_background-clip.asp">CSS参考手册（里面有测试，可以很直观的看到不同属性值的区别）</a></p>
<hr>
<table>
<thead>
<tr>
<th>attribute属性</th>
<th>类型</th>
<th>描述</th>
<th><span style="display:inline-block;width: 380px"> 示例</span></th>
</tr>
</thead>
<tbody><tr>
<td>alternate-background-color</td>
<td>Brush</td>
<td>交替背景色。</td>
<td><img src="/2021/06/27/Qt/03f311a21fe8477a99b7956ec88e6903.png" alt="img"></td>
</tr>
<tr>
<td>background</td>
<td>Background</td>
<td>背景，相当于指定background-color、background-image、background-repeat和background-position。</td>
<td><img src="/2021/06/27/Qt/096b07252b1a43408eb437110ae7778f.png" alt="img"></td>
</tr>
<tr>
<td>background-color</td>
<td>Brush</td>
<td>背景颜色，例如：</td>
<td><img src="/2021/06/27/Qt/2e24da43d7e64dff9f7ce6fa26fed5a6.png" alt="img"></td>
</tr>
<tr>
<td>background-image</td>
<td>Url</td>
<td>背景图像（图像的半透明部分会被背景颜色穿透）。</td>
<td><img src="/2021/06/27/Qt/9045714dab1d4231aa5a5162fd06d8c4.png" alt="img"></td>
</tr>
<tr>
<td>background-repeat</td>
<td>Repeat</td>
<td>背景图像如何充满背景矩形，如果未指定此属性，背景图像将在两个方向上重复(repeat)。</td>
<td><img src="/2021/06/27/Qt/cfbfd8a063e44ac2b8c80582c64e944d.png" alt="img"></td>
</tr>
<tr>
<td>background-position</td>
<td>Alignment</td>
<td>背景图像在背景原点矩形内的对齐。如果未指定此属性，则对齐方式为左上角。</td>
<td><img src="/2021/06/27/Qt/51486f7927ac4ec78a07a23caac11b9a.png" alt="img"></td>
</tr>
<tr>
<td>background-attachment</td>
<td>Attachment</td>
<td>背景图像是否相对于视口进行滚动或固定。默认情况下，背景图像随视口滚动。</td>
<td><img src="/2021/06/27/Qt/0a9b91d36fd444beb1ab231273fd22a4.png" alt="img"></td>
</tr>
<tr>
<td>background-clip</td>
<td>Origin</td>
<td>规定背景的绘制区域。如果未指定此属性，则默认为border。     border：背景被裁剪到边框盒     padding：背景被裁剪到内边距框     content：背景被裁剪到内容框</td>
<td><img src="/2021/06/27/Qt/f7ba5af0f8eb444885208663f19773c8.png" alt="img"></td>
</tr>
<tr>
<td>background-origin</td>
<td>Origin</td>
<td>背景图像相对于什么来定位。如果未指定此属性，则默认为  padding 填充。     padding：背景图像相对于内边距框来定位     border：背景图像相对于边框盒来定位     content：背景图像相对于内容框来定位</td>
<td><img src="/2021/06/27/Qt/d1d489c0fc7b43f0a32b2d3c94088fcd.png" alt="img"></td>
</tr>
<tr>
<td>border</td>
<td>Border</td>
<td>设置 4  个边框的样式，按照一下顺序进行设置：border-width，border-style，border-color。</td>
<td><img src="/2021/06/27/Qt/6360de287f4f47ea965eecb5164c48f5.png" alt="img"></td>
</tr>
<tr>
<td>border-top</td>
<td>Border</td>
<td>顶部边框</td>
<td></td>
</tr>
<tr>
<td>border-bottom</td>
<td>Border</td>
<td>底部边框</td>
<td></td>
</tr>
<tr>
<td>border-right</td>
<td>Border</td>
<td>右边边框</td>
<td></td>
</tr>
<tr>
<td>border-left</td>
<td>Border</td>
<td>左边边框</td>
<td></td>
</tr>
<tr>
<td>border-color</td>
<td>Box Colors</td>
<td>边框的颜色。</td>
<td><img src="/2021/06/27/Qt/e0886f3796e5443e9db45e552bd6f604.png" alt="img"></td>
</tr>
<tr>
<td>border-top-color</td>
<td>Brush</td>
<td>边框上边缘颜色</td>
<td></td>
</tr>
<tr>
<td>border-bottom-color</td>
<td>Brush</td>
<td>边框下边缘颜色</td>
<td></td>
</tr>
<tr>
<td>border-right-color</td>
<td>Brush</td>
<td>边框右边缘颜色</td>
<td></td>
</tr>
<tr>
<td>border-left-color</td>
<td>Brush</td>
<td>边框左边缘颜色</td>
<td></td>
</tr>
<tr>
<td>border-image</td>
<td>Border Image</td>
<td>填充边框的图像</td>
<td></td>
</tr>
<tr>
<td>border-radius</td>
<td>Radius</td>
<td>边角的半径，即边角圆弧。</td>
<td><img src="/2021/06/27/Qt/e9ce19b985ab410b854f0f2a55fc838b.png" alt="img"></td>
</tr>
<tr>
<td>border-top-left-radius</td>
<td>Radius</td>
<td>左上角圆弧</td>
<td></td>
</tr>
<tr>
<td>border-top-right-radius</td>
<td>Radius</td>
<td>右上角圆弧</td>
<td></td>
</tr>
<tr>
<td>border-bottom-right-radius</td>
<td>Radius</td>
<td>右下角圆弧</td>
<td></td>
</tr>
<tr>
<td>border-bottom-left-radius</td>
<td>Radius</td>
<td>左下角圆弧</td>
<td></td>
</tr>
<tr>
<td>border-style</td>
<td>Border Style</td>
<td>边框边缘的样式，若未指定默认为none。</td>
<td><img src="/2021/06/27/Qt/083f128113d944d6803729f822feb9af.png" alt="img"></td>
</tr>
<tr>
<td>border-top-style</td>
<td>Border Style</td>
<td>边框上边缘的样式</td>
<td></td>
</tr>
<tr>
<td>border-bottom-style</td>
<td>Border Style</td>
<td>边框下边缘的样式</td>
<td></td>
</tr>
<tr>
<td>border-right-style</td>
<td>BorderStyle</td>
<td>边框右边缘的样式</td>
<td></td>
</tr>
<tr>
<td>border-left-style</td>
<td>BorderStyle</td>
<td>边框左边缘的样式</td>
<td></td>
</tr>
<tr>
<td>border-width</td>
<td>Box Lengths</td>
<td>边框的宽度。</td>
<td><img src="/2021/06/27/Qt/d5767b0b8404460a91d78bab1faf3341.png" alt="img"></td>
</tr>
<tr>
<td>border-top-width</td>
<td>Box Lengths</td>
<td>上边框的宽度</td>
<td></td>
</tr>
<tr>
<td>border-bottom-width</td>
<td>Box Lengths</td>
<td>下边框的宽度</td>
<td></td>
</tr>
<tr>
<td>border-right-width</td>
<td>Box Lengths</td>
<td>右边框的宽度</td>
<td></td>
</tr>
<tr>
<td>border-left-width</td>
<td>Box Lengths</td>
<td>左边框的宽度</td>
<td></td>
</tr>
<tr>
<td>bottom</td>
<td>Length</td>
<td>在部件边底部其子控件向上的偏移量，即元素与底部边缘的距离。</td>
<td><img src="/2021/06/27/Qt/c7a3d92399f242f9a9f033b71bc0319e.png" alt="img"></td>
</tr>
<tr>
<td>top</td>
<td>Length</td>
<td>在部件边顶部其子控件向下的偏移量，即元素与顶部边缘的距离。</td>
<td><img src="/2021/06/27/Qt/d84d5be4b7fd4a978f199565fd59faf2.png" alt="img"></td>
</tr>
<tr>
<td>right</td>
<td>Length</td>
<td>在部件右边其子控件向左的偏移量，即元素与右边缘的距离。</td>
<td><img src="/2021/06/27/Qt/011f6a4b5ef44988bd5117b81c65852a.png" alt="img"></td>
</tr>
<tr>
<td>left</td>
<td>Length</td>
<td>在部件左边其子控件向右的偏移量，即元素与左边缘的距离。</td>
<td><img src="/2021/06/27/Qt/1deebdc383fb4b28b89c1a6f9597e4e2.png" alt="img"></td>
</tr>
<tr>
<td>button-layout</td>
<td>Number</td>
<td>QDialogButtonBox或QMessageBox中的按钮布局。取值为0  (WinLayout)、1 (MacLayout)、2 (KdeLayout)、3 (GnomeLayout)和5  (AndroidLayout)。如果未指定此属性，它默认为SH_DialogButtonLayout样式提示的当前样式所指定的值。</td>
<td><img src="/2021/06/27/Qt/7a67fc38ed28480ebf4f5a9fbdea19d1.png" alt="img"></td>
</tr>
<tr>
<td>color</td>
<td>Brush</td>
<td>渲染文本的颜色，默认值为黑色。</td>
<td><img src="/2021/06/27/Qt/13e549987d2c41498d0ae9e38f707aba.png" alt="img"></td>
</tr>
<tr>
<td>dialogbuttonbox-buttons-have-icons</td>
<td>Boolean</td>
<td>QDialogButtonBox中的按钮是否显示图标如果这个属性被设置为1,QDialogButtonBox的按钮显示图标;如果设置为0，则不显示图标。</td>
<td><img src="/2021/06/27/Qt/9ef25d60e08d429c87d6a90b813391bd.png" alt="img"></td>
</tr>
<tr>
<td>font</td>
<td>Font</td>
<td>设置字体。相当于指定font-family、font-size、font-style和/或font-weight。</td>
<td><img src="/2021/06/27/Qt/11887dfa824e4e268463c31c40e97d03.png" alt="img"></td>
</tr>
<tr>
<td>font-family</td>
<td>String</td>
<td>字体类型。</td>
<td><img src="/2021/06/27/Qt/9223c9cdc2a64b69b83866c90288da9c.png" alt="img"></td>
</tr>
<tr>
<td>font-size</td>
<td>Font Size</td>
<td>字体大小。</td>
<td><img src="/2021/06/27/Qt/59168e074ee74fe2bf9569c39f75198d.png" alt="img"></td>
</tr>
<tr>
<td>font-style</td>
<td>Font Style</td>
<td>字体风格(倾斜）。</td>
<td><img src="/2021/06/27/Qt/9ddcd53eb7bc4b24ab6bb0ffad55ace4.png" alt="img"></td>
</tr>
<tr>
<td>font-weight</td>
<td>Font Weight</td>
<td>字体的粗细。</td>
<td></td>
</tr>
<tr>
<td>gridline-color*</td>
<td>Color</td>
<td>QTableView中网格线的颜色。如果没有指定此属性，它默认为SH_Table_GridLineColor样式提示的当前样式所指定的值。</td>
<td><img src="/2021/06/27/Qt/094978b3a49e438c81482018a388c14c.png" alt="img"></td>
</tr>
<tr>
<td>height</td>
<td>Length</td>
<td>子部件的高度。如果希望小部件具有固定的高度，请将min-height和max-height设置为相同的值。</td>
<td><img src="/2021/06/27/Qt/b571f9c0bf754f0698bae54027f898e3.png" alt="img"></td>
</tr>
<tr>
<td>width</td>
<td>Length</td>
<td>子控件(在某些情况下是小部件)的宽度。</td>
<td><img src="/2021/06/27/Qt/4ee58bf5b2784586883df59f6c3beb35.png" alt="img"></td>
</tr>
<tr>
<td>icon</td>
<td>Url+</td>
<td>所使用的图标，用于具有图标的小部件。目前唯一支持此属性的小部件是QPushButton。</td>
<td></td>
</tr>
<tr>
<td>icon-size</td>
<td>Length</td>
<td>小部件中图标的宽度和高度。可以使用此属性设置以下小部件的图标大小：QCheckBox、QListView、QPushButton、QRadioButton、QTabBar、QToolBar、QToolBox、QTreeView。</td>
<td></td>
</tr>
<tr>
<td>image*</td>
<td>Url+</td>
<td>在子控件的内容矩形中绘制图像。image属性接受一个url列表或者一个svg。绘制的实际图像使用与QIcon相同的算法。图像从不放大，但在必要时总是缩小。如果指定了svg，则图像会被缩放为内容矩形的大小。警告：渲染SVG图像需要QIcon  SVG插件。     隐式设置down-button的大小为spindown.png的大小</td>
<td><img src="/2021/06/27/Qt/c2b7e04e093a4278a315fd9c3f0819e4.png" alt="img"></td>
</tr>
<tr>
<td>image-position</td>
<td>Alignment</td>
<td>图像位置的对齐方式</td>
<td></td>
</tr>
<tr>
<td>lineedit-password-character*</td>
<td>Number</td>
<td>QLineEdit密码字符作为Unicode数字。如果没有指定此属性，它默认为SH_LineEdit_PasswordCharacter样式提示的当前样式所指定的值。</td>
<td><img src="/2021/06/27/Qt/cf40fa384aaf44998d5bf153ee449ea4.png" alt="img"></td>
</tr>
<tr>
<td>lineedit-password-mask-delay*</td>
<td>Number</td>
<td>在lineedit-password-character应用到可见字符之前，QLineEdit密码掩码延迟毫秒。如果未指定此属性，它默认为SH_LineEdit_PasswordMaskDelay样式提示的当前样式所指定的值。</td>
<td><img src="/2021/06/27/Qt/c11d096366f34120b53b35873cfb7046.png" alt="img"></td>
</tr>
<tr>
<td>margin</td>
<td>Box Lengths</td>
<td>设置元素的4个外边距。相当于指定margin-top、margin-right、margin-bottom和margin-left。</td>
<td><img src="/2021/06/27/Qt/f97d2770f76c43e1b26f9afdc61a6b9a.png" alt="img"></td>
</tr>
<tr>
<td>margin-top</td>
<td>Length</td>
<td>上边距</td>
<td></td>
</tr>
<tr>
<td>margin-right</td>
<td>Length</td>
<td>右边距</td>
<td></td>
</tr>
<tr>
<td>margin-bottom</td>
<td>Length</td>
<td>下边距</td>
<td></td>
</tr>
<tr>
<td>margin-left</td>
<td>Length</td>
<td>左边距</td>
<td></td>
</tr>
<tr>
<td>max-height</td>
<td>Length</td>
<td>小部件或子控件（例如Item）的最大高度。</td>
<td><img src="/2021/06/27/Qt/ea35e6d95cbf4b869fcb892cd18dfba4.png" alt="img"></td>
</tr>
<tr>
<td>max-width</td>
<td>Length</td>
<td>小部件或子控件（例如Item）的最大宽度。</td>
<td><img src="/2021/06/27/Qt/5843ad0a54ca44848eab14114fce609d.png" alt="img"></td>
</tr>
<tr>
<td>min-height</td>
<td>Length</td>
<td>小部件或子控件（例如Item）的最小高度。</td>
<td><img src="/2021/06/27/Qt/11bcb912897848f3bf23d8ad719cf748.png" alt="img"></td>
</tr>
<tr>
<td>min-width</td>
<td>Length</td>
<td>小部件或子控件（例如Item）的最小宽度。</td>
<td><img src="/2021/06/27/Qt/c2449d720d2e440084a2301040e2a3aa.png" alt="img"></td>
</tr>
<tr>
<td>messagebox-text-interaction-flags*</td>
<td>Number</td>
<td>消息框中文本的交互行为。可能的值基于Qt::TextInteractionFlags。如果未指定此属性，则默认为SH_MessageBox_TextInteractionFlags样式提示的当前样式所指定的值。</td>
<td><img src="/2021/06/27/Qt/f82f76ff6934444c8737e4cf4af0f148.png" alt="img"></td>
</tr>
<tr>
<td>opacity*</td>
<td>Number</td>
<td>小部件的不透明度。取值范围为0(透明)~  255(不透明)。目前，这只支持tooltips。如果未指定此属性，它默认为SH_ToolTipLabel_Opacity样式提示的当前样式指定的值。</td>
<td><img src="/2021/06/27/Qt/fa06400764224b288f3b936828a0ece1.png" alt="img"></td>
</tr>
<tr>
<td>outline</td>
<td></td>
<td>边框的轮廓</td>
<td></td>
</tr>
<tr>
<td>outline-color</td>
<td>Color</td>
<td>轮廓的颜色</td>
<td></td>
</tr>
<tr>
<td>outline-offset</td>
<td>Length</td>
<td>轮廓与小部件边界的偏移量</td>
<td></td>
</tr>
<tr>
<td>outline-style</td>
<td></td>
<td>指定用于绘制轮廓的模式</td>
<td></td>
</tr>
<tr>
<td>outline-radius</td>
<td></td>
<td>在轮廓中添加圆角</td>
<td></td>
</tr>
<tr>
<td>outline-bottom-left-radius</td>
<td>Radius</td>
<td>轮廓左下角的圆角</td>
<td></td>
</tr>
<tr>
<td>outline-bottom-right-radius</td>
<td>Radius</td>
<td>轮廓右下角的圆角</td>
<td></td>
</tr>
<tr>
<td>outline-top-right-radius</td>
<td>Radius</td>
<td>轮廓右上角的圆角</td>
<td></td>
</tr>
<tr>
<td>outline-top-left-radius</td>
<td>Radius</td>
<td>轮廓左上角的圆角</td>
<td></td>
</tr>
<tr>
<td>padding</td>
<td>Box Lengths</td>
<td>小部件的填充。相当于指定填充顶部、填充右侧、填充底部和填充左侧。如果未指定此属性，则默认为0。</td>
<td><img src="/2021/06/27/Qt/4601979f48274f0695d2d769ebbf6a85.png" alt="img"></td>
</tr>
<tr>
<td>padding-top</td>
<td>Length</td>
<td>顶部填充</td>
<td></td>
</tr>
<tr>
<td>padding-right</td>
<td>Length</td>
<td>右侧填充</td>
<td></td>
</tr>
<tr>
<td>padding-bottom</td>
<td>Length</td>
<td>底部填充</td>
<td></td>
</tr>
<tr>
<td>padding-left</td>
<td>Length</td>
<td>左侧填充</td>
<td></td>
</tr>
<tr>
<td>paint-alternating-row-colors-for-empty-area</td>
<td>bool</td>
<td>QTreeView是否为空区域(即没有项目的区域)绘制交替的行色</td>
<td></td>
</tr>
<tr>
<td>posotion</td>
<td>relative | absolute</td>
<td>使用左、右、上和下指定的偏移量是相对坐标还是绝对坐标。如果未指定此属性，则默认为relative。</td>
<td></td>
</tr>
<tr>
<td>selection-background-color*</td>
<td>Brush</td>
<td>所选文本或项的背景。如果未设置此属性，则默认值是为调色板palette的Highlight角色设置的值。</td>
<td><img src="/2021/06/27/Qt/c9c6a94511df4e538cf4220600a6e054.png" alt="img"></td>
</tr>
<tr>
<td>selection-color*</td>
<td>Brush</td>
<td>所选文本或项的前景。如果未设置此属性，则默认值是为调色板palette的HighlightedText角色设置的值。</td>
<td><img src="/2021/06/27/Qt/59dd298befa744d5a28a141db8011fca.png" alt="img"></td>
</tr>
<tr>
<td>show-decoration-selected*</td>
<td>Boolean</td>
<td>控制QListView中的选择是覆盖整行还是仅覆盖文本的范围。如果未指定此属性，它默认为SH_ItemView_ShowDecorationSelected样式提示的当前样式指定的值。</td>
<td><img src="/2021/06/27/Qt/475c2d85a46040a8b7d3a8449d005ba6.png" alt="img"></td>
</tr>
<tr>
<td>spacing*</td>
<td>Length</td>
<td>小部件中的内部间距。</td>
<td><img src="/2021/06/27/Qt/f68656ffae1349179969dfdf244659be.png" alt="img"></td>
</tr>
<tr>
<td>subcontrol-origin*</td>
<td>Origin</td>
<td>父元素中子控件的起始矩形。如果未指定此属性，则默认为填充。</td>
<td><img src="/2021/06/27/Qt/212b8c238f894bed8a0eaf9e7c755f21.png" alt="img"></td>
</tr>
<tr>
<td>subcontrol-position*</td>
<td>Alignment</td>
<td>子控件在subcontrol-origin指定的原点矩形内的对齐。如果未指定此属性，则默认为依赖于子控件的值。</td>
<td><img src="/2021/06/27/Qt/50b011d99951456fb76966f492365c64.png" alt="img"></td>
</tr>
<tr>
<td>titlebar-show-tooltips-on-buttons</td>
<td>bool</td>
<td>工具提示是否显示在窗口标题栏按钮上。</td>
<td></td>
</tr>
<tr>
<td>widget-animation-duration*</td>
<td>Number</td>
<td>动画应该持续多长时间(以毫秒为单位)。值等于零意味着动画将被禁用。如果没有指定此属性，它默认为SH_Widget_Animation_Duration样式提示的当前样式指定的值。</td>
<td><img src="/2021/06/27/Qt/6da38939d5aa4787b43aeb2630beee36.png" alt="img"></td>
</tr>
<tr>
<td>text-align</td>
<td>Alignment</td>
<td>小部件内容中的文本和图标的对齐方式。</td>
<td><img src="/2021/06/27/Qt/3167e91bcde34de9bd82ae0b8eec9e43.png" alt="img"></td>
</tr>
<tr>
<td>text-decoration</td>
<td>none     underline     overline     line-through</td>
<td>附加文本效果</td>
<td></td>
</tr>
<tr>
<td>-qt-background-role</td>
<td>PaletteRole</td>
<td>基于所选角色的子控件或小部件的背景色。</td>
<td></td>
</tr>
<tr>
<td>-qt-style-features</td>
<td>list</td>
<td>要在其上应用特定于qt的样式的CSS属性列表。注意:列表只能包含非基于像素图的属性。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>  当几个样式规则为同一个属性指定不同的值时，就产生了冲突。请考虑下面的样式表：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#okButton</span> &#123; <span class="attribute">color</span>: gray &#125;</span><br><span class="line">QPushButton &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure>

<p>  两条规则都匹配名为okButton的QPushButton实例并且冲突于颜色属性。为了解决冲突，我们必须考虑到选择器的特殊性。在上面的例子中，QPushButton#okButton被视为比QPushButton更特殊，因为它（通常）指向一个单一的对象而不是QPushButton的所有实例。</p>
<p>  相似的，指定了伪状态的选择器比没有指定伪状态的更特殊。从而，下面的样式表指明了当鼠标悬浮到QPushButton上方时其字体颜色应该为白色，而其余情况则为红色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: white &#125;</span><br><span class="line">QPushButton &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure>

<p>  接下来看一个很有意思的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: white &#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure>

<p>  两个选择器都有相同的特殊性，所以当鼠标悬浮在一个enabled的按钮上时，第二条规则优先。如果在这种情况下我们想要文字变成白色，我们可以像下面那样重新排布一下样式规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: white &#125;</span><br></pre></td></tr></table></figure>

<p>  另外，我们可以使第一条规则更特殊一些：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:enabled</span> &#123; <span class="attribute">color</span>: white &#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure>

<p>  相似的问题出现在相互配合的类型选择器上。考虑以下情况：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">QAbstractButton &#123; <span class="attribute">color</span>: gray &#125;</span><br></pre></td></tr></table></figure>

<p>  两条规则都应用于QPushButton的实例（因为QPushButton继承于QAbstractButton）并且冲突于color属性。因为QPushButton继承于QAbstractButton，这让人不禁想到QPushButton比QAbstractButton更特殊。然而，对于样式表的运算，所有的类型选择器都具有同等的特殊性，并且出现在更后面的规则优先级更高。换句话说，QAbstractButton的color会被设置成灰色，包括QPushButton。如果我们确实想要QPushButton字体颜色设置为红色，我们总是可以使用重新排列样式表规则顺序的方式实现。</p>
<p>为确定规则的特殊性，Qt样式表跟随<a href="http://www.w3.org/TR/REC-CSS2/cascade.html#specificity">CSS2规范</a></p>
<p>一个选择器的特殊性由下面的方式计算：<br>- 计算选择器中ID属性的数量[=a]<br>- 计算选择器中其他属性和伪类的数量[=b]<br>- 计算选择器中元素名字的数量[=c]<br>- 忽略伪原素[如:subcontrol]</p>
<p>串联这三个数字a-b-c（在一个大基数的数字系统）就得到了特殊性等级。</p>
<p>举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*             &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 -&gt; specificity =   0 */</span></span><br><span class="line"><span class="selector-tag">LI</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 -&gt; specificity =   1 */</span></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">LI</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 -&gt; specificity =   2 */</span></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span>+<span class="selector-tag">LI</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=3 -&gt; specificity =   3 */</span></span><br><span class="line"><span class="selector-tag">H1</span> + *<span class="selector-attr">[REL=up]</span>&#123;&#125;  <span class="comment">/* a=0 b=1 c=1 -&gt; specificity =  11 */</span></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span> <span class="selector-tag">LI</span><span class="selector-class">.red</span>  &#123;&#125;  <span class="comment">/* a=0 b=1 c=3 -&gt; specificity =  13 */</span></span><br><span class="line"><span class="selector-tag">LI</span><span class="selector-class">.red</span><span class="selector-class">.level</span>  &#123;&#125;  <span class="comment">/* a=0 b=2 c=1 -&gt; specificity =  21 */</span></span><br><span class="line"><span class="selector-id">#x34y</span>         &#123;&#125;  <span class="comment">/* a=1 b=0 c=0 -&gt; specificity = 100 */</span></span><br></pre></td></tr></table></figure>

<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>样式表可以设置到QApplication、父部件、子部件。任意部件应用的样式表通过合并设置到祖先部件（父亲、祖父等）的样式表获得，以及设置到QApplication上的任何样式表。</p>
<p>  当冲突产生时，部件本身的样式表总是优先于继承来的样式表，不论冲突规则计算的特殊性是多少。同样，父部件的样式表优先级要高于祖父部件的等等。</p>
<p>  这样做的一个后果是，部件上的一个样式规则自动获得高于其他由祖先部件或QApplication样式表指定的样式规则。考虑下面这个例子。首先，我们给QApplication设置样式表：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet(&quot;QPushButton &#123; <span class="attribute">color</span>: white &#125;&quot;);<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  然后，我们给一个QPushButton对象设置样式表：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">myPushButton-&gt;setStyleSheet(&quot;* &#123; <span class="attribute">color</span>: blue &#125;&quot;);<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  设置到QPushButton上的样式表强制要求QPushButton（包括其任何子部件）的字体颜色为蓝色，尽管程序范围内的样式表给出了更详尽的样式规则。</p>
<p>  如果我们写成下面这样，效果还是一样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">myPushButton-&gt;setStyleSheet(&quot;<span class="attribute">color</span>: blue<span class="string">&quot;);1</span></span><br></pre></td></tr></table></figure>

<p>  如果该QPushButton有孩子（这是不太可能的），这段样式表对它们无效。</p>
<p>  样式表级联是一个很复杂的话题。请参考<a href="http://www.w3.org/TR/CSS2/cascade.html#cascade">CSS2规范</a>获取更多细节。请注意Qt目前没有实现的！很重要。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>  在典型的CSS中，如果一个项的字体和颜色没有显式设置，它会自动从其父亲获得。当使用Qt样式表时，一个部件不会从其父亲继承字体和颜色的设置（<strong>请注意，父亲和父类、孩子和子类都是不同的概念，不要搞混</strong>）。</p>
<p><img src="/2021/06/27/Qt/v2-8a8386c016bcd7162e6bbf26a588648c_720w.webp" alt="img"></p>
<p>举个例子，考虑一个QGroupBox内有一个QPushButton：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet(&quot;QGroupBox &#123; <span class="attribute">color</span>: red; &#125; &quot;);</span><br></pre></td></tr></table></figure>

<p>  QPushButton没有任何显式的color设置。因此，它会获得系统的颜色而不是从父亲继承color的值。如果我们要设置QGroupBox及其所有孩子的color，我们可以这样写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet(&quot;QGroupBox, QGroupBox * &#123; <span class="attribute">color</span>: red; &#125;&quot;);<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  与此相反，使用QWidget::setFont()可以设置字体包括孩子的字体，使用 QWidget::setPalette()可以设置调色板包括孩子的调色板。</p>
<h3 id="C-命名空间内的部件"><a href="#C-命名空间内的部件" class="headerlink" title="C++命名空间内的部件"></a>C++命名空间内的部件</h3><p>类型选择器可以用于样式化特定的类型，举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">class MyPushButton : public QPushButton &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">qApp-&gt;setStyleSheet(&quot;MyPushButton &#123; <span class="attribute">background</span>: yellow; &#125;&quot;);</span><br></pre></td></tr></table></figure>

<p>  Qt样式表使用widget的QObject::className()来决定何时应用类型选择器。当自定义部件在命名空间之中，QObject::className()会返回::。这与subcontrol产生了冲突。为了解决这个问题，当为命名空间中widget使用类型选择器时，我们必须将”::”替换成”–”。举个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">namespace ns &#123;</span><br><span class="line">    class MyPushButton : public QPushButton &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">qApp-&gt;setStyleSheet(&quot;ns--MyPushButton &#123; <span class="attribute">background</span>: yellow; &#125;&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="设置对象的属性"><a href="#设置对象的属性" class="headerlink" title="设置对象的属性"></a>设置对象的属性</h3><p>  从4.3以后，任何使用<a href="http://doc.qt.io/qt-4.8/qobject.html#Q_PROPERTY">Q_PROPERTY</a>宏声明的属性都可以使用qproperty-<property name>语法。举个例子：</property></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">MyLabel &#123; qproperty-pixmap: <span class="built_in">url</span>(<span class="string">pixmap.png</span>); &#125;MyGroupBox &#123; qproperty-titleColor: <span class="built_in">rgb</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>); &#125;QPushButton &#123; qproperty-iconSize: <span class="number">20px</span> <span class="number">20px</span>; &#125;</span><br><span class="line">原文转载自:http://blog.csdn.net/matchyang/article/details/<span class="number">47703469</span></span><br></pre></td></tr></table></figure>

<h3 id="如何为全局添加QSS样式（全局加载QSS的方法）"><a href="#如何为全局添加QSS样式（全局加载QSS的方法）" class="headerlink" title="如何为全局添加QSS样式（全局加载QSS的方法）"></a>如何为全局添加QSS样式（全局加载QSS的方法）</h3><p>在Resource文件中添加qss文件，构造函数中直接调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::loadStyleSheet</span><span class="params">(<span class="keyword">const</span> QString &amp;styleSheetFile)</span></span>&#123;  <span class="comment">//styleSheetFile是qss文件的Path</span></span><br><span class="line">	<span class="function">QFile <span class="title">file</span><span class="params">(styleSheetFile)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(file.<span class="built_in">open</span>(QFile::ReadOnly))&#123;</span><br><span class="line">		<span class="comment">//如果在MainWindow使用了setStyleSheet，对qss文件的内容进行追加</span></span><br><span class="line">		<span class="comment">//QString styleSheet = this-&gt;styleSheet();</span></span><br><span class="line">		<span class="comment">//styleSheet += QLatin1String(file.readAll());//读取样式表文件</span></span><br><span class="line">		QString styleSheet = <span class="built_in">QLatin1String</span>(file.<span class="built_in">readAll</span>());  <span class="comment">//QByteArray可直接转换为QString</span></span><br><span class="line">    	<span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(styleSheet);</span><br><span class="line">    	file.<span class="built_in">close</span>();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>,<span class="string">&quot;tip&quot;</span>,<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="QTabWidget、QTableView"><a href="#QTabWidget、QTableView" class="headerlink" title="QTabWidget、QTableView"></a>QTabWidget、QTableView</h3><p>设置背景色，发现选项卡右侧空白区域怎么设置都不行，并且右侧和下方有白条，需要按下面操作：</p>
<p><img src="/2021/06/27/Qt/image-20231206163957257.png" alt="image-20231206163957257"></p>
<p><img src="/2021/06/27/Qt/image-20231206164009725.png" alt="image-20231206164009725"></p>
<p>解决方法：</p>
<p>QTabWidget的documentMode属性复选框打钩即可。<img src="/2021/06/27/Qt/20200805205631582.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QTabBar::tab &#123;</span><br><span class="line">    border: <span class="number">2px</span> solid <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">8ex</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">51</span>);</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QTabBar::tab:selected,QTabBar::tab:hover&#123;</span><br><span class="line">   background-color:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QHeaderView &#123;</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QHeaderView::section,QTableCornerButton::section &#123;</span><br><span class="line">	background:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QTableView</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">	selection-<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPushButton</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/slices/矩形 46(9</span>).png);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span><br><span class="line">	<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">22</span>, <span class="number">33</span>, <span class="number">55</span>, <span class="number">0.38</span>);</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QPushButton::hover</span><br><span class="line">&#123;</span><br><span class="line">	background-color:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span><br><span class="line">	<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QScrollBar </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::handle:horizontal </span><br><span class="line">&#123;</span><br><span class="line">    background-color: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::handle:vertical</span><br><span class="line">&#123;</span><br><span class="line">    background-color: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::add-page</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::sub-page</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::add-line</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::sub-line</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个控件比较复杂，里面包含了滑动条、表头（又细分为内容区/空白区）、表格、整体、左上角按钮等多种不同的元素，他们之间有复杂的叠层关系。需要通过各种“选择器”来指定样式的作用范围。</p>
<p>本文由【暴躁的野生猿】发表于CSDN，如果有非法转载，请帮忙举报，谢谢。百度搜索暴躁的野生猿《QT各种控件常用样式表qss示例》可找到本文的原文。</p>
<p>下面通过示例来一步步观察他的叠层关系。首先使能表格的交替行：alternatingRowColors=true。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QTableView </span><br><span class="line">&#123;<span class="comment">/*整个表格区域最底层*/</span></span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">   <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/2021/06/27/Qt/3161ab3bc3c24e7c926e4b8586c53c65.png" alt="img"></p>
<p>发现这个绿色背景并没有作用于整体，表头部分仍然为白色，那是因为表头在顶层，遮住了<a href="https://so.csdn.net/so/search?q=QTableView&spm=1001.2101.3001.7020">QTableView</a>的绿色背景。</p>
<p>下面设置表头背景色，黑色，半透明，透明度为50。按照预期，黑色半透明和QTableView的绿色叠加后，会形成深绿色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QTableView </span><br><span class="line">&#123;<span class="comment">/*整个表格区域最底层*/</span></span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">   <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line">QHeaderView</span><br><span class="line">&#123;<span class="comment">/*表头整体样式，包括水平表头的右侧空白区域，垂直表头的下方空白区域*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/0e62201080b341898574c2365c9f8c10.png" alt="img"></p>
<p>发现表头区域并没有全部变成深绿色，只有表头的非文字区域（空白区域）变成了深绿色。这是因为表头的文字区域，比空白区域的叠层更靠前，白色背景把深绿色给遮住了。下面继续设置表头的文字区域，设置为黑色半透明，透明度50。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QTableView </span><br><span class="line">&#123;<span class="comment">/*整个表格区域最底层*/</span></span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">   <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QHeaderView</span><br><span class="line">&#123;<span class="comment">/*表头整体样式，包括水平表头的右侧空白区域，垂直表头的下方空白区域*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">QHeaderView::section </span><br><span class="line">&#123;/*表头有文字内容的区域*/</span><br><span class="line">     background-color: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">     <span class="attribute">color</span>: white;</span><br><span class="line">	<span class="attribute">border</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/cf18f448756d4e3a83bb74e47ecad035.png" alt="img"></p>
<p>如上图所示，表头的文字区域，变成了颜色更深的深绿色，这是因为这个区域的颜色，实际上是3层颜色的叠加：QTableView整体的绿色+QHeadView表头整体的黑色半透明+section表头文字区域黑色半透明。</p>
<p>上图左上角的按钮还是白色，下面把他设置为黑色半透明：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QTableView </span><br><span class="line">&#123;<span class="comment">/*整个表格区域最底层*/</span></span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">   <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line">QHeaderView</span><br><span class="line">&#123;<span class="comment">/*表头整体样式，包括水平表头的右侧空白区域，垂直表头的下方空白区域*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">QHeaderView::section </span><br><span class="line">&#123;/*表头有文字内容的区域*/</span><br><span class="line">     background-color: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">     <span class="attribute">color</span>: white;</span><br><span class="line">	<span class="attribute">border</span>:none;</span><br><span class="line">&#125;</span><br><span class="line">QTableView QTableCornerButton::section </span><br><span class="line">&#123;/*表格左上角按钮*/</span><br><span class="line">    border:none;</span><br><span class="line">    <span class="attribute">background-color</span>:  <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/21845cf3debe40ebb5ad9e7a710dbd1f.png" alt="img"></p>
<p>发现他呈现为较深的绿色，说明他位于QTableView整体绿色的上方，层次和QHeadView表头整体是同一层。</p>
<p>下面通过设置各个元素的边框，来更直观的看一下他们的包含与层次关系：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QTableView </span><br><span class="line">&#123;<span class="comment">/*整个表格区域最底层*/</span></span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">   <span class="attribute">color</span>:white;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">QHeaderView</span><br><span class="line">&#123;<span class="comment">/*表头整体样式，包括水平表头的右侧空白区域，垂直表头的下方空白区域*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line">QHeaderView::section </span><br><span class="line">&#123;/*表头有文字内容的区域*/</span><br><span class="line">     background-color: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">     <span class="attribute">color</span>: white;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid yellow;</span><br><span class="line">&#125;</span><br><span class="line">QTableView QTableCornerButton::section </span><br><span class="line">&#123;/*表格左上角按钮*/</span><br><span class="line">    border:none;</span><br><span class="line">    <span class="attribute">background-color</span>:  <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid white;</span><br><span class="line">&#125;</span><br><span class="line">QTableView::item </span><br><span class="line">&#123;/*每个单元格*/</span><br><span class="line">    background: gray;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid purple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/5a562abc5212493fa74ab89ccbf1ef90.png" alt="img"></p>
<p> 表头部分，还支持选中不同的区域，如第一个、最后一个、中间部分、下一个等<img src="/2021/06/27/Qt/23d1fbdfee144a02b97c7fb08c804d7a.png" alt="img"></p>
<p>例如：垂直表头的第1格，，水平表头中间的所有格，设置为红色边框：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QHeaderView::section:first:vertical</span><br><span class="line">&#123;/*垂直表头第一格文字区域*/</span><br><span class="line">	background-color: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line">QHeaderView::section:middle:horizontal</span><br><span class="line">&#123;/*水平表头所有的中间格文字区域*/</span><br><span class="line">	background-color: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/2021/06/27/Qt/eabf9b7203d34c5286a9d117598531f4.png" alt="img"></p>
<h4 id="mysue"><a href="#mysue" class="headerlink" title="mysue"></a>mysue</h4><p><img src="/2021/06/27/Qt/image-20231212141216118.png" alt="image-20231212141216118"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">QTabBar::tab &#123;</span><br><span class="line">    border: <span class="number">2px</span> solid <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">4px</span>;</span><br><span class="line">	<span class="comment">/*下面这几行约束了tab的长宽*/</span></span><br><span class="line">	<span class="attribute">padding-left</span>:-<span class="number">9px</span>;</span><br><span class="line">	<span class="attribute">padding-right</span>:-<span class="number">9px</span>;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">30px</span>;</span><br><span class="line">	<span class="attribute">margin-left</span>:<span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">margin-right</span>:<span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">51</span>);</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QTabBar::tab:selected,QTabBar::tab:hover&#123;</span><br><span class="line">   background-color:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QHeaderView &#123;</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QHeaderView::section,QTableCornerButton::section &#123;</span><br><span class="line">	background:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QTableView</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">	selection-<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QPushButton</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/slices/矩形 46(9</span>).png);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span><br><span class="line">	<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">22</span>, <span class="number">33</span>, <span class="number">55</span>, <span class="number">0.38</span>);</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QPushButton::hover</span><br><span class="line">&#123;</span><br><span class="line">	background-color:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span><br><span class="line">	<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QScrollBar </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面这两个是约束了滚动条默认的宽、高*/</span></span><br><span class="line">QScrollBar:vertical</span><br><span class="line">&#123;</span><br><span class="line">	width:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar:horizontal</span><br><span class="line">&#123;</span><br><span class="line">	height:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::handle:horizontal </span><br><span class="line">&#123;</span><br><span class="line">    background-color: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">max-height</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::handle:vertical</span><br><span class="line">&#123;</span><br><span class="line">    background-color: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">max-width</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::add-page</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::sub-page</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::add-line</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::sub-line</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="滚动条QScrollBar"><a href="#滚动条QScrollBar" class="headerlink" title="滚动条QScrollBar"></a><a href="https://so.csdn.net/so/search?q=%E6%BB%9A%E5%8A%A8%E6%9D%A1&spm=1001.2101.3001.7020">滚动条</a>QScrollBar</h3><p><img src="/2021/06/27/Qt/v2-987fe00992f1df1ef9e40771bfa7cb2b_720w.webp" alt="img"></p>
<h4 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h4><p>我们现在给QScrollBar设置StyleSheet：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setStyleSheet</span>(<span class="string">&quot;QScrollBar&#123;&quot;</span></span><br><span class="line">              <span class="string">&quot;background-color:#3e3e3e;&quot;</span></span><br><span class="line">              <span class="string">&quot;border-radius:4px;&#125;&quot;</span></span><br><span class="line">              <span class="string">&quot;QScrollBar::handle:horizontal&#123; background: #909090;border-radius:4px;&#125;&quot;</span></span><br><span class="line">              <span class="string">&quot;QScrollBar::add-page:horizontal&#123;background-color:transparent;&#125;&quot;</span></span><br><span class="line">              <span class="string">&quot;QScrollBar::sub-page:horizontal&#123;background-color:transparent;&#125;&quot;</span></span><br><span class="line">              <span class="string">&quot;QScrollBar::sub-line:horizontal&#123;background-color:transparent;&#125;&quot;</span></span><br><span class="line">              <span class="string">&quot;QScrollBar::add-line:horizontal&#123;background-color:transparent;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中，设置<strong>QScrollBar的border-radius</strong>，来设置其滑动条背景的一个倒圆角数值。</p>
<p>设置<strong>QScrollBar</strong>中<strong>handle</strong>的<strong>border-radius</strong>，来设置其滑动条中滑块背景的一个倒圆角数值。</p>
<p>而<strong>add-page</strong>*<em>sub-page、add-line</em>***sub-line**是将滑块两端的背景颜色以及边缘两端的两个按钮设置为透明，这样就可以只看到滑块以及背景的颜色。</p>
<p>*<em><strong><strong>如果border-radius等于滑动条的高度的一半，则边缘会是一个半圆。</strong></strong></em></p>
<p>如果我们不将add-page\sub-page、add-line\sub-line的背景颜色设置为透明，滑动条的圆角效果就会变成比较糟糕。</p>
<p>如果我们把QSS改成这样，add-page\sub-page具备背景色。</p>
<p>（ScrollBar的高度是20px,现在border-radius设置为10px，即半圆效果）</p>
<p><img src="/2021/06/27/Qt/v2-880a3638e5cea698aeda64ba64d61fe0_720w.webp" alt="img"></p>
<p><img src="/2021/06/27/Qt/v2-6e82b59c44a19f5c7add2542363875d0_720w.webp" alt="img"></p>
<p><img src="/2021/06/27/Qt/v2-453dbe562ba0624703bf731911b25a81_720w.webp" alt="img"></p>
<p>我们发现如果sub-page设置了颜色，没有设置border-radius,那左侧滑动条边缘还是一个直角。如上图的1号区域。</p>
<p>如果add-page设置了颜色，并且设置了border-radius,那么这个add-page的区域都会变成一个圆角矩形。</p>
<p>这时候和原本的handle的圆角就冲突了，所以要实现比较好的圆角滑动条效果，则需要把add-page/sub-page的背景色设置为透明。</p>
<p>如果我们把QSS改成这样，add-line\sub-line具备背景色。</p>
<p><img src="/2021/06/27/Qt/v2-c5e9ad226f1df9a32f8e94c668af745d_720w.webp" alt="img"></p>
<p><img src="/2021/06/27/Qt/v2-d39b5f77dddcaf15b16edec2d64a1759_720w.webp" alt="img"></p>
<p><img src="/2021/06/27/Qt/v2-8b0758dbf7b07b90be7c7a7a275bddac_720w.webp" alt="img"></p>
<p>我们发现add-line\sub-line具备颜色之后，将会使得滑动条两端变成直角矩形，所以这两端的控制器的背景色也需要设置成透明。</p>
<p><strong><em>*</em>*注意：但是有一个情况，在我写这个文章的时候发现，如果你系统支持的透明色是黑色，那以上通过设置add-line\sub-line的样式表的方法，也没办法很好的支持圆角边框的效果。</strong></p>
<p><img src="/2021/06/27/Qt/v2-a4747b15c6d3cf89cf26960807bb9a53_720w.webp" alt="img"></p>
<p>我们发现<strong>add-line\sub-line</strong>的区域被设置成透明色之后，呈现了黑色，使得界面效果是那种会被UX设计师捶的效果。</p>
<p>这个问题在QScrollBar上面我还没有比较好的解决方案。</p>
<p>所以现在我们尝试使用Qt的QSlider控件来实现。</p>
<p><img src="/2021/06/27/Qt/v2-c667b1ff0deea7bc82448fffd299ed5c_720w.webp" alt="img"></p>
<p><img src="/2021/06/27/Qt/v2-5a777cd0342432ab31ef8bede94d34ed_720w-170237585294639.webp" alt="img"></p>
<p>QSlider的QSS选择器部件</p>
<p>我们现在给QSlider设置StyleSheet：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">setStyleSheet(&quot;QSlider::groove&#123;<span class="string">&quot;</span></span><br><span class="line"><span class="string">              &quot;</span>background-color:<span class="number">#3e3e3e</span>;&quot;</span><br><span class="line">              &quot;<span class="attribute">border-radius</span>:<span class="number">10px</span>;&#125;&quot;</span><br><span class="line">              &quot;QSlider::handle:horizontal&#123;<span class="string">&quot;</span></span><br><span class="line"><span class="string">              &quot;</span>background-color: <span class="number">#909090</span>;&quot;</span><br><span class="line">              &quot;<span class="attribute">border-radius</span>:<span class="number">10px</span>;&quot;</span><br><span class="line">　　　　　　　&quot;<span class="attribute">width</span>:<span class="number">60px</span>;&#125;&quot;</span><br><span class="line">              &quot;QSlider::add-page&#123;background-color:transparent;&#125;&quot;</span><br><span class="line">              &quot;QSlider::sub-page&#123;background-color:transparent;&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p>其中，QSlider不需要设置background-color，因为会被<strong>groove</strong>的背景色覆盖。</p>
<p>并且可以通过设置<strong>QSlider::handle:horizontal</strong>来设置滑块的大小，实现和QScrollBar通过设置singleStep来控制滑块大小的效果一样，并且更加灵活。</p>
<p>其他的QSS设置和QScrollBar的思路是类似的。</p>
<p>QSS设置完之后的效果如下，看起来很设计图相差不会太大。</p>
<p><img src="/2021/06/27/Qt/v2-9e9d48c5617f443984a164a948bb404a_720w.webp" alt="img"></p>
<p>QScrollBar的基类和QSlider的基类是一样的，都是QAbstractSlider,所以基本上滑动控件的基本操作，QScrollBar有的，都可以在QSlider里面实现。</p>
<p>所以使用QSlider来实现一个圆角的滑动条会更加灵活方便一些。</p>
<h4 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  QScrollBar:horizontal &#123;</span><br><span class="line">/*整个滑动区域*/</span><br><span class="line">    border:<span class="number">5px</span> solid green;</span><br><span class="line">      <span class="attribute">background</span>: cyan;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">60px</span> <span class="number">0</span> <span class="number">60px</span>;<span class="comment">/*左右留边，给左右箭头按钮留出空间*/</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  QScrollBar::handle:horizontal &#123;</span><br><span class="line">/*滑块*/</span><br><span class="line">border:<span class="number">3px</span> solid white;</span><br><span class="line">      <span class="attribute">background</span>: gray;</span><br><span class="line">      <span class="attribute">min-width</span>: <span class="number">5px</span>;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  QScrollBar::add-line:horizontal &#123;</span><br><span class="line">/*水平+按钮，也即右按钮*/</span><br><span class="line">      background: blue;</span><br><span class="line">      subcontrol-<span class="attribute">position</span>: right;</span><br><span class="line">      subcontrol-origin: margin;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">26px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">right</span>:<span class="number">0px</span>;<span class="comment">/*右按钮的右边紧贴控件的边沿*/</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  QScrollBar::sub-line:horizontal &#123;</span><br><span class="line">/*水平-按钮，也即左按钮，点击一下滚动一行*/</span><br><span class="line">      background: magenta;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">26px</span>;</span><br><span class="line">      subcontrol-<span class="attribute">position</span>: top left;</span><br><span class="line">      subcontrol-origin: margin;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">      <span class="attribute">left</span>:<span class="number">10px</span>;<span class="comment">/*左按钮的左边不靠边*/</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  QScrollBar<span class="selector-pseudo">:left</span>-arrow:horizontal, QScrollBar::right-arrow:horizontal &#123;</span><br><span class="line">   /*左右按钮里面的箭头符号*/   </span><br><span class="line">width: <span class="number">8px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">      <span class="attribute">background</span>: white;</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal &#123;</span><br><span class="line">/*滑块左右两侧的空白区域，点击一下滚动一页*/</span><br><span class="line">      border: <span class="number">3px</span> solid red;</span><br><span class="line"><span class="attribute">background</span>: transparent;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/54226e54c33740679896fbbc4251f9e3.png" alt="img"></p>
<h4 id="myuse"><a href="#myuse" class="headerlink" title="myuse"></a>myuse</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QScrollBar </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::handle:horizontal </span><br><span class="line">&#123;</span><br><span class="line">    background-color: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::handle:vertical</span><br><span class="line">&#123;</span><br><span class="line">    background-color: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">125</span>);</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QScrollBar::add-page</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::sub-page</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::add-line</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">QScrollBar::sub-line</span><br><span class="line">&#123;</span><br><span class="line">    background-color: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="QProgressBar"><a href="#QProgressBar" class="headerlink" title="QProgressBar"></a>QProgressBar</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># 设置QProgressBar的样式</span><br><span class="line">progress_bar = QProgressBar()</span><br><span class="line">style_sheet = &quot;&quot;&quot;</span><br><span class="line">    QProgressBar &#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid grey;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: grey;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">    &#125;</span><br><span class="line">    QProgressBar::chunk &#123;</span><br><span class="line">        background-color: <span class="number">#2453A4</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">20px</span>; <span class="comment">/* just a placeholder value */</span></span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0.5px</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">progress_bar<span class="selector-class">.setStyleSheet</span>(style_sheet)</span><br></pre></td></tr></table></figure>

<h4 id="myuse-1"><a href="#myuse-1" class="headerlink" title="myuse"></a>myuse</h4><p><img src="/2021/06/27/Qt/image-20231212141251841.png" alt="image-20231212141251841"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QProgressBar </span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">QProgressBar::chunk </span><br><span class="line">&#123;</span><br><span class="line">	background-color: <span class="built_in">rgba</span>(<span class="number">211</span>, <span class="number">248</span>, <span class="number">248</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">20px</span>; <span class="comment">/* just a placeholder value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置Qwidget类背景方法总结"><a href="#设置Qwidget类背景方法总结" class="headerlink" title="设置Qwidget类背景方法总结"></a>设置Qwidget类背景方法总结</h3><h4 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h4><p>  在实现一个页面跳转功能时，选择PushButton或QWidget可以有效当作按钮，而Qwidget可以添加label或者其它控件，自定义程度更高，因此本文给出几种给Qwidget绘制背景图片方法。</p>
<h4 id="2、使用样式表（setStyleSheet）"><a href="#2、使用样式表（setStyleSheet）" class="headerlink" title="2、使用样式表（setStyleSheet）"></a>2、使用样式表（setStyleSheet）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui-&gt;widget-&gt;setStyleSheet(&quot;border-image:url(://MainButton1.png)&quot;);</span><br></pre></td></tr></table></figure>

<p>  该种方法简单高效，可以快速实现Qwidget背景图片的切换。</p>
<h4 id="3、QPalette"><a href="#3、QPalette" class="headerlink" title="3、QPalette"></a>3、QPalette</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPalette pal =<span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line">pal.<span class="built_in">setBrush</span>(QPalette::Background,<span class="built_in">QBrush</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/bg.jpg&quot;</span>)));</span><br><span class="line"><span class="built_in">setPalette</span>(pal);</span><br></pre></td></tr></table></figure>

<p>  首先获得Widget调色板，再设置Brush，最后将设置应用到Widget中。<br>  若显示不出来加上setAutoFillBackground(true);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置背景图片</span></span><br><span class="line"><span class="built_in">setAutoFillBackground</span>(<span class="literal">true</span>);    <span class="comment">// 这句要加上, 否则可能显示不出背景图.</span></span><br><span class="line">QPalette palette = <span class="keyword">this</span>-&gt;<span class="built_in">palette</span>();</span><br><span class="line"><span class="comment">//palette.setColor(QPalette::Window, Qt::red);  // 设置背景色</span></span><br><span class="line"><span class="comment">//palette.setBrush(this-&gt;backgroundRole(), Qt::black);// 设置背景色</span></span><br><span class="line">palette.<span class="built_in">setBrush</span>(QPalette::Window,</span><br><span class="line">        <span class="built_in">QBrush</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/image/bkg.png&quot;</span>).<span class="built_in">scaled</span>(    <span class="comment">// 缩放背景图.</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">size</span>(),</span><br><span class="line">            Qt::IgnoreAspectRatio,</span><br><span class="line">            Qt::SmoothTransformation)));    <span class="comment">// 使用平滑的缩放方式</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setPalette</span>(palette);</span><br></pre></td></tr></table></figure>
<h4 id="4、paintEvent事件"><a href="#4、paintEvent事件" class="headerlink" title="4、paintEvent事件"></a>4、paintEvent事件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent * ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	painter.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),<span class="built_in">QPixmap</span>(<span class="string">&quot;:/bg.jpg&quot;</span>),<span class="built_in">QRect</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>  使用drawPixmap方法绘制一个矩形，传入第三个参数QRect()表示整个矩形区域，使用需要在新的类中重写PaintEvent，不适用于子窗口中的Widget绘制。</p>
<h5 id="5、简洁方式"><a href="#5、简洁方式" class="headerlink" title="5、简洁方式"></a>5、简洁方式</h5><p>QLabel：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent) :</span><br><span class="line">	<span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">	m_lblBg = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">	m_lblBg -&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/bg.jpg&quot;</span>));</span><br><span class="line">	m_lblBg -&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::resizeEvent</span><span class="params">(QResizeEvent * ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_lblBg-&gt;<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  需要调用QLabel的setScaledContents(true)，否则会和使用qss效果相同，不过label可以显示动态图，因此这种方式也适用于动态界面。</p>
<p>QFrame：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFrame *frame = <span class="keyword">new</span> <span class="built_in">QFrame</span>(<span class="keyword">this</span>);</span><br><span class="line">frame-&gt;<span class="built_in">setObjectName</span>(<span class="string">&quot;myframe&quot;</span>);</span><br><span class="line">frame-&gt;<span class="built_in">setGeometry</span>(<span class="keyword">this</span>-&gt;<span class="built_in">geometry</span>());</span><br><span class="line">frame-&gt;<span class="built_in">resize</span>(<span class="built_in">width</span>(),<span class="built_in">height</span>());</span><br><span class="line">frame-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QFrame#myframe&#123;border-image:url(:/image/bkg.png)&#125;&quot;</span> );</span><br></pre></td></tr></table></figure>

<p>  将label或frame通过Widget 的resizeEvent时间设置成和Widget一样，可以实现平铺效果，不过还是需要新建一个类，不适用子窗口。</p>
<h5 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h5><table>
<thead>
<tr>
<th>方法</th>
<th>自适应</th>
<th>动图</th>
<th>新建类</th>
</tr>
</thead>
<tbody><tr>
<td>Qss</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>QPalette</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>paintEvent</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>QLabel</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>QFrame</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h3><p>QPushButton样式表设置背景色 background-color无效的原因</p>
<p><img src="/2021/06/27/Qt/70.png" alt="img"> </p>
<p>想使背景色生效，必须要设置一下某个border属性，border-color、border-width等等任何一个跟border相关的属性都行。因为pushbutton的原生边界把背景色给覆盖住了。</p>
<h4 id="setFlat（TRUE）后，会取消凸出效果"><a href="#setFlat（TRUE）后，会取消凸出效果" class="headerlink" title="setFlat（TRUE）后，会取消凸出效果"></a>setFlat（TRUE）后，会取消凸出效果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于QPushButton设置属性setFlat（TRUE）后，会取消凸出效果，但是点击后还会出现下陷效果，该如何让QPushButton点击后无下陷效果呢？</span><br><span class="line">可以试试stylesheet。</span><br><span class="line">button-&gt;setStyleSheet(&quot;QPushButton&#123;border:none;&#125;&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="myuse-2"><a href="#myuse-2" class="headerlink" title="myuse"></a>myuse</h4><p><img src="/2021/06/27/Qt/image-20231212141320048.png" alt="image-20231212141320048"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QPushButton</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/slices/矩形 46(9</span>).png);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span><br><span class="line">	<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">22</span>, <span class="number">33</span>, <span class="number">55</span>, <span class="number">0.38</span>);</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QPushButton::hover</span><br><span class="line">&#123;</span><br><span class="line">	background-color:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;  </span><br><span class="line">	<span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="QCalendarWidget"><a href="#QCalendarWidget" class="headerlink" title="QCalendarWidget"></a>QCalendarWidget</h3><p><img src="/2021/06/27/Qt/QSS-Subcontrol-CalendarWidget.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzIzOTM3,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*日历部分的背景颜色*/</span></span><br><span class="line"><span class="selector-id">#qt_calendar_calendarview</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">10</span>, <span class="number">95</span>, <span class="number">189</span>, <span class="number">1</span>);	<span class="comment">/*背景颜色*/</span></span><br><span class="line">    <span class="attribute">font</span>: <span class="number">16px</span>;								<span class="comment">/*字体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这是日历部分的另外一个写法*/</span></span><br><span class="line">QCalendarWidget QTableView </span><br><span class="line">&#123;</span><br><span class="line">    alternate-<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">10</span>, <span class="number">95</span>, <span class="number">189</span>, <span class="number">1</span>);  <span class="comment">/* day name/week number background */</span></span><br><span class="line"> 	<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标题栏的样式*/</span></span><br><span class="line">QCalendarWidget QWidget<span class="selector-id">#qt_calendar_navigationbar</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">4</span>, <span class="number">51</span>, <span class="number">114</span>, <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上一月的箭头的样式*/</span></span><br><span class="line">QCalendarWidget QToolButton<span class="selector-id">#qt_calendar_prevmonth</span> </span><br><span class="line">&#123;</span><br><span class="line">    qproperty-<span class="attribute">icon</span>: <span class="built_in">url</span>(<span class="string">:/images/images/B.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下一月的箭头的图标*/</span></span><br><span class="line">QCalendarWidget QToolButton<span class="selector-id">#qt_calendar_nextmonth</span> </span><br><span class="line">&#123;</span><br><span class="line">    qproperty-<span class="attribute">icon</span>: <span class="built_in">url</span>(<span class="string">:/images/images/A.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里是激活的日期的样式也就是当前这个月*/</span></span><br><span class="line">QCalendarWidget QAbstractItemView<span class="selector-pseudo">:enabled</span> </span><br><span class="line"> &#123;</span><br><span class="line">   	<span class="attribute">font-size</span>:<span class="number">24px</span>;  </span><br><span class="line">   	<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>); </span><br><span class="line"><span class="comment">/* 这里是你选择一个日期时的样式，包括背景和字体颜色</span></span><br><span class="line"><span class="comment">   selection-background-color: rgb(64, 64, 64); </span></span><br><span class="line"><span class="comment">   selection-color: rgb(0, 255, 0); */</span></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/*这里是其他月份的样式*/</span></span><br><span class="line">QCalendarWidget QAbstractItemView<span class="selector-pseudo">:disabled</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextCharFormat format = calendarWidget-&gt;<span class="built_in">weekdayTextFormat</span>(Qt::Saturday);</span><br><span class="line">format.<span class="built_in">setForeground</span>(<span class="built_in">QBrush</span>(Qt::white, Qt::SolidPattern));</span><br><span class="line">calendarWidget-&gt;<span class="built_in">setWeekdayTextFormat</span>(Qt::Saturday, format);</span><br></pre></td></tr></table></figure>

<h4 id="标题背景"><a href="#标题背景" class="headerlink" title="标题背景"></a>标题背景</h4><p><img src="/2021/06/27/Qt/3bae3e3020764776a38d28fb78890d28.png" alt="img"></p>
<p>​    标题背景： </p>
<p><img src="/2021/06/27/Qt/011e9a4d1c264f1d888fa55438d87208.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#qt_calendar_navigationbar</span>&#123;</span><br><span class="line">        <span class="attribute">font</span>:<span class="number">18px</span> Microsoft YaHei;</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">196</span>, <span class="number">196</span>, <span class="number">249</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果需要将年月选择栏背景颜色和日期背景颜色设置为同一个颜色，可以选择设置QWidget。</p>
<p><img src="/2021/06/27/Qt/b4c3df49d05e4c34b94cad1f73b95a46.png" alt="img"><img src="/2021/06/27/Qt/d758ff909cb24010a9daf2aa2b13acc5.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QCalendarWidget QWidget&#123;</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">153</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上一个月、下一个月跳转图标"><a href="#上一个月、下一个月跳转图标" class="headerlink" title="上一个月、下一个月跳转图标"></a>上一个月、下一个月跳转图标</h4><p> 如果设置了QDateEdit的时间范围（本例：当前时间），下一个月按钮样式自动回变成灰色的不可点击状态（上一个月图标同理），不需要单独去设置上一个月、下一个月的不可点击状态样式。</p>
<p><img src="/2021/06/27/Qt/0dc10133aaaa4f19b3767e988bc3f386.png" alt="img"><img src="/2021/06/27/Qt/e14057f812bc4bd1a436ce877f70b455.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#qt_calendar_prevmonth</span>&#123;</span><br><span class="line">        qproperty-<span class="attribute">icon</span>:<span class="built_in">url</span>(<span class="string">:/Picture/iconGate_blue.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#qt_calendar_nextmonth</span>&#123;</span><br><span class="line">        qproperty-<span class="attribute">icon</span>:<span class="built_in">url</span>(<span class="string">:/Picture/iconGate_red.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="月份选择"><a href="#月份选择" class="headerlink" title="月份选择"></a>月份选择</h4><p>分为两个部分，当前月的正常状态与选择状态，月份下拉框。        </p>
<p> <img src="/2021/06/27/Qt/ecb1cd1163014f33bce1aaddb6321449.png" alt="img"><img src="/2021/06/27/Qt/fd35446aac2a428fb852c759ac0d09bc.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QToolButton<span class="selector-id">#qt_calendar_monthbutton</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">51</span>, <span class="number">153</span>);</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">244</span>, <span class="number">244</span>, <span class="number">244</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">QCalendarWidget QMenu&#123;</span><br><span class="line">        <span class="attribute">font</span>:<span class="number">18px</span> Microsoft YaHei;</span><br><span class="line">        <span class="attribute">left</span>:<span class="number">5px</span>;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">128</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">196</span>, <span class="number">196</span>, <span class="number">249</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="年份选择"><a href="#年份选择" class="headerlink" title="年份选择"></a>年份选择</h4><p>修改样式其实就是QSpinBox修改样式。</p>
<p><img src="/2021/06/27/Qt/111187fbae4b47d1ad5036899ba4e6d8-170237580828119.png" alt="img"><img src="/2021/06/27/Qt/8d394762d4ca48f8968d745e676ea436-170237579561614.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/f8e35567fe6241a6b545a22fe0cf890f.png" alt="img"><img src="/2021/06/27/Qt/18bb4da6d45946a9a99244d36d636636.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*年份选择：正常状态*/</span></span><br><span class="line">QToolButton<span class="selector-id">#qt_calendar_yearbutton</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">51</span>, <span class="number">153</span>);</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">244</span>, <span class="number">244</span>, <span class="number">244</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:修改时*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>&#123;</span><br><span class="line">        <span class="attribute">font</span>:<span class="number">18px</span> Microsoft YaHei;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">178</span>, <span class="number">102</span>);</span><br><span class="line">        <span class="attribute">background</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">209</span>, <span class="number">204</span>);                  <span class="comment">/*文本框背景颜色*/</span></span><br><span class="line">        selection-<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);             <span class="comment">/*选中字体颜色*/</span></span><br><span class="line">        selection-<span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">204</span>, <span class="number">153</span>, <span class="number">255</span>);  <span class="comment">/*选中背景颜色*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向上箭头*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::up-arrow&#123;</span><br><span class="line">        image:<span class="built_in">url</span>(<span class="string">:/Picture/44.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向下箭头*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::down-arrow&#123;</span><br><span class="line">        image:<span class="built_in">url</span>(<span class="string">:/Picture/44.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向上图标*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::up-button&#123;</span><br><span class="line">        /*border-image:<span class="built_in">url</span>(<span class="string">:/Picture/top.png</span>);*/</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">153</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向下图标*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::down-button&#123;</span><br><span class="line">        /*border-image:<span class="built_in">url</span>(<span class="string">:/Picture/bottom.png</span>);*/</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">153</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="周一到周末栏"><a href="#周一到周末栏" class="headerlink" title="周一到周末栏"></a>周一到周末栏</h4><p>修改字体颜色、背景色。</p>
<p>修改背景色。周一到周五字体的颜色和日期当中周一到周五的颜色是同步的设置的，周六和周末的字体颜色和日期当中的周六周末的颜色是同步设置的。如果在此处修改字体颜色，后续就不要设置日期当中的字体颜色了，否则，日期当中的周一到周五的颜色设置会覆盖此处的字体颜色设置。</p>
<p><img src="/2021/06/27/Qt/8dd13fc785ad40bca0e3919ec5d19f1b.png" alt="img"><img src="/2021/06/27/Qt/a298120c21b240518c7dbb971959a32b.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/dfe472dc52e140558800d446e6935d9d.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QCalendarWidget QTableView</span><br><span class="line">&#123;</span><br><span class="line">        alternate-background-color:<span class="built_in">rgb</span>(<span class="number">204</span>, <span class="number">229</span>, <span class="number">255</span>);</span><br><span class="line">        color:<span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">128</span>, <span class="number">255</span>);     <span class="comment">/*字体颜色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 周六周末的颜色是单独在代码里面设置的，不在QSS里。</p>
<p><img src="/2021/06/27/Qt/672b9675c09e49d9a0a59c22e46927dc.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCalendarWidget *calendar = ui-&gt;dateEdit_timeEnd-&gt;<span class="built_in">calendarWidget</span>();</span><br><span class="line">QTextCharFormat weekendFormat;</span><br><span class="line">weekendFormat.<span class="built_in">setForeground</span>(<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">153</span>, <span class="number">51</span>, <span class="number">255</span>)));</span><br><span class="line">calendar-&gt;<span class="built_in">setWeekdayTextFormat</span>(Qt::Saturday, weekendFormat);</span><br><span class="line">calendar-&gt;<span class="built_in">setWeekdayTextFormat</span>(Qt::Sunday, weekendFormat);</span><br></pre></td></tr></table></figure>

<h4 id="日期栏背景色"><a href="#日期栏背景色" class="headerlink" title="日期栏背景色"></a>日期栏背景色</h4><p><img src="/2021/06/27/Qt/b00091c1efe445b3bfbe0fce9201e0b8.png" alt="img"><img src="/2021/06/27/Qt/7697c67f750a4afb8a7e431786f98bef.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#qt_calendar_calendarview</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">229</span>, <span class="number">229</span>, <span class="number">252</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*选中月日期*/</span></span><br><span class="line">QCalendarWidget QAbstractItemView<span class="selector-pseudo">:enabled</span>&#123;</span><br><span class="line">        <span class="attribute">font</span>:<span class="number">18px</span> Microsoft YaHei;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">204</span>, <span class="number">204</span>);</span><br><span class="line">        selection-<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);           <span class="comment">/* 当前选中日期：字体颜色*/</span></span><br><span class="line">        selection-<span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">102</span>, <span class="number">102</span>);  <span class="comment">/* 当前选中日期：背景颜色*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*非选中月日期*/</span></span><br><span class="line">QCalendarWidget QAbstractItemView<span class="selector-pseudo">:disabled</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">204</span>, <span class="number">255</span>, <span class="number">204</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="myuse-3"><a href="#myuse-3" class="headerlink" title="myuse"></a>myuse</h4><p><img src="/2021/06/27/Qt/image-20231212141349546.png" alt="image-20231212141349546"><img src="/2021/06/27/Qt/image-20231212141358404.png" alt="image-20231212141358404"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*日历部分的背景颜色*/</span></span><br><span class="line"><span class="selector-id">#qt_calendar_calendarview</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>); 	<span class="comment">/*背景颜色*/</span></span><br><span class="line">    <span class="attribute">font</span>: <span class="number">16px</span>;								<span class="comment">/*字体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标题栏的样式*/</span></span><br><span class="line">QCalendarWidget QWidget<span class="selector-id">#qt_calendar_navigationbar</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>); </span><br><span class="line">  <span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这是日历部分的另外一个写法*/</span></span><br><span class="line">QCalendarWidget QTableView </span><br><span class="line">&#123;</span><br><span class="line">    alternate-<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);  <span class="comment">/* day name/week number background */</span></span><br><span class="line"> 	<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QDateTimeEdit&#123;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">	<span class="attribute">border</span>:<span class="number">1px</span> solid  <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">204</span>);</span><br><span class="line">&#125;</span><br><span class="line">QDateEdit<span class="selector-id">#dateEdit</span><span class="selector-pseudo">:drop</span>-down&#123;</span><br><span class="line">        <span class="attribute">border-image</span>:<span class="built_in">url</span>(<span class="string">:/Images/showcalendar.png</span>);</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上一月的箭头的样式*/</span></span><br><span class="line">QToolButton<span class="selector-id">#qt_calendar_prevmonth</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: transparent;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">	qproperty-<span class="attribute">icon</span>: <span class="built_in">url</span>(<span class="string">:/slices/Shape807.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下一月的箭头的样式*/</span></span><br><span class="line">QToolButton<span class="selector-id">#qt_calendar_nextmonth</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: transparent;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">	qproperty-<span class="attribute">icon</span>: <span class="built_in">url</span>(<span class="string">:/slices/Shape807-2.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*月份选择*/</span></span><br><span class="line">QToolButton<span class="selector-id">#qt_calendar_monthbutton</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line">QCalendarWidget QMenu&#123;</span><br><span class="line">	<span class="comment">/*font:18px Microsoft YaHei;*/</span></span><br><span class="line">	<span class="attribute">left</span>:<span class="number">5px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*年份选择*/</span></span><br><span class="line">QToolButton<span class="selector-id">#qt_calendar_yearbutton</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*年份选择:修改时*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">	<span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>);                 <span class="comment">/*文本框背景颜色*/</span></span><br><span class="line">	selection-<span class="attribute">color</span>:<span class="built_in">r</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);          <span class="comment">/*选中字体颜色*/</span></span><br><span class="line">	selection-<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">27</span>, <span class="number">35</span>, <span class="number">41</span>, <span class="number">1</span>); <span class="comment">/*选中背景颜色*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向上箭头*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::up-arrow&#123;</span><br><span class="line">        image:<span class="built_in">url</span>(<span class="string">:/slices/向上年份选择.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向下箭头*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::down-arrow&#123;</span><br><span class="line">        image:<span class="built_in">url</span>(<span class="string">:/slices/向下年份选择.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*年份选择:向上图标*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::up-button&#123;</span><br><span class="line">        /*border-image:<span class="built_in">url</span>(<span class="string">:/Picture/top.png</span>);*/</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">153</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*年份选择:向下图标*/</span></span><br><span class="line">QSpinBox<span class="selector-id">#qt_calendar_yearedit</span>::down-button&#123;</span><br><span class="line">        /*border-image:<span class="built_in">url</span>(<span class="string">:/Picture/bottom.png</span>);*/</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">153</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QDateEdit样式"><a href="#QDateEdit样式" class="headerlink" title="QDateEdit样式"></a>QDateEdit样式</h3><h4 id="正常状态与选中状态"><a href="#正常状态与选中状态" class="headerlink" title="正常状态与选中状态"></a>正常状态与选中状态</h4><p><img src="/2021/06/27/Qt/e2f13aed47db45fea75cba8b5971237a.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*正常状态*/</span></span><br><span class="line">QDateEdit#dateEdit_timeEnd&#123;</span><br><span class="line">        font:<span class="number">20</span>px Microsoft YaHei;</span><br><span class="line">        color:<span class="built_in">rgb</span>(<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line">        background-color:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">204</span>, <span class="number">229</span>, <span class="number">80</span>);</span><br><span class="line">        border-color:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">153</span>, <span class="number">204</span>);</span><br><span class="line">        border-style:solid;</span><br><span class="line">        border-radius:<span class="number">10</span>px;</span><br><span class="line">        border-width:<span class="number">5</span>px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*选中状态*/</span></span><br><span class="line">QDateEdit#dateEdit:focus&#123;</span><br><span class="line">        font:<span class="number">20</span>px Microsoft YaHei;</span><br><span class="line">        border-color:<span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">102</span>, <span class="number">178</span>);    <span class="comment">/*边框颜色*/</span></span><br><span class="line">        border-style:solid;                 <span class="comment">/*边框内容*/</span></span><br><span class="line">        border-radius:<span class="number">10</span>px;                 <span class="comment">/*边框圆角弧度*/</span></span><br><span class="line">        border-width:<span class="number">5</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日历下拉图标设置</p>
<p><img src="/2021/06/27/Qt/7f5470c6db0a44529d088995035c8f07-17023757570242.png" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QDateEdit<span class="selector-id">#dateEdit</span><span class="selector-pseudo">:drop</span>-down&#123;</span><br><span class="line">        <span class="attribute">border-image</span>:<span class="built_in">url</span>(<span class="string">:/Picture/calendar-icon.png</span>);</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QComboBox"><a href="#QComboBox" class="headerlink" title="QComboBox"></a>QComboBox</h3><p><img src="/2021/06/27/Qt/image-20231212141510099.png" alt="image-20231212141510099"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">QComboBox &#123;</span><br><span class="line">    	<span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgb</span>(<span class="number">113</span>,<span class="number">140</span>,<span class="number">201</span>);</span><br><span class="line">        <span class="attribute">background-color</span>: transparent;</span><br><span class="line">		<span class="attribute">border-radius</span>:<span class="number">5px</span>;</span><br><span class="line">		<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox<span class="selector-pseudo">:enabled</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">240</span>, <span class="number">244</span>, <span class="number">252</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox:!enabled &#123;</span><br><span class="line">        color:<span class="built_in">rgba</span>(<span class="number">240</span>, <span class="number">244</span>, <span class="number">252</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox<span class="selector-pseudo">:enabled</span><span class="selector-pseudo">:hover</span>, QComboBox<span class="selector-pseudo">:enabled</span><span class="selector-pseudo">:focus</span> </span><br><span class="line">&#123;</span><br><span class="line">		<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">240</span>, <span class="number">244</span>, <span class="number">252</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">146</span>, <span class="number">170</span>, <span class="number">186</span>, <span class="number">75</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox::drop-down &#123;</span><br><span class="line">        border: none;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">146</span>, <span class="number">170</span>, <span class="number">186</span>, <span class="number">25</span>);</span><br><span class="line">		<span class="attribute">border-radius</span>:<span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QComboBox::drop-down:hover &#123;</span><br><span class="line">        background-color: <span class="built_in">rgba</span>(<span class="number">146</span>, <span class="number">170</span>, <span class="number">186</span>, <span class="number">75</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox::down-arrow &#123;</span><br><span class="line">       image:<span class="built_in">url</span>(<span class="string">:/Images/downArrow.png</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox::down-arrow:on &#123;</span><br><span class="line">        /**top: <span class="number">1px</span>;**/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QComboBox QAbstractItemView</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: transparent;</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line">QComboBox QAbstractItemView::item &#123;</span><br><span class="line">        height: <span class="number">32px</span>;</span><br><span class="line">		<span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">QComboBox QAbstractItemView::item:selected &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QMenu"><a href="#QMenu" class="headerlink" title="QMenu"></a>QMenu</h3><p><img src="/2021/06/27/Qt/image-20231212141626200.png" alt="image-20231212141626200"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QMenu&#123;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>); </span><br><span class="line">	<span class="attribute">border</span>:<span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">5px</span>;</span><br><span class="line">	<span class="attribute">margin</span>:<span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QMenu::item&#123;</span><br><span class="line">    height:<span class="number">34px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">232</span>, <span class="number">250</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">QMenu::item:text &#123; </span><br><span class="line">	padding-left:<span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">padding-right</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QMenu::item:selected&#123; </span><br><span class="line">	color:<span class="built_in">rgb</span>(<span class="number">112</span>, <span class="number">197</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="QIFW（Qt-Installer-Framework）"><a href="#QIFW（Qt-Installer-Framework）" class="headerlink" title="QIFW（Qt Installer Framework）"></a>QIFW（Qt Installer Framework）</h1><p>官网-<a href="https://doc.qt.io/qtinstallerframework/ifw-overview.html">https://doc.qt.io/qtinstallerframework/ifw-overview.html</a></p>
<p><img src="/2021/06/27/Qt/image-20240206143605770.png" alt="image-20240206143605770"></p>
<p>组件信号-<a href="https://doc.qt.io/qtinstallerframework/scripting-installer.html">https://doc.qt.io/qtinstallerframework/scripting-installer.html</a></p>
<p>所有默认界面-<a href="https://doc.qt.io/qtinstallerframework/scripting-qinstaller.html">https://doc.qt.io/qtinstallerframework/scripting-qinstaller.html</a></p>
<p><strong>看了这么多，这两个是最有用的：<a href="https://blog.csdn.net/qq_39480297/article/details/132038981">https://blog.csdn.net/qq_39480297/article/details/132038981</a></strong></p>
<p><strong><a href="https://blog.csdn.net/qq_34183232/article/details/118255975">https://blog.csdn.net/qq_34183232/article/details/118255975</a></strong></p>
<h2 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h2><p>GIFW下载地址：<a href="https://download.qt.io/official_releases/qt-installer-framework/">https://download.qt.io/official_releases/qt-installer-framework/</a></p>
<p><img src="/2021/06/27/Qt/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg5MjEwMQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>bin：提供了一些基本的工具，比如打包要用的 binarycreator。<br>doc：包含了相应的帮助文档，有助于更好的掌握 Qt IFW。<br>examples：有各种各样的示例，方便我们学习研究。<br>Licenses：许可协议。</p>
<p><img src="/2021/06/27/Qt/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg5MjEwMQ==,size_16,color_FFFFFF,t_70-17072022583692.png" alt="img"></p>
<h3 id="添加到Qt-Creator帮助文档"><a href="#添加到Qt-Creator帮助文档" class="headerlink" title="添加到Qt Creator帮助文档"></a>添加到Qt Creator帮助文档</h3><p>打开 Qt Creator，选择【工具】–&gt;【选项】–&gt;【帮助】–&gt;【文档】–&gt;【添加】<br>选择Qt IFW安装目录doc下的ifw.qch文件。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">binarycreator -c config\config.xml -p packages MySoftwareInstaller.exe -v</span><br></pre></td></tr></table></figure>



<h2 id="离线安装文件结构"><a href="#离线安装文件结构" class="headerlink" title="离线安装文件结构"></a>离线安装文件结构</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">--Installer</span><br><span class="line">  |__config（全局配置）</span><br><span class="line">     |__config.xml</span><br><span class="line">     |__control.qs</span><br><span class="line">  |__packages</span><br><span class="line">     |__com.root(根目录，主包)</span><br><span class="line">        |__data</span><br><span class="line">           |__可执行程序及所有的库文件</span><br><span class="line">           |__uninstallscript.qs</span><br><span class="line">        |__meta</span><br><span class="line">           |__installscript.js</span><br><span class="line">           |__package.xml</span><br><span class="line">           |__license.txt</span><br><span class="line">     |__com.root.foundation（多包）</span><br><span class="line">   		|__data</span><br><span class="line">           |__第三方安装包</span><br><span class="line">        |__meta</span><br><span class="line">           |__installscript.qs</span><br><span class="line">           |__package.xml</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li>com.root中的license.txt就是随便写，到时候安装会加载显示；</li>
<li>comfig、packages两个名字不能改；com.root和com.root.foundation名字可以改，但是都要放在packages下面，同时各自下面都要有data和meta文件夹，data放用到的可执行程序以及库，meta放配置文件和脚本；</li>
<li>对于第三方安装包，可以在配置文件中设置installer为true（没有验证）；</li>
<li>卸载静默，将卸载脚本uninstallscript.qs放入 data 目录中（例如：data/script/uninstallscript.qs），最终由 Qt IFW 打包进安装程序。当需要进行覆盖安装时，maintenancetool 工具就可以很容易的找到它。</li>
</ol>
<h2 id="离线安装示例："><a href="#离线安装示例：" class="headerlink" title="离线安装示例："></a>离线安装示例：</h2><p><strong>在对应的文件下</strong></p>
<p>Install.rar</p>
<h2 id="离线安装详解："><a href="#离线安装详解：" class="headerlink" title="离线安装详解："></a>离线安装详解：</h2><h3 id="config文件夹"><a href="#config文件夹" class="headerlink" title="config文件夹"></a>config文件夹</h3><h4 id="config-xml"><a href="#config-xml" class="headerlink" title="config.xml"></a>config.xml</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!--配置的所有属性-https:<span class="comment">//doc.qt.io/qtinstallerframework/ifw-globalconfig.html--&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Installer</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>TZ Weather System Installer<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.01<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Title</span>&gt;</span>TZ Weather System Installer<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Publisher</span>&gt;</span>ISCAS<span class="tag">&lt;/<span class="name">Publisher</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">StartMenuDir</span>&gt;</span>TZWeather System<span class="tag">&lt;/<span class="name">StartMenuDir</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">TargetDir</span>&gt;</span>@rootDir@/TZWeather<span class="tag">&lt;/<span class="name">TargetDir</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Installer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="control-qs"><a href="#control-qs" class="headerlink" title="control.qs"></a>control.qs</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://doc.qt.io/qtinstallerframework/noninteractive.html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是卸载程序</span></span><br><span class="line">    <span class="keyword">if</span>(installer.isUninstaller())&#123;</span><br><span class="line">        installer.uninstallationStarted.connect(<span class="built_in">this</span>, <span class="built_in">this</span>.uninstallationStarted);</span><br><span class="line">    	installer.uninstallationFinished.connect(<span class="built_in">this</span>, <span class="built_in">this</span>.uninstallationFinished);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 判断是否是安装程序</span></span><br><span class="line">    <span class="keyword">if</span>(installer.isInstaller())&#123;</span><br><span class="line">        installer.installationStarted.connect(<span class="built_in">this</span>,<span class="built_in">this</span>.installationStarted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载开始前需要执行的操作</span></span><br><span class="line">Controller.prototype.uninstallationStarted = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//var dir = installer.value(&quot;TargetDir&quot;);</span></span><br><span class="line">    <span class="comment">//installer.execute(dir + &quot;/script/uninstall.sh&quot;); // 可以自定义一些卸载的shell脚本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当卸载完成时，触发</span></span><br><span class="line">Controller.prototype.uninstallationFinished = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始安装前执行的操作</span></span><br><span class="line">Controller.prototype.installationStarted = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//installer.execute(&quot;touch&quot;,&quot;/home/arteryflow/aa/bb.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="packages的com-root的meta"><a href="#packages的com-root的meta" class="headerlink" title="packages的com.root的meta"></a>packages的com.root的meta</h3><h4 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;!--package中所有的属性-https:<span class="comment">//doc.qt.io/qtinstallerframework/ifw-component-description.html--&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Package</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>com.root<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">DisplayName</span>&gt;</span>TZ Weather System<span class="tag">&lt;/<span class="name">DisplayName</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Description</span>&gt;</span>TZ Weather System<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.01<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">ReleaseDate</span>&gt;</span>2024-02-05<span class="tag">&lt;/<span class="name">ReleaseDate</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--就是个txt，在安装过程中可以显示出来--&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Licenses</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">License</span> <span class="attr">name</span>=<span class="string">&quot;license&quot;</span> <span class="attr">file</span>=<span class="string">&quot;license.txt&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Licenses</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Default</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Script</span>&gt;</span>installscript.js<span class="tag">&lt;/<span class="name">Script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">UserInterfaces</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">UserInterface</span>&gt;</span>targetwidget.ui<span class="tag">&lt;/<span class="name">UserInterface</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">UserInterfaces</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Package</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="installscript-js"><a href="#installscript-js" class="headerlink" title="installscript.js"></a>installscript.js</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** Copyright (C) 2017 The Qt Company Ltd.</span></span><br><span class="line"><span class="comment">** Contact: https://www.qt.io/licensing/</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** This file is part of the Qt Installer Framework.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_BEGIN_LICENSE:GPL-EXCEPT$</span></span><br><span class="line"><span class="comment">** Commercial License Usage</span></span><br><span class="line"><span class="comment">** Licensees holding valid commercial Qt licenses may use this file in</span></span><br><span class="line"><span class="comment">** accordance with the commercial license agreement provided with the</span></span><br><span class="line"><span class="comment">** Software or, alternatively, in accordance with the terms contained in</span></span><br><span class="line"><span class="comment">** a written agreement between you and The Qt Company. For licensing terms</span></span><br><span class="line"><span class="comment">** and conditions see https://www.qt.io/terms-conditions. For further</span></span><br><span class="line"><span class="comment">** information use the contact form at https://www.qt.io/contact-us.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** GNU General Public License Usage</span></span><br><span class="line"><span class="comment">** Alternatively, this file may be used under the terms of the GNU</span></span><br><span class="line"><span class="comment">** General Public License version 3 as published by the Free Software</span></span><br><span class="line"><span class="comment">** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT</span></span><br><span class="line"><span class="comment">** included in the packaging of this file. Please review the following</span></span><br><span class="line"><span class="comment">** information to ensure the GNU General Public License requirements will</span></span><br><span class="line"><span class="comment">** be met: https://www.gnu.org/licenses/gpl-3.0.html.</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** $QT_END_LICENSE$</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentSelectionPage = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Dir = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.toNativeSparator = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (systemInfo.productType === <span class="string">&quot;windows&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> path.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//判断当前是安装、卸载、更新程序-https://doc.qt.io/qtinstallerframework/scripting-installer.html</span></span><br><span class="line">    <span class="keyword">if</span> (installer.isInstaller()) &#123;</span><br><span class="line">		<span class="comment">//信号0---加载组件后立即调用（一共有哪些组件的信号可绑定-https://doc.qt.io/qtinstallerframework/scripting-component.html）</span></span><br><span class="line">        component.loaded.connect(<span class="built_in">this</span>, Component.prototype.installerLoaded);</span><br><span class="line">        ComponentSelectionPage = gui.pageById(QInstaller.ComponentSelection);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//默认提供的界面不显示，使用自定义的ui界面（一共有哪些默认提供的页面-https://doc.qt.io/qtinstallerframework/scripting-qinstaller.html</span></span><br><span class="line">		<span class="comment">//installer一共有哪些函数-https://doc.qt.io/qtinstallerframework/scripting-installer.html）</span></span><br><span class="line">        installer.setDefaultPageVisible(QInstaller.TargetDirectory, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//installer.setDefaultPageVisible(QInstaller.ComponentSelection, false);</span></span><br><span class="line">        <span class="comment">//installer.setDefaultPageVisible(QInstaller.LicenseCheck, false);</span></span><br><span class="line">		<span class="comment">//可以获取的系统变量有哪些-https://doc.qt.io/qtinstallerframework/qinstaller-systeminfo.html</span></span><br><span class="line">        <span class="comment">//if (systemInfo.productType === &quot;windows&quot;)</span></span><br><span class="line">        <span class="comment">//    installer.setDefaultPageVisible(QInstaller.StartMenuSelection, false);</span></span><br><span class="line">        <span class="comment">//installer.setDefaultPageVisible(QInstaller.ReadyForInstallation, false);</span></span><br><span class="line">		</span><br><span class="line">		installer.installationFinished.connect(<span class="built_in">this</span>,Component.prototype.installationFinishedPageIsShown);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否是更新程序</span></span><br><span class="line">    <span class="keyword">if</span>(installer.isUpdater())</span><br><span class="line">	&#123;</span><br><span class="line">		installer.finishButtonClicked.connect(<span class="built_in">this</span>,Component.prototype.updateFinishedOpenText);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 判断是否是卸载程序</span></span><br><span class="line">    <span class="keyword">if</span>(installer.isUninstaller())</span><br><span class="line">	&#123;</span><br><span class="line">    	installer.uninstallationFinished.connect(<span class="built_in">this</span>, Component.prototype.uninstallationFinishedMessage);</span><br><span class="line">		installer.finishButtonClicked.connect(<span class="built_in">this</span>, Component.prototype.uninstallationFinishedMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安装完其实就是把data中的东西放在@TargetDir@下了</span></span><br><span class="line">Component.prototype.createOperations = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call default implementation to actually install README.txt!</span></span><br><span class="line">    component.createOperations();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有哪些operation -https://doc.qt.io/qtinstallerframework/operations.html</span></span><br><span class="line">    <span class="keyword">if</span> (systemInfo.productType === <span class="string">&quot;windows&quot;</span>) &#123;</span><br><span class="line">		<span class="comment">//创建开始菜单快捷方式</span></span><br><span class="line">        component.addOperation(<span class="string">&quot;CreateShortcut&quot;</span>, <span class="string">&quot;@TargetDir@/OceanWindPlatform.exe&quot;</span>, <span class="string">&quot;@StartMenuDir@/天智海洋气象区域精细化服务保障系统.lnk&quot;</span>,</span><br><span class="line">            <span class="string">&quot;workingDirectory=@TargetDir@/&quot;</span>);</span><br><span class="line">		<span class="comment">//创建桌面快捷方式</span></span><br><span class="line">		component.addOperation(<span class="string">&quot;CreateShortcut&quot;</span>, <span class="string">&quot;@TargetDir@/OceanWindPlatform.exe&quot;</span>, <span class="string">&quot;@DesktopDir@/天智海洋气象区域精细化服务保障系统.lnk&quot;</span>,</span><br><span class="line">            <span class="string">&quot;workingDirectory=@TargetDir@/&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		component.addOperation(</span><br><span class="line">        <span class="string">&quot;RegisterFileType&quot;</span>,</span><br><span class="line">        <span class="string">&quot;TZP&quot;</span>,                						<span class="comment">//需要注册的后缀名，不包含.</span></span><br><span class="line">        <span class="string">&quot;@TargetDir@\\OceanWindPlatform.exe %1&quot;</span>,    <span class="comment">//打开该文件的执行型程序, %1是文件路径命令行参数占位符，不可缺少</span></span><br><span class="line">        <span class="string">&quot;天智气象预报数据包&quot;</span>,              <span class="comment">//描述</span></span><br><span class="line">        <span class="string">&quot;text/xml&quot;</span>,                        <span class="comment">//上下文类型</span></span><br><span class="line">        <span class="string">&quot;@TargetDir@\\logo.ico,0&quot;</span>     	   <span class="comment">//文件图标</span></span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//槽函数0---加载组件后立即调用</span></span><br><span class="line">Component.prototype.installerLoaded = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用新UI代替默认的安装路径选择界面，使用的时候是Dynamic+自定义的名称（https://doc.qt.io/qtinstallerframework/ifw-customizing-installers.html）</span></span><br><span class="line">    <span class="keyword">if</span> (installer.addWizardPage(component, <span class="string">&quot;TargetWidget&quot;</span>, QInstaller.TargetDirectory)) &#123;</span><br><span class="line">        <span class="keyword">var</span> widget = gui.pageWidgetByObjectName(<span class="string">&quot;DynamicTargetWidget&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (widget != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">//信号1---当点击选择安装位置按钮时调用（根据UI控件的实际信号和槽函数）</span></span><br><span class="line">            widget.targetChooser.clicked.connect(<span class="built_in">this</span>, Component.prototype.chooseTarget);</span><br><span class="line">			<span class="comment">//信号2---当安装位置发生改变时调用（根据UI控件的实际信号和槽函数）</span></span><br><span class="line">            widget.targetDirectory.textChanged.connect(<span class="built_in">this</span>, Component.prototype.targetChanged);</span><br><span class="line"></span><br><span class="line">            widget.windowTitle = qsTranslate(<span class="string">&quot;installscript&quot;</span>, <span class="string">&quot;选择安装目录&quot;</span>);;</span><br><span class="line">			<span class="comment">//在页面上的安装位置lineedit中更新路径</span></span><br><span class="line">            widget.targetDirectory.text = Dir.toNativeSparator(installer.value(<span class="string">&quot;TargetDir&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//槽函数1---当安装位置发生改变时调用</span></span><br><span class="line">Component.prototype.targetChanged = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> widget = gui.pageWidgetByObjectName(<span class="string">&quot;DynamicTargetWidget&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (widget != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (text != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">			<span class="comment">//如果是新路径</span></span><br><span class="line">            <span class="keyword">if</span> (!installer.fileExists(text + <span class="string">&quot;/components.xml&quot;</span>)) &#123;</span><br><span class="line">                widget.complete = <span class="literal">true</span>;</span><br><span class="line">                installer.setValue(<span class="string">&quot;TargetDir&quot;</span>, text);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果已经存在需要先卸载</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(installer.fileExists(text + <span class="string">&quot;/maintenancetool.exe&quot;</span>))&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//在控制脚本中弹出信息消息框提醒要覆盖安装--方式一</span></span><br><span class="line">				<span class="keyword">var</span> result = QMessageBox.warning(<span class="string">&quot;os.warning&quot;</span>, <span class="string">&quot;Installer&quot;</span>,<span class="string">&quot;检测到程序已安装，继续将会被覆盖.&quot;</span>, QMessageBox.Yes | QMessageBox.No);</span><br><span class="line">				<span class="keyword">if</span> (result === QMessageBox.Yes) &#123;</span><br><span class="line">					<span class="comment">//卸载时使用uninstallscript.qs脚本静默卸载</span></span><br><span class="line">					installer.execute(text + <span class="string">&quot;/maintenancetool.exe&quot;</span>, <span class="string">&quot;--script=&quot;</span> + text + <span class="string">&quot;/uninstallscript.qs&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					 widget.targetDirectory.text = installer.value(<span class="string">&quot;TargetDir&quot;</span>);<span class="comment">//恢复默认路径</span></span><br><span class="line">					 widget.complete = <span class="literal">true</span>;</span><br><span class="line">					 <span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//在控制脚本中弹出信息消息框提醒要覆盖安装--方式二</span></span><br><span class="line">				<span class="comment">//QMessageBox[&quot;warning&quot;](&quot;os.warning&quot;, &quot;Installer&quot;,&quot;检测到程序已安装，继续将会被覆盖.&quot;,QMessageBox.Ok|QMessageBox::Cancel);</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//设置新路径</span></span><br><span class="line">				widget.complete = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//原则上这个里面的所有内容都能设置值并且获取（https://doc.qt.io/qtinstallerframework/ifw-globalconfig.html）</span></span><br><span class="line">                installer.setValue(<span class="string">&quot;TargetDir&quot;</span>, text);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        widget.complete = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//槽函数2---当点击选择安装位置按钮时调用</span></span><br><span class="line">Component.prototype.chooseTarget = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> widget = gui.pageWidgetByObjectName(<span class="string">&quot;DynamicTargetWidget&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (widget != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> newTarget = QFileDialog.getExistingDirectory(qsTranslate(<span class="string">&quot;installscript&quot;</span>, <span class="string">&quot;请选择程序的安装位置：&quot;</span>), widget</span><br><span class="line">            .targetDirectory.text);</span><br><span class="line">        <span class="keyword">if</span> (newTarget != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            widget.targetDirectory.text = Dir.toNativeSparator(newTarget)+<span class="string">&quot;\\TZWeather\\&quot;</span>;<span class="comment">//自定义文件夹名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装完成执行的操作</span></span><br><span class="line">Component.prototype.installationFinishedPageIsShown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//installer.execute(&quot;touch&quot;,&quot;/home/arteryflow/aa/bb.txt&quot;);</span></span><br><span class="line">	<span class="keyword">var</span> dir = installer.value(<span class="string">&quot;TargetDir&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(installer.fileExists(dir + <span class="string">&quot;/doc/天智全球海洋区域气象服务系统V1.0-用户手册-20231213.pdf&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		QDesktopServices.openUrl(<span class="string">&quot;file:///&quot;</span> + dir + <span class="string">&quot;/doc/天智全球海洋区域气象服务系统V1.0-用户手册-20231213.pdf&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新完成后的操作</span></span><br><span class="line">Component.prototype.updateFinishedOpenText = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//installer.execute(&quot;touch&quot;,&quot;/home/arteryflow/aa/bb.txt&quot;);</span></span><br><span class="line">	<span class="keyword">var</span> dir = installer.value(<span class="string">&quot;TargetDir&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(installer.fileExists(dir + <span class="string">&quot;/update.txt&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		QDesktopServices.openUrl(<span class="string">&quot;file:///&quot;</span> + dir + <span class="string">&quot;/update.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当卸载完成时，触发(不起作用)</span></span><br><span class="line">Component.prototype.uninstallationFinishedMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	QMessageBox.warning(<span class="string">&quot;os.warning&quot;</span>, <span class="string">&quot;UnInstaller&quot;</span>,<span class="string">&quot;卸载完成.&quot;</span>, QMessageBox.Yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="license-txt"><a href="#license-txt" class="headerlink" title="license.txt"></a>license.txt</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> is a license！</span><br></pre></td></tr></table></figure>

<h3 id="packages的com-root的data"><a href="#packages的com-root的data" class="headerlink" title="packages的com.root的data"></a>packages的com.root的data</h3><h4 id="uninstallscript-qs"><a href="#uninstallscript-qs" class="headerlink" title="uninstallscript.qs"></a>uninstallscript.qs</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以通过模拟用户单击与 UI 交互，来实现最终的卸载功能</span></span><br><span class="line"><span class="comment">// 卸载脚本：如果程序已安装，则会调用 maintenance 工具，自动进行卸载。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gui.clickButton(buttons.NextButton);</span><br><span class="line">    gui.clickButton(buttons.NextButton);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接信号槽</span></span><br><span class="line">    installer.uninstallationFinished.connect(<span class="built_in">this</span>, <span class="built_in">this</span>.uninstallationFinished);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当卸载完成时，触发</span></span><br><span class="line">Controller.prototype.uninstallationFinished = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gui.clickButton(buttons.NextButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与完成页面上的部件交互</span></span><br><span class="line">Controller.prototype.FinishedPageCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gui.clickButton(buttons.FinishButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="packages的com-root-foundation的meta"><a href="#packages的com-root-foundation的meta" class="headerlink" title="packages的com.root.foundation的meta"></a>packages的com.root.foundation的meta</h3><h4 id="package-xml-1"><a href="#package-xml-1" class="headerlink" title="package.xml"></a>package.xml</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;!--package中所有的属性-https:<span class="comment">//doc.qt.io/qtinstallerframework/ifw-component-description.html--&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Package</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>com.root.foundation<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">DisplayName</span>&gt;</span>TZ Weather librarys<span class="tag">&lt;/<span class="name">DisplayName</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Description</span>&gt;</span>TZ Weather librarys<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.01<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">ReleaseDate</span>&gt;</span>2024-02-05<span class="tag">&lt;/<span class="name">ReleaseDate</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--是否默认被选中--&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Default</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--表示对应的data文件夹中是个需要安装的安装包（https://doc.qt.io/qtinstallerframework/scripting-component.html）--&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">installer</span>&gt;</span>true<span class="tag">&lt;/<span class="name">installer</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Package</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="在线安装与更新"><a href="#在线安装与更新" class="headerlink" title="在线安装与更新"></a>在线安装与更新</h2><p>流程说明：</p>
<ol>
<li><p>先安装离线安装过程创建文件结构和配置；</p>
</li>
<li><p>修改config下的config.xml，新增在线库地址；</p>
</li>
<li><p>按离线安装包创建过程创建安装包，以后就用这个安装包在不同机器上安装程序；</p>
</li>
<li><p>执行repogen  -p packages repository生成存储库，</p>
</li>
<li><p><strong>有了更新之后，增加packages里面的config下的config.xml版本号（修改config下的config.xml不管用，这个是全局配置，不是包配置）</strong></p>
<p>​    <strong>经过实际测试，不能只在包中包含更新的部分，需要全部都覆盖！</strong></p>
</li>
<li><p>删掉第四步生成的存储库，重新执行第四步</p>
</li>
<li><p>在其他机器上打开maintenancetool.exe，选择更新组件，就可以看到版本号变大，可以完成更新了</p>
</li>
</ol>
<p><img src="/2021/06/27/Qt/image-20240206172451977.png" alt="image-20240206172451977"></p>
<p>大体上和离线安装一样，指示config下的config.xml文件需要加几句话RemoteRepositories:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!--配置的所有属性-https:<span class="comment">//doc.qt.io/qtinstallerframework/ifw-globalconfig.html--&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Installer</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>TZ Weather System Installer<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.01<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Title</span>&gt;</span>TZ Weather System Installer<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Publisher</span>&gt;</span>ISCAS<span class="tag">&lt;/<span class="name">Publisher</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">StartMenuDir</span>&gt;</span>TZWeather System<span class="tag">&lt;/<span class="name">StartMenuDir</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- Directory name is used in component.xml --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">TargetDir</span>&gt;</span>@rootDir@/TZWeather<span class="tag">&lt;/<span class="name">TargetDir</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">RemoteRepositories</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">Repository</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">Url</span>&gt;</span>http://192.168.6.44:44444/repository<span class="tag">&lt;/<span class="name">Url</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">Enabled</span>&gt;</span>1<span class="tag">&lt;/<span class="name">Enabled</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Username</span>&gt;</span>user<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">Password</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">DisplayName</span>&gt;</span>Example repository<span class="tag">&lt;/<span class="name">DisplayName</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">Repository</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">RemoteRepositories</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Installer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="自建服务器，替代文件夹形式，可用于在局域网内发布"><a href="#自建服务器，替代文件夹形式，可用于在局域网内发布" class="headerlink" title="自建服务器，替代文件夹形式，可用于在局域网内发布"></a>自建服务器，替代文件夹形式，可用于在局域网内发布</h3><blockquote>
<p>注意！<Url><a href="http://192.168.6.44:44444/repository">http://192.168.6.44:44444/repository</a></Url>这一段，<a href="http://192.168.6.44:44444就是自建服务的位置,不需要再写Server这一层级的文件夹了">http://192.168.6.44:44444就是自建服务的位置,不需要再写Server这一层级的文件夹了</a></p>
<p><img src="/2021/06/27/Qt/image-20240207154404530.png" alt="image-20240207154404530"></p>
<p>同时如果要完成上图的构造，生成资源库的命令应该是：repogen  -p packages ./Server/repository；生成安装包的命令应该是：binarycreator -c config\config.xml -p packages ./Server/installer.exe -v</p>
</blockquote>
<h4 id="Python3开启http-server服务"><a href="#Python3开启http-server服务" class="headerlink" title="Python3开启http server服务"></a><strong>Python3开启http server服务</strong></h4><p>python3可以为当前目录开启http server，实现该目录下，文件的网络共享。</p>
<p>通过以下指令，python会默认开启一个端口为8000的http服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure>

<p>如果想更换端口，直接在指令最后加端口号即可（注意这个端口不要用6000段<a href="https://zhuanlan.zhihu.com/p/605845898%EF%BC%89">https://zhuanlan.zhihu.com/p/605845898）</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m http.server -b 192.168.6.44 44444</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a><strong>效果</strong></h4><p>python3开启http server，默认端口为8000</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E:\Projects\SpxFrame\<span class="number">212</span>\TZweatherDisplay\Main\Installer-online\Server&gt;python -m http.server</span><br><span class="line">Serving HTTP on :: port <span class="number">8000</span> (http://[::]:<span class="number">8000</span>/) ...</span><br></pre></td></tr></table></figure>

<p>python3开启http server，手动指定端口为44444</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\Projects\SpxFrame\212\TZweatherDisplay\Main\Installer-online\Server&gt;python -m http.server -b 192.168.6.44 44444</span><br><span class="line">Serving HTTP on 192.168.6.44 port 44444 (http://192.168.6.44:44444/) ...</span><br></pre></td></tr></table></figure>

<p>例：查看浏览器访问效果</p>
<p><img src="/2021/06/27/Qt/image-20240207154050275.png" alt="image-20240207154050275"></p>
<h3 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h3><p><a href="https://blog.csdn.net/qq_34183232/article/details/118255975">https://blog.csdn.net/qq_34183232/article/details/118255975</a></p>
<p>需要在应用程序中添加模块完成版本号查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在使用 --checkupdates 检测更新时，并不会运行 GUI，而是仅输出更新信息</span></span><br><span class="line">    <span class="comment">//以下内容放入main.cpp中的一个函数中</span></span><br><span class="line">    <span class="function">QString <span class="title">program</span><span class="params">(<span class="string">&quot;./maintenancetool.exe&quot;</span>)</span></span>;</span><br><span class="line">    QStringList checkArgs;</span><br><span class="line">    checkArgs &lt;&lt; <span class="string">&quot;--checkupdates&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测更新</span></span><br><span class="line">    QProcess process;</span><br><span class="line">    process.<span class="built_in">start</span>(program, checkArgs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待检测完成</span></span><br><span class="line">    <span class="keyword">if</span> (!process.<span class="built_in">waitForFinished</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error checking for updates.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取输出内容</span></span><br><span class="line">    QByteArray data = process.<span class="built_in">readAllStandardOutput</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有输出意味着没有可用的更新</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;No updates available.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">contains</span>(<span class="string">&quot;no updates available&quot;</span>))&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;No updates available.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倘若需要特定的更新信息，应该解析输出的 XML。</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;444444444444:::::&quot;</span>&lt;&lt;data;</span><br><span class="line">    <span class="comment">//当检测到有可用的更新之后，以更新模式启动 maintenancetool</span></span><br><span class="line">    QMessageBox::StandardButton result =QMessageBox::<span class="built_in">information</span>(<span class="literal">NULL</span>,QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;更新&quot;</span>),QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;版本更新，是否继续?&quot;</span>),QMessageBox::Ok,QMessageBox::Cancel);</span><br><span class="line">    <span class="keyword">if</span>(result==QMessageBox::Ok)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 以分离式启动</span></span><br><span class="line">        QStringList updaterArgs;</span><br><span class="line">        updaterArgs &lt;&lt; <span class="string">&quot;--updater&quot;</span>;</span><br><span class="line">        <span class="keyword">bool</span> success = QProcess::<span class="built_in">startDetached</span>(program, updaterArgs);</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Program startup failed.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭当前正在运行的程序，打开更新程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="NSIS"><a href="#NSIS" class="headerlink" title="NSIS"></a>NSIS</h1><h2 id="脚本文件：-xiangdao-nsi"><a href="#脚本文件：-xiangdao-nsi" class="headerlink" title="脚本文件： xiangdao.nsi"></a>脚本文件： <a href="E:\oOo\source_posts\Qt\xiangdao.nsi">xiangdao.nsi</a></h2><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>IDE：<a href="https://hmne.sourceforge.net/">https://hmne.sourceforge.net/</a></p>
<p>编译：<a href="https://nsis.sourceforge.io/Main_Page">https://nsis.sourceforge.io/Main_Page</a></p>
<p>参考：<a href="https://blog.csdn.net/cai901022/article/details/135221270">https://blog.csdn.net/cai901022/article/details/135221270</a></p>
<p>用户手册：<a href="https://www.wenjiangs.com/doc/ang9qqgc">https://www.wenjiangs.com/doc/ang9qqgc</a></p>
<h3 id="1、点击-“脚本编辑器VNISEdit”"><a href="#1、点击-“脚本编辑器VNISEdit”" class="headerlink" title="1、点击 “脚本编辑器VNISEdit”"></a>1、点击 “脚本编辑器VNISEdit”</h3><p><img src="/2021/06/27/Qt/image-20240221135741227.png" alt="image-20240221135741227"></p>
<h3 id="2、选择“新建脚本：向导”"><a href="#2、选择“新建脚本：向导”" class="headerlink" title="2、选择“新建脚本：向导”"></a>2、选择“新建脚本：向导”</h3><p><img src="/2021/06/27/Qt/image-20240221135542436.png" alt="image-20240221135542436"></p>
<p><img src="/2021/06/27/Qt/3ba11f0a6cb449bba7b86717ab52dc1a.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/cf92e1b6ed8a4a3092f1453010b0a996.png" alt="img"></p>
<h3 id="3、这里的参数自己都可以设置试一下，点击下一步："><a href="#3、这里的参数自己都可以设置试一下，点击下一步：" class="headerlink" title="3、这里的参数自己都可以设置试一下，点击下一步："></a>3、这里的参数自己都可以设置试一下，点击下一步：</h3><p>以打包一个test.exe程序为例：</p>
<p><img src="/2021/06/27/Qt/0d6efeb24ec448a0b20db4f84808ac25.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/8a6dde29789241a5af3c454033e114f6.png" alt="img"></p>
<h3 id="4、授权文件"><a href="#4、授权文件" class="headerlink" title="4、授权文件"></a>4、授权文件</h3><p>就是我们的licence.txt文件，这个文件的编码ASCII编码，就是记事本新建的默认文本格式，这个文件的的路径必须是存在的，否则后面的时候不能生成安装程序。</p>
<p><img src="/2021/06/27/Qt/2ccfdd042bee428a9c8a6896b3170d30.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/e7525eb297d94a1cbb6f1ad49bce9a1f.png" alt="img"></p>
<p>这里就是添加要打包程序文件夹的步骤。先把默认的模版文件删掉</p>
<p><img src="/2021/06/27/Qt/a53ed224910240cf8d60c73e67dd8196.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/4092b9c95967481896c746197e00b64b.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/32ed87ac83b345089ccf3cd39b861da4.png" alt="img"></p>
<p>勾选包含子目录（如果没有包含子目录选择就直接点击确定，后面再在脚本中加/r参数就行了）</p>
<blockquote>
<p>这里可以新加多个Section，在左上角的窗口里，意为要打包多个程序、安装包</p>
</blockquote>
<p><img src="/2021/06/27/Qt/21f1ad0386944fdbaa0451dd3f76af9d.png" alt="img"></p>
<p>点击下一步：<br>添加桌面快捷方式</p>
<p><img src="/2021/06/27/Qt/b4304e305e014a47a1822f566ebe4ea7.png" alt="img"></p>
<p>手动补全：</p>
<p><img src="/2021/06/27/Qt/7d4dd2a3c2f146f283621623ba2a14ee.png" alt="img"></p>
<p>test.lnk是自己的快捷方式名<br>$INSTDIR\test.exe 这个是你打包的文件中的可执行文件</p>
<p><strong>注：</strong></p>
<p><em><strong>$STARTMENU</strong></em></p>
<p><strong>开始菜单目录 (常用于添加一个开始菜单项，使用 <a href="https://www.wenjiangs.com/doc/o6EbTz7C">CreateShortCut</a>)。该常量的内容 (所有用户或当前用户) 取决于 <a href="https://www.wenjiangs.com/doc/o6EbTz7C">SetShellVarContext</a> 设置。默认为当前用户。</strong></p>
<p><em><strong>$SMPROGRAMS</strong></em></p>
<p><strong>开始菜单程序目录 (当你想定位“$STARTMENU\程序”时可以使用它)。该常量的内容 (所有用户或当前用户) 取决于 <a href="https://www.wenjiangs.com/doc/o6EbTz7C">SetShellVarContext</a> 设置。默认为当前用户。</strong></p>
<p><em><strong>$SMSTARTUP</strong></em></p>
<p><strong>开始菜单程序/启动 目录。该常量的内容 (所有用户或当前用户) 取决于 <a href="https://www.wenjiangs.com/doc/o6EbTz7C">SetShellVarContext</a> 设置。默认为当前用户。</strong></p>
<p><em><strong>$QUICKLAUNCH</strong></em></p>
<p><strong>在 IE4 活动桌面及以上的快速启动目录。如果快速启动不可用，仅仅返回和 $TEMP 一样。</strong></p>
<p><img src="/2021/06/27/Qt/3de046a0ebf040b0a3ee6da545cfec04.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/6489312f18f946eea3d2caaa80c22b2b.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/f1840743cea74cb082b2d153751a9a9a.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/ce3e386bc3824ea5bb95a003d703eeea.png" alt="img"></p>
<p>保存脚本，下次就可以不用重新设置一遍了（要注意的是，脚本里使用的是<a href="https://so.csdn.net/so/search?q=%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84&spm=1001.2101.3001.7020">相对路径</a>）。</p>
<p><img src="/2021/06/27/Qt/417721c15188460fbc93f08e17faf952.png" alt="img"></p>
<p><img src="/2021/06/27/Qt/6b2727ec27654ddf94b15f2974a41a71.png" alt="img"></p>
<p>如果报错，下面有提示信息，看看什么没有设置。设置好后，下面就会出现这个安装向导程序：</p>
<p><img src="/2021/06/27/Qt/f02ab95f065e4653a6b99bc824f9de23.png" alt="img"></p>
<p>安装完成后，桌面有快捷图标。双击，看是否出现界面。<br>安装目录中，有个uninst.exe卸载程序</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Script generated by the HM NIS Edit Script Wizard.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====================== 自定义宏 ==============================</span></span><br><span class="line"><span class="comment">; HM NIS Edit Wizard helper defines</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_NAME <span class="string">&quot;OceanWindPlatform&quot;</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_VERSION <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_PUBLISHER <span class="string">&quot;My company, Inc.&quot;</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_WEB_SITE <span class="string">&quot;http://www.mycompany.com&quot;</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_DIR_REGKEY <span class="string">&quot;Software\Microsoft\Windows\CurrentVersion\App Paths\OceanWindPlatform.exe&quot;</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_UNINST_KEY <span class="string">&quot;Software\Microsoft\Windows\CurrentVersion\Uninstall\<span class="variable">$&#123;PRODUCT_NAME&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">!define</span> PRODUCT_UNINST_ROOT_KEY <span class="string">&quot;HKLM&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===================== 外部插件以及宏 =============================</span></span><br><span class="line"><span class="comment">; MUI 1.67 compatible ------</span></span><br><span class="line"><span class="keyword">!include</span> <span class="string">&quot;MUI.nsh&quot;</span></span><br><span class="line"><span class="keyword">!include</span> LogicLib.nsh</span><br><span class="line"><span class="keyword">!include</span> Integration.nsh</span><br><span class="line"><span class="keyword">!include</span> FileFunc.nsh <span class="comment">#刷新桌面图标缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== MUI属性 =================================</span></span><br><span class="line"><span class="comment">; MUI Settings</span></span><br><span class="line"><span class="keyword">!define</span> MUI_ABORTWARNING</span><br><span class="line"><span class="keyword">!define</span> MUI_ICON <span class="string">&quot;logo.ico&quot;</span></span><br><span class="line"><span class="keyword">!define</span> MUI_UNICON <span class="string">&quot;<span class="variable">$&#123;NSISDIR&#125;</span>\Contrib\Graphics\Icons\modern-uninstall.ico&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Language Selection Dialog Settings</span></span><br><span class="line"><span class="keyword">!define</span> MUI_LANGDLL_REGISTRY_ROOT <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">!define</span> MUI_LANGDLL_REGISTRY_KEY <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">!define</span> MUI_LANGDLL_REGISTRY_VALUENAME <span class="string">&quot;NSIS:Language&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Welcome page</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_WELCOME</span><br><span class="line"><span class="comment">; License page</span></span><br><span class="line"><span class="keyword">!define</span> MUI_LICENSEPAGE_RADIOBUTTONS</span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_LICENSE <span class="string">&quot;license.txt&quot;</span></span><br><span class="line"><span class="comment">; Components page</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_COMPONENTS</span><br><span class="line"><span class="comment">; Directory page</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_DIRECTORY</span><br><span class="line"><span class="comment">; Instfiles page</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_INSTFILES</span><br><span class="line"><span class="comment">; Finish page</span></span><br><span class="line"><span class="keyword">!define</span> MUI_FINISHPAGE_RUN <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$&#123;PRODUCT_NAME&#125;</span>.exe&quot;</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_PAGE_FINISH</span><br><span class="line"></span><br><span class="line"><span class="comment">; Uninstaller pages</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_UNPAGE_INSTFILES</span><br><span class="line"></span><br><span class="line"><span class="comment">; Language files</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_LANGUAGE <span class="string">&quot;English&quot;</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_LANGUAGE <span class="string">&quot;SimpChinese&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; MUI end ------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==================== NSIS属性 ================================</span></span><br><span class="line"><span class="keyword">Name</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_NAME&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">OutFile</span> <span class="string">&quot;install.exe&quot;</span></span><br><span class="line"><span class="keyword">InstallDir</span> <span class="string">&quot;<span class="variable">$PROGRAMFILES</span>\<span class="variable">$(^Name)</span>&quot;</span></span><br><span class="line"><span class="keyword">InstallDirRegKey</span> <span class="params">HKLM</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_DIR_REGKEY&#125;</span>&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">ShowInstDetails</span> <span class="literal">show</span></span><br><span class="line">ShowUnInstDetails <span class="literal">show</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宏定义，参考5.4.11 !macro</span></span><br><span class="line"><span class="keyword">!macro</span> EnsureAdminRights</span><br><span class="line">  <span class="comment">#从堆栈里弹出一个字串到用户变量 $x。如果堆栈是空的，则会置一个错误标记。</span></span><br><span class="line">  <span class="comment">#下面是把UserInfo::GetAccountType 给了$0</span></span><br><span class="line">  <span class="class">UserInfo::GetAccountType</span></span><br><span class="line">  <span class="keyword">Pop</span> <span class="variable">$0</span></span><br><span class="line">  <span class="comment">#E.4 逻辑函数库</span></span><br><span class="line">  <span class="variable">$&#123;If&#125;</span> <span class="variable">$0</span> != <span class="string">&quot;admin&quot;</span> <span class="comment">; Require admin rights on WinNT4+</span></span><br><span class="line">    <span class="comment">#参考4.9.4.15 MessageBox</span></span><br><span class="line">    <span class="keyword">MessageBox</span> MB_IconStop <span class="string">&quot;Administrator rights required!&quot;</span></span><br><span class="line">    <span class="keyword">SetErrorLevel</span> <span class="number">740</span> <span class="comment">; ERROR_ELEVATION_REQUIRED</span></span><br><span class="line">    <span class="keyword">Quit</span></span><br><span class="line">  <span class="variable">$&#123;EndIf&#125;</span></span><br><span class="line"><span class="keyword">!macro</span>end</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数名以“.”开头的(例如 “.Whatever”)一般作为回调函数保留。</span></span><br><span class="line"><span class="comment">#参考4.7.2.1.2 .onInit</span></span><br><span class="line"><span class="function"><span class="keyword">Function</span> .onInit</span></span><br><span class="line">  <span class="keyword">!insertmacro</span> MUI_LANGDLL_DISPLAY</span><br><span class="line">  <span class="keyword">!insertmacro</span> EnsureAdminRights</span><br><span class="line">FunctionEnd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Section</span> &quot;MainSection&quot; SEC01</span></span><br><span class="line">  <span class="comment">#设置输出路径 ($OUTDIR) 且当路径不存在时创建 (需要时会递归创建)。必须为全路径名，通常都使用 $INSTDIR。</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">SetOverwrite</span> <span class="literal">try</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\2023122216.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\20231222161328.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\20231222164301.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\2023122216_Opt.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\2023122217.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\20240114152951.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\2024011509.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\2024011510.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\20240115101900.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\20240117162258.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\20240118161736最短距离Opt.tzr&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\AWTDataDecoder.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\awtz.conf&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\bearer&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\bearer\qgenericbearer.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\blackLand.qss&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\config.iscas&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\crush32.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\currenttime.config&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\D3Dcompiler_47.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\dat\s57data&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\dat\s57data\C1100001.000&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\dat\s57data\C13A7300.000&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\dat\s57data\C1416170.000&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\dat\s57data\C1416310.000&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\decode.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateDirectory</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\OceanWindPlatform&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\OceanWindPlatform\OceanWindPlatform.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\decode.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$DESKTOP</span>\OceanWindPlatform.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\decode.exe&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\doc&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\doc\天智全球海洋区域气象服务系统V1.0-用户手册-20231213.pdf&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\FileTcpClient.exe&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\iconengines&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\iconengines\qsvgicon.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\imageformats&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qgif.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qicns.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qico.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qjpeg.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qsvg.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qtga.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qtiff.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qwbmp.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\imageformats\qwebp.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\libEGL.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\libGLESV2.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\LibMComp.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\libzstd.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\logo.ico&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\mapConfig.conf&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\OceanWindPlatform.exe&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\opengl32sw.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\pdf.txt&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\platforms&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\platforms\qwindows.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\printsupport&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\printsupport\windowsprintersupport.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\printsupport\windowsprintersupportd.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\fitz&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\fitz\_fitz.cp310-win_amd64.pyd&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\python310.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\readpdf.exe&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\select.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\ucrtbase.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\unicodedata.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\VCRUNTIME140.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\zlib.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\_bz2.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\_decimal.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\_hashlib.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\_lzma.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\_socket.pyd&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\readpdf\_ssl.pyd&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\resource.rcc&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57Attributes&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57Colours&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57ComplexLineStyles&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57LookupTable&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57ObjectClasses&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57Patterns&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\S57Lib\S57Symbols&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\sqldrivers&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\sqldrivers\qsqlite.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\sqldrivers\qsqlmysql.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\sqldrivers\qsqlodbc.dll&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\sqldrivers\qsqlpsql.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\stationConfig.iscas&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\styles&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\styles\qwindowsvistastyle.dll&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\test.qss&quot;</span></span><br><span class="line">  <span class="keyword">SetOutPath</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\TZ-ImmedReq.xml&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\TzStart.exe&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\uninstallscript.qs&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\update.txt&quot;</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">&quot;F:\MyC-Example\install\Installer-nsis\OceanWindPlatform\user-route.iscas&quot;</span></span><br><span class="line">SectionEnd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Section</span> &quot;third&quot; SEC02</span></span><br><span class="line">  <span class="keyword">ExecWait</span>  <span class="string">&quot;third\RuntimePack x86 x64 17.3.14.exe&quot;</span></span><br><span class="line">SectionEnd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Section</span> -AdditionalIcons</span></span><br><span class="line">  WriteIniStr <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$&#123;PRODUCT_NAME&#125;</span>.url&quot;</span> <span class="string">&quot;InternetShortcut&quot;</span> <span class="string">&quot;URL&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_WEB_SITE&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\<span class="variable">$(^Name)</span>\Website.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$&#123;PRODUCT_NAME&#125;</span>.url&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\<span class="variable">$(^Name)</span>\Uninstall.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\uninst.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\<span class="variable">$(^Name)</span>\<span class="variable">$(^Name)</span>.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$DESKTOP</span>\<span class="variable">$(^Name)</span>.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$STARTMENU</span>\<span class="variable">$(^Name)</span>.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$QUICKLAUNCH</span>\<span class="variable">$(^Name)</span>.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">  <span class="keyword">CreateShortCut</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\<span class="variable">$(^Name)</span>.lnk&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">SectionEnd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Section</span> -Post</span></span><br><span class="line">  <span class="comment">#由指定的文件名(路径为可选项)写入卸载程序。</span></span><br><span class="line">  <span class="keyword">WriteUninstaller</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\uninst.exe&quot;</span></span><br><span class="line">  <span class="comment">#在 HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall 下创建一个以你的产品名为名的项，就可以向控制面板中的添加/删除程序添加一个条目。</span></span><br><span class="line">  <span class="comment">#参考D.2与4.9.2.17 WriteRegExpandStr</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKLM</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_DIR_REGKEY&#125;</span>&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span> <span class="string">&quot;DisplayName&quot;</span> <span class="string">&quot;<span class="variable">$(^Name)</span>&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span> <span class="string">&quot;UninstallString&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\uninst.exe&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span> <span class="string">&quot;DisplayIcon&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$(^Name)</span>.exe&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span> <span class="string">&quot;DisplayVersion&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_VERSION&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span> <span class="string">&quot;URLInfoAbout&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_WEB_SITE&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span> <span class="string">&quot;Publisher&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_PUBLISHER&#125;</span>&quot;</span></span><br><span class="line">SectionEnd</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件后缀与应用程序关联,不在安装界面中体现出来</span></span><br><span class="line"><span class="function"><span class="keyword">Section</span> -IconExe</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKCR</span> <span class="string">&quot;.TZP&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;TZP.File&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKCR</span> <span class="string">&quot;TZP.File&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;天智全球海洋区域气象服务系统文件&quot;</span>                       <span class="comment">; 文件类型名称</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKCR</span> <span class="string">&quot;TZP.File\DefaultIcon&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\logo.ico&quot;</span>       <span class="comment">; 图标</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKCR</span> <span class="string">&quot;TZP.File\shell&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKCR</span> <span class="string">&quot;TZP.File\shell\open&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">WriteRegStr</span> <span class="params">HKCR</span> <span class="string">&quot;TZP.File\shell\open\command&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&#x27;&quot;<span class="variable">$InstDir</span>\<span class="variable">$(^Name)</span>.exe&quot; &quot;%1&quot;&#x27;</span> <span class="comment">; 运行时指令，单引号里的内容同前面FTYPE指令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#刷新桌面图标缓存</span></span><br><span class="line">  <span class="variable">$&#123;RefreshShellIcons&#125;</span></span><br><span class="line">  </span><br><span class="line">SectionEnd</span><br><span class="line"></span><br><span class="line"><span class="comment">; Section descriptions</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_FUNCTION_DESCRIPTION_BEGIN</span><br><span class="line">  <span class="keyword">!insertmacro</span> MUI_DESCRIPTION_TEXT <span class="variable">$&#123;SEC01&#125;</span> <span class="string">&quot;主程序&quot;</span></span><br><span class="line">  <span class="keyword">!insertmacro</span> MUI_DESCRIPTION_TEXT <span class="variable">$&#123;SEC02&#125;</span> <span class="string">&quot;库文件&quot;</span></span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_FUNCTION_DESCRIPTION_END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Function</span> un.onUninstSuccess</span></span><br><span class="line">  <span class="keyword">HideWindow</span></span><br><span class="line">  <span class="keyword">MessageBox</span> <span class="params">MB_ICONINFORMATION</span>|<span class="params">MB_OK</span> <span class="string">&quot;<span class="variable">$(^Name)</span> 已成功地从你的计算机移除。&quot;</span></span><br><span class="line">FunctionEnd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Function</span> un.onInit</span></span><br><span class="line"><span class="keyword">!insertmacro</span> EnsureAdminRights</span><br><span class="line"><span class="keyword">!insertmacro</span> MUI_UNGETLANGUAGE</span><br><span class="line"> <span class="comment">#相对跳转由数字标定。+1 跳转到下一条指令 (默认的步进)，+2 会跳过一条指令也并且从当前指令转到第二条指令，-2 将往后跳两条指令，+10 将会跳过 9 条指令，从当前指令跳到第十条指令。</span></span><br><span class="line">  <span class="comment">#参考4.4 相对跳转</span></span><br><span class="line">  <span class="comment">#错误时跳转的标记 [没有错误时跳转的标记]（有错误就执行下面的MessageBox,没有错误就跳3行向下执行）</span></span><br><span class="line">  <span class="keyword">MessageBox</span> <span class="params">MB_ICONQUESTION</span>|<span class="params">MB_YESNO</span>|<span class="params">MB_DEFBUTTON2</span> <span class="string">&quot;你确实要完全移除 <span class="variable">$(^Name)</span> ，其及所有的组件？&quot;</span> <span class="params">IDYES</span> +<span class="number">2</span></span><br><span class="line">  <span class="keyword">Abort</span></span><br><span class="line">FunctionEnd</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果区段名为空、遗漏或者以一个 - 开头，那么它将是一个隐藏的区段，用户也不能选择禁止它。如果一个区段名为“Uninstall”或以“un.”为前缀，那么它就是一个卸载程序区段。</span></span><br><span class="line"><span class="comment">#参考4.6.1.2 Section</span></span><br><span class="line"><span class="function"><span class="keyword">Section</span> Uninstall</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\<span class="variable">$&#123;PRODUCT_NAME&#125;</span>.url&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\uninst.exe&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\user-route.iscas&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\update.txt&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\uninstallscript.qs&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\TzStart.exe&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\TZ-ImmedReq.xml&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\test.qss&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\styles\qwindowsvistastyle.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\stationConfig.iscas&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\sqldrivers\qsqlpsql.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\sqldrivers\qsqlodbc.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\sqldrivers\qsqlmysql.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\sqldrivers\qsqlite.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57Symbols&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57Patterns&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57ObjectClasses&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57LookupTable&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57ComplexLineStyles&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57Colours&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib\S57Attributes&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\resource.rcc&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\_ssl.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\_socket.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\_lzma.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\_hashlib.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\_decimal.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\_bz2.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\zlib.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\VCRUNTIME140.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\unicodedata.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\ucrtbase.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\select.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\readpdf.exe&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\python310.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\fitz\_fitz.cp310-win_amd64.pyd&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\base_library.zip&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\qwt.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Xml.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Widgets.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Svg.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Sql.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5PrintSupport.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5OpenGL.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Network.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Gui.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Core.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\Qt5Charts.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\qrc_resource.tmp.obj&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\qrc_resource.obj&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\qrc_resource.cpp&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\pthreadVC2.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\ProhebitedArea.phb&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\printsupport\windowsprintersupportd.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\printsupport\windowsprintersupport.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\platforms\qwindows.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\pdf.txt&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\opengl32sw.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\OceanWindPlatform.exe&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\mapConfig.conf&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\logo.ico&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\FileTcpClient.exe&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\doc\天智全球海洋区域气象服务系统V1.0-用户手册-20231213.pdf&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\decode.exe&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\D3Dcompiler_47.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\currenttime.config&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\crush32.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\config.iscas&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\blackLand.qss&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\bearer\qgenericbearer.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\awtz.conf&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\AWTDataDecoder.dll&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\20240118161736最短距离Opt.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\20240117162258.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\20240115101900.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\2024011510.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\2024011509.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\20240114152951.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\2023122217.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\2023122216_Opt.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\20231222164301.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\20231222161328.tzr&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\2023122216.tzr&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\OceanWindPlatform\Uninstall.lnk&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\OceanWindPlatform\Website.lnk&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$DESKTOP</span>\OceanWindPlatform.lnk&quot;</span></span><br><span class="line">  <span class="keyword">Delete</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\OceanWindPlatform\OceanWindPlatform.lnk&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$SMPROGRAMS</span>\OceanWindPlatform&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\translations&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\styles&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\sqldrivers&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\saveImg&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\S57Lib&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf\fitz&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\readpdf&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\printsupport&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\platforms&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\imageformats&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\iconengines&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\doc&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\dat&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\bearer&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>&quot;</span></span><br><span class="line">  <span class="keyword">RMDir</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">DeleteRegKey</span> <span class="variable">$&#123;PRODUCT_UNINST_ROOT_KEY&#125;</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_UNINST_KEY&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">DeleteRegKey</span> <span class="params">HKLM</span> <span class="string">&quot;<span class="variable">$&#123;PRODUCT_DIR_REGKEY&#125;</span>&quot;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#解除文件后缀与应用程序关联</span></span><br><span class="line">  <span class="keyword">DeleteRegKey</span> <span class="params">HKCR</span> <span class="string">&quot;.TZP&quot;</span></span><br><span class="line">  <span class="comment">#刷新桌面图标缓存</span></span><br><span class="line">  <span class="variable">$&#123;RefreshShellIcons&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">SetAutoClose</span> <span class="literal">true</span></span><br><span class="line">SectionEnd</span><br></pre></td></tr></table></figure>

<h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p>对于制作好的安装包，有些时候可能需要在安装完成界面上添加一个可勾选的开机自启动的选项。</p>
<p>下面是具体的细节：</p>
<p>1.在安装完成界面设置添加如下代码：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="keyword">!define</span> MUI_FINISHPAGE_SHOWREADME</span><br><span class="line"><span class="keyword">!define</span> MUI_FINISHPAGE_SHOWREADME_Function AutoBoot</span><br><span class="line"><span class="keyword">!define</span> MUI_FINISHPAGE_SHOWREADME_TEXT <span class="string">&quot;开机自启动&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码务必要添加在 “ !insertmacro MUI_PAGE_FINISH “之前。</p>
<p><img src="/2021/06/27/Qt/c4614f0b67ee4bbd9e5517fda4cbaba5.png" alt="img"></p>
<p>2.在Section后区段的后面添加Function部分（在Section之后，是为了避免产生未知的错误）</p>
<p>代码如下：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span> AutoBoot</span></span><br><span class="line">    <span class="keyword">WriteRegStr</span> <span class="params">HKCU</span> <span class="string">&quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;</span> <span class="string">&quot;testKey&quot;</span> <span class="string">&quot;test.exe&quot;</span></span><br><span class="line">FunctionEnd</span><br></pre></td></tr></table></figure>

<p>把上面的test替换成你要打包程序名就行了，主要是把信息写入系统注册表。</p>
<p>3.前两步已经可以实现开机自启动了。这最后一步，需要在卸载和初始化区段里面把注册表信息删除。原因是让用户在卸载程序和覆盖安装程序后，不会受到刚开始安装程序的写入系统注册表的影响。</p>
<p>在Section Uninstall里面添加如下代码：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="comment">;删除开机自启</span></span><br><span class="line"><span class="keyword">DeleteRegValue</span> <span class="params">HKCU</span> <span class="string">&quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;</span> <span class="string">&quot;testKey&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/a650e7c64615416b85869109cc5b4506.png" alt="img"></p>
<p>最后编译运行，就会发现在程序的安装完成界面出现了可勾选的开机自启动选项。</p>
<h3 id="注册启动项"><a href="#注册启动项" class="headerlink" title="注册启动项"></a>注册启动项</h3><ul>
<li><p>WriteRegStr</p>
<p>root_key + subkey + key_name + value</p>
</li>
<li><p>以Test.exe为例, 注册启动项命令如下</p>
<p>WriteRegStr HKCU “Software\Microsoft\Windows\CurrentVersion\Run” “TestAddKey” “$INSTDIR\Test.exe”</p>
</li>
<li><p>#该命令放在安装区域(Section “MainSection” SEC01), 或者注册区域(Section -Post)都可以</p>
</li>
</ul>
<p>命令解释:</p>
<p>root_key: 注册表根键值: HKCU (HKEY_CURRENT_USER)<br>subkey: 子键值: Run键(解释见前言)<br>key_name: 新增键值名称: TestAddKey<br>value: 启动命令: “Test.exe绝对路径”, 如有命令行参数可以在路径后添加</p>
<h3 id="删除启动项"><a href="#删除启动项" class="headerlink" title="删除启动项"></a>删除启动项</h3><ul>
<li><p>DeleteRegValue</p>
<p>root_key + subkey + key_name</p>
</li>
<li><p>以Test.exe为例, 删除启动项命令如下</p>
<p>DeleteRegValue HKCU “Software\Microsoft\Windows\CurrentVersion\Run” “TestAddKey”</p>
</li>
<li><p>#该命令放在卸载命令区域(Section Uninstall)</p>
</li>
</ul>
<p>命令解释:</p>
<p>root_key: 注册表根键: HKCU (HKEY_CURRENT_USER)<br>subkey: 子键位置: Run键(解释见前言)<br>key_name: 要删除的Key名称: TestAddKey</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>打开注册表: WIN + R 输入: regedit</p>
<p><img src="/2021/06/27/Qt/3df60040bd574a51a70a79c368020ad8.png" alt="img"></p>
<p>在HKCU下依次展开找到Run键<br>观察Run键下子键是否新增/删除, 键值是否正确</p>
<h2 id="解决程序安装后要右键管理员权限运行问题"><a href="#解决程序安装后要右键管理员权限运行问题" class="headerlink" title="解决程序安装后要右键管理员权限运行问题"></a>解决程序安装后要右键管理员权限运行问题</h2><p>如下图，加入一下几行代码</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="comment">;让安装程序以管理权限运行</span></span><br><span class="line"><span class="keyword">RequestExecutionLevel</span> <span class="literal">admin</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">Section</span> &quot;test&quot;</span></span><br><span class="line"> 	<span class="comment">;针对当前用户有效</span></span><br><span class="line">	<span class="keyword">WriteRegStr</span> <span class="params">HKCU</span> <span class="string">&quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\xxxx.exe&quot;</span> <span class="string">&quot;RUNASADMIN&quot;</span></span><br><span class="line">	<span class="comment">;针对所有用户有效</span></span><br><span class="line">	<span class="keyword">WriteRegStr</span> <span class="params">HKEY_LOCAL_MACHINE</span> <span class="string">&quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers&quot;</span> <span class="string">&quot;<span class="variable">$INSTDIR</span>\xxxx.exe&quot;</span> <span class="string">&quot;RUNASADMIN&quot;</span></span><br><span class="line">SectionEnd</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Qt/36f98d15ab8847e3ab3a33c4d82875a0.png" alt="img"></p>
<p>注意：程序安装时需要使用管理员权限进行安装，才能往注册写入信息</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>qss</tag>
      </tags>
  </entry>
  <entry>
    <title>函数积累</title>
    <url>/2021/06/27/%E5%87%BD%E6%95%B0%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit()"></a>isdigit()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[]=<span class="string">&quot;1776ad&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[<span class="number">0</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    year = <span class="built_in">atoi</span> (str);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;The year that followed %d was %d.\n&quot;</span>, year, year+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string-copy"><a href="#string-copy" class="headerlink" title="string.copy()"></a>string.copy()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str=<span class="string">&quot;1733.9270,N&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> szField[<span class="number">256</span>];</span><br><span class="line">str.<span class="built_in">copy</span>(szField,<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//size_t copy (char* s, size_t len, size_t pos = 0) const;</span></span><br><span class="line"><span class="comment">//s 目的地址</span></span><br><span class="line"><span class="comment">//    Pointer to an array of characters.</span></span><br><span class="line"><span class="comment">//    The array shall contain enough storage for the copied characters.</span></span><br><span class="line"><span class="comment">//len 复制长度</span></span><br><span class="line"><span class="comment">//    Number of characters to copy (if the string is shorter, as many characters as possible are copied).</span></span><br><span class="line"><span class="comment">// pos 起始索引</span></span><br><span class="line"><span class="comment">//    Position of the first character to be copied.</span></span><br><span class="line"><span class="comment">//    If this is greater than the string length, it throws out_of_range.</span></span><br><span class="line"><span class="comment">//    Note: The first character in the string is denoted by a value of 0 (not 1).</span></span><br></pre></td></tr></table></figure>



<h2 id="Round-floor-ceil"><a href="#Round-floor-ceil" class="headerlink" title="Round(),floor(),ceil()"></a>Round(),floor(),ceil()</h2><p>​                                                          2.1       2.6       -2.1       -2.6<br>floor : 不大于自变量的最大整数       2        2         -3         -3<br>ceil  :不小于自变量的最大整数          3        3         -2         -2<br>round:四舍五入到最邻近的整数       2        3         -2         -3</p>
<p><strong>round(num,num_dight) 把num精确到num_dight位数</strong></p>
<p>floor(),ceil() 需包含头文件&lt;math.h&gt;</p>
<p>C++中没有直接的round函数 需自己建立</p>
<p>double round(double r)<br>{<br>  return (r &gt; 0.0) ? floor(r + 0.5) : ceil(r - 0.5);<br>}</p>
<h2 id="获取毫秒时间"><a href="#获取毫秒时间" class="headerlink" title="获取毫秒时间"></a>获取毫秒时间</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">    函数名:    	</span></span><br><span class="line"><span class="comment">    gettimeofday</span></span><br><span class="line"><span class="comment">    函数描述:	获取毫秒时间</span></span><br><span class="line"><span class="comment">    输入参数:</span></span><br><span class="line"><span class="comment">    输出参数:</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">    ***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tp, <span class="keyword">void</span> *tzp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> clock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line">    SYSTEMTIME wtm;</span><br><span class="line">    <span class="built_in">GetLocalTime</span>(&amp;wtm);</span><br><span class="line">    tm.tm_year = wtm.wYear - <span class="number">1900</span>;</span><br><span class="line">    tm.tm_mon = wtm.wMonth - <span class="number">1</span>;</span><br><span class="line">    tm.tm_mday = wtm.wDay;</span><br><span class="line">    tm.tm_hour = wtm.wHour;</span><br><span class="line">    tm.tm_min = wtm.wMinute;</span><br><span class="line">    tm.tm_sec = wtm.wSecond;</span><br><span class="line">    tm.tm_isdst = <span class="number">-1</span>;</span><br><span class="line">    clock = <span class="built_in">mktime</span>(&amp;tm);</span><br><span class="line">    tp-&gt;tv_sec = clock;</span><br><span class="line">    tp-&gt;tv_usec = wtm.wMilliseconds * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br></pre></td></tr></table></figure>

<h2 id="查找注册表是否安装某个程序"><a href="#查找注册表是否安装某个程序" class="headerlink" title="查找注册表是否安装某个程序"></a>查找注册表是否安装某个程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/xiaopei_yan/article/details/90268008</span></span><br><span class="line"><span class="function">QString <span class="title">HasIntStall</span><span class="params">(QString softName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString header = <span class="string">&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QSettings <span class="title">reg</span><span class="params">(header,QSettings::NativeFormat)</span></span>;</span><br><span class="line">    QStringList sum = reg.<span class="built_in">allKeys</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m  = <span class="number">0</span> ; m &lt; sum.<span class="built_in">size</span>();++m)&#123;</span><br><span class="line">        QString id = sum.<span class="built_in">at</span>(m);</span><br><span class="line">        QStringList strList=id.<span class="built_in">split</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="function">QSettings <span class="title">gt</span><span class="params">(header + strList[<span class="number">0</span>],QSettings::NativeFormat)</span></span>;</span><br><span class="line">        QString name = gt.<span class="built_in">value</span>(<span class="string">&quot;DisplayName&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(name.<span class="built_in">contains</span>(softName))</span><br><span class="line">        &#123;</span><br><span class="line">            QString tempStr=gt.<span class="built_in">value</span>(<span class="string">&quot;InstallLocation&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"><span class="comment">//            QString filePath=tempStr.replace(&quot;\\&quot;,&quot;/&quot;)+&quot;bin/&quot;+m_strCurExecFileName;</span></span><br><span class="line">            <span class="keyword">return</span> tempStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QString</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进制转换-bitset"><a href="#进制转换-bitset" class="headerlink" title="进制转换  || bitset"></a>进制转换  || bitset</h2><p>个人理解，无论什么进制，在程序中显示的都是十进制的数字，所以在写入或者发送的时候，转成16进制，看起来也是显示的10进制。因为计算机中存储的都是二进制，各种数据类型如int short 都是十进制，压根没有16进制，况且显示的时候，数字咋显示abcd，只能用字符显示，所以这也是为啥16进制要用字符串来存储了。所以无论怎样只要数字显示的是对的就行。</p>
<p>所谓的以16进制发送，不过就是我们给缓存看起来是16进制的数，实际上发送的时候如果发送数字，发送的就是10进制的数；如果是字符串，那可以发送16进制的。</p>
<p>都是用二进制存储的，十六进制只是为了给人们看的时候方便一点，毕竟二进制直接写出来太长了。</p>
<p>为什么不用十进制表示呢？因为二进制转十进制需要经过一系列换算，而且长度还不一定（四位数的二进制，写成十进制，有可能是一位数，也有可能是两位数）；而二进制转十六进制，每四位数的二进制都对应一位数的十六进制，直接通过查表就能转换，有经验的人甚至可以直接口算。</p>
<p>所以，计算机内部都是用的二进制，但需要查看源码的时候，用十六进制写出来，不至于写出来太长，反推回去也很方便。</p>
<p>所以，当涉及到源码时，一般都习惯用十六进制表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//转16进制,由QString 开始转换</span><br><span class="line">short zoom = (&quot;0x&quot; + wZoomPos).toUShort(&amp;ok, 16);</span><br></pre></td></tr></table></figure>

<p>简单记忆方法：最终转成的是字符串，那就不是10进制（10进制没法显示字母），如果转成的是基本类型如int等，那就是10进制。</p>
<p>C++库函数，十进制转二进制，<mark class="hl-label res(int">bitset<32></32></mark>  **</p>
<p><img src="/2021/06/27/%E5%87%BD%E6%95%B0%E7%A7%AF%E7%B4%AF/fad97a61-83be-43fa-931a-84490bcefcdf.png" alt="img"></p>
<p>对于一个叫做bit的bitset：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit.size()       返回大小（位数）</span><br><span class="line">bit.count()     返回1的个数</span><br><span class="line">bit.any()       返回是否有1</span><br><span class="line">bit.none()      返回是否没有1</span><br><span class="line">bit.set()       全都变成1</span><br><span class="line">bit.set(p)      将第p + 1位变成1（bitset是从第0位开始的！） </span><br><span class="line">bit.set(p, x)   将第p + 1位变成x</span><br><span class="line">bit.reset()     全都变成0</span><br><span class="line">bit.reset(p)    将第p + 1位变成0</span><br><span class="line">bit.flip()      全都取反</span><br><span class="line">bit.flip(p)     将第p + 1位取反</span><br><span class="line">bit.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错</span><br><span class="line">bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错</span><br><span class="line">bit.to_string() 返回它转换为string的结果</span><br><span class="line">bit.test()      返回是否为1</span><br></pre></td></tr></table></figure>



<h2 id="SetTimer定时器"><a href="#SetTimer定时器" class="headerlink" title="SetTimer定时器"></a>SetTimer定时器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int timerID=SetTimer(NULL, 111, 125, OnTimer);</span><br><span class="line"></span><br><span class="line">void CALLBACK OnTimer(HWND hwnd,         // handle to window</span><br><span class="line">	UINT uMsg,         // WM_TIMER message</span><br><span class="line">	UINT_PTR idEvent,  // timer identifier</span><br><span class="line">	DWORD dwTime       // current system time</span><br><span class="line">	)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KillTimer(NULL, timerID);</span><br></pre></td></tr></table></figure>

<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">splitWithStl</span><span class="params">(<span class="keyword">const</span> std::string &amp;str,<span class="keyword">const</span> std::string &amp;pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; resVec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span> == str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> resVec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方便截取最后一段数据</span></span><br><span class="line">    std::string strs = str + pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    <span class="keyword">size_t</span> size = strs.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string x = strs.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">        resVec.<span class="built_in">push_back</span>(x);</span><br><span class="line">        strs = strs.<span class="built_in">substr</span>(pos+<span class="number">1</span>,size);</span><br><span class="line">        pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SetTimer定时器-1"><a href="#SetTimer定时器-1" class="headerlink" title="SetTimer定时器"></a>SetTimer定时器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> timerID=<span class="built_in">SetTimer</span>(<span class="literal">NULL</span>, <span class="number">111</span>, <span class="number">125</span>, OnTimer);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">OnTimer</span><span class="params">(HWND hwnd,         <span class="comment">// handle to window</span></span></span></span><br><span class="line"><span class="params"><span class="function">	UINT uMsg,         <span class="comment">// WM_TIMER message</span></span></span></span><br><span class="line"><span class="params"><span class="function">	UINT_PTR idEvent,  <span class="comment">// timer identifier</span></span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwTime       <span class="comment">// current system time</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">KillTimer</span>(<span class="literal">NULL</span>, timerID);</span><br></pre></td></tr></table></figure>

<h2 id="弧度角度转换"><a href="#弧度角度转换" class="headerlink" title="弧度角度转换"></a>弧度角度转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getRad</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d * PI / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三角函数与反三角函数"><a href="#三角函数与反三角函数" class="headerlink" title="三角函数与反三角函数"></a>三角函数与反三角函数</h3><p>角度 / 180 * π = 弧度。</p>
<p>弧度* 180 / π = 角度 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtMath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是弧度，结果是比例值</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;cos(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">cos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qCos(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qCos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;sin(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">sin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qSin(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qSin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tan(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">tan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qTan(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qTan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是比例值，结果是弧度，需要转成角度</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;acos(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">acos</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAcos(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">qAcos</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;asin(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">asin</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAsin(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">qAsin</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;atan(1)=&quot;</span>&lt;&lt;<span class="built_in">atan</span>(<span class="number">1</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAtan(1)=&quot;</span>&lt;&lt;<span class="built_in">qAtan</span>(<span class="number">1</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">qCos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">qSin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">1</span></span><br><span class="line"><span class="built_in">qTan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">1</span></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAcos</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAsin</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAtan</span>(<span class="number">1</span>)= <span class="number">45</span></span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1><h2 id="极坐标转直角坐标"><a href="#极坐标转直角坐标" class="headerlink" title="极坐标转直角坐标"></a>极坐标转直角坐标</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qmath.h&gt;</span></span></span><br><span class="line"><span class="comment">//没有下面这句，所有的通讯函数都将报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//必须链接这个库</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">polarToXY</span><span class="params">(<span class="keyword">double</span> angle, <span class="keyword">double</span> r, <span class="keyword">double</span> &amp;x, <span class="keyword">double</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//x = r*cos(getRad(angle));</span></span><br><span class="line">    <span class="comment">//y = r*sin(getRad(angle));</span></span><br><span class="line">    x = r*<span class="built_in">sin</span>(<span class="built_in">getRad</span>(angle));</span><br><span class="line">    y = r*<span class="built_in">cos</span>(<span class="built_in">getRad</span>(angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="经纬度计算距离"><a href="#经纬度计算距离" class="headerlink" title="经纬度计算距离"></a>经纬度计算距离</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qmath.h&gt;</span></span></span><br><span class="line"><span class="comment">//没有下面这句，所有的通讯函数都将报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//必须链接这个库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EARTH_RADIUS 6371.393        <span class="comment">//地球近似半径</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">double</span> lon1, <span class="keyword">double</span> lat1, <span class="keyword">double</span> lon2, <span class="keyword">double</span> lat2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radLat1 = lat1 * PI / <span class="number">180.0</span>;   <span class="comment">//角度1? = π / 180</span></span><br><span class="line">    <span class="keyword">double</span> radLat2 = lat2 * PI / <span class="number">180.0</span>;   <span class="comment">//角度1? = π / 180</span></span><br><span class="line">    <span class="keyword">double</span> a = radLat1 - radLat2;<span class="comment">//纬度之差</span></span><br><span class="line">    <span class="keyword">double</span> b = lng1 * PI / <span class="number">180.0</span> - lng2* PI / <span class="number">180.0</span>;  <span class="comment">//经度之差</span></span><br><span class="line">    <span class="keyword">double</span> dst = <span class="number">2</span> * <span class="built_in">asin</span>((<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">sin</span>(a / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">cos</span>(radLat1) * <span class="built_in">cos</span>(radLat2) * <span class="built_in">pow</span>(<span class="built_in">sin</span>(b / <span class="number">2</span>), <span class="number">2</span>))));</span><br><span class="line">    dst = dst * EARTH_RADIUS;</span><br><span class="line">    dst = <span class="built_in">round</span>(dst * <span class="number">10000</span>) / <span class="number">10000</span>;</span><br><span class="line">    dst *= <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经纬度计算角度"><a href="#经纬度计算角度" class="headerlink" title="经纬度计算角度"></a>经纬度计算角度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qmath.h&gt;</span></span></span><br><span class="line"><span class="comment">//没有下面这句，所有的通讯函数都将报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//必须链接这个库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EARTH_RADIUS 6371.393        <span class="comment">//地球近似半径</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAzimuth</span><span class="params">(<span class="keyword">double</span> lat1, <span class="keyword">double</span> lng1, <span class="keyword">double</span> lat2, <span class="keyword">double</span> lng2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dRotateAngle = <span class="built_in">atan2</span>(<span class="built_in">fabs</span>(lng1 - lng2), <span class="built_in">fabs</span>(lat1 - lat2));</span><br><span class="line">    <span class="keyword">if</span> (lng2 &gt;= lng1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lat2 &gt;= lat1) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dRotateAngle = PI - dRotateAngle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lat2 &gt;= lat1) &#123;</span><br><span class="line">            dRotateAngle = <span class="number">2</span> * PI - dRotateAngle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dRotateAngle = PI + dRotateAngle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dRotateAngle = dRotateAngle * <span class="number">180</span> / PI;</span><br><span class="line">    <span class="keyword">return</span> dRotateAngle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="两点计算角度，正北顺时针（0-360）"><a href="#两点计算角度，正北顺时针（0-360）" class="headerlink" title="两点计算角度，正北顺时针（0-360）"></a>两点计算角度，正北顺时针（0-360）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get_angle（当前点，中心点）</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_angle</span><span class="params">(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x = x1 - x2;<span class="comment">//t d</span></span><br><span class="line">	<span class="keyword">double</span> y = y1 - y2;<span class="comment">//z y</span></span><br><span class="line">	<span class="keyword">float</span> angle = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; x &gt;= <span class="number">0</span>) angle = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span>) angle = <span class="number">180</span>;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="number">90</span>;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="number">270</span>;</span><br><span class="line">	<span class="keyword">if</span> (angle == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//反正切的角度等于X轴与通过原点和给定坐标点(x, y)的直线之间的夹角。结果为正表示从X</span></span><br><span class="line">		<span class="comment">//轴逆时针旋转的角度，结果为负表示从X轴顺时针旋转的角度</span></span><br><span class="line">		<span class="keyword">if</span> (y &gt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(y, x) / M_PI * <span class="number">180</span>;</span><br><span class="line">		<span class="keyword">if</span> (y &lt; <span class="number">0</span>) angle = <span class="number">360</span> + <span class="built_in">atan2</span>(y, x) / M_PI * <span class="number">180</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> angle+<span class="number">90</span> &gt;<span class="number">360</span> ? angle + <span class="number">90</span> - <span class="number">360</span>: angle +<span class="number">90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两向量计算夹角"><a href="#两向量计算夹角" class="headerlink" title="两向量计算夹角"></a>两向量计算夹角</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以pt1为基准，原定在左下角！！！！</span></span><br><span class="line"><span class="function">QPointF <span class="title">c</span><span class="params">(<span class="number">-1</span>, <span class="number">0</span>)</span></span>;<span class="comment">//交点</span></span><br><span class="line"><span class="function">QPointF <span class="title">pt1</span><span class="params">(<span class="number">-1</span>, <span class="number">2</span>)</span></span>;<span class="comment">//基准轴某一点</span></span><br><span class="line"><span class="function">QPointF <span class="title">pt2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">//目标点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getAngelOfTwoVector</span><span class="params">(QPointF &amp;pt1, QPointF &amp;pt2, QPointF &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> theta = <span class="built_in">atan2</span>(pt1.<span class="built_in">y</span>() - c.<span class="built_in">y</span>(), pt1.<span class="built_in">x</span>() - c.<span class="built_in">x</span>()) - <span class="built_in">atan2</span>(pt2.<span class="built_in">y</span>() - c.<span class="built_in">y</span>(), pt2.<span class="built_in">x</span>() - c.<span class="built_in">x</span>());</span><br><span class="line">    <span class="keyword">if</span> (theta &gt; M_PI)</span><br><span class="line">        theta -= <span class="number">2</span> * M_PI;</span><br><span class="line">    <span class="keyword">if</span> (theta &lt; -M_PI)</span><br><span class="line">        theta += <span class="number">2</span> * M_PI;</span><br><span class="line"></span><br><span class="line">    theta = theta * <span class="number">180.0</span> / M_PI;</span><br><span class="line">    <span class="keyword">if</span>(theta&lt;<span class="number">0</span>) theta+=<span class="number">360</span>;</span><br><span class="line">    <span class="keyword">return</span> theta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> theta = <span class="built_in">getAngelOfTwoVector</span>(pt1,pt2,c);</span><br><span class="line"><span class="comment">//theta=45</span></span><br></pre></td></tr></table></figure>

<h2 id="获取16进制数，0x16，获取16，而非1"><a href="#获取16进制数，0x16，获取16，而非1" class="headerlink" title="获取16进制数，0x16，获取16，而非1"></a>获取16进制数，0x16，获取16，而非1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换函数,传入0x16的十进制，即1*16^1+6*16^0=22，得到16</span></span><br><span class="line"><span class="function">DWORD <span class="title">HexToDecMa</span><span class="params">(DWORD wHex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (wHex / <span class="number">4096</span>) * <span class="number">1000</span> + ((wHex % <span class="number">4096</span>) / <span class="number">256</span>) * <span class="number">100</span> + ((wHex % <span class="number">256</span>) / <span class="number">16</span>) * <span class="number">10</span> + (wHex % <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt; <span class="built_in">HexToDecMa</span>(<span class="number">22</span>);  <span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<h2 id="异或校验"><a href="#异或校验" class="headerlink" title="异或校验"></a>异或校验</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入16进制的十进制数组就行，16进制</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">MainWindow::BBC</span><span class="params">(QByteArray &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> x;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;value.<span class="built_in">size</span>();i++)</span><br><span class="line">        x^=value[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3字节数组转4字节int"><a href="#3字节数组转4字节int" class="headerlink" title="3字节数组转4字节int"></a>3字节数组转4字节int</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MainWindow::CharToInt</span><span class="params">(<span class="keyword">char</span> temp[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sendID;</span><br><span class="line">    <span class="keyword">char</span> _temp=temp[<span class="number">0</span>];</span><br><span class="line">    temp[<span class="number">0</span>]=temp[<span class="number">2</span>];</span><br><span class="line">    temp[<span class="number">2</span>]=_temp;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sendID,temp,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(sendID&gt;<span class="number">8388608</span>)&#123;</span><br><span class="line">        sendID = sendID<span class="number">-16777216</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="毫秒转时分秒显示"><a href="#毫秒转时分秒显示" class="headerlink" title="毫秒转时分秒显示"></a>毫秒转时分秒显示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">formatTime</span><span class="params">(<span class="keyword">int</span> ms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ss = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = ss * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> hh = mi * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> dd = hh * <span class="number">24</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> day = ms / dd;</span><br><span class="line">    <span class="keyword">long</span> hour = (ms - day * dd) / hh;</span><br><span class="line">    <span class="keyword">long</span> minute = (ms - day * dd - hour * hh) / mi;</span><br><span class="line">    <span class="keyword">long</span> second = (ms - day * dd - hour * hh - minute * mi) / ss;</span><br><span class="line">    <span class="keyword">long</span> milliSecond = ms - day * dd - hour * hh - minute * mi - second * ss;</span><br><span class="line"> </span><br><span class="line">    QString hou = QString::<span class="built_in">number</span>(hour,<span class="number">10</span>);</span><br><span class="line">    QString min = QString::<span class="built_in">number</span>(minute,<span class="number">10</span>);</span><br><span class="line">    QString sec = QString::<span class="built_in">number</span>(second,<span class="number">10</span>);</span><br><span class="line">    QString msec = QString::<span class="built_in">number</span>(milliSecond,<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//qDebug() &lt;&lt; &quot;minute:&quot; &lt;&lt; min &lt;&lt; &quot;second&quot; &lt;&lt; sec &lt;&lt; &quot;ms&quot; &lt;&lt; msec &lt;&lt;endl;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> hou + <span class="string">&quot;:&quot;</span> + min + <span class="string">&quot;:&quot;</span> + sec ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><h3 id="发送1"><a href="#发送1" class="headerlink" title="发送1"></a>发送1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>         INT8, *PINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span>        INT16, *PINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">int</span>          INT32, *PINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> __int64      INT64, *PINT64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>       UINT8, *PUINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>      UINT16, *PUINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        UINT32, *PUINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int64    UINT64, *PUINT64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>               FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//海事传输数据头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeaCommunication</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT32 PacketHead=<span class="number">0x66666666</span>;<span class="comment">//帧头</span></span><br><span class="line">    UINT32 PayloadSize;<span class="comment">//消息长度</span></span><br><span class="line">    UINT16 ChunkNum;<span class="comment">//总块数</span></span><br><span class="line">    UINT16 ChunkID;<span class="comment">//当前块序号</span></span><br><span class="line">    UINT32 DataTime;<span class="comment">//数据产生时间</span></span><br><span class="line">    FLOAT Longitude;<span class="comment">//数据产生经度</span></span><br><span class="line">    FLOAT Latitude;<span class="comment">//数据产生纬度</span></span><br><span class="line">    UINT16 SystemID;<span class="comment">//数据源平台系统</span></span><br><span class="line">    UINT16 DataType;<span class="comment">//数据类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">BBC</span><span class="params">(QByteArray &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> x;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;value.<span class="built_in">size</span>();i++)</span><br><span class="line">        x^=value[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">QUdpSocket* m_sender;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DecodePackets</span><span class="params">(QByteArray value,UINT16 systemID,UINT16 DataType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SeaCommunication _communication;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data_len=value.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> packet_size = <span class="number">1400</span>;</span><br><span class="line">    <span class="keyword">int</span> packet_num = data_len / packet_size;<span class="comment">//不算最后1包的包数</span></span><br><span class="line">    <span class="keyword">int</span> final_packet_size = data_len%packet_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packet_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _communication.PacketHead = <span class="number">0x66666666</span>;<span class="comment">//UINT32 帧头</span></span><br><span class="line">        _communication.PayloadSize = packet_size + <span class="number">28</span> + <span class="number">1</span>;<span class="comment">//UINT32 消息长度,28是头长度，1是bbc校验码</span></span><br><span class="line">        _communication.ChunkNum = packet_num + <span class="number">1</span>;<span class="comment">//UINT16 总块数</span></span><br><span class="line">        _communication.ChunkID = i;<span class="comment">//UINT16 当前块序号</span></span><br><span class="line">        _communication.DataTime = QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toTime_t</span>();<span class="comment">//UINT32 数据产生时间</span></span><br><span class="line">        _communication.Latitude =<span class="number">0.</span>;<span class="comment">//FLOAT 数据产生经度</span></span><br><span class="line">        _communication.Longitude =<span class="number">0.</span>;<span class="comment">//FLOAT 数据产生纬度</span></span><br><span class="line">        _communication.SystemID = systemID;<span class="comment">//UINT16 数据源平台系统</span></span><br><span class="line">        _communication.DataType=DataType;<span class="comment">//UINT16 数据类型</span></span><br><span class="line"></span><br><span class="line">        QByteArray Data =value.<span class="built_in">mid</span>(i*packet_size,packet_size);<span class="comment">//数据体</span></span><br><span class="line">        QByteArray sendBuf;</span><br><span class="line">        sendBuf=<span class="built_in">QByteArray</span>((<span class="keyword">char</span>*)&amp;_communication, <span class="built_in"><span class="keyword">sizeof</span></span> (_communication));</span><br><span class="line">        sendBuf.<span class="built_in">append</span>(Data);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> bbc=<span class="built_in">BBC</span>(sendBuf);<span class="comment">//校验符</span></span><br><span class="line">        sendBuf.<span class="built_in">append</span>(bbc);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;send :&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,Data size = &quot;</span>&lt;&lt;_communication.PayloadSize&lt;&lt;<span class="string">&quot;,All size is =&quot;</span>&lt;&lt;data_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        Sleep(10);</span></span><br><span class="line"></span><br><span class="line">        QThread::<span class="built_in">msleep</span>(<span class="number">10</span>);</span><br><span class="line">        m_sender-&gt;<span class="built_in">writeDatagram</span>(sendBuf,sendBuf.<span class="built_in">size</span>(),<span class="built_in">QHostAddress</span>(<span class="string">&quot;192.168.30.10&quot;</span>),<span class="number">8889</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _communication.PacketHead = <span class="number">0x66666666</span>;<span class="comment">//UINT32 帧头</span></span><br><span class="line">    _communication.PayloadSize = final_packet_size + <span class="number">28</span> + <span class="number">1</span>;<span class="comment">//UINT32 消息长度,28是头长度，1是bbc校验码</span></span><br><span class="line">    _communication.ChunkNum = packet_num + <span class="number">1</span>;<span class="comment">//UINT16 总块数</span></span><br><span class="line">    _communication.ChunkID = packet_num;<span class="comment">//UINT16 当前块序号</span></span><br><span class="line">    _communication.DataTime = QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toTime_t</span>();<span class="comment">//UINT32 数据产生时间</span></span><br><span class="line">    _communication.Latitude =<span class="number">0.</span>;<span class="comment">//FLOAT 数据产生经度</span></span><br><span class="line">    _communication.Longitude =<span class="number">0.</span>;<span class="comment">//FLOAT 数据产生纬度</span></span><br><span class="line">    _communication.SystemID = systemID;<span class="comment">//UINT16 数据源平台系统</span></span><br><span class="line">    _communication.DataType=DataType;<span class="comment">//UINT16 数据类型</span></span><br><span class="line">    QByteArray Data =value.<span class="built_in">right</span>(final_packet_size);<span class="comment">//数据体</span></span><br><span class="line">    QByteArray sendBuf;</span><br><span class="line">    sendBuf=<span class="built_in">QByteArray</span>((<span class="keyword">char</span>*)&amp;_communication, <span class="built_in"><span class="keyword">sizeof</span></span>(_communication));</span><br><span class="line">    sendBuf.<span class="built_in">append</span>(Data);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bbc=<span class="built_in">BBC</span>(sendBuf);<span class="comment">//校验符</span></span><br><span class="line">    sendBuf.<span class="built_in">append</span>(bbc);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(_communication);</span><br><span class="line"></span><br><span class="line">    m_sender-&gt;<span class="built_in">writeDatagram</span>(sendBuf,sendBuf.<span class="built_in">size</span>(),<span class="built_in">QHostAddress</span>(<span class="string">&quot;192.168.30.10&quot;</span>),<span class="number">8889</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"></span><br><span class="line">m_sender=<span class="keyword">new</span> <span class="built_in">QUdpSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片压缩</span></span><br><span class="line"><span class="function">QImage <span class="title">img1</span><span class="params">(<span class="string">&quot;1.jpg&quot;</span>)</span></span>;</span><br><span class="line">QByteArray pixArray;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;pixArray)</span></span>;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">img1.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;JPG&quot;</span>); <span class="comment">// writes image into ba in PNG format</span></span><br><span class="line"><span class="comment">//    //文件内存</span></span><br><span class="line"><span class="comment">//    QFile file(&quot;1.jpg&quot;);</span></span><br><span class="line"><span class="comment">//    QByteArray bitimg;</span></span><br><span class="line"><span class="comment">//    file.open(QFile::ReadOnly);</span></span><br><span class="line"><span class="comment">//    bitimg = file.readAll();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片不压缩</span></span><br><span class="line"><span class="comment">//    QImage img(&quot;1.jpg&quot;);</span></span><br><span class="line"><span class="comment">//    QByteArray bitimg1((char *)img.bits(),img.width()*img.height()*img.depth()/8);</span></span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;buffer.size()&lt;&lt;bitimg1.size()&lt;&lt;pixArray.size()&lt;&lt;img.size()&lt;&lt;img.depth()/8&lt;&lt;img.width()*img.height()*img.depth()/8;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QByteArray sendbuf;</span><br><span class="line"><span class="comment">//图片尺寸</span></span><br><span class="line"><span class="keyword">int</span> imgsize= pixArray.<span class="built_in">size</span>();</span><br><span class="line">sendbuf.<span class="built_in">append</span>(<span class="built_in">QByteArray</span>((<span class="keyword">char</span>*)&amp;imgsize, <span class="built_in"><span class="keyword">sizeof</span></span>(imgsize)));</span><br><span class="line"><span class="comment">//    int imgwidth= img.width();</span></span><br><span class="line"><span class="comment">//    sendbuf.append(QByteArray((char*)&amp;imgwidth, sizeof(imgwidth)));</span></span><br><span class="line"><span class="comment">//    int imgheight= img.height();</span></span><br><span class="line"><span class="comment">//    sendbuf.append(QByteArray((char*)&amp;imgheight, sizeof(imgheight)));</span></span><br><span class="line"><span class="comment">//    int imgdepth= img.format();</span></span><br><span class="line"><span class="comment">//    sendbuf.append(QByteArray((char*)&amp;imgdepth, sizeof(imgdepth)));</span></span><br><span class="line"><span class="comment">//图片内容</span></span><br><span class="line">sendbuf.<span class="built_in">append</span>(pixArray);</span><br><span class="line"><span class="comment">//添加包头发送</span></span><br><span class="line"><span class="built_in">DecodePackets</span>(sendbuf,<span class="number">0x0101</span>,<span class="number">0x0303</span>);</span><br></pre></td></tr></table></figure>

<h3 id="接收1-–没有考虑到乱序的情况"><a href="#接收1-–没有考虑到乱序的情况" class="headerlink" title="接收1 –没有考虑到乱序的情况"></a>接收1 –没有考虑到乱序的情况</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive::slot_TCPgetMes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SeaCommunication _communication;</span><br><span class="line">    m_Msgdata.<span class="built_in">append</span>(m_tcpSocket-&gt;<span class="built_in">readAll</span>());<span class="comment">//分包</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;rece:&quot;</span>&lt;&lt;QString::<span class="built_in">fromLocal8Bit</span>(m_Msgdata);</span><br><span class="line">    <span class="keyword">while</span> (m_Msgdata.<span class="built_in">size</span>()&gt;<span class="built_in"><span class="keyword">sizeof</span></span>(_communication))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;_communication,m_Msgdata,<span class="built_in"><span class="keyword">sizeof</span></span>(_communication));</span><br><span class="line">        <span class="keyword">if</span>(_communication.PayloadSize &gt; m_Msgdata.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//分包</span></span><br><span class="line"></span><br><span class="line">        m_buf.<span class="built_in">append</span>(m_Msgdata.<span class="built_in">mid</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_communication),_communication.PayloadSize-<span class="built_in"><span class="keyword">sizeof</span></span> (_communication)<span class="number">-1</span>));<span class="comment">//不要bbc校验符</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;rece:&quot;</span>&lt;&lt;m_Msgdata.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;,Data size = &quot;</span>&lt;&lt;_communication.PayloadSize-<span class="built_in"><span class="keyword">sizeof</span></span> (_communication)<span class="number">-1</span>&lt;&lt;<span class="string">&quot;,All size is =&quot;</span>&lt;&lt;m_buf.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        m_Msgdata.<span class="built_in">remove</span>(<span class="number">0</span>,_communication.PayloadSize);<span class="comment">//粘包</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_communication.ChunkID+<span class="number">1</span>==_communication.ChunkNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> offset=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> imgsize;</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;imgsize,m_buf.<span class="built_in">begin</span>()+offset,<span class="built_in"><span class="keyword">sizeof</span></span>(imgsize));</span><br><span class="line">            offset+=<span class="built_in"><span class="keyword">sizeof</span></span>(imgsize);</span><br><span class="line"></span><br><span class="line">            QByteArray imgarray=m_buf.<span class="built_in">mid</span>(offset,m_buf.<span class="built_in">size</span>()-offset);</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;m_buf.<span class="built_in">size</span>()&lt;&lt;imgarray.<span class="built_in">size</span>()&lt;&lt;imgsize;</span><br><span class="line"></span><br><span class="line">            m_buf.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(imgarray.<span class="built_in">size</span>() == imgsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//                //图片不压缩</span></span><br><span class="line">                <span class="comment">//                QImage img((uchar *)imgarray.data(),imgwidth,imgheight,QImage::Format_RGB32);</span></span><br><span class="line">                <span class="comment">//                img.save(&quot;img.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//                //文件内存</span></span><br><span class="line">                <span class="comment">//                QFile file(&quot;resule.jpg&quot;);</span></span><br><span class="line">                <span class="comment">//                file.open(QFile::WriteOnly);</span></span><br><span class="line">                <span class="comment">//                file.write(imgarray);</span></span><br><span class="line">                <span class="comment">//                file.close();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//图片压缩</span></span><br><span class="line">                <span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;imgarray)</span></span>;</span><br><span class="line">                buffer.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">                <span class="function">QImageReader <span class="title">reader</span><span class="params">(&amp;buffer,<span class="string">&quot;JPG&quot;</span>)</span></span>;</span><br><span class="line">                QImage img = reader.<span class="built_in">read</span>();</span><br><span class="line">                img.<span class="built_in">save</span>(<span class="string">&quot;resule.jpg&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送2"><a href="#发送2" class="headerlink" title="发送2"></a>发送2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UdpPackSend</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT32 Magic;<span class="comment">//0x5350584E</span></span><br><span class="line">    UCHAR Protocol;<span class="comment">//Protocol version of packeting. Version 1 is defined by this document. 分包的协议版本,本文档设定为 版本 1</span></span><br><span class="line">    UCHAR HeaderSize;<span class="comment">//The size of this header in bytes. 包头长度（字节）</span></span><br><span class="line">    UCHAR NumChunks;<span class="comment">//The number of packets.数据块数量</span></span><br><span class="line">    UCHAR ChunkID;<span class="comment">//The ID of this chunk (0 ..Num Chunks – 1). 当前块的ID</span></span><br><span class="line">    UINT16 SequenceNumber;<span class="comment">//Packet sequence numbers (wraps around after 65536). 包序列值（0 - 65536循环）</span></span><br><span class="line">    UINT16 PayloadSize;<span class="comment">//The number of data bytes in this chunk. 当前块中的数据载荷长度（字节）</span></span><br><span class="line">    UINT32 TotalPayloadSize;<span class="comment">//Total size of all payloads. 总载荷大小</span></span><br><span class="line">    UINT32 payloadOffset;<span class="comment">//Position of this payload in message.	当前载荷在消息中的位置</span></span><br><span class="line">    UINT32 SoutceIdenetifier;<span class="comment">//Server-assigned source identifier.服务分配的源ID</span></span><br><span class="line">    string Data;<span class="comment">//Data segment is of length “Payload Size”. 数据段是数据载荷</span></span><br><span class="line">    <span class="built_in">PACKETISE</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Magic=<span class="number">9999</span>;<span class="comment">//初始化0标记，用来标记未赋值的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadFileSend::UDP_SEND_RETURN</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *return_data, <span class="keyword">int</span> data_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UdpPackSend udpPackSend = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> UINT16 seq16 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> packet_size = <span class="number">1376</span>;<span class="comment">//1376+24=1400byte</span></span><br><span class="line">	<span class="keyword">int</span> packet_num = data_len / packet_size;<span class="comment">//不算最后1包的包数</span></span><br><span class="line">	<span class="keyword">int</span> final_packet_size = data_len%packet_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = return_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packet_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//修改UDP头24Bytes</span></span><br><span class="line">		udpPackSend.Magic = <span class="built_in">htonl</span>(<span class="number">0x5350584E</span>);</span><br><span class="line">		udpPackSend.Protocol = <span class="number">1</span>;<span class="comment">//UCHAR</span></span><br><span class="line">		udpPackSend.HeaderSize = <span class="number">24</span>;<span class="comment">//UCHAR</span></span><br><span class="line">		udpPackSend.NumChunks = packet_num + <span class="number">1</span>;<span class="comment">//UCHAR</span></span><br><span class="line">		udpPackSend.ChunkID = i;<span class="comment">//UCHAR</span></span><br><span class="line"></span><br><span class="line">		udpPackSend.SequenceNumber = <span class="built_in">htons</span>(seq16);<span class="comment">//UINT16</span></span><br><span class="line"></span><br><span class="line">		udpPackSend.PayloadSize = <span class="built_in">htons</span>(packet_size);<span class="comment">//UINT16</span></span><br><span class="line">		<span class="comment">//qDebug() &lt;&lt; &quot;udpPackSend.PayloadSize=&quot;&lt;&lt; udpPackSend.PayloadSize&lt;&lt;&quot;,packet_size=&quot;&lt;&lt; packet_size;</span></span><br><span class="line">		udpPackSend.TotalPayloadSize = <span class="built_in">htonl</span>(data_len);<span class="comment">//UINT32</span></span><br><span class="line">		udpPackSend.payloadOffset = <span class="built_in">htonl</span>(packet_size*i);<span class="comment">//UINT32</span></span><br><span class="line">		udpPackSend.SoutceIdenetifier = <span class="number">0</span>;<span class="comment">//UINT32</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(udpPackSend.data, ptr, packet_size);</span><br><span class="line">		ptr += packet_size;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_pUDPmanageg_return.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;alive&quot;</span>;</span><br><span class="line">			m_pUDPmanageg_return[i]-&gt;<span class="built_in">sendMsg</span>(<span class="built_in">QByteArray</span>((<span class="keyword">char</span> *)&amp;udpPackSend, <span class="built_in"><span class="keyword">sizeof</span></span>(UdpPackSend)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//for (int i = 0; i &lt; m_ReturnIpConfig.size(); i++)</span></span><br><span class="line">		<span class="comment">//	&#123;</span></span><br><span class="line">		<span class="comment">//	//UDP发送 UdpPackSend</span></span><br><span class="line">		<span class="comment">//	sendto(sockfd, (char *)&amp;udpPackSend, sizeof(UdpPackSend), 0, (struct sockaddr*)&amp;m_socReturnDes[i], sizeof(m_socReturnDes[i]));</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改UDP头24Bytes</span></span><br><span class="line">	udpPackSend.Magic = <span class="built_in">htonl</span>(<span class="number">0x5350584E</span>);<span class="comment">//UINT32</span></span><br><span class="line"></span><br><span class="line">	udpPackSend.Protocol = <span class="number">1</span>;<span class="comment">//UCHAR</span></span><br><span class="line">	udpPackSend.HeaderSize = <span class="number">24</span>;<span class="comment">//UCHAR</span></span><br><span class="line">	udpPackSend.NumChunks = packet_num + <span class="number">1</span>;<span class="comment">//UCHAR</span></span><br><span class="line">	udpPackSend.ChunkID = packet_num;<span class="comment">//UCHAR</span></span><br><span class="line"></span><br><span class="line">	udpPackSend.SequenceNumber = <span class="built_in">htons</span>(seq16);<span class="comment">//UINT16</span></span><br><span class="line">	seq16++;<span class="comment">//每根回波才+1</span></span><br><span class="line"></span><br><span class="line">	udpPackSend.PayloadSize = <span class="built_in">htons</span>(final_packet_size);<span class="comment">//UINT16</span></span><br><span class="line">	udpPackSend.TotalPayloadSize = <span class="built_in">htonl</span>(data_len);<span class="comment">//UINT32</span></span><br><span class="line">	udpPackSend.payloadOffset = <span class="built_in">htonl</span>(packet_size*packet_num);<span class="comment">//UINT32</span></span><br><span class="line">	udpPackSend.SoutceIdenetifier = <span class="number">0</span>;<span class="comment">//UINT32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//qDebug() &lt;&lt; &quot;udpPackSend.PayloadSize=&quot; &lt;&lt; udpPackSend.PayloadSize &lt;&lt; &quot;,packet_size=&quot; &lt;&lt; final_packet_size;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(udpPackSend.data, ptr, final_packet_size);</span><br><span class="line">	ptr += final_packet_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_pUDPmanageg_return.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;alive&quot;</span>;</span><br><span class="line">		m_pUDPmanageg_return[i]-&gt;<span class="built_in">sendMsg</span>(<span class="built_in">QByteArray</span>((<span class="keyword">char</span> *)&amp;udpPackSend, <span class="number">24</span> + final_packet_size));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; m_ReturnIpConfig.size(); i++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	//UDP发送 24+final_packet_size</span></span><br><span class="line">	<span class="comment">//	sendto(sockfd, (char *)&amp;udpPackSend, sizeof(UdpPackSend), 0, (struct sockaddr*)&amp;m_socReturnDes[i], sizeof(m_socReturnDes[i]));</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接收2-–考虑到乱序的情况"><a href="#接收2-–考虑到乱序的情况" class="headerlink" title="接收2  –考虑到乱序的情况"></a>接收2  –考虑到乱序的情况</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PlotReceive_Thread::revPack</span><span class="params">(QByteArray &amp;data,PACKETISE udpPackage[<span class="number">32</span>],string &amp;radarData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">size</span>()&lt;<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>*recvBuf = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预先读出包总数和包序号</span></span><br><span class="line">    <span class="keyword">char</span> numChunks = recvBuf[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">char</span> chunkID = recvBuf[<span class="number">7</span>];<span class="comment">//包序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据包</span></span><br><span class="line">    <span class="keyword">if</span>(chunkID&gt;=<span class="number">0</span> &amp;&amp; chunkID&lt;=(numChunks<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;udpPackage[chunkID],recvBuf,<span class="number">24</span>);<span class="comment">//UDP头</span></span><br><span class="line">        udpPackage[chunkID].PayloadSize = <span class="built_in">htons</span>(udpPackage[chunkID].PayloadSize);</span><br><span class="line">        <span class="keyword">if</span>(udpPackage[chunkID].PayloadSize != data.<span class="built_in">length</span>()<span class="number">-24</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;udpPackage[chunkID].PayloadSize != len-24!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;udpPackage[chunkID].PayloadSize != len-24!&quot;</span>&lt;&lt;data.<span class="built_in">length</span>()&lt;&lt;udpPackage[chunkID].PayloadSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//qDebug()&lt;&lt;&quot;numChunks=&quot;&lt;&lt;int(numChunks)&lt;&lt;&quot;,chunkID=&quot;&lt;&lt;int(chunkID)&lt;&lt;&quot;,PayloadSize=&quot;&lt;&lt;udpPackage[chunkID].PayloadSize;</span></span><br><span class="line">        <span class="comment">//UDP数据</span></span><br><span class="line">        udpPackage[chunkID].Data.<span class="built_in">assign</span>((<span class="keyword">char</span> *)recvBuf + <span class="number">24</span>, udpPackage[chunkID].PayloadSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1根回波的4个数据包接收完成</span></span><br><span class="line">    <span class="keyword">if</span>(chunkID==numChunks<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//回波数据合并</span></span><br><span class="line">        radarData.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numChunks;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            radarData.<span class="built_in">append</span>(udpPackage[i].Data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PACKETISE m_trackudpPackage[<span class="number">32</span>]=&#123;&#125;;</span><br><span class="line"><span class="comment">//回波格式数据缓存区</span></span><br><span class="line">string m_trackradarData;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlotReceive_Thread::slot_trackUdp</span><span class="params">(QByteArray &amp;data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="built_in">revPack</span>(data,m_trackudpPackage,m_trackradarData);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdFromName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*processName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    DWORD id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS,<span class="number">0</span>);</span><br><span class="line">    pe.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span>( !<span class="built_in">Process32First</span>(hSnapshot,&amp;pe) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> pname[<span class="number">300</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pe.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESSENTRY32);</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">Process32Next</span>(hSnapshot,&amp;pe)==FALSE )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//把WCHAR*类型转换为const char*类型</span></span><br><span class="line">        <span class="built_in">sprintf</span>(pname,<span class="string">&quot;%ws&quot;</span>,pe.szExeFile);</span><br><span class="line">        <span class="comment">//比较两个字符串，如果找到了要找的进程</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pname,processName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            id = pe.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">killProcess</span><span class="params">(QString name )</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过进程名获取进程ID</span></span><br><span class="line">    <span class="keyword">while</span> (DWORD pid = <span class="built_in">GetProcessIdFromName</span>((<span class="keyword">char</span>*)name.<span class="built_in">toLatin1</span>().<span class="built_in">data</span>())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取进程的最大权限</span></span><br><span class="line">        HANDLE token = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS,FALSE,pid);</span><br><span class="line">        <span class="comment">//关闭进程</span></span><br><span class="line">        <span class="built_in">TerminateProcess</span>(token, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QString name = QApplication::<span class="built_in">applicationName</span>()+<span class="string">&quot;.exe&quot;</span>;</span><br><span class="line"><span class="built_in">killProcess</span>(name);</span><br></pre></td></tr></table></figure>

<h2 id="根据范围值和颜色，返回给定数值的颜色"><a href="#根据范围值和颜色，返回给定数值的颜色" class="headerlink" title="根据范围值和颜色，返回给定数值的颜色"></a>根据范围值和颜色，返回给定数值的颜色</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QColor <span class="title">getColor</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>&amp; value ,<span class="keyword">const</span> <span class="keyword">float</span>&amp; min,<span class="keyword">const</span> <span class="keyword">float</span>&amp; max,<span class="keyword">const</span> QColor&amp; c1,<span class="keyword">const</span> QColor&amp; c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((value&lt;min)||(value&gt;max))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QColor</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> bz = (value-min)/(max-min);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">QColor</span>((c2.<span class="built_in">red</span>()-c1.<span class="built_in">red</span>())*bz+c1.<span class="built_in">red</span>(),(c2.<span class="built_in">green</span>()-c1.<span class="built_in">green</span>())*bz+c1.<span class="built_in">green</span>(),(c2.<span class="built_in">blue</span>()-c1.<span class="built_in">blue</span>())*bz+c1.<span class="built_in">blue</span>(),(c2.<span class="built_in">alpha</span>()-c1.<span class="built_in">alpha</span>())*bz+c1.<span class="built_in">alpha</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经纬度相关"><a href="#经纬度相关" class="headerlink" title="经纬度相关"></a>经纬度相关</h2><h3 id="数值转度分"><a href="#数值转度分" class="headerlink" title="数值转度分"></a>数值转度分</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">lonlatFromFloat</span><span class="params">(<span class="keyword">float</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xdeg =v; <span class="comment">// 取整数部分，即度</span></span><br><span class="line">    <span class="keyword">double</span> xmin = (v - xdeg) * <span class="number">60</span>; <span class="comment">// 取小数部分并乘以60，即分</span></span><br><span class="line">    <span class="keyword">return</span> QString::<span class="built_in">number</span>(xdeg)+<span class="string">&quot;°&quot;</span>+QString::<span class="built_in">number</span>(xmin,<span class="string">&#x27;f&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">degree2Dmc</span><span class="params">(<span class="keyword">double</span> dbDegree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lon = dbDegree;</span><br><span class="line">    <span class="keyword">if</span> (lon &lt; <span class="number">0.0</span>)</span><br><span class="line">        lon = -dbDegree;</span><br><span class="line">    <span class="keyword">int</span> nDegree = (<span class="keyword">int</span>)lon;</span><br><span class="line">    <span class="keyword">double</span> dbMin = (lon - nDegree) * <span class="number">60.0</span>;</span><br><span class="line">    <span class="keyword">int</span> nMin = dbMin;</span><br><span class="line">    <span class="keyword">double</span> sec = (dbMin - (<span class="keyword">int</span>)dbMin) * <span class="number">60.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dbDegree &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nDegree = -nDegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString textLon = <span class="built_in">QString</span>((<span class="string">&quot;%1%2%3\&#x27;%4\&quot;&quot;</span>)).<span class="built_in">arg</span>(nDegree).<span class="built_in">arg</span>(<span class="string">&#x27;\xb0&#x27;</span>).<span class="built_in">arg</span>(nMin).<span class="built_in">arg</span>(sec);</span><br><span class="line">    <span class="keyword">return</span> textLon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串转数值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dmc2Degree</span><span class="params">(QString strDmc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString strTemp = strDmc;</span><br><span class="line"></span><br><span class="line">    QString strSec = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    QString strMin = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    QString strDegree = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nDegree = strTemp.<span class="built_in">indexOf</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;°&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (nDegree != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strDegree = strTemp.<span class="built_in">left</span>(nDegree);</span><br><span class="line">        strTemp = strTemp.<span class="built_in">mid</span>(nDegree + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nMin = strTemp.<span class="built_in">indexOf</span>(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nMin != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strMin = strTemp.<span class="built_in">left</span>(nMin);</span><br><span class="line">        strTemp = strTemp.<span class="built_in">mid</span>(nMin + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nSec = strTemp.<span class="built_in">indexOf</span>(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nSec != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strSec = strTemp.<span class="built_in">left</span>(nSec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> dbDegree = strDegree.<span class="built_in">toDouble</span>();</span><br><span class="line">    <span class="keyword">double</span> dbMin = strMin.<span class="built_in">toDouble</span>();</span><br><span class="line">    <span class="keyword">double</span> dbSec = strSec.<span class="built_in">toDouble</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    qDebug()&lt;&lt;&quot;:::::::::::::::::&quot;&lt;&lt;dbDegree&lt;&lt;dbMin&lt;&lt;dbSec&lt;&lt;strDegree&lt;&lt;strMin&lt;&lt;strSec;</span></span><br><span class="line">    <span class="keyword">double</span> dbRet;</span><br><span class="line">    <span class="keyword">if</span> (dbDegree &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dbDegree = -dbDegree;</span><br><span class="line">        dbRet = -(dbDegree + dbMin / <span class="number">60.0</span> + dbSec / <span class="number">3600.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dbRet = dbDegree + dbMin / <span class="number">60.0</span> + dbSec / <span class="number">3600.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dbRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经度转字符串"><a href="#经度转字符串" class="headerlink" title="经度转字符串"></a>经度转字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">degree2DmcOfLon</span><span class="params">(<span class="keyword">double</span> dbDegree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lon = dbDegree;</span><br><span class="line">    <span class="keyword">if</span> (lon &lt; <span class="number">0.0</span>)</span><br><span class="line">        lon = -dbDegree;</span><br><span class="line">    <span class="keyword">int</span> nDegree = (<span class="keyword">int</span>)lon;</span><br><span class="line">    <span class="keyword">double</span> dbMin = (lon - nDegree) * <span class="number">60.0</span>;</span><br><span class="line">    <span class="keyword">int</span> nMin = dbMin;</span><br><span class="line">    <span class="keyword">double</span> sec = (dbMin - (<span class="keyword">int</span>)dbMin) * <span class="number">60.0</span>;</span><br><span class="line"></span><br><span class="line">    QString sLon;</span><br><span class="line">    <span class="keyword">if</span>(dbDegree&lt;<span class="number">0</span>) sLon=<span class="string">&quot;W&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> sLon=<span class="string">&quot;E&quot;</span>;</span><br><span class="line"></span><br><span class="line">    QString textLon = <span class="built_in">QString</span>((<span class="string">&quot;%1%2%3\&#x27;%4\&quot;%5&quot;</span>)).<span class="built_in">arg</span>(nDegree).<span class="built_in">arg</span>(<span class="string">&#x27;\xb0&#x27;</span>).<span class="built_in">arg</span>(nMin).<span class="built_in">arg</span>(sec,<span class="number">0</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>).<span class="built_in">arg</span>(sLon);</span><br><span class="line">    <span class="keyword">return</span> textLon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="维度转字符串"><a href="#维度转字符串" class="headerlink" title="维度转字符串"></a>维度转字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">degree2DmcOfLat</span><span class="params">(<span class="keyword">double</span> dbDegree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lat = dbDegree;</span><br><span class="line">    <span class="keyword">if</span> (lat &lt; <span class="number">0.0</span>)</span><br><span class="line">        lat = -dbDegree;</span><br><span class="line">    <span class="keyword">int</span> nDegree = (<span class="keyword">int</span>)lat;</span><br><span class="line">    <span class="keyword">double</span> dbMin = (lat - nDegree) * <span class="number">60.0</span>;</span><br><span class="line">    <span class="keyword">int</span> nMin = dbMin;</span><br><span class="line">    <span class="keyword">double</span> sec = (dbMin - (<span class="keyword">int</span>)dbMin) * <span class="number">60.0</span>;</span><br><span class="line"></span><br><span class="line">    QString sLat;</span><br><span class="line">    <span class="keyword">if</span>(dbDegree&lt;<span class="number">0</span>) sLat=<span class="string">&quot;S&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> sLat=<span class="string">&quot;N&quot;</span>;</span><br><span class="line"></span><br><span class="line">    QString textLon = <span class="built_in">QString</span>((<span class="string">&quot;%1%2%3\&#x27;%4\&quot;%5&quot;</span>)).<span class="built_in">arg</span>(nDegree).<span class="built_in">arg</span>(<span class="string">&#x27;\xb0&#x27;</span>).<span class="built_in">arg</span>(nMin).<span class="built_in">arg</span>(sec,<span class="number">0</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>).<span class="built_in">arg</span>(sLat);</span><br><span class="line">    <span class="keyword">return</span> textLon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经纬度转字符串"><a href="#经纬度转字符串" class="headerlink" title="经纬度转字符串"></a>经纬度转字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">degree2Dmc</span><span class="params">(QPointF f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> lon = f.<span class="built_in">rx</span>();</span><br><span class="line">    <span class="keyword">float</span> lat = f.<span class="built_in">ry</span>();</span><br><span class="line">    QString sLon,sLat;</span><br><span class="line">    <span class="keyword">if</span>(lat&lt;<span class="number">0</span>) sLat=<span class="string">&quot;S&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> sLat=<span class="string">&quot;N&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(lon&lt;<span class="number">0</span>) sLon=<span class="string">&quot;W&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> sLon=<span class="string">&quot;E&quot;</span>;</span><br><span class="line">    <span class="comment">//转换度分</span></span><br><span class="line">    <span class="keyword">int</span> dlon=lon;</span><br><span class="line">    <span class="keyword">float</span> flon=(lon-dlon)*<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">int</span> dlat=lat;</span><br><span class="line">    <span class="keyword">float</span> flat=(lat-dlat)*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    QString textLon = QString::<span class="built_in">number</span>(<span class="built_in">abs</span>(dlon))+<span class="built_in">QStringLiteral</span>(<span class="string">&quot;°&quot;</span>)+QString::<span class="built_in">number</span>(<span class="built_in">abs</span>(flon),<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>)+<span class="string">&quot;&#x27;&quot;</span>+sLon +<span class="string">&quot;,&quot;</span>+QString::<span class="built_in">number</span>(<span class="built_in">abs</span>(dlat))+<span class="built_in">QStringLiteral</span>(<span class="string">&quot;°&quot;</span>)+QString::<span class="built_in">number</span>(<span class="built_in">abs</span>(flat),<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>)+<span class="string">&quot;&#x27;&quot;</span>+sLat;</span><br><span class="line">    <span class="keyword">return</span> textLon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除路径"><a href="#删除路径" class="headerlink" title="删除路径"></a>删除路径</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">removeDir</span><span class="params">(<span class="keyword">const</span> QString &amp; dirName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">QDir <span class="title">dir</span><span class="params">(dirName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir.<span class="built_in">exists</span>(dirName)) &#123;</span><br><span class="line">        <span class="built_in">Q_FOREACH</span>(QFileInfo info, dir.<span class="built_in">entryInfoList</span>(QDir::NoDotAndDotDot | QDir::System | QDir::Hidden  | QDir::AllDirs | QDir::Files, QDir::DirsFirst)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (info.<span class="built_in">isDir</span>()) &#123;</span><br><span class="line">                result = <span class="built_in">removeDir</span>(info.<span class="built_in">absoluteFilePath</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = QFile::<span class="built_in">remove</span>(info.<span class="built_in">absoluteFilePath</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = dir.<span class="built_in">rmdir</span>(dirName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="点是否位于两点构成直径的圆内"><a href="#点是否位于两点构成直径的圆内" class="headerlink" title="点是否位于两点构成直径的圆内"></a>点是否位于两点构成直径的圆内</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//p为点 g.c为圆</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inCircle</span><span class="params">(QPointF p, QPointF pStart, QPointF pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x, y, l, r;</span><br><span class="line">    x = (pStart.<span class="built_in">rx</span>() + pEnd.<span class="built_in">rx</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    y = (pStart.<span class="built_in">ry</span>() + pEnd.<span class="built_in">ry</span>()) / <span class="number">2.0</span>;</span><br><span class="line">    l = (x - p.<span class="built_in">rx</span>())*(x - p.<span class="built_in">rx</span>()) + (y - p.<span class="built_in">ry</span>())*(y - p.<span class="built_in">ry</span>());</span><br><span class="line">    r = <span class="built_in">sqrt</span>((x - pStart.<span class="built_in">rx</span>())*(x - pStart.<span class="built_in">rx</span>()) + (y - pStart.<span class="built_in">ry</span>())*(y - pStart.<span class="built_in">ry</span>()));</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;***inCircle***&quot;</span>&lt;&lt;x&lt;&lt;y&lt;&lt;<span class="built_in">sqrt</span>(l)&lt;&lt;r;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sqrt</span>(l) &lt;= r) <span class="comment">//点到圆心的距离小于半径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++ Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>头文件</title>
    <url>/2021/06/20/%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h1 id="QFileDialog"><a href="#QFileDialog" class="headerlink" title="QFileDialog"></a>QFileDialog</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;io.h&gt;</span><br></pre></td></tr></table></figure>

<h1 id="max"><a href="#max" class="headerlink" title="max"></a>max</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br></pre></td></tr></table></figure>

<h1 id="T"><a href="#T" class="headerlink" title="_T()"></a>_T()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;tchar.h&gt;</span><br></pre></td></tr></table></figure>

<h1 id="to-string"><a href="#to-string" class="headerlink" title="to_string()"></a>to_string()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br></pre></td></tr></table></figure>

<h1 id="htonl"><a href="#htonl" class="headerlink" title="htonl"></a>htonl</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在linux的头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">在windows的头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h1 id="std-ifstream"><a href="#std-ifstream" class="headerlink" title="std::ifstream"></a>std::ifstream</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br></pre></td></tr></table></figure>

<h1 id="QApplication-desktop"><a href="#QApplication-desktop" class="headerlink" title="QApplication::desktop()"></a>QApplication::desktop()</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDesktopWidget&gt;</span></span></span><br><span class="line">QRect screenRect = QApplication::<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenGeometry</span>();</span><br></pre></td></tr></table></figure>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveTrace</span><span class="params">(<span class="keyword">void</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="function">thread <span class="title">t3</span><span class="params">(RcvPicHistory, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">t3.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReceiveTCP</span><span class="params">(<span class="keyword">void</span> * record)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启接收TCP消息线程</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> t1 = _beginthread(ReceiveTCP, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">uintptr_t</span> t2=_beginthread(sendThreadFun, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	HANDLE harr[<span class="number">2</span>] = &#123; <span class="built_in">HANDLE</span>(t1) ,<span class="built_in">HANDLE</span>(t2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启接收TCP消息线程</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> t2=_beginthread(sendThreadFun, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(<span class="built_in">HANDLE</span>(t2), INFINITE);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//连接多线程库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;pthreadVC2.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">receiveTCP</span><span class="params">(<span class="keyword">void</span> * strIP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> tids;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tids, <span class="literal">NULL</span>, receiveTCP, (<span class="keyword">void</span> *)&amp;(vecIP[i]));</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pthread_create error: error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">windows下</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="comment">//没有下面这句，所有的通讯函数都将报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//必须链接这个库</span></span></span><br><span class="line">    </span><br><span class="line">linux下</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSAEWOULDBLOCK EWOULDBLOCK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSAETIMEDOUT  ETIMEDOUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSAECONNREFUSED EINPROGRESS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSAEISCONN      EISCONN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sleep    sleep</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR          (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVALID_SOCKET (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_ERROR   (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> closesocket    close</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ioctlsocket    ioctl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _strnicmp    strncasecmp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _snprintf    snprintf</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>    SOCKET;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SOCKADDR</span>;</span></span><br></pre></td></tr></table></figure>

<h1 id="access"><a href="#access" class="headerlink" title="_access"></a>_access</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt_io.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="struct-ip-mreq-mreq"><a href="#struct-ip-mreq-mreq" class="headerlink" title="struct ip_mreq mreq;"></a>struct ip_mreq mreq;</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2ipdef.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="std-ofstream"><a href="#std-ofstream" class="headerlink" title="std::ofstream"></a>std::ofstream</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="M-PI"><a href="#M-PI" class="headerlink" title="M_PI"></a>M_PI</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="通配符查询-finddata-t"><a href="#通配符查询-finddata-t" class="headerlink" title="通配符查询 _finddata_t"></a>通配符查询 _finddata_t</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="exe路径"><a href="#exe路径" class="headerlink" title="exe路径"></a>exe路径</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br></pre></td></tr></table></figure>

<h1 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>

<h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure>

<h1 id="HANDLE"><a href="#HANDLE" class="headerlink" title="HANDLE"></a>HANDLE</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br></pre></td></tr></table></figure>

<h1 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br></pre></td></tr></table></figure>

<h1 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//视频</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavformat/avformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/pixfmt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libswscale/swscale.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wtypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil\time.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//音频</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffmpeg/libavutil/opt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffmpeg/libavutil/channel_layout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffmpeg/libavutil/samplefmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffmpeg/libswresample/swresample.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">avcodec.lib</span><br><span class="line">avdevice.lib</span><br><span class="line">avfilter.lib</span><br><span class="line">avformat.lib</span><br><span class="line">avutil.lib</span><br><span class="line">postproc.lib</span><br><span class="line">swresample.lib</span><br><span class="line">swscale.lib</span><br></pre></td></tr></table></figure>

<h1 id="htons"><a href="#htons" class="headerlink" title="htons"></a>htons</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Winsock2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2ipdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关</title>
    <url>/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">( <span class="keyword">const</span> string&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n )</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = <span class="number">0</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">( <span class="keyword">char</span> c, <span class="keyword">size_t</span> pos = <span class="number">0</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数说明：pos查找起始位置 n待查找字符串的前n个字符</span><br><span class="line">使用样例：</span><br><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;the usage of find can you use it&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;the&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">上面定义出了两个字符串；</span><br><span class="line">str1.<span class="built_in">find</span>(str2); <span class="comment">// 从串str1中查找时str2，返回str2中首个字符在str1中的地址</span></span><br><span class="line">str1.<span class="built_in">find</span>(str2,<span class="number">5</span>); <span class="comment">// 从str1的第5个字符开始查找str2</span></span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;usage&quot;</span>); <span class="comment">// 如果usage在str1中查找到，返回u在str1中的位置</span></span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;o&quot;</span>); <span class="comment">// 查找字符o并返回地址</span></span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;of big&quot;</span>,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 从str1中的第二个字符开始查找of big的前两个字符</span></span><br></pre></td></tr></table></figure>

<h2 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a>find_first_of</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">( <span class="keyword">const</span> string&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos, <span class="keyword">size_t</span> n )</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = <span class="number">0</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find_first_of</span> <span class="params">( <span class="keyword">char</span> c, <span class="keyword">size_t</span> pos = <span class="number">0</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line">参数和find基本相同，不在赘述!</span><br><span class="line">特别注意：</span><br><span class="line">find_first_of 函数最容易出错的地方是和find函数搞混。它最大的区别就是如果在一个字符串str1中查找另一个字符串str2，如果str1中含有str2中的任何字符，则就会查找成功，而find则不同；</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am change&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;about&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> k=str1.<span class="built_in">find_first_of</span>(str2); <span class="comment">//k返回的值是about这5个字符中任何一个首次在str1中出现的位置；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">Cfg::valS</span><span class="params">(string paramName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream infile;</span><br><span class="line">    infile.<span class="built_in">open</span>(m_configPath);</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(infile, str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//剔除注释</span></span><br><span class="line">        <span class="keyword">int</span> posCom = str.<span class="built_in">find_first_of</span>(<span class="string">&#x27;#&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (posCom != string::npos)str.<span class="built_in">erase</span>(posCom);</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//截取参数名</span></span><br><span class="line">        <span class="keyword">int</span> pos = str.<span class="built_in">find_first_of</span>(<span class="string">&#x27;=&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">        string param = str.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">        <span class="comment">//剔除字符串前后多余空格</span></span><br><span class="line">        param.<span class="built_in">erase</span>(<span class="number">0</span>, param.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">        param.<span class="built_in">erase</span>(param.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (param == paramName)</span><br><span class="line">        &#123;</span><br><span class="line">            infile.<span class="built_in">close</span>();</span><br><span class="line">            string value = str.<span class="built_in">substr</span>(pos + <span class="number">1</span>, str.<span class="built_in">length</span>() - pos);</span><br><span class="line">            <span class="comment">//剔除字符串前后多余空格</span></span><br><span class="line">            value.<span class="built_in">erase</span>(<span class="number">0</span>, value.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            value.<span class="built_in">erase</span>(value.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find-last-of"><a href="#find-last-of" class="headerlink" title="find_last_of"></a>find_last_of</h2><p>用法：str.find_last_of(str1,pos)</p>
<p>说明：从pos位置开始查找，从后往前，查到str1中的任何一个字符则返回其str中的索引值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            left=s.<span class="built_in">find_first_of</span>(<span class="string">&quot;aeiouAEIOU&quot;</span>,left);</span><br><span class="line">            right=s.<span class="built_in">find_last_of</span>(<span class="string">&quot;aeiouAEIOU&quot;</span>,right);</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left++],s[right--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h1><h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h2><p><strong>basic_string::substr</strong></p>
<p>basic_string substr(<a href="https://baike.so.com/doc/6847447-7064872.html">size_type</a> _Off = 0,size_type _Count = npos) const;</p>
<p>参数</p>
<p>_Off        所需的子字符串的起始位置。<a href="https://baike.so.com/doc/2529629-2672477.html">字符</a>串中第一个字符的索引为 0,默认值为0.</p>
<p>_Count   复制的字符数目</p>
<p>返回值    一个子字符串，从其指定的位置开始</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">splitWithStl</span><span class="params">(<span class="keyword">const</span> std::string &amp;str,<span class="keyword">const</span> std::string &amp;pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; resVec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span> == str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> resVec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方便截取最后一段数据</span></span><br><span class="line">    std::string strs = str + pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    <span class="keyword">size_t</span> size = strs.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pos != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string x = strs.<span class="built_in">substr</span>(<span class="number">0</span>,pos);</span><br><span class="line">        resVec.<span class="built_in">push_back</span>(x);</span><br><span class="line">        strs = strs.<span class="built_in">substr</span>(pos+<span class="number">1</span>,size);</span><br><span class="line">        pos = strs.<span class="built_in">find</span>(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h2><p><em><strong>原型</strong></em>：char *strtok(char *str, const char *delim);<br>功能：分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符串。<br><em><strong>描述</strong></em>：strtok()用来将字符串分割成一个个片段。参数s指向欲分割的字符串，参数delim则为分割字符串，当strtok()在参数s的字符串中发现到参数delim的分割字符时 则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回被分割出片段的指针。</p>
<p>其它：strtok函数线程不安全，可以使用strtok_r替代。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> string &amp;str,<span class="keyword">const</span> string &amp;pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const char* convert to char*</span></span><br><span class="line">    <span class="keyword">char</span> * strc = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.<span class="built_in">c_str</span>())+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(strc, str.<span class="built_in">c_str</span>());</span><br><span class="line">    vector&lt;string&gt; resultVec;</span><br><span class="line">    <span class="keyword">char</span>* tmpStr = <span class="built_in">strtok</span>(strc, pattern.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">while</span> (tmpStr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        resultVec.<span class="built_in">push_back</span>(<span class="built_in">string</span>(tmpStr));</span><br><span class="line">        tmpStr = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, pattern.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] strc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultVec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = <span class="built_in">strtok</span>((<span class="keyword">char</span> *)str.<span class="built_in">data</span>(), <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">    string s = p; <span class="comment">//分割得到的字符串转换为string类型  </span></span><br><span class="line">    timerange.<span class="built_in">push_back</span>(s); <span class="comment">//存入结果数组  </span></span><br><span class="line">    p = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-宽字符处理函数-与-普通函数-对照表"><a href="#C-宽字符处理函数-与-普通函数-对照表" class="headerlink" title="C++宽字符处理函数 与 普通函数 对照表"></a>C++宽字符处理函数 与 普通函数 对照表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">字符串操作： </span><br><span class="line">宽字符函数         普通C函数                       描述</span><br><span class="line"><span class="built_in">wcscat</span>()        <span class="built_in">strcat</span>()                            把一个字符串接到另一个字符串的尾部 </span><br><span class="line"><span class="built_in">wcsncat</span>()      <span class="built_in">strncat</span>()                          类似于<span class="built_in">wcscat</span>()， 而且指定粘接字符串的粘接长度. </span><br><span class="line"><span class="built_in">wcschr</span>()        <span class="built_in">strchr</span>()                            查找子字符串的第一个位置 </span><br><span class="line"><span class="built_in">wcsrchr</span>()       <span class="built_in">strrchr</span>()                          从尾部开始查找子字符串出现的第一个位置 </span><br><span class="line"><span class="built_in">wcspbrk</span>()      <span class="built_in">strpbrk</span>()                         从一字符字符串中查找另一字符串中任何一个字符第一次出现的位置 </span><br><span class="line"><span class="built_in">wcswcs</span>()       /<span class="built_in">wcsstr</span>()        <span class="built_in">strchr</span>()      在一字符串中查找另一字符串第一次出现的位置 </span><br><span class="line"><span class="built_in">wcscspn</span>()      <span class="built_in">strcspn</span>()                        返回不包含第二个字符串的的初始数目 </span><br><span class="line"><span class="built_in">wcsspn</span>()        <span class="built_in">strspn</span>()                         返回包含第二个字符串的初始数目 </span><br><span class="line"><span class="built_in">wcscpy</span>()        <span class="built_in">strcpy</span>()                          拷贝字符串 </span><br><span class="line"><span class="built_in">wcsncpy</span>()      <span class="built_in">strncpy</span>()                        类似于<span class="built_in">wcscpy</span>()， 同时指定拷贝的数目 </span><br><span class="line"><span class="built_in">wcscmp</span>()       <span class="built_in">strcmp</span>()                         比较两个宽字符串 </span><br><span class="line"><span class="built_in">wcsncmp</span>()     <span class="built_in">strncmp</span>()                       类似于<span class="built_in">wcscmp</span>()， 还要指定比较字符字符串的数目 </span><br><span class="line"><span class="built_in">wcslen</span>()        <span class="built_in">strlen</span>()                           获得宽字符串的数目 </span><br><span class="line"><span class="built_in">wcstok</span>()        <span class="built_in">strtok</span>()                          根据标示符把宽字符串分解成一系列字符串 </span><br><span class="line"><span class="built_in">wcswidth</span>()     None                             获得宽字符串的宽度 </span><br><span class="line"><span class="built_in">wcwidth</span>()       None                              获得宽字符的宽度 </span><br><span class="line"></span><br><span class="line">另外还有对应于memory操作 的 <span class="built_in">wmemcpy</span>()， <span class="built_in">wmemchr</span>()， <span class="built_in">wmemcmp</span>()， <span class="built_in">wmemmove</span>()， <span class="built_in">wmemset</span>()．</span><br></pre></td></tr></table></figure>

<h1 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h1><p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/11111.png" alt="img"><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/22222.png" alt="img"></p>
<p>ANSI和UTF8编码下显示结果不同，读入C++，使用窄字符读取不能识别‘？’</p>
<p>而且这个ANSI编码中的’?’，读在程序里ASCII码是-80，不是查表的63；</p>
<p>看UTF8编码中的十六进制显示是176，超过了【-128,127】，经过计算-128+（176-127）-1=-80；</p>
<p>后来使用宽字节读取后显示为汉字的‘°’，是宽字符，所以用窄字符显示的时候，ANSI显示不全。</p>
<h2 id="为什么会是负数"><a href="#为什么会是负数" class="headerlink" title="为什么会是负数"></a><a href="https://blog.csdn.net/kelehaier/article/details/59560419" title="为什么会是负数">为什么会是负数</a></h2><p>最近两天在研究基于位运算的字符串模糊匹配时，在匹配过程中，因为中文的原因，出现了很多问题。最终发现了C++中有一个类型叫做wchar_t，宽字符，用于表示Unicode字符集，很好的解决了string和char在中文表示上的问题。以前没有引起足够的重视，现在在出现了很多问题后才不得不面对这个问题。</p>
<p>在我们常用的类型string和char中，对中文支持并不是很好。在这两种类型中，中文都是两个字节，也就是说中文的汉字要占用两个位置，举个简单的例子，一个“汉”字用一个char是无法表示的，即 char c = ‘汉’ ; 是错误的，必须用 char c[3] = “汉”. 汉字占用两个字节，还有一个结尾符“0/”。string s = “汉” ; s.length()的值是2.</p>
<p>通过以上描述，我们会发现，我们在进行包含中文字符串处理的过程中就会遇到以下问题：在包含数字，字母，汉字的字符串处理中我们应该怎样应付各个字符占多少个字节？总不能在处理之前先转换成ASCII码判断它属于哪种字符在进行处理吧？中文取两个，字母和数字取一个。在进行判断相等与否时也遇到了问题。</p>
<blockquote>
<p>\1. string s = “中国人”; 想知道第二个字是不是“国”字，不能够直接使用 “s[2] == “国””，这样的s[2]是指“国”字的前一个字节代表的数字，是个负数，两个根本无法相等。必须使用 strncmp(&amp;s[2], “国”, 2); 这个函数来进行匹配。这个函数的含义是对字符串进行比较，将从第一个参数位置开始的第三个参数个字符与第二个参数进行比较，如果相等则返回0，不相等就返回1.具体到本例中s[2]开始的2个字符与“国”字进行比较。在这用情况下，不仅增加了表达的复杂度，而且增加了算法的复杂度。</p>
<p>\2. 想进行匹配或者其他处理必须先判断类型，也就是要维护一个几乎和原字符串等长的类型链表，用于标记原字符串各个位置上的类型。在进行操作时，先判断类型，数字和字母等往后挪一位，汉字等往后挪两位，这样即麻烦又浪费存储空间。</p>
<p>\3. 不知者在进行匹配时，用过使用 s[i] == p[j] 时会产生意想不到的结果。我就是问题出在这里。用字母进行匹配时一点问题也没有，简单的几个汉字也没有问题，但是当我使用几万字的两个文本进行匹配时就产生了很大的问题。每个汉字会被拆成两个负整数来表示，假设一个汉字被拆成了-3444，-1235，另外一个被拆成了-6433，-1235，那么本来毫无关系的两个汉字就会错误的被认为成第二个是相等的，最终的结果就会产生错误。</p>
</blockquote>
<p>wchar_t 和 wstring的出现很好的解决了这些问题。</p>
<p>wchar_t c = ‘汉’; 不会出现任何问题。对应的字符串则为wstring。在这两个类型中，默认的情况下字母和数字就占用1个字节，而汉字汉用2个字节，能够很好的解决上面提到的三个问题。如：wstring s = “中国人abc” ; s.length() 的值是6，在string类型下值是9，这基本就是wstring和string的差别。</p>
<p>针对wstring有对应的fopen方法。对于Unicode的文件，使用下面方式读取文件，与默认的不太一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* fp;</span><br><span class="line"><span class="keyword">wchar_t</span> utf[<span class="number">20000</span>], *p = utf;</span><br><span class="line">fp = _wfopen(name.<span class="built_in">c_str</span>(), <span class="string">L&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))</span><br><span class="line"><span class="built_in">fread</span>(p++, <span class="number">1</span>, <span class="number">2</span>, fp);</span><br><span class="line">*--p = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">fclose</span>(fp);[/color]</span><br></pre></td></tr></table></figure>

<p>在宽字符指针p中就存储了文本中的内容。但是记住，一定要是Unicode的编码，如果是其他编码的文本，则会出现乱码。<br>string和char对应的读取字符串的方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* fp = <span class="built_in">fopen</span>(tStr.<span class="built_in">c_str</span>(),rb);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;failed to read&quot;</span>;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">ftell</span>(fp);</span><br><span class="line">cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line"><span class="built_in">rewind</span>(fp);</span><br><span class="line"><span class="keyword">char</span>* pBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(pBuffer, <span class="number">0</span>, len+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">fread</span>(pBuffer, <span class="number">1</span>, len, fp);</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br></pre></td></tr></table></figure>

<p>这样对应文本中的内容就会存在pBuffer中了。另外不能够用方法二只是稍微改动一下，即将char改为wchar_t，string改为wstring，fopen改为_wfopen，就去处理宽字符串，这样是不行的，会在正确文本的结尾产生大量乱码，估计是由于计算 len 的过程中中文按照两个长度算的，导致最后多了很多字符，成为乱码。</p>
<p>最后，记录一下宽字符和字符之间的转换。宽字符和字符实际上是统一的，两个之间只是所使用的字符集不同而已，以下两个函数能够比较理想的实现两者的转化：</p>
<h2 id="将普通字符串转化成宽字符："><a href="#将普通字符串转化成宽字符：" class="headerlink" title="将普通字符串转化成宽字符："></a>将普通字符串转化成宽字符：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pFilePathName = <span class="string">&quot;c:\\aa.dll&quot;</span>; </span><br><span class="line"><span class="keyword">int</span> nLen = <span class="built_in">strlen</span>(pFilePathName) + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> nwLen = <span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, pFilePathName, nLen, <span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">wchar_t</span> lpszFile[<span class="number">256</span>]; </span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, pFilePathName, nLen, lpszFile, nwLen); </span><br></pre></td></tr></table></figure>

<p>最终的宽字符就存储在lpszFile里</p>
<h2 id="将宽字符转化成普通字符："><a href="#将宽字符转化成普通字符：" class="headerlink" title="将宽字符转化成普通字符："></a>将宽字符转化成普通字符：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int bytes = ::WideCharToMultiByte(CP_ACP, 0, tim.c_str(), tim.size(), NULL, 0, NULL, NULL);</span><br><span class="line">std::string strCmd;</span><br><span class="line">strCmd.resize(bytes);</span><br><span class="line">bytes= ::WideCharToMultiByte(CP_ACP, 0, tim.c_str(), tim.size(), const_cast&lt;char*&gt;(strCmd.data()), strCmd.size(), NULL, NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终的普通字符就存储在strCmd里</p>
<h1 id="显示ascii码为负数"><a href="#显示ascii码为负数" class="headerlink" title="显示ascii码为负数??"></a>显示ascii码为负数??</h1><p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/ba176e0a-9b4d-4668-9561-143ceefe9347.png" alt="img"></p>
<p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/b3c89c34-662a-4c52-bb45-184166fcfa38.png" alt="img"></p>
<h1 id="swscanf-s"><a href="#swscanf-s" class="headerlink" title="swscanf_s"></a>swscanf_s</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swscanf_s(timeStamp.c_str(), L&quot;%d-%d-%d %d:%d:%d&quot;,</span><br><span class="line">        &amp;tm.tm_mon, &amp;tm.tm_mday, &amp;tm.tm_year,</span><br><span class="line">        &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec);</span><br></pre></td></tr></table></figure>

<h1 id="strncpy-s"><a href="#strncpy-s" class="headerlink" title="strncpy_s"></a>strncpy_s</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> g_command[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> g_sendmessage[<span class="number">40</span>];<span class="comment">//接收下来的指令</span></span><br><span class="line"></span><br><span class="line">QByteArray ba = command.<span class="built_in">toLatin1</span>(); <span class="comment">// must</span></span><br><span class="line"><span class="built_in">strncpy_s</span>(g_sendbuf, <span class="number">20</span>, ba.<span class="built_in">data</span>(), command.<span class="built_in">length</span>());</span><br><span class="line"><span class="built_in">strncpy_s</span>(g_command, <span class="number">20</span>, ba.<span class="built_in">data</span>(), command.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">ba = sendmessage.<span class="built_in">toLatin1</span>();</span><br><span class="line"><span class="built_in">strncpy_s</span>(g_sendmessage, <span class="number">40</span>, ba.<span class="built_in">data</span>(), sendmessage.<span class="built_in">length</span>());</span><br><span class="line"><span class="built_in">strncpy_s</span>(g_sendbuf + <span class="number">20</span>, <span class="number">40</span>, ba.<span class="built_in">data</span>(), sendmessage.<span class="built_in">length</span>());</span><br></pre></td></tr></table></figure>

<h1 id="sscanf-sprintf"><a href="#sscanf-sprintf" class="headerlink" title="sscanf  sprintf"></a>sscanf  sprintf</h1><p>输入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d,%d,%d,%d,%d,%lf&quot;</span>,</span><br><span class="line">            &amp;boat, &amp;xMin, &amp;yMin,</span><br><span class="line">            &amp;xMax, &amp;yMax, &amp;a);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">doubleToString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;dbNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *chCode;</span><br><span class="line">    chCode = <span class="built_in"><span class="keyword">new</span></span>(std::nothrow)<span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(chCode, <span class="string">&quot;%.2lf&quot;</span>, dbNum);  <span class="comment">// .2 是控制输出bai精度的，两位小数</span></span><br><span class="line">    <span class="function">string <span class="title">strCode</span><span class="params">(chCode)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> []chCode;</span><br><span class="line">    <span class="keyword">return</span> strCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据转换-真实值、ASCII（理解的不对）"><a href="#数据转换-真实值、ASCII（理解的不对）" class="headerlink" title="数据转换-真实值、ASCII（理解的不对）"></a>数据转换-真实值、ASCII（理解的不对）</h1><p>socket发送数据，有两种方式：发送ascii码；发送真实数据。</p>
<p>第一种：发送ascii码（发送字符串，或者string.data()）</p>
<p>字符串里面就是一个一个ascii码追加起来的！</p>
<p>比如1234，要转成“1234”的字符串，然后用sendto或者send发出去，这样的话发送出去的数据就是’1’,’2’,’3’,’4’这样一个一个孤立的ascii码（或者说只要能把数字转换成这种形式（字符串）的函数也行，比如*_itoa<em>）,在收到之后按预留的对应位置取，或者用</em>sscanf*取，<img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/bcf4a515-08cf-49c4-82f8-aa1fce3fc5b4.png" alt="img"></p>
<p>但是*_itoa<em>函数只能处理int，不能处理double和float，可以使用</em>sprintf()*代替，或者干脆简单点，直接弄成string，然后.data()就行了。</p>
<p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/24e049ef-0dbd-40de-a9fe-c6ea36c2ebfa.png" alt="img"></p>
<p><strong>注意，</strong>这样的话发送的字节数和数值类型的字节数就不统一了，比如1234，应该是UINT16，即两个字节，这样转成string就需要4个字节，所以需要预留足够的位置，或者加分隔符。这样每个字节里面存的就是一个ascii码。</p>
<p>我们收到之后再memcpy取出来对应的字节数，然后强转成string，就得到“1234”这个字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送测试</span></span><br><span class="line"><span class="keyword">float</span> _test = <span class="number">25.95</span>;</span><br><span class="line">string _str;</span><br><span class="line">_str = <span class="built_in">to_string</span>(_test) +<span class="string">&quot;,&quot;</span>+ <span class="built_in">to_string</span>(_test - <span class="number">10</span>);<span class="comment">//_str = &quot;25.950001,15.950001&quot;</span></span><br><span class="line"><span class="comment">//先拷贝在char * 里面，在转成float,字节数变了25.95变成25.950000一共占9个字节，是孤立的</span></span><br><span class="line"><span class="keyword">char</span> _test3[<span class="number">9</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(_test3, _str.<span class="built_in">data</span>(), <span class="number">9</span>);<span class="comment">//_test3 = 0x15c1f8ac &quot;25.950001&quot;</span></span><br><span class="line"><span class="keyword">float</span> _test4 = <span class="built_in">atof</span>(_test3);<span class="comment">//25.950008</span></span><br><span class="line"><span class="built_in">memcpy</span>(_test3, _str.<span class="built_in">data</span>() + <span class="number">10</span>, <span class="number">9</span>);<span class="comment">//_test3 = 0x15c1f8ac &quot;15.950001&quot;</span></span><br><span class="line">_test4 = <span class="built_in">atof</span>(_test3);<span class="comment">//15.950008</span></span><br><span class="line"><span class="comment">//或者用sscanf直接把字符串转成float</span></span><br><span class="line"><span class="keyword">float</span> _test1, _test2;</span><br><span class="line"><span class="built_in">sscanf</span>(_str.<span class="built_in">data</span>(), <span class="string">&quot;%f,%f&quot;</span>, &amp;_test1, &amp;_test2);<span class="comment">//25.950008，15.950008</span></span><br><span class="line"><span class="comment">/*********************下面是真实数据那一套，不正确，作为整体拷贝************************/</span></span><br><span class="line"><span class="comment">//直接使用cpy，拷贝到float中</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;_test2, _str.<span class="built_in">data</span>(), <span class="built_in"><span class="keyword">sizeof</span></span>(_test));<span class="comment">//_test2 = 0.000166137499</span></span><br><span class="line"><span class="comment">//下面这个是错的，因为转成字符串发送过来之后字节数就变了25.95变成25.950000一共占9个字节</span></span><br><span class="line"><span class="comment">//memcpy(&amp;_test2, _str.data() + sizeof(_test), sizeof(_test));</span></span><br></pre></td></tr></table></figure>

<p>第二种：发送真实数据</p>
<p>如果我们用memcpy函数来直接由内存转换，1234这个int，转换之后结果如下</p>
<p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/81937487-440c-48ce-b348-4476c6545a7b.png" alt="img"></p>
<p>这是因为什么呢？*_itoa()<em>函数会把1234一个一个整数转换成对应的ascii码( (n % 10)+’0’ ),所以得到的string就是’1’,’2’,’3’,’4’，但是</em>memcpy(void *dest, void *src, unsigned int *count*)*是由src所指内存区域复制count个字节到dest所指内存区域，比如1234，占UINT16即两个字节，把对应字节的东西拷贝到sendbuf中，那sendbuf每个字节对应的都是对应位置的内容，如1234的二进制是10011010010 ，8位一个字节，则可以分成两个部分，分别是100和11010010，二进制100=4，而二进制11010010=210，大于127（sendbuf是有符号的），所以210-127=83，然后从-128又开始网上加，-128+83=-45，然后-45-1=-46恰好和程序中的吻合。</p>
<p>为什么要210-127+（-128）-1呢？210-127是比最大值大多少(83)，说明是从起点开始，第83个数，起点是多少，是-128，那第83个数是多少，-128+83-1=-46。</p>
<p>这样发送过去的就是真实的数据，在取的时候，直接用</p>
<p>int _test2; <em>memcpy</em>(&amp;_test2, _test1, sizeof(_test));</p>
<p>把内存整体复制到int类型的_test2变量中，_test2就是1234，不能使用字符串的那一套，因为这并不是字符串，存储的并不是ascii码，不是孤立的，拼起来啥都不是。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送测试</span></span><br><span class="line"><span class="keyword">float</span> _test = <span class="number">25.95</span>;</span><br><span class="line"><span class="keyword">char</span> _test1[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(_test1, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//赋值给char *</span></span><br><span class="line"><span class="built_in">memcpy</span>(_test1, &amp;_test, <span class="built_in"><span class="keyword">sizeof</span></span>(_test));</span><br><span class="line">_test -= <span class="number">10</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(_test1 + <span class="built_in"><span class="keyword">sizeof</span></span>(_test), &amp;_test, <span class="built_in"><span class="keyword">sizeof</span></span>(_test));</span><br><span class="line"><span class="comment">//直接使用cpy，拷贝到float中,原来占多少字节就是多少字节,作为一个整体拷贝进去</span></span><br><span class="line"><span class="keyword">float</span> _test2;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;_test2, _test1, <span class="built_in"><span class="keyword">sizeof</span></span>(_test));<span class="comment">//25.95</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;_test2, _test1 + <span class="built_in"><span class="keyword">sizeof</span></span>(_test), <span class="built_in"><span class="keyword">sizeof</span></span>(_test));<span class="comment">//25.95</span></span><br><span class="line"><span class="comment">/*********************下面是字符串那一套，不正确************************/</span></span><br><span class="line"><span class="comment">//先拷贝在char * 里面，在转成float，每个字节是孤立的</span></span><br><span class="line"><span class="keyword">char</span> _test3[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(_test3, _test1, <span class="built_in"><span class="keyword">sizeof</span></span>(_test));</span><br><span class="line"><span class="comment">//把_test3当成了存储ascii码的字符串,[0] = -102 &#x27;?&#x27;,[1] = -102 &#x27;?&#x27;，[2] = -49 &#x27;?&#x27;，[3] = 65 &#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">float</span> _test4 = <span class="built_in">atof</span>(_test3);<span class="comment">//0.0000，</span></span><br><span class="line"><span class="built_in">memcpy</span>(_test3, _test1 + <span class="built_in"><span class="keyword">sizeof</span></span>(_test), <span class="built_in"><span class="keyword">sizeof</span></span>(_test));</span><br><span class="line"><span class="comment">//把_test3当成了存储ascii码的字符串,[0] = 52 &#x27;4&#x27;,[1] = 51 &#x27;3&#x27;，[2] = 127 &#x27;•&#x27;，[3] = 65 &#x27;A&#x27;</span></span><br><span class="line">_test4 = <span class="built_in">atof</span>(_test3);<span class="comment">//43.0000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float转char </span></span><br><span class="line"><span class="keyword">float</span> a = <span class="number">12.54</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">char</span> *sendbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> number[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(number, <span class="string">&quot;%f&quot;</span>,a);</span><br><span class="line"><span class="built_in">memcpy</span>(sendbuf, &amp;number, <span class="built_in"><span class="keyword">sizeof</span></span>(number));</span><br><span class="line"><span class="built_in">memset</span>(number, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(number));</span><br><span class="line"><span class="built_in">sprintf</span>(number, <span class="string">&quot;%f&quot;</span>, b);</span><br><span class="line"><span class="built_in">memcpy</span>(sendbuf + <span class="built_in"><span class="keyword">sizeof</span></span>(number), &amp;(number), <span class="built_in"><span class="keyword">sizeof</span></span>(number));</span><br></pre></td></tr></table></figure>

<h1 id="数据转换-真实值、ASCII（其实都是值）"><a href="#数据转换-真实值、ASCII（其实都是值）" class="headerlink" title="数据转换-真实值、ASCII（其实都是值）"></a>数据转换-真实值、ASCII（其实都是值）</h1><p>网络发送都是发送的内存值，只不过解析的时候按照类型来不同的解析，1234，在short里是-46 4 0 0，在字符串里是‘1’ ‘2’ ‘3’ ‘4’ ‘/0’，根据类型来解析，发送的时候，short是&amp;,字符串是.data() ,但是都发送的是内存存储的值，short是-46 4 0 0，字符串里是‘1’ ‘2’ ‘3’ ‘4’ ‘/0’，接收到之后再相应的转换memcpy。</p>
<p>原型：void* memcpy(void * dest, const void * src, unsigned int count); </p>
<p>功能：由src所指内存区域复制count个字节到dest所指内存区域。 </p>
<p>说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针。 </p>
<h1 id="数组与结构体取内存值"><a href="#数组与结构体取内存值" class="headerlink" title="数组与结构体取内存值"></a>数组与结构体取内存值</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;test&gt; tes;</span><br><span class="line">test temp;</span><br><span class="line">temp.a=<span class="number">1111</span>;</span><br><span class="line">temp.b=<span class="number">2222</span>;</span><br><span class="line">tes.<span class="built_in">push_back</span>(temp);</span><br><span class="line">tes.<span class="built_in">push_back</span>(temp);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;&amp;=&quot;</span>&lt;&lt;&amp;tes&lt;&lt;<span class="string">&quot;  1=&quot;</span>&lt;&lt;&amp;tes[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;  2=&quot;</span>&lt;&lt;&amp;tes[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来的结果是</span></span><br><span class="line"><span class="comment">//&amp;= 0x27992ffa38   1= 0x18e04293e00   2= 0x18e04293e08</span></span><br><span class="line"><span class="comment">//从这可以看出来，首先，结构体的内存是连续的，其次，容器内的模板数据内存是连续的，但是容器的内存和模板数据的内存不连续，</span></span><br><span class="line"><span class="comment">//因此在发送网络数据时，不能对容器直接取地址然后发送，需要对容器内的数据取地址再发送：</span></span><br><span class="line"><span class="comment">//sendbuf.append(QByteArray((char*)&amp;tes[0], sizeof(test)*tes.size()));</span></span><br><span class="line"><span class="comment">//相应的,在接收端也需要如此取</span></span><br></pre></td></tr></table></figure>

<p>个人理解：<br>容器除了模板数据之外，还有其他变量，容器是类，里面包含了模板数据、对数据的描述（个数等），这些加起来的长度和模板数据本身<br>的大小不一致，不能完全取地址发送，简单点，vector里面还有容量这个成员变量，发送端容量和接收端容量不一致，导致两者字节数不匹配</p>
<p>#可变长结构体内存拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUF_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_one</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s_one_cnt;</span><br><span class="line">    <span class="keyword">char</span>*s_one_buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_two</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s_two_cnt;</span><br><span class="line">    <span class="keyword">char</span> s_two_buf[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_three</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s_three_cnt;</span><br><span class="line">    <span class="keyword">char</span> s_three_buf[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//赋值用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* tmp_buf = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ntmp_buf_size = <span class="built_in">strlen</span>(tmp_buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;1&gt;注意s_one 与s_two的大小的不同</span></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sizeof(s_one) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s_one) &lt;&lt; endl; <span class="comment">//8</span></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sizeof(s_two) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s_two) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;sizeof(s_three) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s_three) &lt;&lt; endl;<span class="comment">//5--&gt;8结构体对齐</span></span><br><span class="line">    cout&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为buf分配空间</span></span><br><span class="line">    <span class="keyword">int</span> ntotal_stwo_onw= <span class="number">1</span> + ntmp_buf_size;</span><br><span class="line">    <span class="keyword">int</span> ntotal_stwo_len = <span class="built_in"><span class="keyword">sizeof</span></span>(s_two) + (<span class="number">1</span> + ntmp_buf_size) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);<span class="comment">//+1是因为char数组最后一位是/0</span></span><br><span class="line">    <span class="keyword">int</span> ntotal_sthree_len = <span class="built_in"><span class="keyword">sizeof</span></span>(s_three) + ntmp_buf_size * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给s_one buf赋值</span></span><br><span class="line">    s_one*p_sone = (s_one*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(s_one));</span><br><span class="line">    <span class="built_in">memset</span>(p_sone,<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s_one));</span><br><span class="line">    p_sone-&gt;s_one_buf= (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(ntotal_stwo_onw);</span><br><span class="line">    <span class="built_in">memset</span>(p_sone-&gt;s_one_buf,<span class="number">0</span>, ntotal_stwo_onw);</span><br><span class="line">    <span class="built_in">memcpy</span>(p_sone-&gt;s_one_buf,tmp_buf, ntmp_buf_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给s_two buf赋值</span></span><br><span class="line">    s_two*p_stwo = (s_two*)<span class="built_in">malloc</span>(ntotal_stwo_len);</span><br><span class="line">    <span class="built_in">memset</span>(p_stwo,<span class="number">0</span>, ntotal_stwo_len);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)(p_stwo-&gt;s_two_buf),tmp_buf, ntmp_buf_size);  <span class="comment">//不用加偏移量，直接拷贝!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给s_three_buf赋值</span></span><br><span class="line">    s_three*p_sthree = (s_three*)<span class="built_in">malloc</span>(ntotal_sthree_len);</span><br><span class="line">    <span class="built_in">memset</span>(p_sthree,<span class="number">0</span>, ntotal_sthree_len);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)(p_sthree-&gt;s_three_buf),tmp_buf, ntmp_buf_size);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;p_sone-&gt;s_one_buf = &quot;</span> &lt;&lt; p_sone-&gt;s_one_buf&lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;p_stwo-&gt;s_two_buf = &quot;</span> &lt;&lt; p_stwo-&gt;s_two_buf&lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;p_sthree-&gt;s_three_buf = &quot;</span> &lt;&lt;p_sthree-&gt;s_three_buf &lt;&lt; endl; <span class="comment">//不用加偏移量，直接拷贝!</span></span><br><span class="line">    cout&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;2&gt;注意s_one 与s_two释放的不同！</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != p_sone-&gt;s_one_buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p_sone-&gt;s_one_buf);</span><br><span class="line">        p_sone-&gt;s_one_buf= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != p_sone)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(p_sone);</span><br><span class="line">            p_sone= <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;free(p_sone) successed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != p_stwo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p_stwo);</span><br><span class="line">        p_stwo= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;free(p_stwo) successed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != p_sthree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p_sthree);</span><br><span class="line">        p_sthree= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;free(p_sthree) successed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比结果，我们能发现：<br>&lt;1&gt; 存储大小方面：s_two的存储较s_one、s_three都要少，[0]的好处，即用指针的方式需要多开辟存储空间的。<br>&lt;2&gt; 数据连续存储方面：s_one明显数据域是单独开辟的空间，与前的nsize不在连续的存储区域，而s_two，s_three则在连续的存储空间下。<br>&lt;3&gt; 释放内存方面：显然s_one的指针的方式，需要先释放数据域部分，才能释放指向结构体的指针变量；而s_two，s_three可以直接释放。</p>
<p>总结如下：</p>
<p>结构体最后使用0或1的长度数组的原因，主要是为了方便的管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）。</p>
<p>而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。</p>
<p>其实变长结构体就是分配一段连续的的内存，减少内存的碎片化，简化内存的管理。</p>
<p>#可变长结构体网络发送</p>
<p><a href="https://www.cnblogs.com/yongdaimi/p/14120907.html">https://www.cnblogs.com/yongdaimi/p/14120907.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QBuffer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileInfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QUdpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImageReader&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inside</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">2</span>;</span><br><span class="line">    inside _inside[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line">QTcpSocket *m_tcp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    inside _temp[<span class="number">2</span>];</span><br><span class="line">    _temp[<span class="number">0</span>].a=<span class="number">111</span>;</span><br><span class="line">    _temp[<span class="number">0</span>].b=<span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">    _temp[<span class="number">1</span>].a=<span class="number">111</span>;</span><br><span class="line">    _temp[<span class="number">1</span>].b=<span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _structLength = <span class="built_in"><span class="keyword">sizeof</span></span>(test) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(inside);</span><br><span class="line"></span><br><span class="line">    test* p_test = (test*)<span class="built_in">malloc</span>(_structLength);</span><br><span class="line">    <span class="built_in">memset</span>(p_test,<span class="number">0</span>, _structLength);</span><br><span class="line">    p_test-&gt;c=<span class="number">1</span>;</span><br><span class="line">    p_test-&gt;d=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)(p_test-&gt;_inside),_temp, <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span> (inside));</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;sizeof(inside)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span> (inside)&lt;&lt;<span class="string">&quot;,sizeof(test)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span> (test)&lt;&lt;<span class="string">&quot;,_structLength=&quot;</span>&lt;&lt;_structLength</span><br><span class="line">           &lt;&lt;<span class="string">&quot;,p_test.c=&quot;</span>&lt;&lt;p_test-&gt;c&lt;&lt;<span class="string">&quot;,p_test.d=&quot;</span>&lt;&lt;p_test-&gt;d</span><br><span class="line">          &lt;&lt;<span class="string">&quot;,p_test._inside[0].a=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">0</span>].a&lt;&lt;<span class="string">&quot;,p_test._inside[0].b=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">0</span>].b</span><br><span class="line">         &lt;&lt;<span class="string">&quot;,p_test._inside[1].a=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">1</span>].a&lt;&lt;<span class="string">&quot;,p_test._inside[1].b=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">1</span>].b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m_tcp = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line">    m_tcp-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(<span class="string">&quot;10.16.52.102&quot;</span>),<span class="number">8010</span>);<span class="comment">//(&quot;159.226.20.181&quot;),9999);//</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">waitForConnected</span>();</span><br><span class="line"></span><br><span class="line">    QByteArray sendBuf=<span class="built_in">QByteArray</span>((<span class="keyword">char</span>*)p_test, _structLength);</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(sendBuf);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECEIVE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECEIVE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QUdpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpServer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REAL32 float</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receive</span>:</span><span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Receive</span>();</span><br><span class="line"></span><br><span class="line">    QUdpSocket* m_reciver;</span><br><span class="line"></span><br><span class="line">    QTcpServer *m_tcpServer =<span class="literal">NULL</span>;<span class="comment">//监听套接字</span></span><br><span class="line">    QTcpSocket *m_tcpSocket;<span class="comment">//通信套接字</span></span><br><span class="line"></span><br><span class="line">    QByteArray m_buf;</span><br><span class="line">    QByteArray m_Msgdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_connecting</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">slot_TCPgetMes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RECEIVE_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Receive.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QBuffer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDir&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImageReader&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inside</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    inside _inside[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Receive::<span class="built_in">Receive</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//监听套接字</span></span><br><span class="line">    m_tcpServer = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    m_tcpServer-&gt;<span class="built_in">listen</span>(<span class="built_in">QHostAddress</span>(<span class="string">&quot;10.16.52.102&quot;</span>),<span class="number">8010</span>);<span class="comment">//(&quot;172.18.12.10&quot;),4391);//(&quot;172.18.12.10&quot;),4391);</span></span><br><span class="line">    <span class="comment">//如果客户端成功和服务器连接</span></span><br><span class="line">    <span class="comment">//tcpServer 会自动触发   newConnection()</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcpServer,<span class="built_in">SIGNAL</span>(<span class="built_in">newConnection</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_connecting</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive::slot_connecting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//取出建立好连接的套接字</span></span><br><span class="line">    m_tcpSocket = m_tcpServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对方的ip和端口</span></span><br><span class="line">    QString ip = m_tcpSocket-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toString</span>();</span><br><span class="line">    quint16 port = m_tcpSocket-&gt;<span class="built_in">peerPort</span>();</span><br><span class="line">    QString str = QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;[%1 : %2] 成功连接&quot;</span>).<span class="built_in">arg</span>(ip).<span class="built_in">arg</span>(port);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Connected OK.&quot;</span>&lt;&lt;str;</span><br><span class="line">    <span class="built_in">connect</span>(m_tcpSocket,<span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">slot_TCPgetMes</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive::slot_TCPgetMes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QByteArray value= m_tcpSocket-&gt;<span class="built_in">readAll</span>();<span class="comment">//分包</span></span><br><span class="line"></span><br><span class="line">    inside _temp[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> _structLength = <span class="built_in"><span class="keyword">sizeof</span></span>(test) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(inside);</span><br><span class="line"></span><br><span class="line">    test* p_test = (test*)<span class="built_in">malloc</span>(_structLength);</span><br><span class="line">    <span class="built_in">memset</span>(p_test,<span class="number">0</span>, _structLength);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)(p_test),value, value.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;sizeof(inside)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span> (inside)&lt;&lt;<span class="string">&quot;,sizeof(test)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span> (test)&lt;&lt;<span class="string">&quot;,_structLength=&quot;</span>&lt;&lt;_structLength</span><br><span class="line">           &lt;&lt;<span class="string">&quot;,p_test.c=&quot;</span>&lt;&lt;p_test-&gt;c&lt;&lt;<span class="string">&quot;,p_test.d=&quot;</span>&lt;&lt;p_test-&gt;d</span><br><span class="line">          &lt;&lt;<span class="string">&quot;,p_test._inside[0].a=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">0</span>].a&lt;&lt;<span class="string">&quot;,p_test._inside[0].b=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">0</span>].b</span><br><span class="line">         &lt;&lt;<span class="string">&quot;,p_test._inside[1].a=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">1</span>].a&lt;&lt;<span class="string">&quot;,p_test._inside[1].b=&quot;</span>&lt;&lt;p_test-&gt;_inside[<span class="number">1</span>].b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sizeof-、strlen-、str-length"><a href="#sizeof-、strlen-、str-length" class="headerlink" title="sizeof() 、strlen()、str.length()"></a>sizeof() 、strlen()、str.length()</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(C/C++ <span class="built_in">strlen</span>(str)和str.<span class="built_in">length</span>()和str.<span class="built_in">size</span>()都可以求字符串长度。</span><br><span class="line"></span><br><span class="line">其中str.<span class="built_in">length</span>()和str.<span class="built_in">size</span>()是用于求string类对象的成员函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">strlen</span>(str)是用于求字符数组的长度，其参数是<span class="keyword">char</span>*。)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	第一种：<span class="built_in">strlen</span>(<span class="keyword">char</span>*)函数求的是字符串的实际长度，它求得方法是从开始到遇到第一个<span class="string">&#x27;\0&#x27;</span>,如果你只定义没有给它赋初值，这个结果是不定的，它会从aa首地址一直找下去，直到遇到<span class="string">&#x27;\0&#x27;</span>停止。</span><br><span class="line">	第二种：<span class="built_in"><span class="keyword">sizeof</span></span>(),求所占总空间的字节数。</span><br><span class="line">这里例如  </span><br><span class="line"><span class="keyword">char</span>[] a=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(a)的值应该为<span class="number">3</span>。</span><br><span class="line"><span class="keyword">char</span>[] b=&#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(b)的值应该是<span class="number">4</span>。</span><br><span class="line">若string str=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;X&#x27;</span>&#125;;</span><br><span class="line">那么<span class="built_in"><span class="keyword">sizeof</span></span>(str)为<span class="number">5</span>，<span class="built_in">strlen</span>(str)为<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<h1 id="Qt显示中文"><a href="#Qt显示中文" class="headerlink" title="Qt显示中文"></a>Qt显示中文</h1><h2 id="Windows-接收、发送"><a href="#Windows-接收、发送" class="headerlink" title="Windows 接收、发送"></a>Windows 接收、发送</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">文件编码用system</span><br><span class="line">QString str;</span><br><span class="line">str.<span class="built_in">append</span>(QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;摄像头类型:S:&quot;</span>));</span><br><span class="line"><span class="function">emit <span class="title">signal_sendStatus</span><span class="params">(str.toLocal8Bit())</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="Linux-发送"><a href="#Linux-发送" class="headerlink" title="Linux 发送"></a>Linux 发送</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">文件编码用UTF<span class="number">-8</span></span><br><span class="line">QTextCodec *code= QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">QString strtest = <span class="string">&quot;你好Test&quot;</span>;</span><br><span class="line">QByteArray bytest = code-&gt;<span class="built_in">fromUnicode</span>( strtest );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收未测试</span></span><br><span class="line">QTextCodec *tc =QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">QByteArray ba = file.<span class="built_in">readAll</span>();</span><br><span class="line">QString str =tc-&gt;<span class="built_in">toUnicode</span>(ba);</span><br></pre></td></tr></table></figure>

<h1 id="字符串转16进制"><a href="#字符串转16进制" class="headerlink" title="字符串转16进制"></a>字符串转16进制</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string_to_hex</span><span class="params">(QString hex,QByteArray &amp;qbyte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hex=hex.<span class="built_in">trimmed</span>();</span><br><span class="line"> </span><br><span class="line">    QStringList sl=hex.<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    foreach(QString s,sl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">isEmpty</span>())</span><br><span class="line">            qbyte.<span class="built_in">append</span>((<span class="keyword">char</span>)s.<span class="built_in">toInt</span>(<span class="number">0</span>,<span class="number">16</span>)&amp;<span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来输出16进制</span></span><br><span class="line">QString str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;_str.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    str.<span class="built_in">append</span>(<span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)_str[i],<span class="number">2</span>,<span class="number">16</span>,<span class="built_in">QLatin1Char</span>(<span class="string">&#x27;0&#x27;</span>)).<span class="built_in">toUpper</span>());</span><br><span class="line">    str.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="QByteArray-转换为16进制字符串QString"><a href="#QByteArray-转换为16进制字符串QString" class="headerlink" title="QByteArray 转换为16进制字符串QString"></a>QByteArray 转换为16进制字符串QString</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">MainWindow::ByteArrayToHexString</span><span class="params">(QByteArray data)</span></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">ret</span><span class="params">(data.toHex().toUpper())</span></span>;</span><br><span class="line">    <span class="keyword">int</span> len = ret.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;i;</span><br><span class="line">        ret.<span class="built_in">insert</span>(<span class="number">2</span>*i+i<span class="number">-1</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16进制字符串QString转换QByteArray"><a href="#16进制字符串QString转换QByteArray" class="headerlink" title="16进制字符串QString转换QByteArray"></a><a href="https://so.csdn.net/so/search?q=16%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">16进制</a>字符串QString转换QByteArray</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @breif 将16进制字符串转换为对应的字节序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">QByteArray <span class="title">HexStringToByteArray</span><span class="params">(QString HexString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    QByteArray ret;</span><br><span class="line">    HexString = HexString.<span class="built_in">trimmed</span>();</span><br><span class="line">    HexString = HexString.<span class="built_in">simplified</span>();</span><br><span class="line">    QStringList sl = HexString.<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    foreach (QString s, sl) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.<span class="built_in">toInt</span>(&amp;ok,<span class="number">16</span>)&amp;<span class="number">0xFF</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">                ret.<span class="built_in">append</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;非法的16进制字符：&quot;</span>&lt;&lt;s;</span><br><span class="line">                QMessageBox::<span class="built_in">warning</span>(<span class="number">0</span>,<span class="built_in">tr</span>(<span class="string">&quot;错误：&quot;</span>),<span class="built_in">QString</span>(<span class="string">&quot;非法的16进制字符: \&quot;%1\&quot;&quot;</span>).<span class="built_in">arg</span>(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="IO输出截断"><a href="#IO输出截断" class="headerlink" title="IO输出截断"></a>IO输出截断</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">* index： 0    1    2    3</span></span><br><span class="line"><span class="comment">* —————————————————————————</span></span><br><span class="line"><span class="comment">* temp: 0x64 0x00 0x64 0x00</span></span><br><span class="line"><span class="comment">*IO输出时，只要中间有\0,后续输出均会被截断,如上，会在index为1的地方截断，在下面去Debug的地方，-2-后面就没有了</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">***************************************/</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;output:&quot;</span>&lt;&lt;<span class="string">&quot;-1-&quot;</span>&lt;&lt;temp[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;-2-&quot;</span>&lt;&lt;temp[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;-3-&quot;</span>&lt;&lt;temp[<span class="number">2</span>]&lt;&lt;<span class="string">&quot;-4-&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符串碰到\0就会终止输出，不光是整个字符串，连续输出时也会如此！！！</p>
<p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/image-20231218182757834.png" alt="image-20231218182757834"></p>
<p>想要避免这个问题，把输出的字符串转换成非字符形式即可！</p>
<p><img src="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/image-20231218182739433.png" alt="image-20231218182739433"></p>
<h1 id="x-0x区别"><a href="#x-0x区别" class="headerlink" title="\x,0x区别"></a>\x,0x区别</h1><ul>
<li><code>0x</code> 用于表示整数值的十六进制形式，通常用于整数或指针等数据类型。</li>
<li><code>\x</code> 用于表示字符的十六进制值，通常用于字符串或字符常量中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- <span class="number">0</span>x 表示整型数值（十六进制）。</span><br><span class="line">	 <span class="number">0x41</span> = <span class="number">65</span>  </span><br><span class="line">	 <span class="number">0</span>o41 = <span class="number">33</span> </span><br><span class="line">	 <span class="number">0b101</span> = <span class="number">5</span></span><br><span class="line">-<span class="string">&#x27;\x&#x27;</span> 表示字符串表达（带引号）</span><br><span class="line">	<span class="string">&#x27;\x41&#x27;</span> 表示 <span class="string">&#x27;A&#x27;</span></span><br><span class="line">	<span class="string">&#x27;\x42&#x27;</span> 表示 <span class="string">&#x27;B&#x27;</span></span><br><span class="line">- \ 表示转义</span><br></pre></td></tr></table></figure>



<p>0x 表示法<br>0x 表示法是C语言中用于表示十六进制数字的标准表示方法。它的形式是一个前缀 0x，后跟一个十六进制数字序列。这个前缀告诉编译器，后面的数字应该被解释为十六进制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hexValue = <span class="number">0x1A</span>;</span><br><span class="line"><span class="comment">// 十六进制数值 0x1A 表示十进制数值 26</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，0x1A 表示一个十六进制数，它等于十进制数值 26。</p>
<p>\x 转义序列<br>\x 转义序列是用于表示字符的十六进制值的方法。它的形式是 \x 后跟两个十六进制数字，用于表示一个字符。这通常用于字符串中，以表示包含特殊字符的字符序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> specialChar = <span class="string">&#x27;\x0A&#x27;</span>;</span><br><span class="line"><span class="comment">// 表示换行字符</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，\x0A 表示一个字符，它是ASCII码中的换行字符。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数</title>
    <url>/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 </p>
<p><a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin">https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin</a> </p>
<p>回调函数机制： </p>
<p>1、定义一个函数（普通函数即可）； </p>
<p>2、将此函数的地址注册给调用者； </p>
<p>3、特定的事件或条件发生时，调用者使用函数指针调用回调函数。 </p>
<p>注：为什么要特定事件或条件发生？不应该随时都可以调用回调函数吗？ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,callback p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">add</span>(<span class="number">4</span>,<span class="number">2</span>,add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(callBack)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="keyword">size_t</span> size,<span class="keyword">char</span> *p_out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(callBack *consume_bytes, <span class="keyword">char</span> *p_out)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callFunc\n&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">consume_bytes</span>(buffer,<span class="number">0</span>,p_out); <span class="comment">//传入值可以随便填</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callBackFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">char</span> *p_out)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callBackFunc\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p_out,<span class="number">0x00</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p_out,<span class="string">&quot;encoderCallback:this is string.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p_out[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">callFunc</span>(callBackFunc,p_out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p_out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> student_id;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> student_age;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Student</span>&#123;</span></span><br><span class="line">    student_id id;</span><br><span class="line">    student_age age;</span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="comment">//类型重定义：函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*pFun)</span><span class="params">(Student, Student)</span></span>;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//冒泡排序法：能够按AGE或ID排序，用同一个函数实现</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Student stu[],<span class="keyword">const</span> <span class="keyword">int</span> num,pFun fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">　　&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num - i <span class="number">-1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((*fun)(stu[j],stu[j+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = stu[j];</span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//回调函数：比较年龄</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CompareAge</span><span class="params">(Student stu1,Student stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//更改从大到小还是从小到大的顺序，只需反一下。</span></span><br><span class="line">    <span class="keyword">if</span>(stu1.age &lt; stu2.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//回调函数：比较id</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CompareId</span><span class="params">(Student stu1,Student stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//更改从大到小还是从小到大的顺序，只需反一下。</span></span><br><span class="line">    <span class="keyword">if</span>(stu1.id &lt; stu2.id)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stu[] = &#123;</span><br><span class="line">    &#123;<span class="number">1103</span>,<span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1102</span>,<span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1104</span>,<span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1107</span>,<span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1105</span>,<span class="number">21</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    pFun fun = CompareAge;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(stu)/<span class="built_in"><span class="keyword">sizeof</span></span>(Student);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(stu,size,fun);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,stu[i].id,stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是回？"><a href="#什么是回？" class="headerlink" title="什么是回？"></a>什么是回？</h2><p>根据上面的代码，我们知道，库开发方提供了一个方法，然后形参又带有一个函数指针，等着用户去写然后拿来调用，并在其实现中调用了这个函数。<em>站在库开发方的立场</em>，我们可以总结为一句话：库开发方调用了用户的函数（回调函数）。</p>
<p>现在，我们把视角移到<em>回调函数的立场</em>上来看，它被调用了。但同时它也有参数，且传进来的参数是库开发方提供的数据，这里我们又可以总结一句话：回调函数调用了库开发方的数据。</p>
<p>这就是<em>“回”</em>的意思，你调我我也调用你，双方互相调用。</p>
<p><img src="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/0.6947029617222265.png" alt="img"></p>
<h2 id="回调函数的重点是什么"><a href="#回调函数的重点是什么" class="headerlink" title="回调函数的重点是什么?"></a>回调函数的重点是什么?</h2><p>根据上文分析，发现回调函数其实也不是难于理解，我觉得重点在于一定要划分清楚谁是库开发方（也可称为提供方，调用者），谁是用户，把<em>职能</em>划分清楚是最关键的。</p>
<p>库函数中的sort排序是怎么弄的。algorithm它提供了某些排序算法的实现（如冒泡排序、快速排序、shell排序、shake排序等等），为了能让库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，能让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">5</span>,<span class="number">43</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">74</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(a,a+<span class="number">10</span>,cmp);<span class="comment">//callback</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++可以使用全局函数和静态函数作为回调函数。考虑到全局函数会破坏封装性，所以一般都用静态成员函数。故除了理解函数指针，还要理解静态成员函数，具体一点是在静态成员函数中访问非静态成员函数的方法，因为我们很可能需要获取静态成员函数中的数据。</p>
<p>　　<strong>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</strong>下面通过例子来说明这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> …</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">M</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        A=a;</span><br><span class="line">        B+=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(M m)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">M::f1</span><span class="params">(M m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A=&quot;</span>&lt;&lt;m.a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> M::B=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">M <span class="title">P</span><span class="params">(<span class="number">5</span>)</span>,<span class="title">Q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    M::<span class="built_in">f1</span>(P); <span class="comment">//调用时不用对象名</span></span><br><span class="line">    M::<span class="built_in">f1</span>(Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/sinat_38183777/article/details/83958887">https://blog.csdn.net/sinat_38183777/article/details/83958887</a> </p>
<p><a href="https://blog.csdn.net/qq_32323543/article/details/79738952">https://blog.csdn.net/qq_32323543/article/details/79738952</a> </p>
<p>流程：</p>
<p>接收和使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1.先申明一个函数指针：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span><span class="params">(*replayFunc)</span><span class="params">(<span class="keyword">void</span> * user_parm)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileMergeThread</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//2.接收这个指针和回调函数的参数（函数指针和回调函数的参数要分开）：</span></span><br><span class="line">    <span class="built_in">FileMergeThread</span>(replayFunc func,<span class="keyword">void</span> * parm,QObject *parent =<span class="literal">NULL</span>);</span><br><span class="line">    ~<span class="built_in">FileMergeThread</span>();</span><br><span class="line">    <span class="comment">//3.声明保存回调函数指针的变量</span></span><br><span class="line">    replayFunc m_callback;</span><br><span class="line">    <span class="comment">//4.声明保存回调函数参数变量的变量</span></span><br><span class="line">    <span class="keyword">void</span> *m_parm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FileMergeThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt_io.h&gt;</span></span></span><br><span class="line">FileMergeThread::<span class="built_in">FileMergeThread</span>(replayFunc func, <span class="keyword">void</span> * parm, QObject *parent)</span><br><span class="line">    : <span class="built_in">QThread</span>(parent),</span><br><span class="line">    <span class="comment">//5.赋值回调函数</span></span><br><span class="line">    <span class="built_in">m_callback</span>(func),</span><br><span class="line">    <span class="comment">//6.赋值回调函数参数</span></span><br><span class="line">    <span class="built_in">m_parm</span>(parm)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">FileMergeThread::~<span class="built_in">FileMergeThread</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileMergeThread::createConfigText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//7.在任意地方调用回调函数</span></span><br><span class="line">    <span class="built_in">m_callback</span>(m_parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向目标类注册回调函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8.回调函数体(需要是全局函数或者静态函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">void</span> * user_parm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FilePlay *parm = (FilePlay *)user_parm;</span><br><span class="line">    parm-&gt;<span class="built_in">readFileConfigText</span>();</span><br><span class="line">    parm-&gt;<span class="built_in">SetSilderRange</span>();</span><br><span class="line">    parm-&gt;<span class="built_in">sliderValueChanged</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传递回调函数，船给子类</span></span><br><span class="line"><span class="built_in">m_pMergeThread</span>(<span class="keyword">new</span> <span class="built_in">FileMergeThread</span>(start,<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>



<h2 id="Const-define-enum"><a href="#Const-define-enum" class="headerlink" title="Const #define enum"></a>Const #define enum</h2><p>1.区别</p>
<p>这三种都可以定义常量。</p>
<p>define是宏定义，编译器不对其进行错误检查，在预编译阶段处理，没有作用域限制属于全局常量，在程序中编译器会对定义的常量名以数值进行替换，且每次替换都分配内存，此方法对于大量常量的情况下会占用较多内存从而导致程序效率；</p>
<p>const是常量定义，在编译阶段处理，作用域限制，定义常量分配内存后后续再使用常量情况下不会再为其分配内存，只分配一份内存地址（static 局部只初始化一次，和实例无关，与类有关；而const与实例有关，有几个实例就有几个const），故常用于此方法定义常量；</p>
<p>enum是枚举常量定义，在编译阶段处理，有作用域限制，枚举类型中可以定义多个常量（往往是同一归属的常量，比如定义星期可以有7种，enum weekday｛one=1，two=2，three=3｝；（weekday是定义的枚举类型名）），需注意的是在C++中enum枚举类型中只能赋值int型值（即使可以赋值字符，但输出仍是整型）。</p>
<p>define、cosnt和enum的区别：</p>
<p>（1）define 宏定义常量，在开始预处理时就要被替换，所以定义的记号名不会进入记号表，当编译调试时，因为到时直接是一个数值，可能让人产生迷惑。 可以用const 和 enum 来代替宏。常量肯定会进入记号表，可以更容易跟踪，使用常量可能比使用#define导致较小量的码，因为编译器会盲目的将宏定义进行替换，而常量一般在内存中只有一份实体</p>
<p>（2）我们无法利用#define创建一个class专属常量，因为#define并不重视作用域。</p>
<p>（3）取一个const地址是合法的，但取一个enum的地址是不合法的，取一个#define的地址也不合法</p>
<p>2.用途</p>
<p>（1）define：一般用于全局型常量的定义，通常较少使用，在具有较少全局型常量（程序各处都可能用到该常量）时使用；</p>
<p>（2）const：一般用于类常量，常配合static来使用，定义类中静态常量，类的任何对象都能够共享此常量static const常量在定义时初始化。程序中往往多使用const来替代define。</p>
<p>（3）enum：一般用于某种类型具有多个常量的时候定义，比如某种功能实现有三种方法，可定义enum method｛method0=0，method1=1，method2=2｝来选择使用哪种方法实现其功能。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h3><p><strong><a href="https://blog.csdn.net/weixin_40311211/article/details/82851300">https://blog.csdn.net/weixin_40311211/article/details/82851300</a></strong> </p>
<h4 id="1-静态局部变量："><a href="#1-静态局部变量：" class="headerlink" title="1.静态局部变量："></a>1.静态局部变量：</h4><p><strong>用于函数体内部修饰变量，这种变量的生存期长于该函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int foo()&#123;</span><br><span class="line">static int i = 1; // note:1</span><br><span class="line">//int i = 1; // note:2</span><br><span class="line">i += 1;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要明白这个用法，我们首先要了解c/c++的内存分布，以及static所在的区间。</p>
<p>对于一个完整的程序，在内存中的分布情况如下图：　<br>1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用域退出而释放空间。<br>3.堆区：程序员分配并释放的区域，像malloc(c),new(c++)<br>3.全局数据区(静态区)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。<br>4.代码区</p>
<p>所以上面note:1的static是在全局数据区分配的,那么它存在的意思是什么？又是什么时候初始化的呢？</p>
<p>首先回答第一个问题：它存在的意义就是随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁(如果把以上的note:1换成note:2,那么就是在栈区分配了，会随着foo的调用结束而释放)。<br>那么第二个问题也就浮出水面了，<mark class="hl-label blue，且只初始化一次">它是在第一次调用进入note:1的时候初始化</mark>  ，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。</p>
<p>那么它跟定义一个全局变量有什么区别呢，同样是初始化一次，连续调用foo()的结果是一样的，但是，使用全局变量的话，变量就不属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<p>那么我们总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：<br>（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);<br>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);<br>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);<br>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);</p>
<h4 id="2-静态全局变量："><a href="#2-静态全局变量：" class="headerlink" title="2.静态全局变量："></a><strong>2.静态全局变量：</strong></h4><p>定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//note:3</span></span><br><span class="line"><span class="comment">//int i = 1; //note:4</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>note:3和note:4有什么差异呢？你调用foo(),无论调用几次，他们的结果都是一样的。也就是说在本文件内调用他们是完全相同的(指的是使用note:3和note:4产生的结果是一样的，并不是单独使用note:3的时候调用几次结果都相同)。那么他们的区别是什么呢？<br><strong>文件隔离！</strong></p>
<p>假设我有一个文件a.c,我们再新建一个b.c,内容如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file a.c</span></span><br><span class="line"><span class="comment">//static int n = 15; //note:5</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>; <span class="comment">//note:6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file b.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after: %d\n&quot;</span>,n);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before: %d\n&quot;</span>,n);</span><br><span class="line"><span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先使用note:6,也就是非静态全局变量，发现输出为:<br>before: 15<br>after: 16<br>也就是我们的b.c通过extern使用了a.c定义的全局变量。<br>那么我们改成使用note:5,也就是使用静态全局变量呢？</p>
<p><em>gcc a.c b.c -o output.out</em></p>
<p>会出现类似undeference to “n”的报错，它是找不到n的，因为static进行了文件隔离，你是没办法访问a.c定义的静态全局变量的，当然你用 #include “a.c”,那就不一样了。</p>
<p>以上我们就可以得出静态全局变量的特点：</p>
<p>静态全局变量不能被其它文件所用(全局变量可以);<br>其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);</p>
<h4 id="3-静态函数："><a href="#3-静态函数：" class="headerlink" title="3.静态函数："></a><strong>3.静态函数：</strong></h4><p>准确的说，静态函数跟静态全局变量的作用类似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is non-static func in a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file b.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>; <span class="comment">//我们用extern声明其他文件的fn(),供本文件使用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以正常输出：this is non-static func in a。<br>当给void fn()加上static的关键字之后呢？ undefined reference to “fn”.</p>
<p>所以，静态函数的好处跟静态全局变量的好处就类似了：</p>
<mark class="hl-label 2.其它文件中可以定义相同名字的函数，不会发生冲突;">1.静态函数不能被其它文件所用;</mark>  



<p>上面一共说了三种用法，为什么说准确来说是两种呢？<br>1.一种是修饰变量(静态局部和静态全局)，一种是修饰函数，所以说是两种（这种解释不多）。<br>2.静态全局变量和修饰静态函数的作用是一样的，一般合并为一种。（这是比较多的分法）。</p>
<h4 id="3-静态数据成员："><a href="#3-静态数据成员：" class="headerlink" title="3.静态数据成员："></a><strong>3.静态数据成员</strong>：</h4><p>用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象<mark class="hl-label instance）">（实体</mark>  。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_w,m_h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_sum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_w = w;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_h = h;</span><br><span class="line">        s_sum += (<span class="keyword">this</span>-&gt;m_w * <span class="keyword">this</span>-&gt;m_h);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;s_sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rectangle::s_sum = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(Rectangle)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(Rectangle)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    Rectangle *rect1 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    rect1-&gt;<span class="built_in">GetSum</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect1)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(*rect1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Rectangle <span class="title">rect2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    rect2.<span class="built_in">GetSum</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect2)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(rect2)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/0.5083759780270944.png" alt="img"></p>
<p>由图可知：sizeof(Rectangle)=8bytes=sizeof(m_w)+sizeof(m_h)。也就是说 static 并不占用Rectangle的内存空间。<br>那么static在哪里分配内存的呢？是的，全局数据区(静态区)。<br>再看看GetSum()，第一次12=0+3×4，第二次18=1×2+2×3。由此可得，static只会被初始化一次，于实例无关。</p>
<p>结论：</p>
<p>对于非静态数据成员，每个类对象(实例)都有自己的拷贝（<strong>即每次实例化之后都会重新初始化，变量值可以不同</strong>）。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存(和局部静态变量一样)。<br>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</p>
<p>也就是说，你每new一个Rectangle，并不会为static int s_sum的构建一份内存拷贝，它是不管你new了多少Rectangle的实例，因为它只与类Rectangle挂钩，而跟你每一个Rectangle的对象没关系。</p>
<h4 id="4-静态成员函数："><a href="#4-静态成员函数：" class="headerlink" title="4.静态成员函数："></a>4.静态成员函数：</h4><p>用于修饰 class 的成员函数。<br>我们对上面的例子稍加改动：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_w,m_h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_sum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Rectangle</span>(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_w = w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_h = h;</span><br><span class="line">            s_sum += (<span class="keyword">this</span>-&gt;m_w * <span class="keyword">this</span>-&gt;m_h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span> <span class="comment">//这里加上static</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;s_sum&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">int</span> Rectangle::s_sum = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(Rectangle)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(Rectangle)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    Rectangle *rect1 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    rect1-&gt;<span class="built_in">GetSum</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect1)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(*rect1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Rectangle <span class="title">rect2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    rect2.<span class="built_in">GetSum</span>(); <span class="comment">//可以用对象名.函数名访问</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect2)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(rect2)&lt;&lt;endl;</span><br><span class="line">    Rectangle::<span class="built_in">GetSum</span>(); <span class="comment">//也可以可以用类名::函数名访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/f95c01fe-c842-4922-b5d1-e2c8b0145288.png" alt="img"></p>
<p>上面注释可见:对GetSum()加上static，使它变成一个静态成员函数，可以用类名::函数名进行访问。</p>
<p>那么静态成员函数有特点呢？<br>1.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;<br>2.非静态成员函数可以任意地访问静态成员函数和静态数据成员;<br>3.静态成员函数不能访问非静态成员函数和非静态数据成员;<br>4.调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)</p>
<p>前三点其实是一点：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态，有点晕吗？没关系，我给你个解释，<br>因为静态是属于类的，它是不知道你创建了10个还是100个对象，所以它对你对象的函数或者数据是一无所知的，所以它没办法调用，而反过来，你创建的对象是对类一清二楚的(不然你怎么从它那里实例化呢)，所以你是可以调用类函数和类成员的，就像不管GetSum是不是static，都可以调用static的s_sum一样。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><strong>const</strong></h3><p> 常变量： <strong>const 类型说明符 变量名</strong></p>
<p> 常引用： <strong>const 类型说明符 &amp;引用名</strong></p>
<p> 常对象： <strong>类名 const 对象名</strong></p>
<p> 常成员函数： <strong>类名::fun(形参) const</strong></p>
<p> 常数组： <strong>类型说明符 const 数组名[大小]   如 int const  p[]</strong></p>
<p> 常指针： <strong>const 类型说明符* 指针名 ，类型说明符*   如 const 指针名  const int *  p; int *const p</strong></p>
<p>**<br>**</p>
<p>首先提示的是：在<strong>常变量</strong>（<strong>const 类型说明符 变量名）、****常引用</strong>（<strong>const 类型说明符 &amp;引用名</strong>）、<strong>常对象</strong>（<strong>类名 const 对象名）、</strong> <strong>常数组</strong>（<strong>类型说明符 const 数组名[大小]）中，</strong> <strong>const”</strong> <strong>与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符）</strong> 的位置可以互换。如：</p>
<p>   const int a=5; 与 int const a=5; 等同</p>
<p>   类名 const 对象名 与 const 类名 对象名 等同</p>
<h4 id="用法1：常量"><a href="#用法1：常量" class="headerlink" title="用法1：常量"></a><strong>用法1：常量</strong></h4><p>  取代了C中的宏定义，声明时必须进行初始化(!c++类中则不然）。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。―《C++ Program Language》<br>  用const声明的变量虽然增加了分配空间，但是可以保证类型安全。<br>  C标准中，const定义的常量是全局的，C++中视声明位置而定。</p>
<h4 id="用法2：指针和常量"><a href="#用法2：指针和常量" class="headerlink" title="用法2：指针和常量"></a><strong>用法2：指针和常量</strong></h4><p>  使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。<br>  所以出现在 * 之前的const是作为基础类型的一部分：<br>char *const cp; //到char的const指针<br>char const *pc1; //到const char的指针<br>const char <em>pc2; //到const char的指针（后两个声明是等同的）<br>  从右向左读的记忆方式：<br>cp is a <strong>const pointer</strong> to char. 故pc不能指向别的字符串，但可以修改其指向的字符串的内容<br>pc2 is a pointer to <strong>const char.</strong> 故</em>pc2的内容不可以改变，但pc2可以指向别的字符串</p>
<p>且注意：允许把非 const 对象的地址赋给指向 const 对象的指针,不允许把一个 const 对象的地址赋给一个普通的、非 const 对象的指针。</p>
<h4 id="用法3：const修饰函数传入参数"><a href="#用法3：const修饰函数传入参数" class="headerlink" title="用法3：const修饰函数传入参数"></a><strong>用法3：const修饰函数传入参数</strong></h4><p>  将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。<br>  通常修饰指针参数和引用参数：<br>void Fun( const A *in); //修饰指针型传入参数<br>void Fun(const A &amp;in); //修饰引用型传入参数</p>
<h4 id="用法4：修饰函数返回值"><a href="#用法4：修饰函数返回值" class="headerlink" title="用法4：修饰函数返回值"></a><strong>用法4：修饰函数返回值</strong></h4><p>  可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。</p>
<h4 id="用法5：const修饰成员函数-c-特性"><a href="#用法5：const修饰成员函数-c-特性" class="headerlink" title="用法5：const修饰成员函数(c++特性)"></a><strong>用法5：const修饰成员函数</strong>(c++特性)</h4><p>const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；<br>const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；<br>const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。</p>
<h4 id="一-：常量与指针"><a href="#一-：常量与指针" class="headerlink" title="(一)：常量与指针"></a><strong>(一)：常量与指针</strong></h4><p> 常量与指针放在一起很容易让人迷糊。对于常量指针和指针常量也不是所有的学习C/C++的人都能说清除。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *m1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的两个表达式中，最容易让人迷惑的是const到底是修饰指针还是指针指向的内存区域？其实，只要知道：<mark class="hl-label red">const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用</mark>  。根据这个规则来判断，m1应该是<strong>常量指针</strong>（即，不能通过m1来修改它所指向的内容。）；而m2应该是<strong>指针常量</strong>（即，不能让m2指向其他的内存模块）。由此可见：</p>
<p>  \1. 对于常量指针，不能通过该指针来改变所指的内容。即，下面的操作是错误的：</p>
<p>   int i = 10;</p>
<p>   const int *pi = &i;</p>
<p>   *pi = 100;</p>
<p>   因为你在试图通过pi改变它所指向的内容。但是，并不是说该内存块中的内容不能被修改。我们仍然可以通过其他方式去修改其中的值。例如：</p>
<p>   // 1: 通过i直接修改。</p>
<p>   i = 100;</p>
<p>   // 2:　使用另外一个指针来修改。</p>
<p>   int <em>p = (int</em>)pi;</p>
<p>   *p = 100;</p>
<p>   实际上，在将程序载入内存的时候，会有专门的一块内存区域来存放常量。但是，上面的i本身不是常量，是存放在栈或者堆中的。我们仍然可以修改它的值。而pi不能修改指向的值应该说是编译器的一个限制。</p>
<p>  \2. 根据上面const的规则，const int *m1 = new int(10);我们也可写作：</p>
<p>   int const　*m1 = new int(10);</p>
<p>   这是，理由就不须作过多说明了。</p>
<p>  \3. 在函数参数中指针常量时表示不允许将该指针指向其他内容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func_02</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">      <span class="comment">//错误！P是指针常量。不能对它赋值。</span></span><br><span class="line">      p = pi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">      <span class="built_in">func_02</span>(p);</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  \4. 在函数参数中使用常量指针时表示在函数中不能改变指针所指向的内容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *pi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//错误！不能通过pi去改变pi所指向的内容！</span></span><br><span class="line">    *pi = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(p);　</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们可以使用这样的方法来防止函数调用者改变参数的值。但是，这样的限制是有限的，作为参数调用者，我们也不要试图去改变参数中的值。因此，下面的操作是在语法上是正确的，但是可能破还参数的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">void func(const int *pi)</span><br><span class="line">&#123;</span><br><span class="line">    //这里相当于重新构建了一个指针，指向相同的内存区域。当然就可以通过该指针修改内存中的值了。</span><br><span class="line">    int* pp = (int*)pi;</span><br><span class="line">    *pp = 100;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int* p = new int(10);</span><br><span class="line">    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    func(p);</span><br><span class="line">    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    delete p;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二-：常量与引用"><a href="#二-：常量与引用" class="headerlink" title="(二)：常量与引用"></a><strong>(二)：常量与引用</strong></h4><p>  常量与引用的关系稍微简单一点。因为引用就是另一个变量的别名，它本身就是一个常量。也就是说不能再让一个引用成为另外一个变量的别名, 那么他们只剩下代表的内存区域是否可变。即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 正确：表示不能通过该引用去修改对应的内存的内容。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ri = i;</span><br><span class="line"><span class="comment">// 错误！不能这样写。</span></span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">const</span> rci = i;</span><br></pre></td></tr></table></figure>

<p>  由此可见，如果我们不希望函数的调用者改变参数的值。最可靠的方法应该是使用引用。下面的操作会存在编译错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// 错误！不能通过i去改变它所代表的内存区域。</span></span><br><span class="line">     i = <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里已经明白了常量与指针以及常量与引用的关系。但是，有必要深入的说明以下。在系统加载程序的时候，系统会将内存分为4个区域：堆区 栈区 全局区（静态）和代码区。从这里可以看出，对于常量来说，<strong>系统没有划定专门的区域来保护其中的数据不能被更改</strong>。也就是说，使用常量的方式对数据进行保护是通过编译器作语法限制来实现的。我们仍然可以绕过编译器的限制去修改被定义为“常量”的内存区域。看下面的代码：</p>
<p>  const int i = 10;</p>
<p>  // 这里i已经被定义为常量，但是我们仍然可以通过另外的方式去修改它的值。</p>
<p>  // 这说明把i定义为常量，实际上是防止通过i去修改所代表的内存。</p>
<p>  int <em>pi = (int</em>) &i;</p>
<h4 id="三-：常量函数"><a href="#三-：常量函数" class="headerlink" title="(三)：常量函数"></a><strong>(三)：常量函数</strong></h4><p>  常量函数是C++对常量的一个扩展，它很好的确保了C++中类的封装性。在C++中，为了防止类的数据成员被非法访问，将类的成员函数分成了两类，一类是常量成员函数（也被称为观察者）；另一类是非常量成员函数（也被成为变异者）。在一个函数的签名后面加上关键字const后该函数就成了常量函数。对于常量函数，最关键的不同是编译器不允许其修改类的数据成员。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> class Test</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">     void func() const;</span><br><span class="line">     private:</span><br><span class="line">     int intValue;</span><br><span class="line"> &#125;;</span><br><span class="line">void Test::func() const</span><br><span class="line">&#123;</span><br><span class="line">    intValue = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，常量函数func函数内试图去改变数据成员intValue的值，因此将在编译的时候引发异常。</p>
<p> 当然，对于非常量的成员函数，我们可以根据需要读取或修改数据成员的值。但是，这要依赖调用函数的对象是否是常量。通常，如果我们把一个类定义为常量，我们的本意是希望他的状态（数据成员）不会被改变。那么，如果一个常量的对象调用它的非常量函数会产生什么后果呢？看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fred</span><br><span class="line">&#123;</span><br><span class="line">      public:</span><br><span class="line">      void inspect() const;</span><br><span class="line">      void mutate();</span><br><span class="line">&#125;;</span><br><span class="line">void UserCode(Fred&amp; changeable, const Fred&amp; unChangeable)</span><br><span class="line">&#123;</span><br><span class="line">    changeable.inspect(); // 正确，非常量对象可以调用常量函数。</span><br><span class="line">    changeable.mutate(); // 正确，非常量对象也允许修改调用非常量成员函数修改数据成员。</span><br><span class="line">    unChangeable.inspect(); // 正确，常量对象只能调用常理函数。因为不希望修改对象状态。</span><br><span class="line">    unChangeable.mutate(); // 错误！常量对象的状态不能被修改，而非常量函数存在修改对象状态的可能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  从上面的代码可以看出，由于常量对象的状态不允许被修改，因此，通过常量对象调用非常量函数时将会产生语法错误。实际上，我们知道每个成员函数都有一个隐含的指向对象本身的this指针。而常量函数则包含一个this的常量指针。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void inspect(const Fred* this) const;</span><br><span class="line">void mutate(Fred* this);</span><br></pre></td></tr></table></figure>

<p>   也就是说对于常量函数，我们不能通过this指针去修改对象对应的内存块。但是，在上面我们已经知道，这仅仅是编译器的限制，我们仍然可以绕过编译器的限制，去改变对象的状态。看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fred</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void inspect() const;</span><br><span class="line">    private:</span><br><span class="line">    int intValue;</span><br><span class="line">&#125;;</span><br><span class="line">void Fred::inspect() const</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;At the beginning. intValue = &quot;&lt;&lt; intValue &lt;&lt; endl;</span><br><span class="line">    // 这里，我们根据this指针重新定义了一个指向同一块内存地址的指针。</span><br><span class="line">    // 通过这个新定义的指针，我们仍然可以修改对象的状态。</span><br><span class="line">    Fred* pFred = (Fred*)this;</span><br><span class="line">    pFred-&gt;intValue = 50;</span><br><span class="line">    cout &lt;&lt; &quot;Fred::inspect() called. intValue = &quot;&lt;&lt; intValue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Fred fred;</span><br><span class="line">    fred.inspect();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的代码说明，只要我们愿意，我们还是可以通过常量函数修改对象的状态。同理，对于常量对象，我们也可以构造另外一个指向同一块内存的指针去修改它的状态。这里就不作过多描述了。</p>
<p>  另外，也有这样的情况，虽然我们可以绕过编译器的错误去修改类的数据成员。但是C++也允许我们在数据成员的定义前面加上mutable，以允许该成员可以在常量函数中被修改。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fred&#123;</span><br><span class="line">    public:</span><br><span class="line">    void inspect() const;</span><br><span class="line">    private:</span><br><span class="line">    mutable int intValue;</span><br><span class="line">&#125;;</span><br><span class="line">void Fred::inspect() const</span><br><span class="line">&#123;</span><br><span class="line">    intValue = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  但是，并不是所有的编译器都支持mutable关键字。这个时候我们上面的歪门邪道就有用了。</p>
<p>  关于常量函数，还有一个问题是重载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Fred&#123;</span><br><span class="line">    public:</span><br><span class="line">    void func() const;</span><br><span class="line">    void func();</span><br><span class="line">&#125;;</span><br><span class="line">void Fred::func() const</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;const function is called.&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fred::func()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;non-const function is called.&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void UserCode(Fred&amp; fred, const Fred&amp; cFred)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;fred is non-const object, and the result of fred.func() is:&quot; &lt;&lt; endl;</span><br><span class="line">    fred.func();</span><br><span class="line">    cout &lt;&lt; &quot;cFred is const object, and the result of cFred.func() is:&quot; &lt;&lt; endl;</span><br><span class="line">    cFred.func();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Fred fred;</span><br><span class="line">    UserCode(fred, fred);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果为：</p>
<p>   从上面的输出结果，我们可以看出。当存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。常量对象调用常量成员；非常量对象调用非常量的成员。</p>
<p>  总之，我们需要明白常量函数是为了最大程度的保证对象的安全。通过使用常量函数，我们可以只允许必要的操作去改变对象的状态，从而防止误操作对对象状态的破坏。但是，就像上面看见的一样，这样的保护其实是有限的。关键还是在于我们开发人员要严格的遵守使用规则。另外需要注意的是常量对象不允许调用非常量的函数。这样的规定虽然很武断，但如果我们都根据原则去编写或使用类的话这样的规定也就完全可以理解了。</p>
<h4 id="四-：常量返回值"><a href="#四-：常量返回值" class="headerlink" title="(四)：常量返回值"></a><strong>(四)：常量返回值</strong></h4><p>   很多时候，我们的函数中会返回一个地址或者引用。调用这得到这个返回的地址或者引用后就可以修改所指向或者代表的对象。这个时候如果我们不希望这个函数的调用这修改这个返回的内容，就应该返回一个常量。这应该很好理解，大家可以去试试。</p>
<p>+++++++++++++++++++++++++++++++++++++++</p>
<blockquote>
<p>**c++ 中const<br>**</p>
</blockquote>
<p>+++++++++++++++++++++++++++++++++++++++</p>
<p>\1. const常量，如const int max = 100;<br>优点：const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误（边际效应）<br>\2. const 修饰类的数据成员。如：<br>class A<br>{</p>
<p>  const int size;</p>
<p>  …</p>
<p>}</p>
<p>const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。如</p>
<p>class A</p>
<p>{</p>
<p> const int size = 100;  //错误</p>
<p> int array[size];     //错误，未知的size</p>
<p>}<br>const数据成员的初始化只能在类的构造函数的初始化表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现。如</p>
<p>class A</p>
<p>{…</p>
<p> enum {size1=100, size2 = 200 };</p>
<p>int array1[size1];</p>
<p>int array2[size2];</p>
<p>}</p>
<p>枚举常量不会占用对象的存储空间，他们在编译时被全部求值。但是枚举常量的隐含数据类型是整数，其最大值有限，且不能表示浮点数。</p>
<p>\3. const修饰指针的情况，见下式：</p>
<p>int b = 500;<br>const int* a = &amp;         [1]<br>int const <em>a = &amp;         [2]<br>int</em> const a = &amp;         [3]<br>const int* const a = &amp;      [4]</p>
<p>如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effectivec++》Item21上的做法，如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。</p>
<p>\4. const的初始化</p>
<p>先看一下const变量初始化的情况 </p>
<ol>
<li><p>非指针const常量初始化的情况：A b;<br>const A a = b;</p>
</li>
<li><p>指针const常量初始化的情况：</p>
</li>
</ol>
<p>A* d = new A();<br>const A* c = d;<br>或者：const A* c = new A();<br>3）引用const常量初始化的情况：<br>A f;<br>const A&amp; e = f;   // 这样作e只能访问声明为const的函数，而不能访问一般的成员函数；</p>
<p>  [思考1]： 以下的这种赋值方法正确吗？<br>  const A* c=new A();<br>  A* e = c;<br>  [思考2]： 以下的这种赋值方法正确吗？<br>  A* const c = new A();<br>  A* b = c;</p>
<p>\5. 另外const 的一些强大的功能在于它在函数声明中的应用。在一个函数声明中，const可以修饰函数的返回值，或某个参数；对于成员函数，还可以修饰是整个函数。有如下几种情况，以下会逐渐的说明用法：A&amp;operator=(const A&amp; a);<br>void fun0(const A* a );<br>void fun1( ) const; // fun1( ) 为类成员函数<br>const A fun2( );</p>
<ol>
<li>修饰参数的const，如 void fun0(const A* a ); void fun1(const A&amp; a);<br>调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，如形参为const A*a，则不能对传递进来的指针的内容进行改变，保护了原指针所指向的内容；如形参为const A&amp;a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。<br>[注意]：参数const通常用于参数为指针或引用的情况，且只能修饰输入参数;若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。</li>
</ol>
<p>[总结]对于非内部数据类型的输入参数，因该将“值传递”的方式改为“const引用传递”，目的是为了提高效率。例如，将void Func(A a)改为void Func(const A &amp;a)</p>
<p>   对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x)不应该改为void Func(const int &amp;x)</p>
<ol start="2">
<li>修饰返回值的const，如const A fun2( ); const A* fun3( );<br>这样声明了返回值后，const按照”修饰原则”进行修饰，起到相应的保护作用。</li>
</ol>
<p>const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)<br>{ </p>
<blockquote>
<p>return Rational(lhs.numerator() * rhs.numerator(), </p>
<p>lhs.denominator() * rhs.denominator()); </p>
</blockquote>
<p>}</p>
<p>返回值用const修饰可以防止允许这样的操作发生:</p>
<p>Rational a,b;<br>Radional c;<br>(a*b) = c;</p>
<p>一般用const修饰返回值为对象本身（非引用和指针）的情况多用于二目操作符重载函数并产生新对象的时候。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="[总结]"></a><strong>[总结]</strong></h4><p>\1. 一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A实例）或某个对象的引用为const（const A&amp; test = A实例），则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
<p>\2. 如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。如：</p>
<p>const char * GetString(void);</p>
<p>如下语句将出现编译错误：</p>
<p>char *str=GetString();</p>
<p>正确的用法是：</p>
<p>const char *str=GetString();</p>
<p>\3.   函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赙值函数中，目的是为了实现链式表达。如：</p>
<p>class A</p>
<p>{…</p>
<p> A &amp;operate = (const A &amp;other); //负值函数</p>
<p>}<br>A a,b,c;       //a,b,c为A的对象</p>
<p>…</p>
<p>a=b=c;      //正常</p>
<p>(a=b)=c;     //不正常，但是合法</p>
<p>若负值函数的返回值加const修饰，那么该返回值的内容不允许修改，上例中a=b=c依然正确。(a=b)=c就不正确了。<br>[思考3]： 这样定义赋值操作符重载函数可以吗？<br>const A&amp; operator=(const A&amp; a);</p>
<p>\6.   类成员函数中const的使用<br>一般放在函数体后，形如：void fun() const;<br>任何不会修改数据成员的函数都因该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其他非const成员函数，编译器将报错，这大大提高了程序的健壮性。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;   <span class="comment">//const 成员函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> m_num;</span><br><span class="line">      <span class="keyword">int</span> m_data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ++m_num;              <span class="comment">//编译错误，企图修改数据成员m_num</span></span><br><span class="line">  <span class="built_in">Pop</span>();                <span class="comment">//编译错误，企图调用非const函数</span></span><br><span class="line">  Return m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\7. 使用const的一些建议</p>
<ol>
<li>要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委； </li>
<li>要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题； </li>
<li>在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上； </li>
<li>const在成员函数中的三种用法（参数、返回值、函数）要很好的使用； </li>
<li>不要轻易的将函数的返回值类型定为const; </li>
<li>除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;</li>
</ol>
<p>[思考题答案] </p>
<p>  [思考1]： 以下的这种赋值方法正确吗？<br>  const A* c=new A();<br>  A* e = c;<br>  [思考2]： 以下的这种赋值方法正确吗？<br>  A* const c = new A();<br>  A* b = c;</p>
<ol>
<li>这种方法不正确，因为声明指针的目的是为了对其指向的内容进行改变，而声明的指针e指向的是一个常量，所以不正确； </li>
<li>这种方法正确，因为声明指针所指向的内容可变； </li>
<li>这种做法不正确；<br>在const A::operator=(const A&amp; a)中，参数列表中的const的用法正确，而当这样连续赋值的时侯，问题就出现了：<br>A a,b,c:<br>(a=b)=c;<br>因为a.operator=(b)的返回值是对a的const引用，不能再将c赋值给const常量。</li>
</ol>
<p>++++++++++++++++++++++++++++++++++++++++</p>
<blockquote>
<p><a href="http://tech.e800.com.cn/articles/2009/722/1248229886744_1.html"><strong>const 在c和c++中的区别</strong></a></p>
</blockquote>
<p>++++++++++++++++++++++++++++++++++++++++</p>
<p>\1. C++中的const正常情况下是看成编译期的常量,编译器并不为const分配空间,只是在编译的时候将期值保存在名字表中,并在适当的时候折合在代码中.所以,以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const int a = 1;</span><br><span class="line">const int b = 2;</span><br><span class="line">int array[ a + b ] = &#123;0&#125;;</span><br><span class="line">for (int i = 0; i &lt; sizeof array / sizeof *array; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; array &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在可以通过编译,并且正常运行.但稍加修改后,放在C编译器中,便会出现错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">const int a = 1;</span><br><span class="line">const int b = 2;</span><br><span class="line">int array[ a + b ] = &#123;0&#125;;</span><br><span class="line">for (i = 0; i &lt; sizeof array / sizeof *array; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,array);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误消息:<br>c:\test1\te.c(8): error C2057: 应输入常数表达式<br>c:\test1\te.c(8): error C2466: 不能分配常数大小为 0 的数组<br>出现这种情况的原因是:在C中,const是一个不能被改变的普通变量,既然是变量,就要占用存储空间,所以编译器不知道编译时的值.而且,数组定义时的下标必须为常量.<br>\2. 在C语言中: const int size; 这个语句是正确的，因为它被C编译器看作一个声明,指明在别的地方分配存储空间.但在C++中这样写是不正确的.C++中const默认是内部连接,如果想在C++中达到以上的效果,必须要用extern关键字.即<strong>C++中,const默认使用内部连接.而C中使用外部连接.</strong><br><strong>(1) 内连接</strong>:编译器只对正被编译的文件创建存储空间,别的文件可以使用相同的表示符或全局变量.C/C++中内连接使用static关键字指定.<br><strong>(2) 外连接</strong>:所有被编译过的文件创建一片单独存储空间.一旦空间被创建,连接器必须解决对这片存储空间的引用.全局变量和函数使用外部连接.通过extern关键字声明,可以从其他文件访问相应的变量和函数.<br>/* C++代码 header.h <em>/<br>const int test = 1;<br>/</em> C++代码 test1.cpp <em>/<br>#include “header.h”<br>using namespace std;<br>int main() { cout &lt;&lt; “in test1 :” &lt;&lt; test &lt;&lt; endl; }<br>/</em> C++代码 test2.cpp <em>/<br>#include “header.h”<br>using namespace std;<br>void print() { cout &lt;&lt; “in test2:” &lt;&lt; test &lt;&lt; endl;}<br>以上代码编译连接完全不会出问题,但如果把header.h改为:<br>extern const int test = 1;<br>在连接的时候,便会出现以下错误信息:<br>test2 error LNK2005: “int const test” (<a href="mailto:?test@@3HB">?test@@3HB</a>) 已经在 test1.obj 中定义<br>  因为extern关键字告诉C++编译器test会在其他地方引用,所以,C++编译器就会为test创建存储空间,不再是简单的存储在名字表里面.所以,当两个文件同时包含header.h的时候,会发生名字上的冲突.<br>此种情况和C中const含义相似:<br>/</em> C代码 header.h <em>/<br>const int test = 1;<br>/</em> C代码 test1.c <em>/<br>#include “header.h”<br>int main() { printf(“in test1:%d\n”,test); }<br>/</em> C代码 test2.c */<br>#include “header.h”<br>void print() { printf(“in test2:%d\n”,test); }<br>错误消息:<br>test3 fatal error LNK1169: 找到一个或多个多重定义的符号<br>test3 error LNK2005: _test 已经在 test1.obj 中定义</p>
<p>也就是说：在c++ 中const 对象默认为文件的局部变量。与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象：<br>   // file_1.cc<br>   // defines and initializes a const that is accessible to other files<br>   extern const int bufSize = fcn();<br>   // file_2.cc<br>   extern const int bufSize; // uses bufSize from file_1<br>   // uses bufSize defined in file_1<br>   for (int index = 0; index != bufSize; ++index)<br>      // …</p>
<p>\3. C++中,是否为const分配空间要看具体情况.如果加上关键字extern或者取const变量地址,则编译器就要为const分配存储空间.<br>\4. C++中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.</p>
<p>来源： <a href="https://www.cnblogs.com/lanjianhappy/p/7298427.html">https://www.cnblogs.com/lanjianhappy/p/7298427.html</a></p>
<p><strong>static  const</strong>  </p>
<p>**const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。<br>**</p>
<p>**对于非静态数据成员，每个类对象(实例)都有自己的拷贝（**即每次实例化之后都会重新初始化，变量值可以不同**）。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存(和局部静态变量一样)。<br>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。<br>**</p>
<p><a href="https://blog.csdn.net/tobefxz/article/details/14109697">https://blog.csdn.net/tobefxz/article/details/14109697</a> </p>
<p>const定义的常量在超出其作用域之后其空间会被释放，而<strong>static定义的静态常量在函数执行后不会释放其存储空间</strong>。</p>
<p>static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。<strong>即使没有具体对象，也能调用类的静态成员函数和成员变量</strong>。<strong>一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中</strong>。</p>
<p>在C++中，<strong>static静态成员变量不能在类的内部初始化</strong>。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static</p>
<p>在C++中，<strong>const成员变量也不能在类定义处初始化</strong>，只能通过构造函数初始化列表进行，并且必须有构造函数。</p>
<p>const数据成员 <strong>只在某个对象生存期内是常量，而对于整个类而言却是可变的</strong>。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。</p>
<p>const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cost。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">public:</span><br><span class="line">    Test():a(0)&#123;&#125;</span><br><span class="line">    enum &#123;size1=100,size2=200&#125;;</span><br><span class="line">private:</span><br><span class="line">    const int a;//只能在构造函数初始化列表中初始化</span><br><span class="line">    static int b;//在类的实现文件中定义并初始化</span><br><span class="line">    const static int c;//与 static const int c;相同。</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。</span><br><span class="line">cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。</span><br></pre></td></tr></table></figure>

<p>cosnt成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。</p>
<p>static成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员函数2、不能被声明为virtual</p>
<h3 id="关于static、const、static-cosnt、const-static成员的初始化问题："><a href="#关于static、const、static-cosnt、const-static成员的初始化问题：" class="headerlink" title="关于static、const、static cosnt、const static成员的初始化问题："></a>关于static、const、static cosnt、const static成员的初始化问题：</h3><h4 id="1、类里的const成员初始化："><a href="#1、类里的const成员初始化：" class="headerlink" title="1、类里的const成员初始化："></a>1、类里的const成员初始化：</h4><p>在一个<strong>类里建立一个const时，不能给他初值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">public:</span><br><span class="line">    foo():i(100)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    const int i=100;//error!!!</span><br><span class="line">&#125;;</span><br><span class="line">//或者通过这样的方式来进行初始化</span><br><span class="line">foo::foo():i(100)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、类里的static成员初始化："><a href="#2、类里的static成员初始化：" class="headerlink" title="2、类里的static成员初始化："></a>2、类里的static成员初始化：</h4><p>类中的static变量是属于类的，不属于某个对象，它在整个程序的运行过程中只有一个副本，因此<strong>不能在定义对象时对变量进行初始化，就是不能用构造函数进行初始化</strong>，其正确的初始化方法是：</p>
<p>数据类型 类名::静态数据成员名=值；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">public:</span><br><span class="line">    foo();</span><br><span class="line">private:</span><br><span class="line">static int i;</span><br><span class="line">&#125;;</span><br><span class="line">int foo::i=20;</span><br></pre></td></tr></table></figure>

<p>这表明：</p>
<p>1、<strong>初始化在类体外进行，而前面不加static</strong>，以免与<strong>一般静态变量</strong>或对象相混淆</p>
<p>2、初始化时不加该成员的访问权限控制符private、public等</p>
<p>3、初始化时使用<strong>作用域运算符来表明它所属的类</strong>，因此，静态数据成员是类的成员而不是对象的成员。</p>
<h4 id="3、类里的static-cosnt-和-const-static成员初始化"><a href="#3、类里的static-cosnt-和-const-static成员初始化" class="headerlink" title="3、类里的static cosnt 和 const static成员初始化"></a>3、类里的static cosnt 和 const static成员初始化</h4><p>**这两种写法的作用一样，为了便于记忆，在此值说明一种通用的初始化方法：<br>*</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">public:</span><br><span class="line">    static const int mask1;</span><br><span class="line">    const static int mask2;</span><br><span class="line">&#125;;</span><br><span class="line">const Test::mask1=0xffff;</span><br><span class="line">const Test::mask2=0xffff;</span><br><span class="line">//它们的初始化没有区别，虽然一个是静态常量一个是常量静态。静态都将存储在全局变量区域，其实最后结果都一样。</span><br><span class="line">//可能在不同编译器内，不同处理，但最后结果都一样。</span><br></pre></td></tr></table></figure>

<h4 id="这是一个完整的例子："><a href="#这是一个完整的例子：" class="headerlink" title="这是一个完整的例子："></a>这是一个完整的例子：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef A_H_</span><br><span class="line">#define A_H_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">usingnamespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int a);</span><br><span class="line">    static void print();//静态成员函数</span><br><span class="line">private:</span><br><span class="line">    static int aa;//静态数据成员的声明</span><br><span class="line">    static const int count;//常量静态数据成员（可以在构造函数中初始化）</span><br><span class="line">    const int bb;//常量数据成员</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int A::aa=0;//静态成员的定义+初始化</span><br><span class="line">const int A::count=25;//静态常量成员定义+初始化</span><br><span class="line"> </span><br><span class="line">A::A(int a):bb(a)&#123;//常量成员的初始化</span><br><span class="line">aa+=1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void A::print()&#123;</span><br><span class="line">cout&lt;&lt;&quot;count=&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;aa=&quot;&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">void main()&#123;</span><br><span class="line">    A a(10);</span><br><span class="line">    A::print();//通过类访问静态成员函数</span><br><span class="line">    a.print();//通过对象访问静态成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化位置"><a href="#初始化位置" class="headerlink" title="初始化位置"></a>初始化位置</h3><p>静态成员不能在类的定义里初始化（除int外）。不能在头文件里初始化。<br>比如定义了 myclass.h，一般放到myclass.cpp里初始化它。</p>
<p>1、根据primer第4版的解释，static局部对象必须遵守【确保不迟于在程序执行流程第一次经过该对象的定义语句时进行<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>】的这一个原则。<br>2、同时，我们知道类内部的执行顺序并不是按行次序执行的，而是按对象调用执行的。<br>3、以上两者决定了一个问题：如果在类内定义，那么不建立对象时，<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态数据</a>成员无法<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>，或<a href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>时间太迟。【可能原因之一】<br>4、再者，<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态成员</a>的生命周期是，一经建立便会存在与整个程序的生命周期内。而<a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态数据</a>成员即属于类、也不属于类的原因便在此，在类内定义，会使其完全成为该类中的成员，也就是说，当建立复数个该类对象时，会再次声明并定义这个变量的位置，且<a href="https://www.baidu.com/s?wd=%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">名字空间</a>和作用域相同下，导致重名问题。【可能原因之二】<br>5、因此static的成员需要独立于类作定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------Test.h----------------------------</span><br><span class="line">#pragma once</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">private :</span><br><span class="line">    int var1;</span><br><span class="line">    // int var11= 4; 错误的初始化方法</span><br><span class="line">    const int var2 ;</span><br><span class="line">    // const int var22 =22222; 错误的初始化方法</span><br><span class="line">    static int var3;</span><br><span class="line">    // static int var3333=33333; 错误，只有静态常量int成员才能直接赋值来初始化</span><br><span class="line">    static const int var4=4444; //正确，静态常量成员可以直接初始化  </span><br><span class="line">    static const int var44;</span><br><span class="line">public:</span><br><span class="line">    Test(void);</span><br><span class="line">    ~Test(void);</span><br><span class="line">&#125;;</span><br><span class="line">--------------------Test.cpp-----------------------------------</span><br><span class="line">#include &quot;.\test.h&quot;</span><br><span class="line"> </span><br><span class="line">int Test::var3 = 3333333; //静态成员的正确的初始化方法</span><br><span class="line"> </span><br><span class="line">// int Test::var1 = 11111;; 错误静态成员才能初始化</span><br><span class="line">// int Test::var2 = 22222; 错误</span><br><span class="line">// int Test::var44 = 44444; // 错误的方法，提示重定义</span><br><span class="line">Test::Test(void)：var1(11111),var2(22222)正确的初始化方法//var3(33333)不能在这里初始化</span><br><span class="line">&#123;</span><br><span class="line">    var1 =11111; //正确, 普通变量也可以在这里初始化</span><br><span class="line">    //var2 = 222222; 错误，因为常量不能赋值，只能在 “constructor initializer （构造函数的初始化列表）” 那里初始化  </span><br><span class="line">    var3 =44444; //这个赋值是正确的，不过因为所有对象一个静态成员，所以会影响到其他的，这不能叫做初始化了吧</span><br><span class="line">&#125;</span><br><span class="line">Test::~Test(void)&#123;&#125;</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>

<p><strong>有些成员变量的数据类型比较特别，它们的初始化方式也和普通数据类型的成员变量有所不同。这些特殊的类型的成员变量包括：</strong></p>
<p>  a. 常量型成员变量 const int </p>
<p>  b. 引用型成员变量 int &amp;</p>
<p><em><strong>*对于常量型成员变量和引用型成员变量的初始化，必须通过构造函数初始化列表的方式进行。在构造函数体内给常量型成员变量和引用型成员变量赋值的方式是行不通的。*</strong></em></p>
<p>  c. 静态成员变量 static int </p>
<p>  d. 整型静态常量成员变量 static const int </p>
<p>  e. 非整型静态常量成员变量 static const double</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Initialization of Special Data Member</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;     </span><br><span class="line">class BClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BClass() : i(1),ci(2), ri(i) // 对于常量型成员变量和引用型成员变量，必须通过  </span><br><span class="line">    &#123;               // 参数化列表的方式进行初始化。在构造函数体内进行赋值的方式，是行不通的。</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    voidprint_values()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; &quot;i =\t&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;ci =\t&quot; &lt;&lt; ci &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;ri =\t&quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;si =\t&quot; &lt;&lt; si &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;csi =\t&quot; &lt;&lt; csi &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;csi2 =\t&quot; &lt;&lt; csi2 &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;csd =\t&quot; &lt;&lt; csd &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    int i; // 普通成员变量</span><br><span class="line">    const int ci; // 常量成员变量</span><br><span class="line">    int &amp;ri; // 引用成员变量</span><br><span class="line">    static int si; // 静态成员变量</span><br><span class="line">    //static int si2 = 100; // error: 只有静态常量成员变量，才可以这样初始化</span><br><span class="line">    static const int csi; // 静态常量成员变量</span><br><span class="line">    static const int csi2 = 100; // 静态常量成员变量的初始化(Integral type) (1)</span><br><span class="line">    static const double csd; // 静态常量成员变量(non-Integral type)</span><br><span class="line">    //staticconst double csd2 = 99.9; // error: 只有静态常量整型数据成员才可以在类中初始化</span><br><span class="line">&#125;;</span><br><span class="line">// 静态成员变量的初始化(Integral type)</span><br><span class="line">int BClass::si = 0;</span><br><span class="line">// 静态常量成员变量的初始化(Integral type)</span><br><span class="line">const int BClass::csi = 1;</span><br><span class="line">// 静态常量成员变量的初始化(non-Integral type)</span><br><span class="line">const double BClass::csd = 99.9;</span><br><span class="line"> </span><br><span class="line">// 在初始化(1)中的csi2时，根据Stanley B. Lippman的说法下面这行是必须的。</span><br><span class="line">// 但在VC2003中如果有下面一行将会产生错误，而在VC2005中，下面这行则可有可无，这个和编译器有关。</span><br><span class="line">const int BClass::csi2;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    BClassb_class;</span><br><span class="line">    b_class.print_values(); </span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-静态成员小结-c-static"><a href="#c-静态成员小结-c-static" class="headerlink" title="c++静态成员小结,c++,static"></a><strong>c++静态成员小结,c++,static</strong></h3><p>静态类成员包括静态数据成员和静态函数成员两部分。 </p>
<p><strong>静态数据成员</strong></p>
<p>类体中的数据成员的声明前加上static关键字，该数据成员就成为了该类的静态数据成员。和其他数据成员一样，静态数据成员也遵守public/protected/private访问规则。同时，静态数据成员还具有以下特点： </p>
<p><strong>1.静态数据成员的定义。</strong> </p>
<p>静态数据成员实际上是<strong>类域中的全局变量</strong>。所以，静态数据成员的定义(初始化)不应该被放在头文件中。 （声明vs.定义（初始化））</p>
<p>其定义方式与全局变量相同。举例如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx.h文件 </span><br><span class="line">class base&#123; </span><br><span class="line">private: </span><br><span class="line">    static const int _i;//声明，标准c++支持有序类型在类体中初始化,但vc6不支持。 </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">xxx.cpp文件 </span><br><span class="line">const int base::_i=10;//定义(初始化)时不受private和protected访问限制. </span><br></pre></td></tr></table></figure>

<p>注：不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。 </p>
<p><strong>2.静态数据成员被类的所有对象所共享，包括该类派生类的对象。即派生类对象与基类对象共享基类的静态数据成员。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public : </span><br><span class="line">    static int _num;//声明 </span><br><span class="line">&#125;; </span><br><span class="line">int base::_num=0;//静态数据成员的真正定义 </span><br><span class="line">class derived:public base&#123; &#125;; </span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    base a; </span><br><span class="line">    derived b; </span><br><span class="line">    a._num++; </span><br><span class="line">    cout&lt;&lt;&quot;base class static data number_num is&quot;&lt;&lt;a._num&lt;&lt;endl; </span><br><span class="line">    b._num++; </span><br><span class="line">    cout&lt;&lt;&quot;derived class static datanumber _num is&quot;&lt;&lt;b._num&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">// 结果为1,2;可见派生类与基类共用一个静态数据成员。 </span><br></pre></td></tr></table></figure>

<p><strong>3.静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public : </span><br><span class="line">    static int _staticVar; </span><br><span class="line">    int _var; </span><br><span class="line">    void foo1(int i=_staticVar);//正确,_staticVar为静态数据成员 </span><br><span class="line">    void foo2(int i=_var);//错误,_var为普通数据成员 </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>4.★静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为所属类类型的指针或引用。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public : </span><br><span class="line">    static base _object1;//正确，静态数据成员 </span><br><span class="line">    base _object2;//错误 </span><br><span class="line">    base *pObject;//正确，指针 </span><br><span class="line">    base &amp;mObject;//正确，引用 </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>5.★这个特性，我不知道是属于标准c++中的特性，还是vc6自己的特性。</strong> </p>
<p><strong>静态数据成员的值在const成员函数中可以被合法的改变。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public: </span><br><span class="line">    base()&#123;</span><br><span class="line">        _i=0;</span><br><span class="line">        _val=0;</span><br><span class="line">    &#125; </span><br><span class="line">    mutable int _i; </span><br><span class="line">    static int _staticVal; </span><br><span class="line">    int _val; </span><br><span class="line">    void test() const&#123;//const 成员函数 </span><br><span class="line">        _i++;//正确，mutable数据成员 </span><br><span class="line">        _staticVal++;//正确，static数据成员 </span><br><span class="line">        _val++;//错误 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">int base::_staticVal=0; </span><br></pre></td></tr></table></figure>

<p><strong>静态成员函数</strong> </p>
<p>静态成员函数没有什么太多好讲的。 </p>
<p><strong>1.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用类成员函数指针来储存。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">    static int func1(); </span><br><span class="line">    int func2(); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int (*pf1)()=&amp;base::func1;//普通的函数指针 </span><br><span class="line">int (base::*pf2)()=&amp;base::func2;//成员函数指针 </span><br></pre></td></tr></table></figure>

<p><strong>2.静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。</strong> </p>
<p>***静态成员变量的函数形参中没有默认的this指针指向类对象本身（不能指向具体的类对象）。所以当我们调用对象的非静态成员变量的时候它不能识别该变量然而对于静态成员变量而言，其存在于整个类中，为每个类对象共有，所以就算没有默认的this形参仍然可以识别该静态成员变量*<br>**</p>
<p><strong>3.静态成员函数不可以同时声明为 virtual、const、volatile函数。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">    virtual static void func1();//错误 </span><br><span class="line">    static void func2() const;//错误 </span><br><span class="line">    static void func3() volatile;//错误 </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>最后要说的一点是，静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2021/07/20/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> 或者<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp =a;</span><br><span class="line">a=b;</span><br><span class="line">b=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>模板函数定义的时候，templat关键字只对下面第一个函数起作用，所以如果要定义多个模板函数，每个模板函数上一行都得写template <class t>语句。</class></li>
<li>隐式调用的时候和普通函数没有区别，因为可以自动类型推导；显式调用使用下面的方法：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">swap&lt;<span class="keyword">int</span> &gt;(a,b);</span><br></pre></td></tr></table></figure>

<h2 id="函数模板和普通函数的区别："><a href="#函数模板和普通函数的区别：" class="headerlink" title="函数模板和普通函数的区别："></a>函数模板和普通函数的区别：</h2><ul>
<li>l 函数模板不允许自动类型转换，而普通函数可以（自动类型转换即，如上定义的swap函数a和b的类型都是T，如果传两个同样类型的数就没问题，如int，但是如果传的两个数类型不同，如一个int，一个char就不行）。</li>
<li>l 函数模板必须严格类型匹配</li>
<li>函数模板和普通函数一起调用的规则：</li>
<li>l 函数模板可以重载</li>
<li>l C++编译器优先考虑普通函数</li>
<li>l 可以通过空模板实参列表的语法限定编译器只能通过模板匹配，如swap&lt;&gt;(a,b);</li>
</ul>
<h2 id="c-编译过程"><a href="#c-编译过程" class="headerlink" title="c 编译过程"></a>c 编译过程</h2><p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720213327490.png" alt="image-20210720213327490"></p>
<h2 id="模板函数实现原理"><a href="#模板函数实现原理" class="headerlink" title="模板函数实现原理"></a>模板函数实现原理</h2><p>我们定义的是函数模板，是个模板，在使用的时候，会根据调用生成对应的模板函数，这个函数才是是我们实际调用的，<mark class="hl-label red">我们不是调用的函数模板,函数模板不能被调用</mark>  。</p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720213507325.png" alt="image-20210720213507325"></p>
<p>编译器并不是把函数模板处理成能够处理任何类型的函数，而是通过具体类型产生不同的函数；</p>
<p>编译器会对函数模板进行<mark class="hl-label red">两次编译</mark>  ，一次是在申明的地方对模板代码本身进行编译看有没有问题，第二次是对参数替换后的代码（生成了对应的模板函数）进行编译。</p>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p>函数模板在调用的时候可以自动类型推导（注意不是转换），但是类模板必须显式指定类型；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;</span><br><span class="line">        mAge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//为什么?</span></span><br><span class="line"><span class="comment">//类区定义对象，这个对象是不是需要编译分配内存</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span> :</span> <span class="keyword">public</span> Person&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">jiao</span><span class="params">()</span></span>&#123;</span><br><span class="line">         cout&lt;&lt;mAge&lt;&lt;<span class="string">&quot;岁动物在叫！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> Public Animal&lt;T&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat&lt;<span class="keyword">int</span>&gt; cat;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类内实现："><a href="#类内实现：" class="headerlink" title="类内实现："></a>类内实现：</h2><p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720214710107.png" alt="image-20210720214710107"></p>
<h2 id="类外实现（但是要写在一个文件里）："><a href="#类外实现（但是要写在一个文件里）：" class="headerlink" title="类外实现（但是要写在一个文件里）："></a>类外实现（但是要写在一个文件里）：</h2><p>需要注意在第一个Person后面要加上参数说明，如果不加，表示Show或者构造函数属于所有类，类模板能创建出来很多具体的类，而每个Show或者构造函数只需要一个具体的类，如果不加类型说明，表示它们属于所有，这不对，加上类型说明，形成具体的类</p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720214732036.png" alt="image-20210720214732036"></p>
<h2 id="类外实现（如果-h和-cpp分开写）："><a href="#类外实现（如果-h和-cpp分开写）：" class="headerlink" title="类外实现（如果.h和.cpp分开写）："></a>类外实现（如果.h和.cpp分开写）：</h2><p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720214918284.png" alt="image-20210720214918284"></p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720214855572.png" alt="image-20210720214855572"></p>
<p>在main文件里不能下面这样调用</p>
<p>因为main文件，没有Person的构造函数和show函数定义，跳过，再编译Person.h文件，里面没有函数定义，跳过，所以都编译成功了。</p>
<p>但是调用的时候，没有具体的函数调用（函数模板两次编译，现在这种写法只编译了函数模板，没有编译具体的模板函数，模板函数的产生是需要调用的，这里没有调用）。</p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720215815339.png" alt="image-20210720215815339"></p>
<p>所以改成下面的写法，引用.cpp文件</p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720215831708.png" alt="image-20210720215831708"></p>
<p>这样就能调用成功了。</p>
<h1 id="有元（不要滥用）"><a href="#有元（不要滥用）" class="headerlink" title="有元（不要滥用）"></a>有元（不要滥用）</h1><p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720215848557.png" alt="image-20210720215848557"></p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720215856231.png" alt="image-20210720215856231"></p>
<h1 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h1><p>​                                <img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/wps1.jpg" alt="img"> </p>
<p>​                                <img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/wps2.jpg" alt="img"> </p>
<h1 id="碰到static"><a href="#碰到static" class="headerlink" title="碰到static"></a>碰到static</h1><p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720220028450.png" alt="image-20210720220028450"></p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720220032467.png" alt="image-20210720220032467"></p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720220051587.png" alt="image-20210720220051587"></p>
<p><img src="/2021/07/20/%E6%A8%A1%E6%9D%BF/image-20210720220059063.png" alt="image-20210720220059063"></p>
]]></content>
      <categories>
        <category>C++ 函数模板 类模板</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/2021/06/20/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h1><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFileInfo <span class="title">fi</span><span class="params">(<span class="string">&quot;C:/123&quot;</span>)</span></span>; <span class="comment">// 目录存在</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isFile</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isDir</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">exists</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isRoot</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:/123&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QDir</span>(<span class="string">&quot;C:/123&quot;</span>).<span class="built_in">exists</span>(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">fi.<span class="built_in">setFile</span>(<span class="string">&quot;C:/ABC&quot;</span>); <span class="comment">// 目录不存在</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isFile</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isDir</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isRoot</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:/ABC&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QDir</span>(<span class="string">&quot;C:/ABC&quot;</span>).<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fi.<span class="built_in">setFile</span>(<span class="string">&quot;C:/&quot;</span>); <span class="comment">// 存在的驱动器</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isFile</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isDir</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">exists</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isRoot</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:/&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QDir</span>(<span class="string">&quot;C:/&quot;</span>).<span class="built_in">exists</span>(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">fi.<span class="built_in">setFile</span>(<span class="string">&quot;Z:/&quot;</span>); <span class="comment">// 不存在的驱动器</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isFile</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isDir</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isRoot</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFile::<span class="built_in">exists</span>(<span class="string">&quot;Z:/&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QDir</span>(<span class="string">&quot;Z:/&quot;</span>).<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fi.<span class="built_in">setFile</span>(<span class="string">&quot;C:/123.lnk&quot;</span>); <span class="comment">// 快捷方式存在且指向的文件也存在</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isFile</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isDir</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">exists</span>(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isRoot</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:/123.lnk&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QDir</span>(<span class="string">&quot;C:/123.lnk&quot;</span>).<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fi.<span class="built_in">setFile</span>(<span class="string">&quot;C:/456.lnk&quot;</span>); <span class="comment">// 快捷方式存在但指向的文件不存在</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isFile</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isDir</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fi.<span class="built_in">isRoot</span>(); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QFile::<span class="built_in">exists</span>(<span class="string">&quot;C:/456.lnk&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QDir</span>(<span class="string">&quot;C:/456.lnk&quot;</span>).<span class="built_in">exists</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以看到，容易让人感到混乱的是exists方法，这个方法是通用的判断方法，可以看成是这样的表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exists</span>() == (<span class="built_in">isFile</span>() || <span class="built_in">isDir</span>())</span><br><span class="line">    </span><br><span class="line">准确判断文件是否存在</span><br><span class="line"><span class="number">1.</span>用QFileInfo::<span class="built_in">isFile</span>()方法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">准确判断文件夹是否存在</span><br><span class="line"><span class="number">1.</span>用QFileInfo::<span class="built_in">isDir</span>()方法</span><br><span class="line"><span class="number">2.</span>用QDir::<span class="built_in">exists</span>()方法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#123;% label 不确定字符串是文件还是文件夹路径 blue %&#125;</span><br><span class="line"><span class="number">1.</span>用QFileInfo::<span class="built_in">exists</span>()方法</span><br><span class="line"><span class="number">2.</span>用QFile::<span class="built_in">exists</span>()方法</span><br></pre></td></tr></table></figure>

<h3 id="创建文件夹-1"><a href="#创建文件夹-1" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDir&gt;</span>#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例QDir</span></span><br><span class="line">QDir *folder = <span class="keyword">new</span> QDir;</span><br><span class="line"><span class="comment">//判断创建文件夹是否存在</span></span><br><span class="line"><span class="keyword">bool</span> exist = folder-&gt;<span class="built_in">exists</span>(<span class="string">&quot;D:/NewFolder&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(exist)</span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;创建文件夹&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;文件夹已经存在！&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//如果不存在，创建文件夹</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建文件夹</span></span><br><span class="line">    <span class="keyword">bool</span> ok = folder-&gt;<span class="built_in">mkdir</span>(<span class="string">&quot;D:/NewFolder&quot;</span>);</span><br><span class="line">    <span class="comment">//判断是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(ok)</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;创建文件夹&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;文件夹创建成功！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;创建文件夹&quot;</span>),<span class="built_in">tr</span>(<span class="string">&quot;文件夹创建失败！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString path=QDir::<span class="built_in">currentPath</span>();<span class="comment">//获取程序当前目录</span></span><br><span class="line">path.<span class="built_in">replace</span>(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>);<span class="comment">//将地址中的&quot;/&quot;替换为&quot;\&quot;，因为在Windows下使用的是&quot;\&quot;。</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;path;</span><br><span class="line"><span class="comment">//实例QDir</span></span><br><span class="line">QDir folder;</span><br><span class="line">path.<span class="built_in">append</span>(<span class="string">&quot;\\dat\\video\\src_video\\&quot;</span>);</span><br><span class="line"><span class="comment">//判断创建文件夹是否存在</span></span><br><span class="line"><span class="keyword">bool</span> exist = folder.<span class="built_in">exists</span>(path);</span><br><span class="line"><span class="keyword">if</span>(!exist)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建文件夹</span></span><br><span class="line"><span class="keyword">bool</span> ok = folder.<span class="built_in">mkpath</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="使用-system-调用-dos-命令"><a href="#使用-system-调用-dos-命令" class="headerlink" title="使用 system() 调用 dos 命令"></a>使用 system() 调用 dos 命令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string folderPath = <span class="string">&quot;E:\\database\\testFolder&quot;</span>; </span><br><span class="line">    string command;</span><br><span class="line">    command = <span class="string">&quot;mkdir -p &quot;</span> + folderPath;  </span><br><span class="line">    <span class="built_in">system</span>(command.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用access-和-mkdir-函数"><a href="#使用access-和-mkdir-函数" class="headerlink" title="使用access 和 mkdir 函数"></a>使用access 和 mkdir 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt_io.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string folderPath = <span class="string">&quot;E:\\database\\testFolder&quot;</span>; </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != _access(folderPath.<span class="built_in">c_str</span>(), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if this folder not exist, create a new one.</span></span><br><span class="line">        <span class="built_in">mkdir</span>(folderPath.<span class="built_in">c_str</span>()); <span class="comment">// 返回 0 表示创建成功，-1 表示失败</span></span><br><span class="line">        <span class="comment">//换成 ::_mkdir ::_access 也行，不知道什么意思</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用-Windows-API-函数"><a href="#调用-Windows-API-函数" class="headerlink" title="调用 Windows API 函数"></a>调用 Windows API 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string folderPath = <span class="string">&quot;E:\\database\\testFolder&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetFileAttributesA</span>(folderPath.<span class="built_in">c_str</span>()) &amp; FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="built_in">CreateDirectory</span>(folderPath.<span class="built_in">c_str</span>(), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// flag 为 true 说明创建成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Directory already exists.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h1><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h3 id="调用Windows-API函数"><a href="#调用Windows-API函数" class="headerlink" title="调用Windows API函数"></a>调用Windows API函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RemoveDirectory</span><span class="params">(LPCTSTR lpPathName)</span></span>;</span><br><span class="line"></span><br><span class="line">头、库文件 </span><br><span class="line">Winbase.h, Coredll.lib</span><br><span class="line"></span><br><span class="line">参数： </span><br><span class="line">\- lpPathName：字符串指针，要删除的文件夹的路径。</span><br><span class="line"></span><br><span class="line">返回值： </span><br><span class="line">成功-非零，失败-零。查看错误使用<span class="built_in">GeLastError</span>();</span><br></pre></td></tr></table></figure>

<h3 id="调用C运行库函数"><a href="#调用C运行库函数" class="headerlink" title="调用C运行库函数"></a>调用C运行库函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _rmdir(<span class="keyword">const</span> <span class="keyword">char</span>* dirname);</span><br><span class="line"><span class="keyword">int</span> _wrmdir(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* dirname);</span><br><span class="line"></span><br><span class="line">头、库文件： </span><br><span class="line">direct.h或者wchar.h，c运行库</span><br><span class="line"></span><br><span class="line">宏定义：</span><br><span class="line">tchar.h _MBCS defined _UNICODE defined</span><br><span class="line">_trmdir _rmdir _wrmdir</span><br><span class="line">参数： </span><br><span class="line">- dirname：字符串指针，要删除的文件夹的路径。</span><br><span class="line"></span><br><span class="line">返回值： </span><br><span class="line"><span class="number">0</span>-成功，<span class="number">-1</span>-失败。</span><br></pre></td></tr></table></figure>

<h1 id="查询是否是文件夹"><a href="#查询是否是文件夹" class="headerlink" title="查询是否是文件夹"></a>查询是否是文件夹</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string aa = (string)chRtn + fileinfo.name;</span><br><span class="line">WIN32_FIND_DATAA FindFileData;</span><br><span class="line"><span class="built_in">FindFirstFileA</span>(aa.<span class="built_in">c_str</span>(), &amp;FindFileData);</span><br><span class="line"><span class="comment">//FindFirstFileA(tempPath,&amp;FindFileData);</span></span><br><span class="line"><span class="keyword">if</span> (FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line">    foldername.<span class="built_in">push_back</span>(fileinfo.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前exe路径</span></span><br><span class="line">TCHAR szFilePath[MAX_PATH + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFilePath, MAX_PATH);</span><br><span class="line">(_tcsrchr(szFilePath, _T(<span class="string">&#x27;\\&#x27;</span>)))[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 删除文件名，只获得路径字串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iLen = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">char</span>* chRtn = <span class="keyword">new</span> <span class="keyword">char</span>[iLen*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)];</span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, chRtn, iLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接路径</span></span><br><span class="line">string to_search = (string)chRtn+<span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历路径下的文件，找到需要的png</span></span><br><span class="line">vector&lt;string &gt; foldername;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * point = <span class="string">&quot;.&quot;</span>;<span class="comment">//分割标示</span></span><br><span class="line"><span class="keyword">intptr_t</span> handle;    <span class="comment">//用于查找的句柄</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fileinfo</span>;</span>    <span class="comment">//文件信息的结构体</span></span><br><span class="line">handle = _findfirst(to_search.<span class="built_in">c_str</span>(), &amp;fileinfo);    <span class="comment">//第一次查找</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == handle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fileinfo.attrib == <span class="number">16</span>  &amp;&amp; <span class="built_in">strcmp</span>(fileinfo.name, <span class="string">&quot;.&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fileinfo.name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    foldername.<span class="built_in">push_back</span>(fileinfo.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//finename.push_back(atoi(strtok(fileinfo.name, point)));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!_findnext(handle, &amp;fileinfo)) &#123;    <span class="comment">//循环查找其它符合的文件，直到找不到其它的为止</span></span><br><span class="line">    <span class="keyword">if</span> (fileinfo.attrib == <span class="number">16</span> &amp;&amp; <span class="built_in">strcmp</span>(fileinfo.name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fileinfo.name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        foldername.<span class="built_in">push_back</span>(fileinfo.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">_findclose(handle);</span><br></pre></td></tr></table></figure>

<h1 id="查询子文件夹"><a href="#查询子文件夹" class="headerlink" title="查询子文件夹"></a>查询子文件夹</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="Qt-1"><a href="#Qt-1" class="headerlink" title="Qt"></a>Qt</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QDir <span class="title">dir</span><span class="params">(_srcDirpath)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!dir.<span class="built_in">exists</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dir.<span class="built_in">setFilter</span>(QDir::Dirs );</span><br><span class="line">QFileInfoList list = dir.<span class="built_in">entryInfoList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> file_count = list.<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">if</span>(file_count &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QStringList string_list;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;file_count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    QFileInfo file_info = list.<span class="built_in">at</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(file_info.<span class="built_in">fileName</span>() == <span class="string">&quot;.&quot;</span> | file_info.<span class="built_in">fileName</span>() == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(file_info.<span class="built_in">isDir</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        string_list.<span class="built_in">append</span>(file_info.<span class="built_in">absoluteFilePath</span>());</span><br><span class="line">        <span class="comment">//QString suffix = file_info.suffix();</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;file_info.<span class="built_in">absoluteFilePath</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//        if(QString::compare(suffix, QString(&quot;png&quot;), Qt::CaseInsensitive) == 0)</span></span><br><span class="line">    <span class="comment">//        &#123;</span></span><br><span class="line">    <span class="comment">//            QString absolute_file_path = file_info.absoluteFilePath();</span></span><br><span class="line">    <span class="comment">//            string_list.append(absolute_file_path);</span></span><br><span class="line">    <span class="comment">//            qDebug()&lt;&lt;absolute_file_path;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;string_list.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取当前exe路径</span><br><span class="line">TCHAR szFilePath[MAX_PATH + 1] = &#123; 0 &#125;;</span><br><span class="line">GetModuleFileName(NULL, szFilePath, MAX_PATH);</span><br><span class="line">(_tcsrchr(szFilePath, _T(&#x27;\\&#x27;)))[1] = 0; // 删除文件名，只获得路径字串</span><br><span class="line"></span><br><span class="line">int iLen = WideCharToMultiByte(CP_ACP, 0, szFilePath, -1, NULL, 0, NULL, NULL);</span><br><span class="line">char* chRtn = new char[iLen*sizeof(char)];</span><br><span class="line">WideCharToMultiByte(CP_ACP, 0, szFilePath, -1, chRtn, iLen, NULL, NULL);</span><br><span class="line"></span><br><span class="line">//拼接路径</span><br><span class="line">string to_search = (string)chRtn + &quot;*&quot;;</span><br><span class="line"></span><br><span class="line">//遍历路径下的文件夹</span><br><span class="line">vector&lt;string &gt; foldername;</span><br><span class="line">const char * point = &quot;.&quot;;//分割标示</span><br><span class="line">intptr_t handle;    //用于查找的句柄</span><br><span class="line">struct _finddata_t fileinfo;    //文件信息的结构体</span><br><span class="line">handle = _findfirst(to_search.c_str(), &amp;fileinfo);    //第一次查找</span><br><span class="line">if (-1 == handle) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (fileinfo.attrib == 16 &amp;&amp; strcmp(fileinfo.name, &quot;.&quot;) != 0 &amp;&amp; strcmp(fileinfo.name, &quot;..&quot;) != 0)</span><br><span class="line">&#123;</span><br><span class="line">foldername.push_back(fileinfo.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (!_findnext(handle, &amp;fileinfo)) &#123;    //循环查找其它符合的文件，直到找不到其它的为止</span><br><span class="line">if ((fileinfo.attrib == 16 || fileinfo.attrib == 48) &amp;&amp; strcmp(fileinfo.name, &quot;.&quot;) != 0 &amp;&amp; strcmp(fileinfo.name, &quot;..&quot;) != 0)</span><br><span class="line">&#123;</span><br><span class="line">foldername.push_back((string)chRtn + fileinfo.name+&quot;\\&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fileinfo.name &lt;&lt; fileinfo.attrib &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">_findclose(handle);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;当前目录下有子文件夹个数：&quot; &lt;&lt; foldername.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h2><h3 id="打开文件-二进制"><a href="#打开文件-二进制" class="headerlink" title="打开文件 二进制"></a>打开文件 二进制</h3><p>Windows下，文件换行是/r /n两个组合，Linux下只有/n，所以在写入文件的时候，windows下会在换行的时候自动转换。</p>
<p>所有的文件在机器里存的都是二进制，只不过显示的时候自动给转换成可以看懂的了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；</span></span><br><span class="line"><span class="comment">//如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//ofstream         //文件写操作 内存写入存储设备   </span></span><br><span class="line"><span class="comment">//ifstream         //文件读操作，存储设备读区到内存中  </span></span><br><span class="line"><span class="comment">//fstream          //读写操作，对打开的文件可进行读写操作</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//（一）打开文件的方式在ios类(所以流式I/O的基类)中定义，有如下几种方式：</span></span><br><span class="line"><span class="comment">//ios::in	为输入(读)而打开文件</span></span><br><span class="line"><span class="comment">//ios::out	为输出(写)而打开文件</span></span><br><span class="line"><span class="comment">//ios::ate	初始位置：文件尾</span></span><br><span class="line"><span class="comment">//ios::app	所有输出附加在文件末尾</span></span><br><span class="line"><span class="comment">//ios::trunc	如果文件已存在则先删除该文件</span></span><br><span class="line"><span class="comment">//ios::binary	二进制方式 这些方式是能够进行组合使用的，以“或”运算（“|”）的方式：例如</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//（二）、保护模式</span></span><br><span class="line"><span class="comment">//#define _SH_DENYRW      0x10    /* deny read/write mode */拒绝对文件进行读写 </span></span><br><span class="line"><span class="comment">//#define _SH_DENYWR      0x20    /* deny write mode */拒绝写入文件 </span></span><br><span class="line"><span class="comment">//#define _SH_DENYRD      0x30    /* deny read mode */拒绝文件的读取权限 </span></span><br><span class="line"><span class="comment">//#define _SH_DENYNO      0x40    /* deny none mode */读取和写入许可 </span></span><br><span class="line"><span class="comment">//#define _SH_SECURE      0x80    /* secure mode */共享读取，独占写入 </span></span><br><span class="line"><span class="comment">//注意：假设A进程以_SH_DENYRW 打开，那么是B进程不能再对文件进行读写。</span></span><br><span class="line"> </span><br><span class="line">ofstream ofs;							<span class="comment">//打开文件用于写，若文件不存在就创建它</span></span><br><span class="line"> </span><br><span class="line">locale loc = locale::<span class="built_in">global</span>(<span class="built_in">locale</span>(<span class="string">&quot;&quot;</span>)); 		       <span class="comment">//要打开的文件路径含中文，设置全局locale为本地环境 </span></span><br><span class="line"> </span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;./out.bin&quot;</span>,ios::out| ios::app | ios::binary,_SH_DENYNO); <span class="comment">//输出到文件 ，追加的方式，二进制。 可同时用其他的工具打开此文件</span></span><br><span class="line"> </span><br><span class="line">locale::<span class="built_in">global</span>(loc);					      <span class="comment">//恢复全局locale</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!ofs.<span class="built_in">is_open</span>())<span class="keyword">return</span>;	<span class="comment">//打开文件失败则结束运行  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>* buffer = <span class="string">&quot;fdsfdsfdsfdsfdsfds\n&quot;</span>;</span><br><span class="line">	ofs.<span class="built_in">write</span>(buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">17</span>); </span><br><span class="line">	ofs.<span class="built_in">flush</span>();</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ofs.<span class="built_in">close</span>();  </span><br></pre></td></tr></table></figure>

<h3 id="读取-ANSI-UNICODE-UTF-8-二进制"><a href="#读取-ANSI-UNICODE-UTF-8-二进制" class="headerlink" title="读取 ANSI,UNICODE,UTF-8 二进制"></a>读取 ANSI,UNICODE,UTF-8 二进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FBLOCK_MAX_BYTES = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File Type.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">FileType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ANSI = <span class="number">0</span>,</span><br><span class="line">    UNICODE,</span><br><span class="line">    UTF8,</span><br><span class="line">&#125;FILETYPE;</span><br><span class="line"></span><br><span class="line"><span class="function">FILETYPE <span class="title">GetTextFileType</span><span class="params">(<span class="keyword">const</span> std::string &amp; strFileName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnicodeToANSI</span><span class="params">(<span class="keyword">char</span> * pDes, <span class="keyword">const</span> <span class="keyword">wchar_t</span> * pSrc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// file test.</span></span><br><span class="line">    std::string strFileANSI = <span class="string">&quot;C://Hello_ANSI.txt&quot;</span>;</span><br><span class="line">    std::string strFileUNICODE = <span class="string">&quot;C://Hello_UNICODE.txt&quot;</span>;</span><br><span class="line">    std::string strFileUTF8 = <span class="string">&quot;C://Hello_UTF8.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// please change the file name to test.</span></span><br><span class="line">    std::string strFileName = strFileUTF8;</span><br><span class="line">    FILETYPE fileType = <span class="built_in">GetTextFileType</span>(strFileName);</span><br><span class="line">    <span class="keyword">if</span> (UNICODE == fileType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wchar_t</span> szBuf[FBLOCK_MAX_BYTES];</span><br><span class="line">        <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>) * FBLOCK_MAX_BYTES);</span><br><span class="line">        std::string strMessage;</span><br><span class="line">        FILE * fp = <span class="literal">NULL</span>;</span><br><span class="line">        fp = <span class="built_in">fopen</span>(strFileName.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Unicode file should offset wchar_t bits(2 byte) from start.</span></span><br><span class="line">            <span class="built_in">fseek</span>(fp, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">fread</span>(szBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>), FBLOCK_MAX_BYTES, fp) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> szTemp[FBLOCK_MAX_BYTES] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">UnicodeToANSI</span>(szTemp, szBuf);</span><br><span class="line">                strMessage += szTemp;</span><br><span class="line">                <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>) * FBLOCK_MAX_BYTES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; strMessage &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (UTF8 == fileType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> szBuf[FBLOCK_MAX_BYTES];</span><br><span class="line">        <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * FBLOCK_MAX_BYTES);</span><br><span class="line">        std::string strMessage;</span><br><span class="line">        FILE * fp = <span class="literal">NULL</span>;</span><br><span class="line">        fp = <span class="built_in">fopen</span>(strFileName.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// UTF-8 file should offset 3 byte from start position.</span></span><br><span class="line">            <span class="built_in">fseek</span>(fp, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">fread</span>(szBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), FBLOCK_MAX_BYTES, fp) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                strMessage += szBuf;</span><br><span class="line">                <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * FBLOCK_MAX_BYTES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; strMessage &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> szBuf[FBLOCK_MAX_BYTES];</span><br><span class="line">        <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * FBLOCK_MAX_BYTES);</span><br><span class="line">        </span><br><span class="line">        std::string strMessage;</span><br><span class="line">        </span><br><span class="line">        FILE * fp = <span class="literal">NULL</span>;</span><br><span class="line">        fp = <span class="built_in">fopen</span>(strFileName.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// common file do not offset.</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">fread</span>(szBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), FBLOCK_MAX_BYTES, fp) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                strMessage += szBuf;</span><br><span class="line">                <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * FBLOCK_MAX_BYTES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; strMessage &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FILETYPE <span class="title">GetTextFileType</span><span class="params">(<span class="keyword">const</span> std::string &amp; strFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILETYPE fileType = ANSI;</span><br><span class="line">    std::ifstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(strFileName.<span class="built_in">c_str</span>(), std::ios_base::in);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> bUnicodeFile = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">good</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> szFlag[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        file.<span class="built_in">read</span>(szFlag, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)szFlag[<span class="number">0</span>] == <span class="number">0xFF</span> </span><br><span class="line">            &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)szFlag[<span class="number">1</span>] == <span class="number">0xFE</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fileType = UNICODE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)szFlag[<span class="number">0</span>] == <span class="number">0xEF</span> </span><br><span class="line">            &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)szFlag[<span class="number">1</span>] == <span class="number">0xBB</span> </span><br><span class="line">            &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">char</span>)szFlag[<span class="number">2</span>] == <span class="number">0xBF</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fileType = UTF8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> fileType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UnicodeToANSI</span><span class="params">(<span class="keyword">char</span> * pDes, <span class="keyword">const</span> <span class="keyword">wchar_t</span> * pSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(pDes != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(pSrc != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> nLen = ::<span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, pSrc, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nLen == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, pSrc, <span class="number">-1</span>, pDes, nLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="宽字符文件C-读取"><a href="#宽字符文件C-读取" class="headerlink" title="宽字符文件C++读取"></a>宽字符文件C++读取</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line">	CStdioFile file;</span><br><span class="line">	CString strline;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//string 转 wstring</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, filename.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">wchar_t</span> *wide = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[num];</span><br><span class="line">	<span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, filename.<span class="built_in">c_str</span>(), <span class="number">-1</span>, wide, num);</span><br><span class="line">	<span class="function">std::wstring <span class="title">w_str</span><span class="params">(wide)</span></span>;</span><br><span class="line">	<span class="keyword">delete</span>[] wide;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//wstring.c_str()可用于LPCTSTR</span></span><br><span class="line">	<span class="keyword">if</span> (!file.<span class="built_in">Open</span>(w_str.<span class="built_in">c_str</span>(), CFile::modeRead))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种方式</span></span><br><span class="line">	<span class="comment">//wifstream infile;</span></span><br><span class="line">	<span class="comment">//infile.open(w_str.c_str(), ios::in);</span></span><br><span class="line">	<span class="comment">//while (!infile.eof())            // 若未到文件结束一直循环</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	getline(infile, w_str, L&#x27;\n&#x27;);//读取一行，以换行符结束，存入</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	wstring res=<span class="string">L&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">wchar_t</span> *next=<span class="literal">NULL</span>;</span><br><span class="line">	abc.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="comment">//整理时间，拼接起来</span></span><br><span class="line">	wstring time;</span><br><span class="line">	<span class="comment">//经纬度的DDD形式</span></span><br><span class="line">	<span class="keyword">float</span> latlonvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> degree;</span><br><span class="line">	<span class="keyword">float</span> minu;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (file.<span class="built_in">ReadString</span>(strline))            <span class="comment">// 若未到文件结束一直循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (strline != _T(<span class="string">&quot;&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//cstring转wchar *</span></span><br><span class="line">			<span class="keyword">wchar_t</span> *str = (<span class="keyword">wchar_t</span> *)strline.<span class="built_in">GetBufferSetLength</span>(strline.<span class="built_in">GetLength</span>());</span><br><span class="line"></span><br><span class="line">			res = <span class="built_in">wcstok_s</span>(str, <span class="string">L&quot; &quot;</span>, &amp;next);</span><br><span class="line">			<span class="keyword">if</span> (res.<span class="built_in">find</span>(<span class="string">L&quot;LAT&quot;</span>) != string::npos)<span class="comment">//存在。</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (*(next) != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					res = <span class="built_in">wcstok_s</span>(<span class="literal">NULL</span>, <span class="string">L&quot; &quot;</span>, &amp;next);<span class="comment">//因为是以空格分隔的</span></span><br><span class="line">					<span class="comment">//找到纬度值</span></span><br><span class="line">					<span class="keyword">if</span> (res != <span class="string">L&quot;&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">swscanf_s</span>(res.<span class="built_in">data</span>(),<span class="string">L&quot;%d°%f&quot;</span>,&amp;degree,&amp;minu);</span><br><span class="line">						<span class="comment">////换算成DDD的形式</span></span><br><span class="line">						latlonvalue = degree+(minu)/<span class="number">60</span>;</span><br><span class="line">						abc.<span class="built_in">push_back</span>(<span class="built_in">to_wstring</span>(latlonvalue));</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="built_in">find</span>(<span class="string">L&quot;LONG&quot;</span>) != string::npos)<span class="comment">//存在。</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (res.<span class="built_in">data</span>() != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					res = <span class="built_in">wcstok_s</span>(<span class="literal">NULL</span>, <span class="string">L&quot; &quot;</span>, &amp;next);</span><br><span class="line">					<span class="keyword">if</span> (res != <span class="string">L&quot;&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">swscanf_s</span>(res.<span class="built_in">data</span>(), <span class="string">L&quot;%d°%f&quot;</span>, &amp;degree, &amp;minu);</span><br><span class="line">						<span class="comment">////换算成DDD的形式</span></span><br><span class="line">						latlonvalue = degree + (minu) / <span class="number">60</span>;</span><br><span class="line">						abc.<span class="built_in">push_back</span>(<span class="built_in">to_wstring</span>(latlonvalue));</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="keyword">if</span> (res.<span class="built_in">find</span>(<span class="string">L&quot;DATE&quot;</span>) != string::npos)<span class="comment">//存在。</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (res.<span class="built_in">data</span>() != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					res = <span class="built_in">wcstok_s</span>(<span class="literal">NULL</span>, <span class="string">L&quot; &quot;</span>, &amp;next);</span><br><span class="line">					<span class="keyword">if</span> (res !=<span class="string">L&quot;&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						time = res;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="keyword">if</span> (res.<span class="built_in">find</span>(<span class="string">L&quot;TIME&quot;</span>) != string::npos)<span class="comment">//存在。</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (res.<span class="built_in">data</span>() != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					res = <span class="built_in">wcstok_s</span>(<span class="literal">NULL</span>, <span class="string">L&quot; &quot;</span>, &amp;next);</span><br><span class="line">					<span class="keyword">if</span> (res != <span class="string">L&quot;&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						abc.<span class="built_in">push_back</span>(time+<span class="string">L&quot; &quot;</span>+res);</span><br><span class="line">						abc.<span class="built_in">push_back</span>(<span class="built_in">to_wstring</span>((<span class="built_in">strTime2unix_</span>(time + <span class="string">L&quot; &quot;</span> + res))));</span><br><span class="line">						filenoutputresult.<span class="built_in">push_back</span>(abc);</span><br><span class="line">						file.<span class="built_in">Close</span>();</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	file.<span class="built_in">Close</span>();</span><br></pre></td></tr></table></figure>

<h3 id="宽字符文件C-写"><a href="#宽字符文件C-写" class="headerlink" title="宽字符文件C++写"></a>宽字符文件C++写</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"> _wfopen_s(&amp;fp, <span class="string">L&quot;result.txt&quot;</span>, <span class="string">L&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fwprintf_s</span>(fp, <span class="string">L&quot;LAT,&quot;</span>);</span><br><span class="line"><span class="built_in">fwprintf_s</span>(fp, <span class="string">L&quot;LON,&quot;</span>);</span><br><span class="line"><span class="built_in">fwprintf_s</span>(fp, <span class="string">L&quot;DATE,&quot;</span>);</span><br><span class="line"><span class="built_in">fwprintf_s</span>(fp, <span class="string">L&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; filenoutputresult.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fwprintf_s</span>(fp, filenoutputresult[i][j].<span class="built_in">data</span>());</span><br><span class="line">		<span class="built_in">fwprintf_s</span>(fp, <span class="string">L&quot;,&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fwprintf_s</span>(fp, filenoutputresult[i][<span class="number">2</span>].<span class="built_in">data</span>());</span><br><span class="line">	<span class="built_in">fwprintf_s</span>(fp, <span class="string">L&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br></pre></td></tr></table></figure>



<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">output</span><span class="params">(Cfg::get()-&gt;valS(<span class="string">&quot;InputFile&quot;</span>) + <span class="string">&quot;recordReturnTime.txt&quot;</span>, ios::out | std::ios::app, _SH_DENYNO)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!output.<span class="built_in">is_open</span>()) <span class="keyword">return</span>;</span><br><span class="line">output &lt;&lt; <span class="built_in">strtok</span>(<span class="built_in">strtok</span>(fihenm leinfo.name, point),<span class="string">&quot;new&quot;</span>)[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">output.<span class="built_in">flush</span>();</span><br><span class="line">output.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function">std::ifstream <span class="title">freturn</span><span class="params">(Cfg::get()-&gt;valS(<span class="string">&quot;InputFile&quot;</span>) + <span class="string">&quot;recordReturnTime.txt&quot;</span>, ios::in, _SH_DENYNO)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!freturn.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="keyword">while</span> (!freturn.<span class="built_in">eof</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		std::<span class="built_in">getline</span>(freturn, str);</span><br><span class="line">    &#125;</span><br><span class="line">freturn.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>



<h2 id="Qt-2"><a href="#Qt-2" class="headerlink" title="Qt"></a>Qt</h2><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="comment">//实例QFile</span></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;D:/Qt.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//定义文件内容字符串</span></span><br><span class="line">QString content= <span class="string">&quot;写入文件的内容&quot;</span>;</span><br><span class="line"><span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span>(file.<span class="built_in">exists</span>())</span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;创建文件&quot;</span>,<span class="string">&quot;文件已经存在！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存在打开，不存在创建</span></span><br><span class="line">    file.<span class="built_in">open</span>(QIODevice::ReadWrite | QIODevice::Text);</span><br><span class="line">    <span class="comment">//写入内容,这里需要转码，否则报错。</span></span><br><span class="line">    QByteArray str = content.<span class="built_in">toUtf8</span>();</span><br><span class="line">    <span class="comment">//写入QByteArray格式字符串</span></span><br><span class="line">    file.<span class="built_in">write</span>(str);</span><br><span class="line">    <span class="comment">//提示成功</span></span><br><span class="line">    QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;创建文件&quot;</span>,<span class="string">&quot;文件创建成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<h3 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QFile file(&quot;in.txt&quot;);</span><br><span class="line">if (!file.open(QIODevice::ReadOnly | QIODevice::Text))</span><br><span class="line">    return;</span><br><span class="line"> </span><br><span class="line">QTextStream in(&amp;file);</span><br><span class="line">while (!in.atEnd()) &#123;</span><br><span class="line">    QString line = in.readLine();</span><br><span class="line">    process_line(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QString strs;</span><br><span class="line">	QStringList file_list, output_name;</span><br><span class="line">	QStringList str_path_list = QFileDialog::getOpenFileNames(this, &quot;open file&quot;, &quot;/&quot;, &quot;cpr file(*.cpr);;All file(*.*)&quot;);</span><br><span class="line">	for (int i = 0; i &lt; str_path_list.size(); i++) &#123;</span><br><span class="line">		QString str_path = str_path_list[i];</span><br><span class="line">		//单个文件路径</span><br><span class="line">		qDebug() &lt;&lt; &quot;path=&quot; &lt;&lt; str_path;</span><br><span class="line">		QFileInfo file = QFileInfo(str_path);</span><br><span class="line">		//获得文件名</span><br><span class="line">		QString file_name = file.fileName();</span><br><span class="line">		file_list.append(str_path);</span><br><span class="line">		output_name.append(file_name);</span><br><span class="line">		strs.append(file_name);</span><br><span class="line">		strs += &quot;\n&quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打开文件夹，选择文件"><a href="#打开文件夹，选择文件" class="headerlink" title="打开文件夹，选择文件"></a>打开文件夹，选择文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString m_srcDirpath = QFileDialog::<span class="built_in">getExistingDirectory</span>(</span><br><span class="line">                     <span class="keyword">this</span>, <span class="string">&quot;choose src Directory&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line"> QString m_srcDirpath = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;open file&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;text file(*.txt);;C file(*.cpp);;All file(*.*)&quot;</span>);</span><br><span class="line"><span class="comment">//定义变量str接收QFileDialog对话框获取的文件路径</span></span><br><span class="line">QString str = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;open file&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;text file(*.txt);;C file(*.cpp);;All file(*.*)&quot;</span>);</span><br><span class="line"><span class="comment">//文件路径转换为utf8格式</span></span><br><span class="line">QString str_utf8 =str.<span class="built_in">toUtf8</span>();</span><br><span class="line"><span class="comment">//判断是否选择文件</span></span><br><span class="line"><span class="keyword">if</span>(str_utf8.<span class="built_in">isEmpty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line">QString str = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,<span class="string">&quot;选择文件&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;text</span></span><br><span class="line"><span class="string">file(*.txt);;C file(*.cpp);;All file(*.*)&quot;</span>);</span><br><span class="line"><span class="comment">//转换文件路径</span></span><br><span class="line">QString get = str.<span class="built_in">toUtf8</span>();</span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line">QFile::<span class="built_in">remove</span>(get);</span><br><span class="line"><span class="comment">//提示</span></span><br><span class="line">QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>,<span class="string">&quot;删除文件&quot;</span>,<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="INI文件写入"><a href="#INI文件写入" class="headerlink" title="INI文件写入"></a>INI文件写入</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSettings&gt;</span></span></span><br><span class="line"></span><br><span class="line">QSettings *writeIni;</span><br><span class="line"><span class="comment">//QSettings 构造函数的第一个参数是 ini 文件的路径,第二个参数表示针对 ini 文件</span></span><br><span class="line">writeIni = <span class="keyword">new</span> <span class="built_in">QSettings</span>(<span class="string">&quot;D:/CSDN.ini&quot;</span>, QSettings::IniFormat);</span><br><span class="line"><span class="comment">//写入键、值</span></span><br><span class="line">writeIni-&gt;<span class="built_in">setValue</span>(<span class="string">&quot;node&quot;</span>+<span class="string">&quot;/&quot;</span>+<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;192.168.1.1&quot;</span>);</span><br><span class="line"><span class="comment">//写入完成删除指针</span></span><br><span class="line"><span class="keyword">delete</span> writeIni;</span><br></pre></td></tr></table></figure>

<h3 id="INI文件读取"><a href="#INI文件读取" class="headerlink" title="INI文件读取"></a>INI文件读取</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSettings&gt;</span></span></span><br><span class="line"></span><br><span class="line">QSettings *readIni;</span><br><span class="line">QTextEdit *valEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//QSettings 构造函数的第一个参数是 ini 文件的路径,第二个参数表示针对 ini 文件</span></span><br><span class="line">readIni = <span class="keyword">new</span> <span class="built_in">QSettings</span>(<span class="string">&quot;D:/CSDN.ini&quot;</span>, QSettings::IniFormat);</span><br><span class="line"><span class="comment">/*将读取到的 ini 文件保存在 QString 中，先取值，然后通过 toString()函数转换成QString类型*/</span></span><br><span class="line">QString key = <span class="string">&quot;键值&quot;</span>;</span><br><span class="line">QString ipResult = readIni-&gt;<span class="built_in">value</span>(<span class="string">&quot;node&quot;</span>+<span class="string">&quot;/&quot;</span>+key).<span class="built_in">toString</span>();</span><br><span class="line"><span class="comment">//将结果绑定 IP 值控件上</span></span><br><span class="line">valEdit-&gt;<span class="built_in">setText</span>(ipResult);</span><br><span class="line"><span class="comment">//写入完成删除指针</span></span><br><span class="line"><span class="keyword">delete</span> readIni;</span><br></pre></td></tr></table></figure>

<h1 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找当前exe的路径</span></span><br><span class="line">	TCHAR szFilePath[MAX_PATH + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFilePath, MAX_PATH);</span><br><span class="line">	(_tcsrchr(szFilePath, _T(<span class="string">&#x27;\\&#x27;</span>)))[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//删除文件名，只获得路径字串</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iLen = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">char</span>* chRtn = <span class="keyword">new</span> <span class="keyword">char</span>[iLen*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)];</span><br><span class="line">	<span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, chRtn, iLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取当前exe下的所有pol文件</span></span><br><span class="line">	string houzhui = (string)chRtn + <span class="string">&quot;*.cpr&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span>* to_search = (<span class="keyword">char</span> *)houzhui.<span class="built_in">data</span>();<span class="comment">// &quot;D:/Examples/Polar_C++/x64/Release/?.png&quot;;</span></span><br><span class="line">	<span class="keyword">intptr_t</span> handle;    <span class="comment">//用于查找的句柄</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fileinfo</span>;</span>    <span class="comment">//文件信息的结构体</span></span><br><span class="line">	handle = _findfirst(to_search, &amp;fileinfo);    <span class="comment">//第一次查找</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == handle) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s出错啦！请联系我！&quot;</span>, fileinfo.name);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;正在进行%s\n&quot;</span>, fileinfo.name);    <span class="comment">//打印出找到的文件的文件名</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">BtnRadarReturnClicked</span>(fileinfo.name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*if (GetPic((string)chRtn + fileinfo.name, (string)chRtn) == 2)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		printf(&quot;%s出错啦！请联系我！&quot;, fileinfo.name);</span></span><br><span class="line"><span class="comment">		return -1;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!_findnext(handle, &amp;fileinfo)) &#123;    <span class="comment">//循环查找其它符合的文件，直到找不到其它的为止</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;正在进行%s\n&quot;</span>, fileinfo.name);    <span class="comment">//打印出找到的文件的文件名</span></span><br><span class="line">		<span class="built_in">BtnRadarReturnClicked</span>(fileinfo.name);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*if (GetPic(fileinfo.name, (string)chRtn) == 2)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;%s出错啦！请联系我！&quot;, fileinfo.name);</span></span><br><span class="line"><span class="comment">			return -1;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	_findclose(handle);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;完成！&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;string&gt; vec_path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TraverseDirectory</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	output.<span class="built_in">open</span>(<span class="string">&quot;filepath.txt&quot;</span>, ios::out | std::ios::app, _SH_DENYNO);</span><br><span class="line">	<span class="keyword">if</span> (!output.<span class="built_in">is_open</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	__int64  Handle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">finddata64_t</span>  <span class="title">FileInfo</span>;</span></span><br><span class="line">	string strFind = path + <span class="string">&quot;\\*&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((Handle = _findfirst64(strFind.<span class="built_in">c_str</span>(), &amp;FileInfo)) == <span class="number">-1L</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配的项目\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断是否有子目录</span></span><br><span class="line">		<span class="keyword">if</span> (FileInfo.attrib &amp; _A_SUBDIR)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//判断是子文件夹</span></span><br><span class="line">			<span class="comment">//下面的判断条件很重要，过滤 . 和 ..</span></span><br><span class="line">			<span class="keyword">if</span> ((<span class="built_in">strcmp</span>(FileInfo.name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strcmp</span>(FileInfo.name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				string newPath = path + <span class="string">&quot;\\&quot;</span> + FileInfo.name;</span><br><span class="line">				<span class="built_in">TraverseDirectory</span>(newPath);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//判断是文件</span></span><br><span class="line">		&#123;</span><br><span class="line">			string newPath = path + <span class="string">&quot;\\&quot;</span> + FileInfo.name;</span><br><span class="line">			<span class="keyword">if</span> (newPath.<span class="built_in">find</span>(<span class="string">&quot;.cpr&quot;</span>) != string::npos)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//自定义操作</span></span><br><span class="line">				vec_path.<span class="built_in">push_back</span>(newPath);</span><br><span class="line">				cout &lt;&lt; newPath &lt;&lt; endl;</span><br><span class="line">				output &lt;&lt; newPath &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (_findnext64(Handle, &amp;FileInfo) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	output.<span class="built_in">close</span>();</span><br><span class="line">	_findclose(Handle);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><h2 id="C中的文件指针"><a href="#C中的文件指针" class="headerlink" title="C中的文件指针"></a>C中的文件指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">声明</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">参数</span></span><br><span class="line"><span class="function">stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</span></span><br><span class="line"><span class="function">offset -- 这是相对 whence 的偏移量，以字节为单位。（负号前移，正号后移）</span></span><br><span class="line"><span class="function">whence -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</span></span><br><span class="line"><span class="function">    常量	描述</span></span><br><span class="line"><span class="function">    SEEK_SET	文件的开头</span></span><br><span class="line"><span class="function">    SEEK_CUR	文件指针的当前位置</span></span><br><span class="line"><span class="function">    SEEK_END	文件的末尾</span></span><br><span class="line"><span class="function">返回值</span></span><br><span class="line"><span class="function">如果成功，则该函数返回零，否则返回非零值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">描述</span></span><br><span class="line"><span class="function">C 库函数 <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span> 返回给定流 stream 的当前文件位置。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">声明</span></span><br><span class="line"><span class="function">下面是 <span class="title">ftell</span><span class="params">()</span> 函数的声明。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span></span><br><span class="line"><span class="function">参数</span></span><br><span class="line"><span class="function">stream -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</span></span><br><span class="line"><span class="function">返回值</span></span><br><span class="line"><span class="function">该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的文件指针"><a href="#C-中的文件指针" class="headerlink" title="C++中的文件指针"></a>C++中的文件指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C++中<span class="built_in">seep</span>()和<span class="built_in">seekg</span>()函数功能</span><br><span class="line">seekp：设置输出文件流的文件流指针位置（写）</span><br><span class="line">seekg：设置输入文件流的文件流指针位置（读）</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span><span class="params">( streampos pos )</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span><span class="params">( streamoff off, ios::seek_dir dir )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">( streampos pos )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">( streamoff off, ios::seek_dir dir )</span></span>;</span><br><span class="line"></span><br><span class="line">函数参数</span><br><span class="line">pos：新的文件流指针位置值</span><br><span class="line">off：需要偏移的值</span><br><span class="line">dir：搜索的起始位置</span><br><span class="line">    dir参数用于对文件流指针的定位操作上，代表搜索的起始位置</span><br><span class="line">    在ios中定义的枚举类型：</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">seek_dir</span> &#123;</span>beg, cur, end&#125;;</span><br><span class="line">    每个枚举常量的含义：</span><br><span class="line">    ios::beg：文件流的起始位置</span><br><span class="line">    ios::cur：文件流的当前位置</span><br><span class="line">    ios::end：文件流的结束位置</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">补充：经过调试，发现文件指针有个特性，一旦指针到达文件末尾，就无法再将指针指向文件其他位置，如以下两段代码：</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">srcin.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::end);</span><br><span class="line"><span class="built_in">getline</span>(srcin, str);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;    <span class="comment">//无输出</span></span><br><span class="line">srcin.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line"><span class="built_in">getline</span>(srcin, str);    <span class="comment">//无输出</span></span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">srcin.<span class="built_in">seekg</span>(<span class="number">10</span>, ios::beg);</span><br><span class="line"><span class="built_in">getline</span>(srcin, str);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;    <span class="comment">//有输出</span></span><br><span class="line">srcin.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line"><span class="built_in">getline</span>(srcin, str);    <span class="comment">//有输出</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h1 id="文件大小判断"><a href="#文件大小判断" class="headerlink" title="文件大小判断"></a>文件大小判断</h1><h3 id="Qt-3"><a href="#Qt-3" class="headerlink" title="Qt"></a>Qt</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(record1-&gt;m_SCprName)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//QMessageBox::information(NULL, record1-&gt;m_SCprName</span></span><br><span class="line">    , QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;cpr文件大小监听失败，只能保存一个文件，请手动停止！&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">size</span>() &gt;= <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>)</span><br><span class="line">    file.<span class="built_in">close</span>()<span class="comment">//file.size()这个监听的是字节</span></span><br></pre></td></tr></table></figure>

<h3 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream file;</span><br><span class="line">file.<span class="built_in">open</span>(record1-&gt;m_SCprName);</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getFileSize</span><span class="params">(ifstream * pFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> begin =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> end = begin;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> FileSize = <span class="number">0</span>;</span><br><span class="line">    pFile-&gt;<span class="built_in">seekg</span>(<span class="number">0</span>, ios_base::end);</span><br><span class="line">    end = pFile-&gt;<span class="built_in">tellg</span>();</span><br><span class="line">    FileSize = end - begin;</span><br><span class="line">    <span class="keyword">return</span> FileSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建路径-1"><a href="#创建路径-1" class="headerlink" title="创建路径"></a>创建路径</h1><h2 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h2><p>不知道为啥，下面的函数动不动就会奔溃，用最上面Qt 的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt_io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">createDir</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n;</span><br><span class="line">    string str1, str2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    str1 = path;</span><br><span class="line">    <span class="keyword">if</span> (str1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>) == <span class="string">&quot;.\\&quot;</span>) &#123;</span><br><span class="line">        str2 = str1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        str1 = str1.<span class="built_in">substr</span>(<span class="number">2</span>, str1.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        str2 = str1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        str1 = str1.<span class="built_in">substr</span>(<span class="number">3</span>, str1.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m = str1.<span class="built_in">find</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        str2 += <span class="string">&#x27;\\&#x27;</span> + str1.<span class="built_in">substr</span>(<span class="number">0</span>, m);</span><br><span class="line">        n = _access(str2.<span class="built_in">c_str</span>(), <span class="number">0</span>); <span class="comment">//判断该目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_mkdir(str2.<span class="built_in">c_str</span>()) != <span class="number">0</span>)     <span class="comment">//创建目录</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str1 = str1.<span class="built_in">substr</span>(m + <span class="number">1</span>, str1.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span> 　</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">mkdir_path</span><span class="params">(<span class="keyword">char</span> *p_cMkdir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> file_name[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span><span class="comment">//秒,微秒</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">time</span>;</span><span class="comment">//年月日时分秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> sub_path[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    time = <span class="built_in">localtime</span>(&amp;tv.tv_sec);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strftime</span>(name, <span class="number">128</span>, <span class="string">&quot;%Y%m%d-%H-%M-%S.cpr&quot;</span>, time);</span><br><span class="line">    <span class="built_in">strftime</span>(sub_path, <span class="number">128</span>, <span class="string">&quot;%m%d/&quot;</span>, time);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(file_name,<span class="string">&quot;%s%s&quot;</span>,p_cMkdir,sub_path);</span><br><span class="line"></span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((dir = <span class="built_in">opendir</span>(file_name)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">mkdir</span>(file_name,S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH);<span class="comment">//自动创建日期文件夹</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;current path is not exist!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;path is created success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">closedir</span>(dir);</span><br><span class="line">    <span class="built_in">strcat</span>(file_name,name);<span class="comment">//追加文件名</span></span><br><span class="line">    <span class="keyword">return</span> file_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::string strName=<span class="built_in">mkdir_path</span>(<span class="string">&quot;/home/salman/30/&quot;</span>);<span class="comment">//最后一个字符一定要加/</span></span><br></pre></td></tr></table></figure>



<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="删除非空文件夹及文件夹下的文件"><a href="#删除非空文件夹及文件夹下的文件" class="headerlink" title="删除非空文件夹及文件夹下的文件"></a>删除非空文件夹及文件夹下的文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RadarOverlay::removeDir</span><span class="params">(string dirPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fb</span>;</span> <span class="comment">//find the storage structure of the same properties file.</span></span><br><span class="line">    string path;</span><br><span class="line">    <span class="keyword">long</span> handle;</span><br><span class="line">    <span class="keyword">int</span> resultone;</span><br><span class="line">    <span class="keyword">int</span> noFile; <span class="comment">// the tag for the system&#x27;s hidden files</span></span><br><span class="line"></span><br><span class="line">    noFile = <span class="number">0</span>;</span><br><span class="line">    handle = <span class="number">0</span>;</span><br><span class="line">    path = dirPath + <span class="string">&quot;/*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    handle = _findfirst(path.<span class="built_in">c_str</span>(), &amp;fb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find the first matching file</span></span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//find next matching file</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> == _findnext(handle, &amp;fb))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &quot;.&quot; and &quot;..&quot; are not processed</span></span><br><span class="line">            noFile = <span class="built_in">strcmp</span>(fb.name, <span class="string">&quot;..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != noFile)</span><br><span class="line">            &#123;</span><br><span class="line">                path.<span class="built_in">clear</span>();</span><br><span class="line">                path = dirPath + <span class="string">&quot;/&quot;</span> + fb.name;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//fb.attrib == 16 means folder</span></span><br><span class="line">                <span class="keyword">if</span> (fb.attrib == <span class="number">16</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">removeDir</span>(path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//not folder, delete it. if empty folder, using _rmdir istead.</span></span><br><span class="line">                    <span class="built_in">remove</span>(path.<span class="built_in">c_str</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close the folder and delete it only if it is closed. For standard c, using closedir instead(findclose -&gt; closedir).</span></span><br><span class="line">        <span class="comment">// when Handle is created, it should be closed at last.</span></span><br><span class="line">        _findclose(handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *savePath = “/home/zhuwei/contour/linearIteration.shp”;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">remove</span>(savePath)==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> cout&lt;&lt;“删除成功”&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> cout&lt;&lt;“删除失败”&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="删除一个文件"><a href="#删除一个文件" class="headerlink" title="删除一个文件"></a>删除一个文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">logPath = m_pExportSetting-&gt;m_pathTracks + QString::<span class="built_in">number</span>(<span class="number">0</span>) + QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;.csv&quot;</span>);</span><br><span class="line"><span class="function">QFileInfo <span class="title">delfile</span><span class="params">(logPath)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (delfile.<span class="built_in">isFile</span>())</span><br><span class="line">&#123;</span><br><span class="line">    QFile f;</span><br><span class="line">    f.<span class="built_in">remove</span>(logPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>文件相关</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牢记的概念"><a href="#牢记的概念" class="headerlink" title="牢记的概念"></a>牢记的概念</h1><p> 线程函数还没结束，是未通知状态（无信号状态），会把程序阻塞，不让往下走；结束了，是已通知状态（有信号状态）</p>
<h1 id="什么进程"><a href="#什么进程" class="headerlink" title="什么进程"></a>什么进程</h1><p>进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>
<p>进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。进程是一个正在执行的程序的实例，包括程序计数器、寄存器和程序变量的当前值。</p>
<p>进程有哪些特征？</p>
<blockquote>
<p>进程依赖于程序运行而存在，进程是动态的，程序是静态的；<br>进程是操作系统进行资源分配和调度的一个独立单位（CPU除外，线程是处理器任务调度和执行的基本单位）；<br>每个进程拥有独立的地址空间，地址空间包括代码区、数据区和堆栈区，进程之间的地址空间是隔离的，互不影响。</p>
</blockquote>
<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><p>进程想执行任务，必须得有线程（至少一个），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</p>
<h1 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h1><h2 id="线程内核对象"><a href="#线程内核对象" class="headerlink" title="线程内核对象"></a>线程内核对象</h2><p>操作系统对进程和线程的管理都是通过相应的内核对象实现的。它会为每个线程都分配并初始化这种数据结构。在该数据结构中，包含一组对线程进行描述的属性。数据结构中还包含所谓的线程上下文，上下文是一个内存块，其中包含了CPU的寄存器集合。</p>
<mark class="hl-label blue">线程进程都是数据结构</mark>  

<h2 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a>线程控制块</h2><p>线程的实体包括程序，数据和线程控制块（TCB，Thread Control Block）。线程是动态概念，TCB包括以下信息：</p>
<ul>
<li>线程状态</li>
<li>当线程不运行时，被保存的现场资源</li>
<li>一组执行堆栈</li>
<li>存放每个线程的局部变量主存区</li>
<li>访问每个进程中的主存和其他资源</li>
</ul>
<mark class="hl-label blue">PCB是进程控制块</mark>  

<h2 id="独立调度和分派的基本单元"><a href="#独立调度和分派的基本单元" class="headerlink" title="独立调度和分派的基本单元"></a>独立调度和分派的基本单元</h2><p>线程是能独立运行的基本单元，因而也是独立调度和分派的基本单元。CPU是以线程为单元执行，创建出来的线程不一定马上执行，调度后允许线程运行一个“时间片”，单核处理器一个时间片只执行一个线程，而多核处理器可允许一个进程中所有线程都能并发执行。</p>
<mark class="hl-label blue">进程的执行实际是线程的执行，单核的只是现象的并发，多核的才是真正的并发</mark>  

<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程，当CPU由执行线程A切换到执行线程B的过程中会发生一系列的操作，如“保存线程A的执行现场”然后“载入线程B的执行现场”，这个过程称之为“上下文切换（context switch）”，这个上下文切换过程会消耗资源，所以应尽量减少上下文切换的发生。</p>
<blockquote>
<p><strong>引起上下文切换的原因</strong></p>
</blockquote>
<ul>
<li>时间片用完，CPU正常调度下一个任务</li>
<li>被其他优先级更高的任务抢占</li>
<li>执行任务碰到IO阻塞，调度器挂起当前任务，切换执行下一个任务</li>
<li>用户代码主动挂起当前任务让出CPU时间片</li>
<li>多任务抢占资源，由于没有抢到被挂起</li>
<li>硬件中断</li>
</ul>
<h2 id="共享进程资源"><a href="#共享进程资源" class="headerlink" title="共享进程资源"></a>共享进程资源</h2><p>在同一进程重的各个线程，都可以共享改进程所拥有的资源，这首先表现在：所以线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问改地址空间的每一个虚地址；此外，还可以访问进程所拥有已打开的文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间通信不必调用内核。</p>
<p>线程的状态</p>
<mark class="hl-label blue">线程是动态的，是不断变化的，所以有很多不同的状态</mark>  

<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210714214404130.png" alt="image-20210714214404130"></p>
<h1 id="进程与线程的区别总结："><a href="#进程与线程的区别总结：" class="headerlink" title="进程与线程的区别总结："></a>进程与线程的区别总结：</h1><p>本质区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</p>
<p>包含关系：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p>资源开销：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p>
<p>影响关系：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="创建-CreateThread"><a href="#创建-CreateThread" class="headerlink" title="创建 CreateThread"></a>创建 CreateThread</h2><p>​                                                 <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps1.jpg" alt="img">     </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps2.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps3.jpg" alt="img">                 </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps4.jpg" alt="img"> </p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210714224707676.png" alt="image-20210714224707676"></p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps6.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span><span class="comment">//线程相关头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID lpThreadParameter)</span></span>;</span><br><span class="line">DWORD threadID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="comment">//设为NULL使用默认安全性</span></span><br><span class="line">		<span class="number">0</span>, <span class="comment">//如果为0，那么默认将使用与调用改函数的线程相同的栈空间大小</span></span><br><span class="line">		ThreadFun1,<span class="comment">//线程处理函数，函数名就是函数指针</span></span><br><span class="line">		<span class="string">&quot;hello &quot;</span>,<span class="comment">//向线程函数传入的参数</span></span><br><span class="line">		<span class="number">0</span>, <span class="comment">//创建后马上运行</span></span><br><span class="line">		&amp;threadID</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hThread1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;线程创建失败&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程句柄&quot;</span> &lt;&lt; hThread1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程ID&quot;</span> &lt;&lt; threadID &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *str = (<span class="keyword">char</span> *)lpThreadParameter;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程处理函数中：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取线程ID-GetCurrentThreadId"><a href="#获取线程ID-GetCurrentThreadId" class="headerlink" title="获取线程ID GetCurrentThreadId"></a>获取线程ID GetCurrentThreadId</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps7.jpg" alt="img">                     </p>
<h2 id="关闭句柄CloseHandle"><a href="#关闭句柄CloseHandle" class="headerlink" title="关闭句柄CloseHandle"></a>关闭句柄CloseHandle</h2><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps8.jpg" alt="img"></p>
<mark class="hl-label blue">closeHandle仅仅是引用计数-1，并没有结束线程，线程中的该执行的还是执行。</mark>  

<h2 id="挂起线程-SuspendThread"><a href="#挂起线程-SuspendThread" class="headerlink" title="挂起线程 SuspendThread"></a>挂起线程 SuspendThread</h2><p>从而不会被CPU调度。</p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps12.jpg" alt="img"> </p>
<h2 id="恢复线程ResumeThread"><a href="#恢复线程ResumeThread" class="headerlink" title="恢复线程ResumeThread"></a>恢复线程ResumeThread</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps13.jpg" alt="img"> </p>
<h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps14.jpg" alt="img"> </p>
<h2 id="等待通知-WaitForSingleObject"><a href="#等待通知-WaitForSingleObject" class="headerlink" title="等待通知 WaitForSingleObject"></a>等待通知 WaitForSingleObject</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps15.jpg" alt="img"> </p>
<p>该函数需要传递一个内核对象句柄，如果该内核对象处于未通知状态，则该函数导致线程进入阻塞状态；如果该内核对象处于已通知状态，则该函数立即返回<mark class="hl-label blue">WAIT_OBJECT_0</mark>  。第二个参数表明要等待的时间（毫秒），<mark class="hl-label blue">INFINITE</mark>  表示无限等待，如果第二个参数为0，表示函数立即返回。如果等待超时，该函数返回<mark class="hl-label blue">WAIT_TIMEOUT</mark>  。如果该函数调用失败，返回<mark class="hl-label blue">WAIT_FAILED</mark>  。</p>
<blockquote>
<ul>
<li>等待的时间，如果是0表示立即执行线程函数，不阻塞；给某个数值，表示阻塞某个数值的时间，超过这个时间，会返回等待子线程终止超时，然后继续往下执行，解除阻塞；INFINITE表示一直阻塞，直到线程函数自己退出，才解除阻塞。</li>
<li>内核对象句柄就是线程句柄。</li>
<li><mark class="hl-label blue">线程函数还没结束，是未通知状态（无信号状态），会把程序阻塞，不让往下走；结束了，是已通知状态（有信号状态）</mark>  。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread1, INFINITE);</span><br></pre></td></tr></table></figure>

<h2 id="等待多个对象变为已通知"><a href="#等待多个对象变为已通知" class="headerlink" title="等待多个对象变为已通知"></a>等待多个对象变为已通知</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps16.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps17.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps18.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread2 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(hThread1),<span class="built_in">HANDLE</span>(hThread2) &#125;;</span><br><span class="line"><span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任意一个线程结束就返回数组索引</span></span><br><span class="line">HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(hThread1),<span class="built_in">HANDLE</span>(hThread2) &#125;;</span><br><span class="line">DWORD ret =<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">false</span>, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置等待时间为1秒</span></span><br><span class="line">HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(hThread1),<span class="built_in">HANDLE</span>(hThread2) &#125;;</span><br><span class="line">DWORD ret=<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">false</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>ExitThread只能退出当前线程，而TerminateThread能退出指定线程。</p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps19.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps20.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps21.jpg" alt="img">                                            </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps22.jpg" alt="img"> </p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps23.jpg" alt="img"></p>
<h2 id="获取线程退出码"><a href="#获取线程退出码" class="headerlink" title="获取线程退出码"></a>获取线程退出码</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps24.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps25.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps26.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps27.jpg" alt="img"> </p>
<h2 id="beginthread"><a href="#beginthread" class="headerlink" title="_beginthread"></a>_beginthread</h2><mark class="hl-label red">这个函数使用的线程函数指针和CreateThread使用的形式不一样！</mark>  

<p>CreateThread函数是用来创建线程的Windows函数，不过，如果写C++，应该使用Visual C++运行期库函数_beginthread。</p>
<p>在CreateThread创建的线程中使用sprintf,malloc,strcat等设计CRT存储堆操作的CRT库函数是<mark class="hl-label red">很危险的！</mark>  ，容易造成线程的意外终止。而使用_beginthread和_beginthreadex创建的线程可以安全的使用CRT函数，但是必须在线程结束的时候相应调用————_endthread或者__endthreadex。</p>
<p>如果你在线程函数中进行了以下操作，就应该使用_endthread或者__endthreadex.</p>
<ul>
<li><p>使用malloc和free，或者new和delete</p>
</li>
<li><p>使用stdio.h或io.h里面声明的任何函数</p>
</li>
<li><p>使用浮点变量或浮点运算函数</p>
</li>
<li><p>调用任何一个使用了静态缓冲区的runtime函数，比如asctiome(),strtok(),rang()</p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps28.jpg" alt="img"></p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps29.jpg" alt="img"></p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps30.jpg" alt="img"> </p>
</li>
</ul>
<p>这个的线程函数调用约定是C的，而CreateThread是std的约定。</p>
<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps31.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> t1 =_beginthread(ThreadFun1, <span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(<span class="built_in">HANDLE</span>(t1), INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="endthread"><a href="#endthread" class="headerlink" title="_endthread"></a>_endthread</h2><p>void __endthread(void);</p>
<p>终止由__beginthread创建的线程。对于使用Libcmt.lib链接的可执行文件，不要调用win32 API的ExitThread，它无法释放已分配的资源。而endthread回收线程资源后调用ExitThread。endthread自动关闭线程句柄。</p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210714222506590.png" alt="image-20210714222506590"></p>
<h1 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h1><h2 id="1-几个概念"><a href="#1-几个概念" class="headerlink" title="1. 几个概念"></a>1. 几个概念</h2><p>一个基本的事实前提：一个CPU在一个瞬间只能处理一个任务。但为什么在我们人类视角，哪怕是单核心计算机也能同时做很多事情，比如同时听音乐和浏览网页，作为整个系统唯一可以完成计算任务的 CPU 是如何保证两个进程“同时进行”的呢？时间片轮转调度！</p>
<p>每个进程会被操作系统分配一个时间片，即每次被 CPU 选中来执行当前进程所用的时间。时间一到，无论进程是否运行结束，操作系统都会强制将 CPU 这个资源转到另一个进程去执行。为什么要这样做呢？因为只有一个单核 CPU，假如没有这种轮转调度机制，那它该去处理写文档的进程还是该去处理听音乐的进程？无论执行哪个进程，另一个进程肯定是不被执行，程序自然就是无运行的状态。如果 CPU 一会儿处理 word 进程一会儿处理听音乐的进程，起初看起来好像会觉得两个进程都很卡，但是 CPU 的执行速度已经快到让人们感觉不到这种切换的顿挫感，就真的好像两个进程在“并行运行”。</p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230524163314917.png" alt="image-20230524163314917"></p>
<p>随着多核心CPU的出现，真正的并行得以实现：</p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230524163309056.png" alt="image-20230524163309056"></p>
<blockquote>
<p>所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它 需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p>
</blockquote>
<h3 id="1-1-并发"><a href="#1-1-并发" class="headerlink" title="1.1 并发"></a>1.1 并发</h3><p>在操作系统的一个时间段中，有几个程序同时处于启动运行到运行完毕之间的状态，且这几个程序都在同一个处理机上运行。</p>
<p>并发又有伪并发和真并发：伪并发是指单核处理器的并发，真并发是指多核处理器的并发。</p>
<h3 id="1-2-互斥"><a href="#1-2-互斥" class="headerlink" title="1.2 互斥"></a>1.2 互斥</h3><p>并发进程之间的制约关系有两种，即互斥和同步。</p>
<p>多个并发进程之间，因竞争使用临界资源而互相排斥执行的间接制约关系，叫作互斥。</p>
<h3 id="1-3-同步"><a href="#1-3-同步" class="headerlink" title="1.3 同步"></a>1.3 同步</h3><p>在某些地方，多个并发进程需要相互等待或交换信息而产生的直接制约关系，叫做同步。</p>
<p>并发进程之间不是相互排斥临界资源，而是相互依赖的关系。进一步地说，同步关系就是前一个进程的输出作为后一个进程的输入；当第一个进程没有输出时，第二个进程必须等待。具有同步关系的一组并发进程，相互发送的信息称为消息或事件。</p>
<p>下面是一个司机和售票员同步的例子：</p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps33.jpg" alt="img"> </p>
<h3 id="1-4-并行"><a href="#1-4-并行" class="headerlink" title="1.4 并行"></a>1.4 并行</h3><p>在单核处理器的多道程序环境中，进程被交替执行，表现出一种并发的外部特征；在多核处理器的多道程序环境中，进程不仅可以交替执行，还可以重叠执行，即并行。</p>
<p>在多核处理器上，程序才可以实现并行处理。从而可知，并行是针对多核处理器而言。并行是同一时刻发生多个事件，具有并发的含义；但并发不一定并行，即并发事件之间不一定要同一时刻发生。</p>
<h3 id="1-5-多线程"><a href="#1-5-多线程" class="headerlink" title="1.5 多线程"></a>1.5 多线程</h3><p>多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。</p>
<h3 id="1-6-异步"><a href="#1-6-异步" class="headerlink" title="1.6 异步"></a>1.6 异步</h3><p>异步与同步是相对的：同步是顺序执行进程，执行完一个进程再执行下一个进程，需要进程之间等待、协调运行；异步是进程之间彼此独立，在等待其他进程的运行时，本进程继续做自己的事，不需要等待其他进程完成后再工作。</p>
<p>在多道程序环境下，进程以异步方式并发执行。</p>
<p>异步与多线程不是同等关系：异步是最终目的，多线程只是我们实现异步的一种方式。异步是让调用方法的主线程不用同步等待另一线程的完成，主线程可以同时做其它事情。</p>
<p>实现异步可以采用多线程技术或者交给另外的进程处理。</p>
<h2 id="2-事例理解"><a href="#2-事例理解" class="headerlink" title="2. 事例理解"></a>2. 事例理解</h2><p>为了对以上概念更好地理解，举一个简单例子，假设我们要做烧开水，举杠铃100下， 洗衣服这3件事情。</p>
<p>· 烧开水：准备烧开水（1分钟）， 等开水烧开（8分钟） , 关掉烧水机（1分钟）</p>
<p>· 举杠铃100下：举杠铃100下（10分钟）</p>
<p>· 洗衣服：准备洗衣服（1分钟）， 等衣服洗完（5分钟），关掉洗衣机（1分钟）</p>
<h3 id="2-1-单核处理器"><a href="#2-1-单核处理器" class="headerlink" title="2.1 单核处理器"></a>2.1 单核处理器</h3><p>· 同步执行</p>
<p>事情步骤安排：烧水：准备烧开水（1分钟）， 等开水烧开（8分钟） , 关掉烧水机（1分钟）；举杠铃100下：举杠铃100下（10分钟）；洗衣服：准备洗衣服（1分钟）， 等衣服洗完（5分钟），关掉洗衣机（1分钟）</p>
<p>做完3件事，花费的时间t = 1+ 8 +1 + 10 + 1+ 5 +1 = 27（分钟）</p>
<p>· 异步并行</p>
<p>在等待事情执行时，我（单核）可以切换出去，做别的事情。</p>
<p>事情步骤安排：准备烧开水(1分钟) + 准备洗衣服(1分钟) + 举50下杠铃 (5分钟)+ 关洗衣机（1分钟） + 举杠铃20下（2分钟）+ 关烧水机（1分钟） + 举30下杠铃(3分钟）</p>
<p>在等待衣服洗完（5分钟）时，我（单核）执行举50下杠铃（5分钟）；在等待水烧开（8分钟）时，我（单核）执行举50下杠铃 (5分钟)+ 关洗衣机（1分钟） + 举杠铃20下（2分钟）。</p>
<p>做完3件事，花费的时间t = 1 + 1 + 5 + 1 + 2 + 1 + 3 = 14（分钟）</p>
<h3 id="2-2-双核处理器"><a href="#2-2-双核处理器" class="headerlink" title="2.2 双核处理器"></a>2.2 双核处理器</h3><p>· 异步并行</p>
<p>核1：准备烧开水（1分钟）+ 举杠铃50下（5分钟）+ 等待（3分钟）+ 关掉烧水机 （1分钟）</p>
<p>核2：准备洗衣服（1分钟）+ 举杠铃50下（5分钟）+ 关掉洗衣机（1分钟） + 等待（3分钟）</p>
<p>其中，在等待水烧开（8分钟）时，核1执行举杠铃50下（5分钟），等待（3分钟）；在等待衣服洗完（5分钟）时，核2执行举杠铃50下（5分钟）。</p>
<p>做完3件事，花费的时间t = 1 + 5 + 3 + 1 = 10（分钟），其中双核都等待了3分钟。</p>
<p>· 异步非并行</p>
<p>核1：举杠铃100下（10分钟）</p>
<p>核2：准备烧开水（1分钟）+ 准备洗衣服（1分钟）+ 等待（6分钟）+ 关掉烧水机（1分钟）+ 关掉洗衣机（1分钟）</p>
<p>其中，在等待水烧开（8分钟）时，核2执行准备烧开水（1分钟），准备洗衣服（1分钟），等待（6分钟）；在等待衣服洗完（5分钟）时，核2执行等待（6分钟）。</p>
<p>做完3件事，花费的时间t =1 + 1 + 6 + 1 + 1 = 10（分钟）</p>
<h3 id="2-3-多线程"><a href="#2-3-多线程" class="headerlink" title="2.3 多线程"></a>2.3 多线程</h3><p>· 单核处理器</p>
<p>线程1：准备烧开水（1分钟）， 等水烧开（8分钟） , 关掉烧水机（1分钟）</p>
<p>线程2：举杠铃100下（10分钟）</p>
<p>线程3：准备洗衣服（1分钟）， 等水烧开（5 分钟） , 关掉洗衣机（1分钟）</p>
<p>CPU最理想的切换方式：</p>
<p>线程1：准备烧开水（1分钟）+ sleep 1 + sleep 5 + sleep 1 + sleep 2 + 关开水（1分钟）</p>
<p>线程2：sleep 1+ sleep 1 + 举杠铃50（5分钟）+ sleep 1 + 举杠铃20（2分钟）+ sleep1 + 举杠铃30下（3分钟）</p>
<p>线程3：sleep 1 + 准备洗衣服（1分钟）+ sleep 5 +关洗衣机（1分钟）</p>
<p>最后使用了14分钟，与异步是一样的。但实际上是不一样的，因为线程不会按照我们设想的去跑。如果线程2举杠铃先跑，整个流程的速度就下来了。</p>
<h3 id="2-4-异步和同步，多线程与异步，单核与多核的不同"><a href="#2-4-异步和同步，多线程与异步，单核与多核的不同" class="headerlink" title="2.4 异步和同步，多线程与异步，单核与多核的不同"></a>2.4 异步和同步，多线程与异步，单核与多核的不同</h3><p>异步和同步的区别：在IO等待时，同步不会切走，等待浪费了时间。</p>
<p>多线程比较容易地实现了异步切换的思想， 因为多线程较容易写。多线程本身还是以同步完成，但是比不上异步的效率。</p>
<p>多核的好处，就是可以同时做事情， 这个与单核不一样。如果都是独占CPU的作业，比如举杠铃。在单核情况下，多线程和单线程没有区别。</p>
<h2 id="用户对象与内核对象"><a href="#用户对象与内核对象" class="headerlink" title="用户对象与内核对象"></a>用户对象与内核对象</h2><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps35.jpg" alt="img"> </p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps36.jpg" alt="img"> </p>
<p>首先我们要解释一个概念——进程（Process）。简单来说，****一个可执行程序就是一个进程****，我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。</p>
<p>严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个****静态*<em><strong>的概念；进程是程序加载到内存运行后一些列的活动，是一个</strong></em>*动态****的概念。</p>
<p>“程序的地址空间”的说法，这其实是不严谨的，应该说“进程的地址空间”。****一个进程对应一个地址空间，而一个程序可能会创建多个进程****。</p>
<h2 id="内核模式和用户模式"><a href="#内核模式和用户模式" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h2><p>内核空间存放的是操作系统内核代码和数据，是被所有程序****共享****的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。</p>
<p>要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。</p>
<p><em><strong>*用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。*</strong></em></p>
<p><em><strong>*用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。*</strong></em></p>
<p>计算机会经常在内核模式和用户模式之间切换：<br>·当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；</p>
<p>·操作完成后，继续执行应用程序的代码，就又回到了用户模式。</p>
<p>总结：<em><strong>*用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。*</strong></em></p>
<h2 id="为什么要区分两种模式"><a href="#为什么要区分两种模式" class="headerlink" title="为什么要区分两种模式"></a>为什么要区分两种模式</h2><p>内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。</p>
<p>从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以****运行在 ring0 ~ ring3 四个不同的权限级别****，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<p>·一个是****内核模式，对应 ring0 级*<em><strong>，操作系统的核心部分和设备驱动都运行在该模式下。<br>·另一个是</strong></em>*用户模式，对应 ring3 级****，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。</p>
<h2 id="为什么内核和用户程序要共用地址空间"><a href="#为什么内核和用户程序要共用地址空间" class="headerlink" title="为什么内核和用户程序要共用地址空间"></a>为什么内核和用户程序要共用地址空间</h2><p>既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？</p>
<p><em><strong>*让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。*</strong></em></p>
<p>而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。</p>
<h1 id="模拟火车站售票系统"><a href="#模拟火车站售票系统" class="headerlink" title="模拟火车站售票系统"></a>模拟火车站售票系统</h1><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210714222529718.png" alt="image-20210714222529718"></p>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><h2 id="临界区Critical-Section"><a href="#临界区Critical-Section" class="headerlink" title="临界区Critical Section"></a>临界区Critical Section</h2><p>每个线程中访问临界资源的那端程序称为临界区（Critical Section）每次只准一个线程进入临界区。进入后不允许其他线程进入。无论是硬件临界资源还是软件临界资源，多个线程必须互斥地对它进行访问。</p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210714223353836.png" alt="image-20210714223353836"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps37.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps38.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps39.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps40.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps41.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps42.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 临界区结构</span></span><br><span class="line">CRITICAL_SECTION section;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//2 初始化临界区</span></span><br><span class="line">	<span class="built_in">InitializeCriticalSection</span>(&amp;section);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开始卖票了！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建两个售票窗口</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> t1 = _beginthread(ThreadFun1, <span class="number">0</span>, <span class="string">&quot;售票窗口A&quot;</span>);</span><br><span class="line">	<span class="keyword">uintptr_t</span> t2 = _beginthread(ThreadFun2, <span class="number">0</span>, <span class="string">&quot;售票窗口B&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">	HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(t1),<span class="built_in">HANDLE</span>(t2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;卖票结束！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 删除临界区资源</span></span><br><span class="line">	<span class="built_in">DeleteCriticalSection</span>(&amp;section);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3 进入临界区，禁止其他线程访问</span></span><br><span class="line">		<span class="built_in">EnterCriticalSection</span>(&amp;section);</span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="comment">//CPU恰好执行到这里，这个时候线程时间片到了，并且此时还剩最后一张票</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s卖出第%d张票！\n&quot;</span>, name, tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 离开临界区</span></span><br><span class="line">		<span class="built_in">LeaveCriticalSection</span>(&amp;section);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3 进入临界区，禁止其他线程访问</span></span><br><span class="line">		<span class="built_in">EnterCriticalSection</span>(&amp;section);</span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="comment">//CPU恰好执行到这里，这个时候线程时间片到了，并且此时还剩最后一张票</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s卖出第%d张票！\n&quot;</span>, name, tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 离开临界区</span></span><br><span class="line">		<span class="built_in">LeaveCriticalSection</span>(&amp;section);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程将无法想前推进。</p>
<blockquote>
<p>死锁产生的必要条件：</p>
</blockquote>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不可剥夺条件：进程已获得的资源，在未使用完之前，不可强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种首尾相接的循环等待关系</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION cs1;</span><br><span class="line">CRITICAL_SECTION cs2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">InitializeCriticalSection</span>(&amp;cs1);</span><br><span class="line">	<span class="built_in">InitializeCriticalSection</span>(&amp;cs2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> t1 = _beginthread(ThreadFun1, <span class="number">0</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">	<span class="keyword">uintptr_t</span> t2 = _beginthread(ThreadFun2, <span class="number">0</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//A在1区域，等着B从2区域出来</span></span><br><span class="line">	<span class="comment">//B在2区域，等着A从1区域出来</span></span><br><span class="line">	<span class="comment">//相互等待中，发生死锁</span></span><br><span class="line">	HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(t1),<span class="built_in">HANDLE</span>(t2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line">	<span class="comment">//进入1区域后，任何人无法进入1区域</span></span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;cs1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s进入了1区域,且睡眠了3秒！\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s想进入2区域！\n&quot;</span>, name);</span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;cs2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;cs2);</span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;cs1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line">	<span class="comment">//进入2区域后，任何人无法进入2区域</span></span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;cs2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s进入了2区域,且睡眠了3秒！\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s想进入1区域！\n&quot;</span>, name);</span><br><span class="line">	<span class="built_in">EnterCriticalSection</span>(&amp;cs1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;cs1);</span><br><span class="line">	<span class="built_in">LeaveCriticalSection</span>(&amp;cs2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>临界区一次只运行一个线程访问资源，而信号量运行N个线程在同一时刻访问同一资源。</p>
<ul>
<li><p>使用CreateSemaphore（）创建信号量时要指出允许的最大资源计数和当前可用资源计数。</p>
</li>
<li><p>一般将当前可用资源计数设置为最大值，每增加一个线程对资源的方位，可用资源计数减1，只要当前可用资源计数是大于0，就可以发出信号。当可用计数减小到0，则说明当前占用资源线程数已达到所允许的最大值，不允许其他线程的进入，此时无法发出信号。</p>
</li>
<li><p>线程在处理完共享资源后，通过ReleaseSemaphore（）函数将当前可用资源计数加1.</p>
<p>​                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps43.jpg" alt="img"></p>
<p>​                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps44.jpg" alt="img"></p>
<p>​                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715101201970.png" alt="image-20210715101201970"></p>
<blockquote>
<p>内核对象，semaphore，mutex，exent都是内核对象，而critical section是用户对象。</p>
</blockquote>
<pre><code>                             ![image-20210715100430054](多线程/image-20210715100430054.png)
</code></pre>
<p>​                                 <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715100445889.png" alt="image-20210715100445889"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun</span><span class="params">(LPVOID lpThreadParameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车辆名称与停车时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	DWORD time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 创建信号量,停车位资源只有3</span></span><br><span class="line">HANDLE hSemaphore = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hSemaphore = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">3</span>, <span class="number">3</span>, _T(<span class="string">&quot;停车位&quot;</span>));</span><br><span class="line"></span><br><span class="line">	HANDLE harr[<span class="number">5</span>] = &#123;INVALID_HANDLE_VALUE&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		car *pcar = <span class="keyword">new</span> car;</span><br><span class="line">		<span class="built_in">sprintf_s</span>(pcar-&gt;name, <span class="string">&quot;车辆%c&quot;</span>, <span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">		pcar-&gt;time = <span class="number">3</span> + i * <span class="number">2</span>;</span><br><span class="line">		harr[i]=<span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun, (LPVOID)pcar, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待所有线程执行完毕</span></span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">5</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hSemaphore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果停车位资源剩余，表示是有信号状态，就放行</span></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hSemaphore, INFINITE);</span><br><span class="line"></span><br><span class="line">	car *pcar = (car *)lpThreadParameter;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s进入停车场，停车%d秒！\n&quot;</span>, pcar-&gt;name, pcar-&gt;time);</span><br><span class="line">	<span class="built_in">Sleep</span>(pcar-&gt;time * <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s驶出停车场！\n&quot;</span>, pcar-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放一个停车位（信号量+1）</span></span><br><span class="line">	<span class="built_in">ReleaseSemaphore</span>(hSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用semaphhore实现进程互斥"><a href="#利用semaphhore实现进程互斥" class="headerlink" title="利用semaphhore实现进程互斥"></a>利用semaphhore实现进程互斥</h3><p>有些程序不允许运行同一个程序的多个实例运行（例如以独占方式使用串行口、端口等）。这就引出了进程互斥的问题，Semaphore实现进程互斥的方法：进程在第一次启动时成功创建命名Semaphore实例成功，此后进程实例第二次创建GetLastError会返回ERROR_ALREADY_EXISTS，从而保证进程在系统中只能存在一个实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 hSemaphore</span></span><br><span class="line">HANDLE hSemaphore = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//利用semaphore实现程序只运行一个进程</span></span><br><span class="line">	hSemaphore = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, _T(<span class="string">&quot;停车位&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_ALREADY_EXISTS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;程序已经运行，不允许开启多个进程！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hSemaphore);</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;程序第一次运行！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="互斥量-mutex"><a href="#互斥量-mutex" class="headerlink" title="互斥量 mutex"></a>互斥量 mutex</h2><p>C++使用内核对象互斥体（Mutex）来实现线程同步锁。当两个或更多线程需要同时访问一个共享资源时，Mutex可以只向一个线程授予对共享资源的独占访问权。如果一个线程获取了互斥体，则要获取该互斥体的第二个线程被挂起，直到第一个线程释放该互斥体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CreateMutex创建一个互厍量</span><br><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">BOOL blnitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">参数∶</span><br><span class="line">lpMutexAttributes :安全属性，一般设为<span class="literal">NULL</span></span><br><span class="line">bInitialOwner : TRUE表示调用互斥对象的线程获得互斥对象的所有权</span><br><span class="line">				如果为FALSE不拥有</span><br><span class="line">lpName :表示互斥量的名称，传入<span class="literal">NULL</span>表示匿名互斥量。</span><br><span class="line">返回值︰成功返回句柄，如果创建已有的互斥量，那么返回已经存在的信号量句柄，GetLastError也会设为ERROR_ALREADY_EXISTS失败返回		<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">ReleaseMutex释放线程拥有的互斥体的控制权</span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">ReleaseMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hMutex</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">参数∶</span><br><span class="line">hMutex :互斥体的句柄</span><br><span class="line">返回值:TRUE表示成功，FALSE表示失败。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WaitForSingleObject等待一个内核对象变为已通知状态DWORD</span><br><span class="line">WaitForSingleObject(</span><br><span class="line">HANDLE hObject,</span><br><span class="line">DWORD dwMilliseconds);</span><br><span class="line"></span><br><span class="line">hObject :指明一个内核对象的句柄</span><br><span class="line">dwMilliseconds :等待时间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个互斥量不被任何线程拥有时，可以使用waitforSingleObject让当前线程获取互斥量。</p>
</blockquote>
<p>该函数需要传递一个内核对象句柄，如果该内核对象处于未通知状态，则该函数导致线程进入阻塞状态﹔如果该内核对象处于已通知状态，则该函数立即返回WAIT_OBJECT_0。第二个参数指明要等待的时间(毫秒)，INFINITE表示无限等待，如果第二个参数为0，那么函数立即返回。如果等待超时，该函数返WAIT_TIMEOUT。如果该函数失败，返回WAIT_FAILED。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CloseHandle 关闭一个内核对象。</span><br><span class="line">BOOL CloseHandle( HANDLE hObject );</span><br><span class="line"></span><br><span class="line">只是关闭了一个对象（文件、文件映射、进程、线程、安全和同步对象等)句柄，引用计数减1，表示我不对这个句柄对象不做任何干预(诸如waitforsingleobject之类），但并没有释放对象，当引用计数变为0时，系统删除内核对象。</span><br><span class="line">返回值︰</span><br><span class="line">成功返回TRUE，失败返回FALSE，调用GetLastError()获知失败原因。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 mutex</span></span><br><span class="line">HANDLE hmutex = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//2 创建互斥体，此刻为有信号状态，因为设置了FALSE，如果是true，</span></span><br><span class="line">	<span class="comment">//表示它被main线程获取，那其他的线程获取不到的。</span></span><br><span class="line">	hmutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>,<span class="literal">false</span>,<span class="string">L&quot;售票互斥体&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开始卖票了！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建两个售票窗口</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> t1 = _beginthread(ThreadFun1, <span class="number">0</span>, <span class="string">&quot;售票窗口A&quot;</span>);</span><br><span class="line">	<span class="keyword">uintptr_t</span> t2 = _beginthread(ThreadFun2, <span class="number">0</span>, <span class="string">&quot;售票窗口B&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">	HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(t1),<span class="built_in">HANDLE</span>(t2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;卖票结束！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 删除临界区资源</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tickets &gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3 如果这个互斥体有信号状态（没有线程拥有它），则线程获取它后</span></span><br><span class="line">		<span class="comment">//它继续执行</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hmutex, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="comment">//CPU恰好执行到这里，这个时候线程时间片到了，并且此时还剩最后一张票</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s卖出第%d张票！\n&quot;</span>, name, tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 释放对互斥体的拥有权，它变成有信号状态</span></span><br><span class="line">		<span class="built_in">ReleaseMutex</span>(hmutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3 如果这个互斥体有信号状态（没有线程拥有它），则线程获取它后</span></span><br><span class="line">		<span class="comment">//它继续执行</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hmutex, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="comment">//CPU恰好执行到这里，这个时候线程时间片到了，并且此时还剩最后一张票</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s卖出第%d张票！\n&quot;</span>, name, tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 释放对互斥体的拥有权，它变成有信号状态</span></span><br><span class="line">		<span class="built_in">ReleaseMutex</span>(hmutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="利用mutex实现进程互斥"><a href="#利用mutex实现进程互斥" class="headerlink" title="利用mutex实现进程互斥"></a>利用mutex实现进程互斥</h3><p>利用mutex实现进程只有一个实例有些程序不允许运行同一个程序的多个实例运行（例如以独占方式使用串行口、端口等)。这就引出了进程互斥的问题，mutex实现进程互斥的方法︰进程在第一次启动时成功创建命名mutex实例成功，此后进程实例第二次创建GetLastErrorro会返回ERROR_ALREADY_EXISTS，从而保证进程在系统中只能存在一个实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 Mutex</span></span><br><span class="line">HANDLE Mutex = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//利用semaphore实现程序只运行一个进程</span></span><br><span class="line">	Mutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="string">L&quot;进程互斥&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_ALREADY_EXISTS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;程序已经运行，不允许开启多个进程！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(Mutex);</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;程序第一次运行！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h2><p>事件(Event)是WIN32提供的最灵活的线程间同步方式，根据状态变迁方式的不同，事件可分为两类︰<br>手动设置:这种对象只可能用程序手动设置，在需要该事件或者事件发生时，采用SetEvent及ResetEvent来进行设置。<br>自动恢复︰一旦事件发生并被处理后，自动恢复到没有事件状态，不需要再次设置。</p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps46.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps47.jpg" alt="img"></p>
<blockquote>
<p>这里说的等待线程被释放，是指<strong>WaitForSingleObject</strong>函数已经被执行。如果是自动，则<strong>WaitForSingleObject</strong>函数完成后自动设置为无信号状态，否则设置为ture时，必须手动设置无信号状态。</p>
</blockquote>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps48.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps49.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps50.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps51.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps52.jpg" alt="img"></p>
<p>CloseHandle 关闭一个内核对象。<br>BOOL CloseHandle( HANDLE hObject );</p>
<p>只是关闭了一个对象（文件、文件映射、进程、线程、安全和同步对象等)句柄，引用计数减1，表示我不对这个句柄对象不做任何干预(诸如waitforsingleobject之类），但并没有释放对象，当引用计数变为0时，系统删除内核对象。<br>返回值︰<br>成功返回TRUE，失败返回FALSE，调用GetLastError()获知失败原因。</p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715212401763.png" alt="image-20210715212401763"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 hevent</span></span><br><span class="line">HANDLE hevent = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//2 创建事件,自动重置信号状态(第二个参数)，</span></span><br><span class="line">	<span class="comment">//初始化为有信号状态，线程可以直接获取，不需要阻塞（第三个参数）</span></span><br><span class="line">	hevent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">false</span>,<span class="literal">true</span>, <span class="string">L&quot;售票互斥体&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开始卖票了！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建两个售票窗口</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> t1 = _beginthread(ThreadFun1, <span class="number">0</span>, <span class="string">&quot;售票窗口A&quot;</span>);</span><br><span class="line">	<span class="keyword">uintptr_t</span> t2 = _beginthread(ThreadFun2, <span class="number">0</span>, <span class="string">&quot;售票窗口B&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">	HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(t1),<span class="built_in">HANDLE</span>(t2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;卖票结束！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 删除临界区资源</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3 如果这个对象有信号状态（没有线程拥有它），则线程获取它后它继续执行</span></span><br><span class="line">		<span class="comment">//自动重置的事件对象，调用WaitForSingleObject后，自动重置为无信号</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hevent, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="comment">//CPU恰好执行到这里，这个时候线程时间片到了，并且此时还剩最后一张票</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s卖出第%d张票！\n&quot;</span>, name, tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 SetEvent让事件对象变成有信号状态</span></span><br><span class="line">		<span class="built_in">SetEvent</span>(hevent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">(<span class="keyword">void</span> * param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name = (<span class="keyword">char</span> *)param;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3 如果这个对象有信号状态（没有线程拥有它），则线程获取它后它继续执行</span></span><br><span class="line">		<span class="comment">//自动重置的事件对象，调用WaitForSingleObject后，自动重置为无信号</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hevent, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">			<span class="comment">//CPU恰好执行到这里，这个时候线程时间片到了，并且此时还剩最后一张票</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s卖出第%d张票！\n&quot;</span>, name, tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4 SetEvent让事件对象变成有信号状态</span></span><br><span class="line">		<span class="built_in">SetEvent</span>(hevent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="利用event实现进程互斥"><a href="#利用event实现进程互斥" class="headerlink" title="利用event实现进程互斥"></a>利用event实现进程互斥</h3><p>利用event实现进程只有一个实例有些程序不允许运行同一个程序的多个实例运行（例如以独占方式使用串行口、端口等）。这就引出了进程互斥的问题，event实现进程互斥的方法︰进程在第一次启动时成功创建命名event实例成功，此后进程实例第二次创建GetLastError会返回ERROR_ALREADY_EXISTS，从而保证进程在系统中只能存在一个实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 Event</span></span><br><span class="line">HANDLE hEvent = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//利用semaphore实现程序只运行一个进程</span></span><br><span class="line">	hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">false</span>,<span class="literal">true</span>, <span class="string">L&quot;进程互斥&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == ERROR_ALREADY_EXISTS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;程序已经运行，不允许开启多个进程！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hEvent);</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;程序第一次运行！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps53.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps54.jpg" alt="img"></p>
<blockquote>
<p>P申请资源，V释放资源</p>
</blockquote>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715212744512.png" alt="image-20210715212744512"></p>
<blockquote>
<p>资源-1之后&gt;=0，表示资源还有剩余，比如仓库位置还有剩余，则线程可以通过；如果-1之后&lt;0，表示资源没有剩余，比如仓库没有空余位置，则线程阻塞</p>
</blockquote>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715212806995.png" alt="image-20210715212806995"></p>
<blockquote>
<p>&gt;0,说明之前可能&gt;0也可能=0，表明之前是刚好装满或者本来就没满还有空位；&lt;=0说明之前以前本身就是负数了，说明之前已经有货物在等待空位了。</p>
</blockquote>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715212827813.png" alt="image-20210715212827813"></p>
<h3 id="利用event解决生产者消费者问题"><a href="#利用event解决生产者消费者问题" class="headerlink" title="利用event解决生产者消费者问题"></a>利用event解决生产者消费者问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个仓库</span></span><br><span class="line">queue &lt;<span class="keyword">int</span> &gt; store;</span><br><span class="line"><span class="comment">//仓库可以放三个货物</span></span><br><span class="line"><span class="keyword">int</span> StoreSize = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//货物起始ID</span></span><br><span class="line"><span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个event通知：</span></span><br><span class="line">HANDLE hevent1 = INVALID_HANDLE_VALUE;<span class="comment">//有货物时通知消费者取货物</span></span><br><span class="line">HANDLE hevent2 = INVALID_HANDLE_VALUE;<span class="comment">//仓库为空时通知生产者开始生产</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerThread</span><span class="params">(LPVOID param)</span></span>;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerThread</span><span class="params">(LPVOID param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机事件数组，模拟随机生产与消费速度</span></span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">10</span>] = &#123; <span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hevent1 = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="string">L&quot;事件对象1&quot;</span>);<span class="comment">//需要先开始生产</span></span><br><span class="line">	hevent2 = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">L&quot;事件对象2&quot;</span>);<span class="comment">//一开始，仓库为空，没货物</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> t1= _beginthread(ProducerThread, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">uintptr_t</span> t2 = _beginthread(ConsumerThread, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程运行结束</span></span><br><span class="line">	HANDLE harr[<span class="number">2</span>] = &#123;<span class="built_in">HANDLE</span>(t1),<span class="built_in">HANDLE</span>(t2)&#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hevent1);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hevent2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProducerThread</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//看event1是否允许生产</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hevent1, INFINITE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (store.<span class="built_in">size</span>()&lt;StoreSize)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> id = ID++;<span class="comment">//货物ID号</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;生产了产品：%d\n&quot;</span>, id);</span><br><span class="line">			store.<span class="built_in">push</span>(id);<span class="comment">//把产品放置在仓库</span></span><br><span class="line">			<span class="built_in">Sleep</span>(arr1[id % <span class="number">10</span>] * <span class="number">1000</span>);<span class="comment">//生产有时快有时慢</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//仓库满了,需要停止生产</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ResetEvent</span>(hevent1);<span class="comment">//把事件设置为无信号状态</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;仓库满了！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//仓库有货物的时候，需要通知消费者来取货</span></span><br><span class="line">		<span class="keyword">if</span> (store.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetEvent</span>(hevent2);<span class="comment">//让消费者的事件对象为有信号状态</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerThread</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//看event2是否允许取货</span></span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hevent2, INFINITE);</span><br><span class="line">		<span class="keyword">if</span> (store.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> id = store.<span class="built_in">front</span>();<span class="comment">//获取第一个货物，先进先出</span></span><br><span class="line">			store.<span class="built_in">pop</span>();<span class="comment">//卸载货物，腾出空位（就是删除第一个）</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;------------取出货物：%d\n&quot;</span>, id);</span><br><span class="line">			<span class="built_in">Sleep</span>(arr2[id % <span class="number">10</span>] * <span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//仓库空了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ResetEvent</span>(hevent2);<span class="comment">//设为无信号，不能取货</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;------------仓库空了！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (store.<span class="built_in">size</span>() &lt; <span class="number">3</span>)<span class="comment">//说明仓库没满，可以继续生产</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetEvent</span>(hevent1);<span class="comment">//通知生产者继续生产货物</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="同步总结"><a href="#同步总结" class="headerlink" title="同步总结"></a>同步总结</h2><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715213258018.png" alt="image-20210715213258018"></p>
<h1 id="线程本地存储TLS"><a href="#线程本地存储TLS" class="headerlink" title="线程本地存储TLS"></a>线程本地存储TLS</h1><p>如果一个变量是全局的，那么所有线程访问的是同一份，某一个线程对其修改会影响其他所有线程。如果我们需要一个变量在每个线程都能访问、并且值在每个线程中互不影响，这就是TLS。</p>
<p>线程局部存储在不同的平台有不同的实现，可移植性不太好。好在线程局部存储的实现并不难，最简单的办法就是建立一个全局表，通过当前线程ID去查询相应的数据，因为各个线程的ID不同，查到的数据自然也不同了。<mark class="hl-label blue">相当于一个key-value</mark>  </p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715213517476.png" alt="image-20210715213517476"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID lpThreadParameter)</span></span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun2</span><span class="params">(LPVOID lpThreadParameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 静态TLS</span></span><br><span class="line"><span class="comment">//声明为静态TLS，线程本地存储变量</span></span><br><span class="line">_declspec(thread) <span class="keyword">int</span> N = <span class="number">0</span>;<span class="comment">//每个线程的值互不影响</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	HANDLE hThread2 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">	HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(hThread1),<span class="built_in">HANDLE</span>(hThread2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每个线程中都有自己的Ｎ，和其他线程没关系</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程A打印%d\n&quot;</span>, N++);</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun2</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每个线程中都有自己的Ｎ，和其他线程没关系</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程B打印%d\n&quot;</span>, N);</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715213605513.png" alt="image-20210715213605513"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps55.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps56.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps57.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps58.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 动态TLS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态TLS的索引</span></span><br><span class="line">DWORD tlsindex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置的标志,只设置一次</span></span><br><span class="line"><span class="keyword">bool</span> flag1 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> flag2 = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tlsindex = <span class="built_in">TlsAlloc</span>();</span><br><span class="line">	<span class="keyword">if</span> (tlsindex == TLS_OUT_OF_INDEXES)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;分配TLS表索引失败！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在主线程设置一个值</span></span><br><span class="line">	<span class="built_in">TlsSetValue</span>(tlsindex, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">TlsGetValue</span>(tlsindex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主线程打印%s\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">	HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun1, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	HANDLE hThread2 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun2, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">	HANDLE harr[] = &#123; <span class="built_in">HANDLE</span>(hThread1),<span class="built_in">HANDLE</span>(hThread2) &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">////等待任意一个线程结束就返回数组索引</span></span><br><span class="line">	<span class="comment">//HANDLE harr[] = &#123; HANDLE(hThread1),HANDLE(hThread2) &#125;;</span></span><br><span class="line">	<span class="comment">//DWORD ret =WaitForMultipleObjects(2, harr, false, INFINITE);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">////设置等待时间为1秒</span></span><br><span class="line">	<span class="comment">//HANDLE harr[] = &#123; HANDLE(hThread1),HANDLE(hThread2) &#125;;</span></span><br><span class="line">	<span class="comment">//DWORD ret=WaitForMultipleObjects(2, harr, false, 1000);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放TLS</span></span><br><span class="line">	<span class="built_in">TlsFree</span>(tlsindex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">TlsSetValue</span>(tlsindex, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每个线程同一索引位置的值只属于自己，和其他线程没关系</span></span><br><span class="line">		<span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">TlsGetValue</span>(tlsindex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程A打印%s\n&quot;</span>, p);</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun2</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">TlsSetValue</span>(tlsindex, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//每个线程同一索引位置的值只属于自己，和其他线程没关系</span></span><br><span class="line">		<span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">TlsGetValue</span>(tlsindex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程B打印%s\n&quot;</span>, p);</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="多线程间消息通讯"><a href="#多线程间消息通讯" class="headerlink" title="多线程间消息通讯"></a>多线程间消息通讯</h1><p>线程之间可以使用Windows消息机制来进行消息通讯.一个线程原本是没有消息队列的，调用任何与消息相关的API会<mark class="hl-label red">自动初始化线程消息队列</mark>  相关的数据结构。</p>
<p>自定义windows消息<br><strong>#define MY_MSG  (WM_USER + 1 )</strong><br>为了防止用户定义的消息ID与系统的消息ID冲突，Microsoft定义了一个宏**#define WM_USER Ox0400** 小于WM_USER的ID被系统使用，大于WM_USER的ID被用户使用</p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps59.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps60.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps61.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps62.jpg" alt="img"> </p>
<blockquote>
<p>如果收到WM_QUIT，GetMessage会返回0</p>
</blockquote>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps63.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps64.jpg" alt="img"> </p>
<blockquote>
<p>立即返回，而GetMessage在没有消息是会阻塞。</p>
</blockquote>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps65.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义消息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MSG WM_USER+1</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID param)</span></span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun2</span><span class="params">(LPVOID param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD threadID = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取第一个线程的ID，方便第二个线程给第一个线程发消息</span></span><br><span class="line">	HANDLE htread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun1, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;threadID);</span><br><span class="line"></span><br><span class="line">	HANDLE htread2 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun2, (LPVOID)threadID, <span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无限等待两个线程全部执行完毕</span></span><br><span class="line">	HANDLE harr[] = &#123; htread1,htread2 &#125;;</span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, harr, <span class="literal">true</span>, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CloseHandle</span>(htread1);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(htread2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun1</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//接收第二个线程发来的消息</span></span><br><span class="line">	MSG msg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////GetMessage用法</span></span><br><span class="line">	<span class="comment">//while (GetMessage(&amp;msg,NULL,0,0))//如果有消息，继续，否则阻塞</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	switch (msg.message)</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//	case MY_MSG:</span></span><br><span class="line">	<span class="comment">//		printf(&quot;收到消息：%d\n&quot;, msg.wParam);</span></span><br><span class="line">	<span class="comment">//		break;</span></span><br><span class="line">	<span class="comment">//	default:</span></span><br><span class="line">	<span class="comment">//		break;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">////如果收到WM_QUIT，GetMessage会返回0，直接退出循环，进行这一步</span></span><br><span class="line">	<span class="comment">//printf(&quot;收到WM_QUIT消息,第一个线程退出\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//PeekMessage</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//不阻塞，马上返回</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">PeekMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (msg.message)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> MY_MSG:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;收到消息：%d\n&quot;</span>, msg.wParam);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WM_QUIT:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;收到WM_QUIT消息\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun2</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD threadID = (DWORD)param;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//给第一个线程发消息</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">PostThreadMessage</span>(threadID, MY_MSG, (WPARAM)N++, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (N==<span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//让第一个线程退出消息循环</span></span><br><span class="line">			<span class="built_in">PostThreadMessage</span>(threadID, WM_QUIT, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11-多线程简介"><a href="#C-11-多线程简介" class="headerlink" title="C++ 11 多线程简介"></a>C++ 11 多线程简介</h1><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps66.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps67.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps68.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps69.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps70.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps71.jpg" alt="img"> </p>
<h2 id="线程thread类"><a href="#线程thread类" class="headerlink" title="线程thread类"></a>线程thread类</h2><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps72.jpg" alt="img"> </p>
<blockquote>
<p>拷贝构造函数被删除了，所以不能拷贝，不能用a(b)这样初始化新对象。</p>
</blockquote>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps73.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps74.jpg" alt="img">    </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps75.jpg" alt="img"> </p>
<blockquote>
<p>和WaitForSingleObject相似</p>
</blockquote>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps76.jpg" alt="img"> </p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps77.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(<span class="keyword">char</span> *param)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//采用默认构造函数</span></span><br><span class="line">	thread t1;</span><br><span class="line">	cout &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;<span class="comment">//线程ID为0 </span></span><br><span class="line">	cout &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;<span class="comment">//为0,不能被join</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun, (<span class="keyword">char</span> *)<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;<span class="comment">//线程ID为0 </span></span><br><span class="line">	cout &lt;&lt; t2.<span class="built_in">joinable</span>() &lt;&lt; endl;<span class="comment">//为0,不能被join</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//thread对象在销毁之前，必须调用join，否则程序终止，或者detach</span></span><br><span class="line">	<span class="comment">//t2.join();//等待子线程执行完毕,和WaitForSingleObject相似</span></span><br><span class="line">	t2.<span class="built_in">detach</span>();<span class="comment">//与当前线程对象分离，成为孤儿线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(<span class="keyword">char</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715214808807.png" alt="image-20210715214808807"></p>
<h3 id="This-thread命名空间"><a href="#This-thread命名空间" class="headerlink" title="This_thread命名空间"></a>This_thread命名空间</h3><p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps78.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps79.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps80.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps81.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps82.jpg" alt="img"></p>
<p>时间非常短，微乎其微。</p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps83.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps84.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//this_thread有所有的线程辅助函数</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::this_thread;</span><br><span class="line"><span class="comment">//chrono命名空间下，有seconds模板类，miliseconds模板类</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0  this_thread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(string &amp;param)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun, (string)<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">		</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(string &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;线程ID：&quot;</span>&lt;&lt;<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; param.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//sleep_for(seconds(1));//线程睡眠1秒</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">yield</span>();<span class="comment">//让线程睡眠极小的时间片</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">sleep_until</span>(system_clock::<span class="built_in">now</span>() + <span class="built_in">milliseconds</span>(<span class="number">1000</span>));<span class="comment">//让当前线程睡眠当前时间+1秒</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><a href="https://en.cppreference.com/w/cpp/thread/yield">yield</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//this_thread有所有的线程辅助函数</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::this_thread;</span><br><span class="line"><span class="comment">//chrono命名空间下，有seconds模板类，miliseconds模板类</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 yield() 示例</span></span><br><span class="line"><span class="comment">// &quot;busy sleep&quot; while suggesting that other threads run </span></span><br><span class="line"><span class="comment">// for a small amount of time</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">little_sleep</span><span class="params">(std::chrono::microseconds us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">auto</span> end = start + us;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		std::this_thread::<span class="built_in">yield</span>();<span class="comment">//仅仅让出了2（随机的）微秒</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (std::chrono::high_resolution_clock::<span class="built_in">now</span>() &lt; end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//在100微妙内调用yeild只休息了2（随机的）微秒</span></span><br><span class="line">	<span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">little_sleep</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));<span class="comment">//微秒</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> elapsed = std::chrono::high_resolution_clock::<span class="built_in">now</span>() - start;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;waited for &quot;</span></span><br><span class="line">		&lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).<span class="built_in">count</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot; microseconds\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="原子atomic类-atomic-flag"><a href="#原子atomic类-atomic-flag" class="headerlink" title="原子atomic类 atomic_flag"></a>原子atomic类 atomic_flag</h2><p>​                                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps85.jpg" alt="img"> </p>
<p>​                                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps86.jpg" alt="img"> </p>
<p>Atomic是个模板类</p>
<p>​                                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps87.jpg" alt="img"> </p>
<p>​                                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps88.jpg" alt="img"></p>
<p>​                                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps89.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 原子操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span><span class="comment">//原子操作头文件</span></span></span><br><span class="line">atomic &lt;<span class="keyword">int</span> &gt; M = <span class="number">0</span>;<span class="comment">//用atomic保证对M的操作的原子性，这样就是2000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 非原子操作</span></span><br><span class="line"><span class="keyword">int</span> M = <span class="number">0</span>;<span class="comment">//操作重叠，不是原子操作，因此肯定少于2000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		M++;<span class="comment">//线程并发导致 ++ 操作重叠，不是原子操作，因此肯定少于2000000</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		M++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun1)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun2)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; M &lt;&lt; endl;<span class="comment">//这样做结果不是2000000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>test-and-set操作是<mark class="hl-label blue">原子的</mark>  (因此 test-and-set是原子read-modify-write(RMW)操作)，因此每次只有一个线程访问到。</p>
</blockquote>
<h3 id="模拟十人赛跑"><a href="#模拟十人赛跑" class="headerlink" title="模拟十人赛跑"></a>模拟十人赛跑</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// atomic_flag.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span><span class="comment">//原子操作头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> this_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">bool</span>&gt; ready = <span class="literal">false</span>;<span class="comment">//是否枪响</span></span><br><span class="line"></span><br><span class="line">atomic_flag win = ATOMIC_FLAG_INIT;<span class="comment">//终点线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//十个选手赛跑</span></span><br><span class="line">	vector&lt;thread&gt; verPlayers;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		verPlayers.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(Run,i));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;十个选手已经准备好！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预备跑</span></span><br><span class="line">	<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、2、1开始跑！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可以跑了</span></span><br><span class="line">	ready = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//等待所有选手跑完</span></span><br><span class="line">	<span class="keyword">for</span> (thread &amp;t :verPlayers)</span><br><span class="line">	&#123;</span><br><span class="line">		t.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//表示枪没响，不能跑，都在等待枪响</span></span><br><span class="line">	<span class="keyword">while</span> (!ready)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">yield</span>();<span class="comment">//让其他线程先执行，ready是FALSE，所以能一直进来，进来之后休眠极短的时间</span></span><br><span class="line">		<span class="comment">//在休眠的时间内，别的线程会启动，类似于在让10个线程都运行起来等待ready变成TRUE。</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">//如果不用这个，可以使用信号量，给10，然后waitfor，这样waitfor都能执行，然后在后面接</span></span><br><span class="line">		<span class="comment">//while(!ready)，甚至都可以不写yield，就在这空着while</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//表示跑的过程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果没有被设置过，返回false</span></span><br><span class="line">	<span class="keyword">if</span> (!win.<span class="built_in">test_and_set</span>())<span class="comment">//调用后会将win设置，后面第二第三名走到这会发现已经被设置过了，所以返回true，不能进入判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; id &lt;&lt; <span class="string">&quot;赢了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="互斥mutex类"><a href="#互斥mutex类" class="headerlink" title="互斥mutex类"></a>互斥mutex类</h2><p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps90.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps91.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps92.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps93.jpg" alt="img"></p>
<blockquote>
<p>Try_lock()有可能不被阻塞，立即返回</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 mutex</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SellThread</span><span class="params">(string &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//if (m.try_lock())</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	if (tickets &gt; 0)</span></span><br><span class="line">		<span class="comment">//	&#123;</span></span><br><span class="line">		<span class="comment">//		sleep_for(milliseconds(100));</span></span><br><span class="line">		<span class="comment">//		printf(&quot;%s 卖出 第%d张票！\n&quot;, param.c_str(), tickets--);</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//	m.unlock();</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		m.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep_for</span>(<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s 卖出 第%d张票！\n&quot;</span>, param.<span class="built_in">c_str</span>(), tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		m.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">		<span class="built_in">sleep_for</span>(<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(SellThread, (string)<span class="string">&quot;售票窗口A&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(SellThread, (string)<span class="string">&quot;售票窗口B&quot;</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715220121864.png" alt="image-20210715220121864"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 mutex</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//加锁</span></span><br><span class="line">recursive_mutex m2;<span class="comment">//可以递归加锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SellThread</span><span class="params">(string &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//if (m.try_lock())</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	if (tickets &gt; 0)</span></span><br><span class="line">		<span class="comment">//	&#123;</span></span><br><span class="line">		<span class="comment">//		sleep_for(milliseconds(100));</span></span><br><span class="line">		<span class="comment">//		printf(&quot;%s 卖出 第%d张票！\n&quot;, param.c_str(), tickets--);</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//	m.unlock();</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		m2.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">		m2.<span class="built_in">lock</span>();<span class="comment">//再次加锁</span></span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep_for</span>(<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s 卖出 第%d张票！\n&quot;</span>, param.<span class="built_in">c_str</span>(), tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		m2.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">		m2.<span class="built_in">unlock</span>();<span class="comment">//再次解锁</span></span><br><span class="line">		<span class="built_in">sleep_for</span>(<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(SellThread, (string)<span class="string">&quot;售票窗口A&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(SellThread, (string)<span class="string">&quot;售票窗口B&quot;</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps94.jpg" alt="img"> </p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps95.jpg" alt="img"> </p>
<p>超时之后会自动失去锁，所以在<strong>try_lock_for</strong>之后不能unlock</p>
<blockquote>
<ol>
<li> locking 一段时间(duration)</li>
</ol>
<p>   新创建的 unique_lock 对象管理 Mutex 对象 m，并试图通过调用 m.try_lock_for(rel_time) 来锁住 Mutex 对象一段时间(rel_time)。</p>
<ol start="2">
<li> locking 直到某个时间点(time point)</li>
</ol>
<p>   新创建的 unique_lock 对象管理 Mutex 对象m，并试图通过调用 m.try_lock_until(abs_time) 来在某个时间点(abs_time)之前锁住 Mutex 对象。</p>
</blockquote>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps96.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 mutex</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//加锁</span></span><br><span class="line">recursive_mutex m2;<span class="comment">//可以递归加锁</span></span><br><span class="line">timed_mutex m3;<span class="comment">//指定锁住的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SellThread</span><span class="params">(string &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//if (m.try_lock())</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	if (tickets &gt; 0)</span></span><br><span class="line">		<span class="comment">//	&#123;</span></span><br><span class="line">		<span class="comment">//		sleep_for(milliseconds(100));</span></span><br><span class="line">		<span class="comment">//		printf(&quot;%s 卖出 第%d张票！\n&quot;, param.c_str(), tickets--);</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//	m.unlock();</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s 当前是否获得锁-%d!---&quot;</span>, param.<span class="built_in">c_str</span>(), m3.<span class="built_in">try_lock_for</span>(<span class="built_in">seconds</span>(<span class="number">3</span>)));<span class="comment">//加锁</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep_for</span>(<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s 卖出 第%d张票！\n&quot;</span>, param.<span class="built_in">c_str</span>(), tickets--);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//m3.unlock();//解锁</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//sleep_for(milliseconds(100));</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(SellThread, (string)<span class="string">&quot;售票窗口A&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(SellThread, (string)<span class="string">&quot;售票窗口B&quot;</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210715220825196.png" alt="image-20210715220825196"></p>
<h3 id="模拟十人赛跑-1"><a href="#模拟十人赛跑-1" class="headerlink" title="模拟十人赛跑"></a>模拟十人赛跑</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">std::timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireworks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::timed_mutex&gt; <span class="title">lck</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">	<span class="comment">// waiting to get a lock: each thread prints &quot;-&quot; every 200ms:</span></span><br><span class="line">	<span class="keyword">while</span> (!lck.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>))) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// got a lock! - wait for 1s, then this thread prints &quot;*&quot;</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;*\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::thread threads[<span class="number">10</span>];</span><br><span class="line">	<span class="comment">// spawn 10 threads:</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">		threads[i] = std::<span class="built_in">thread</span>(fireworks);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="锁管理-lock-guard"><a href="#锁管理-lock-guard" class="headerlink" title="锁管理 lock_guard"></a>锁管理 lock_guard</h3><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716145911985.png" alt="image-20210716145911985"></p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716145917365.png" alt="image-20210716145917365"></p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716145931011.png" alt="image-20210716145931011"></p>
<p>lock_guard对象构造时，传入的Mutex对象会一直<mark class="hl-label blue">保持上锁状态</mark>  ，在lock_guard 对象被析构时，它所管理的Mutex对象会<mark class="hl-label blue">自动解锁</mark>  ，无需手动调用lock和unlock 对Mutex进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的Mutex对象可以正确进行解锁操作，极大地简化了程序员编写与Mutex相关的异常处理代码。</p>
<p>lock_guard最大的特点就是<mark class="hl-label blue">安全</mark>  易于使用，通过lock_guard对象管理的Mutex哪怕异常抛出的时候可以得到正确地解锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">1</span>));<span class="comment">//使用lock_guard需要把第32行的sleep放到上面来，因为lock_guard析构自动解锁，for循环中，</span></span><br><span class="line">								  <span class="comment">//每循环一次结束会析构一次（不信可以在lock_guard的析构函数打断点）,如果sleep还写在最后，</span></span><br><span class="line">								  <span class="comment">//那sleep之后解锁马上又新建了lock_guard，接着加锁，另一个线程会得不到mutex，所以放在前面，</span></span><br><span class="line">								  <span class="comment">//每次调用构造函数之前先sleep，给另一个线程拥有锁的机会</span></span><br><span class="line">			<span class="comment">//m.lock();</span></span><br><span class="line">			<span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;<span class="comment">//哪怕发送异常，也可以安全解锁</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">throw</span> logic_error::<span class="built_in">exception</span>(<span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;A打印&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">			<span class="comment">//m.unlock();//抛出异常时导致没有unlock，使得B无法回去mutex，发生死锁</span></span><br><span class="line">			<span class="comment">//sleep_for(seconds(1));</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;错误:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">//m.lock();</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B打印&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//m.unlock();</span></span><br><span class="line">		<span class="comment">//sleep_for(std::chrono::seconds(1));</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun)</span></span>;</span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun1)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="锁管理unique-lock类"><a href="#锁管理unique-lock类" class="headerlink" title="锁管理unique_lock类"></a>锁管理unique_lock类</h3><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716150213175.png" alt="image-20210716150213175"></p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716150216794.png" alt="image-20210716150216794"></p>
<blockquote>
<p>Unique_lock的lock和unlock可以自由显式控制mutex的lock和unlock（还可以通过析构来解锁），而lock_guard只有在构造和析构的时候能lock和unlock，不能显式控制。</p>
</blockquote>
<p><strong>unique_lock比lock_guard优势在于∶</strong></p>
<ul>
<li>unique_lock 不一定要拥有mutex，可建立空的unique_lock。</li>
<li>unique_lock 不可复制( non-copyable )，但它可以转移( movable )。所以它可以被函数回传，可放到STL container里。</li>
<li>unique_lock提供lock()、unlock()等函数，可用来加解锁mutex。</li>
<li>unique_lock本身还可以用于std:lock参数，因为其具备lock、unlock、try_lock成员函数,这些函数不仅完成针对mutex的操作还要更新mutex的状态。</li>
</ul>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716150352131.png" alt="image-20210716150352131"></p>
<p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716150356647.png" alt="image-20210716150356647"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UseMutexLock 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UseLockGuard 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UseUniqueLock 1</span></span><br><span class="line"></span><br><span class="line">mutex m;<span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UseLockGuard</span></span><br><span class="line">			<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">1</span>));<span class="comment">//使用lock_guard需要把第55行的sleep放到上面来，因为lock_guard析构自动解锁，for循环中，</span></span><br><span class="line">								  <span class="comment">//每循环一次结束会析构一次（不信可以在lock_guard的析构函数打断点）,如果sleep还写在最后，</span></span><br><span class="line">								  <span class="comment">//那sleep之后离开lock_guard的作用域解锁马上又新建了lock_guard，接着加锁，另一个线程会得不到mutex，所以放在前面，</span></span><br><span class="line">								  <span class="comment">//每次调用构造函数之前先sleep，给另一个线程拥有锁的机会</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UseMutexLock</span></span><br><span class="line">			m.<span class="built_in">lock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UseLockGuard</span></span><br><span class="line">			lock_guard &lt;mutex&gt; <span class="built_in">lock</span>(m);<span class="comment">//哪怕发送异常，也可以安全解锁，在作用域结束调用析构函数时自动解锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UseUniqueLock</span></span><br><span class="line">			<span class="comment">//和lock_guard对比，unique_lock可以显示控制lock和unlock，用来限定作用域，也可以用析构解锁</span></span><br><span class="line">			unique_lock &lt;mutex&gt; <span class="built_in">lock</span>(m);<span class="comment">//哪怕发送异常，也可以安全解锁</span></span><br><span class="line">			<span class="comment">//lock.unlock();//UniqueLock使用构造函数创建出来自动就加锁了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">throw</span> logic_error::<span class="built_in">exception</span>(<span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;A打印&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UseMutexLock</span></span><br><span class="line">			m.<span class="built_in">unlock</span>();<span class="comment">//抛出异常时导致没有unlock，使得B无法回去mutex，发生死锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UseUniqueLock</span></span><br><span class="line">			lock.<span class="built_in">unlock</span>();<span class="comment">//UniqueLock可以自主控制解锁，比lock_guard更加灵活</span></span><br><span class="line">			<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;错误:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//sleep_for(seconds(1));</span></span><br><span class="line">		<span class="comment">//m.lock();</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="comment">//lock.lock();</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B打印&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//m.unlock();</span></span><br><span class="line">		lock.<span class="built_in">unlock</span>();</span><br><span class="line">		<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun)</span></span>;</span><br><span class="line">	<span class="comment">//使用带参数的构造函数</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun1)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件变量condition-variable类"><a href="#条件变量condition-variable类" class="headerlink" title="条件变量condition_variable类"></a>条件变量condition_variable类</h2><p><img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210716150634234.png" alt="image-20210716150634234"></p>
<blockquote>
<p>condition_variable有5个函数:</p>
</blockquote>
<ul>
<li>wait阻塞自己，等待唤醒</li>
<li>wait_for阻塞自己，等待唤醒，最多等待一段时间</li>
<li>wait_until阻塞自己，等待唤醒，最多等待到某个时间点</li>
<li>notify_one唤醒一个等待在这个条件变量上的线程</li>
<li>notify_all唤醒所有等待在这个条件变量上的线程</li>
</ul>
<p>std:condition_variable对象的某个wait函数被调用的时候，它使用std::unique_lock(通过std::mutex)来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同std::condition_variable对象上调用了notify 函数来唤醒当前线程。</p>
<blockquote>
<p>std::condition_variable提供了两种wait()函数。当前线程调用wait()后将被阻塞(此时当前线程应该获得了锁( mutex ) ，不妨设获得锁lck)，直到另外某个线程调用notify_*唤醒了当前线程。<br>在线程被阻塞时，该函数会自动调用lck.unlock()释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，—旦当前线程获得通知(notified，通常是另外某个线程调用notify_*唤醒了当前线程)，wait()函数也是自动调用lck.lock)，使得lck的状态和wait函数被调用时相同。</p>
</blockquote>
<p>wait可以支持参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果第二个参数为true，那么wait()直接返回,通过</span></span><br><span class="line"><span class="comment">//如果第二个参数（lambda表达式返回值是false，那么wait将解锁互斥量，并堵塞在本行）</span></span><br><span class="line"><span class="comment">//如果wait()没有第二个参数：my_cond.wait(u_lock)；那么第一次调用默认条件为false（解锁互斥量，并堵塞在本行），等到被唤醒后再执行后面代码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堵塞到什么时候为止？堵塞到其他某个线程调用notify_one()成员函数为止</span></span><br><span class="line"><span class="comment">//将wait唤醒后： 1.wait()不断尝试重新获取互斥量锁并加锁；</span></span><br><span class="line"><span class="comment">//             2.wait()在获取到锁并加锁后，如果wait()有第二个参数，则判断lambda表达式（或其他函数），若为false，再次解锁互斥量，并阻塞（再次等待被notify_one唤醒）</span></span><br><span class="line"><span class="comment">//如果lambda表达式为true，则wait()返回，流程走下来（开始执行wait后的代码，拥有互斥量锁）</span></span><br><span class="line"><span class="comment">//如果wait()没有第二个参数，则wait()返回，流程走下来（开始执行wait后的代码，拥有互斥量锁）</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(data_mutex)</span></span>;</span><br><span class="line">data_var.<span class="built_in">wait</span>(lck,[]&#123;<span class="keyword">return</span> flag;&#125;);<span class="comment">//等待flag=true才通过</span></span><br><span class="line"></span><br><span class="line">data_var.<span class="built_in">wait</span>(lck,[]&#123;<span class="keyword">return</span> !flag;&#125;);<span class="comment">//等待flag=false才通过</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 测试Wait的时候自动解锁，当被唤醒时</span></span><br><span class="line">condition_variable  cv;<span class="comment">//仅支持unique_lock&lt;mutex&gt; 作为Wait的参数</span></span><br><span class="line"></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(m)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程ID=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;开始等待！\n&quot;</span> ;</span><br><span class="line">	cv.<span class="built_in">wait</span>(lck);<span class="comment">//等待被唤醒，阻塞住</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程ID=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;执行！\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun1</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="comment">//下面两句加与不加效果不同</span></span><br><span class="line">	<span class="comment">//不加，表示线程1在阻塞，m自动解锁，然后线程2加锁，直接输出，不用等主线程的3秒,先输出2再输出1</span></span><br><span class="line">	<span class="comment">//加上，表示线程1在阻塞，m自动解锁，然后进入线程2，等待5秒，在等待5秒的过程中，主线程唤醒了线程1，</span></span><br><span class="line">	<span class="comment">//线程1的Wait函数自动调用了lock，但是此时线程2还在加锁状态，所以线程1的lock阻塞，得等线程2解锁之后才输出，因此会一共等5秒，而且先输出2再输出1</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程ID=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;开始等待！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程ID=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;执行！\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">//sleep_for(seconds(1));</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun1, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3秒之后准备唤醒\n&quot;</span> ;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">3</span>));<span class="comment">//3秒之后全部唤醒</span></span><br><span class="line"></span><br><span class="line">	cv.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有</span></span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps97.jpg" alt="img"> </p>
<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps98.jpg" alt="img"></p>
<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps99.jpg" alt="img"></p>
<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps100.jpg" alt="img"></p>
<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps101.jpg" alt="img"> </p>
<p>​                                            <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps102.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 使用condition_variable 与condition_variable_any</span></span><br><span class="line">condition_variable  cv;<span class="comment">//仅支持unique_lock&lt;mutex&gt; 作为Wait的参数</span></span><br><span class="line">condition_variable_any  cv2;<span class="comment">//接收任何lockable参数作为Wait的参数</span></span><br><span class="line"></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="comment">//cv.wait(lck);//等待被唤醒，阻塞住</span></span><br><span class="line">	<span class="comment">//cv.wait_for(lck,seconds(1));//等待1秒后继续执行</span></span><br><span class="line">	</span><br><span class="line">	cv2.<span class="built_in">wait</span>(lck);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程ID=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;执行！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(ThreadFun, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">(ThreadFun, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3秒之后准备唤醒&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">3</span>));<span class="comment">//3秒之后全部唤醒</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cv.notify_all();//唤醒所有</span></span><br><span class="line">	<span class="comment">//cv.notify_one();//只唤醒一个，具体是哪个是随机的</span></span><br><span class="line">	cv2.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h2><p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps103.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps104.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps105.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps106.jpg" alt="img"> </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps107.jpg" alt="img"></p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps108.jpg" alt="img">    </p>
<p>​                                        <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps109.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="comment">//费时的操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadFun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始计算&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));<span class="comment">//计算耗时5秒</span></span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将来的结果</span></span><br><span class="line">	future&lt;<span class="keyword">int</span> &gt; result = <span class="built_in">async</span>(ThreadFun, <span class="number">123</span>, <span class="number">456</span>);<span class="comment">//move赋值操作</span></span><br><span class="line">	<span class="comment">//result.wait();//等待结果算出</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;算出结果&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> sum=result.<span class="built_in">get</span>();<span class="comment">//获取结果</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum=&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Promise类"><a href="#Promise类" class="headerlink" title="Promise类"></a>Promise类</h3><blockquote>
<p>一般和future搭配使用。</p>
</blockquote>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps110.jpg" alt="img"></p>
<p>​                                                <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps111.jpg" alt="img"> </p>
<blockquote>
<p>Promise内部有个Future，Future和promise内部是共享的，所以用promise在线程中setvalue之后，调用promise的get_future 函数就可以获取future中设置的值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![img](多线程/wps112.jpg) </span><br></pre></td></tr></table></figure>

<p>​                                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps113.jpg" alt="img"> </p>
<p>​                                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps114.jpg" alt="img"> </p>
<p>​                                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps115.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 setvalue</span></span><br><span class="line"><span class="comment">//费时的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(promise&lt;<span class="keyword">int</span> &gt; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));<span class="comment">//计算耗时5秒</span></span><br><span class="line">	<span class="comment">//promise设置结果值</span></span><br><span class="line">	param.<span class="built_in">set_value</span>(<span class="number">666</span>);<span class="comment">//设置结果，future会Get到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个promise</span></span><br><span class="line">	promise&lt;<span class="keyword">int</span> &gt; prom;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//future和promise搭配使用，类似于aynsc</span></span><br><span class="line">	future&lt;<span class="keyword">int</span> &gt; result = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun, ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum = result.<span class="built_in">get</span>();<span class="comment">//获取结果</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;获取结果=&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 setexception</span></span><br><span class="line"><span class="comment">//费时的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFun</span><span class="params">(promise&lt;<span class="keyword">int</span> &gt; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));<span class="comment">//计算耗时5秒</span></span><br><span class="line">	 <span class="comment">//promise设置结果值</span></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error::<span class="built_in">exception</span>(<span class="string">&quot;运行时错误！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//promise设置异常</span></span><br><span class="line">		param.<span class="built_in">set_exception</span>(<span class="built_in">current_exception</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//定义一个promise</span></span><br><span class="line">	promise&lt;<span class="keyword">int</span> &gt; prom;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//future和promise搭配使用，类似于aynsc</span></span><br><span class="line">	future&lt;<span class="keyword">int</span> &gt; result = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(ThreadFun, ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = result.<span class="built_in">get</span>();<span class="comment">//获取结果</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取结果=&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (exception &amp;e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取结果=&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Packaget-task类"><a href="#Packaget-task类" class="headerlink" title="Packaget_task类"></a>Packaget_task类</h3><p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps116.jpg" alt="img"> </p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps117.jpg" alt="img"> </p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps118.jpg" alt="img"></p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps119.jpg" alt="img"> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  this_thread;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  chrono;</span><br><span class="line"></span><br><span class="line"><span class="comment">//费时的操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sleep_for</span>(<span class="built_in">seconds</span>(<span class="number">5</span>));<span class="comment">//计算耗时5秒</span></span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//packaged_task包装了一个可调用的目标</span></span><br><span class="line">	<span class="function">packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>&gt; <span class="title">pack</span><span class="params">(work)</span></span>;</span><br><span class="line">	future&lt;<span class="keyword">int</span>&gt; result= pack.<span class="built_in">get_future</span>();<span class="comment">//获取packaged_task内部的future</span></span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(move(pack), <span class="number">123</span>,<span class="number">456</span>)</span></span>;<span class="comment">//将packaged_task给线程执行</span></span><br><span class="line">	t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum =result.<span class="built_in">get</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;获取结果=&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future、promise、packaged-task、async总结"><a href="#Future、promise、packaged-task、async总结" class="headerlink" title="Future、promise、packaged_task、async总结"></a>Future、promise、packaged_task、async总结</h2><p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps120.jpg" alt="img"> </p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps121.jpg" alt="img"></p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps122.jpg" alt="img"> </p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps123.jpg" alt="img"></p>
<p>​                                    <img src="/2021/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B/wps124.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>其他</title>
    <url>/2021/06/20/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="获取程序当前目录"><a href="#获取程序当前目录" class="headerlink" title="获取程序当前目录"></a>获取程序当前目录</h1><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString path=QDir::<span class="built_in">currentPath</span>();<span class="comment">//获取程序当前目录</span></span><br><span class="line">path.<span class="built_in">replace</span>(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>);<span class="comment">//将地址中的&quot;/&quot;替换为&quot;\&quot;，因为在Windows下使用的是&quot;\&quot;。</span></span><br><span class="line">QProcess::<span class="built_in">startDetached</span>(<span class="string">&quot;explorer &quot;</span>+path);<span class="comment">//打开上面获取的目录</span></span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找当前exe的路径</span></span><br><span class="line">	TCHAR szFilePath[MAX_PATH + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFilePath, MAX_PATH);</span><br><span class="line">	(_tcsrchr(szFilePath, _T(<span class="string">&#x27;\\&#x27;</span>)))[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 删除文件名，只获得路径字串</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iLen = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">char</span>* chRtn = <span class="keyword">new</span> <span class="keyword">char</span>[iLen*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)];</span><br><span class="line">	<span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, chRtn, iLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h1 id="通配符模糊查询"><a href="#通配符模糊查询" class="headerlink" title="通配符模糊查询"></a>通配符模糊查询</h1><p>通配符是一种特殊语句，主要有星号(<em>)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 实际上用“</em>Not?pad”可以对应Notepad\MyNotepad【*可以代表任何字符串；?仅代表单个字符串，但此单字必须存在】;Notep[ao]d可以对应Notepad\Notepod【ao代表a与o里二选一】，其余以此类推。</p>
<p>* 匹配 0 或多个字符 a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。 ? 匹配任意一个字符 a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//查询所有文件</span></span><br><span class="line">    <span class="keyword">char</span>* to_search = <span class="string">&quot;D:/Examples/Polar_C++/x64/Release/?.png&quot;</span>;<span class="comment">//*</span></span><br><span class="line">    <span class="comment">//遍历路径下的文件，找到需要的png</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span> &gt; finename;<span class="comment">//文件名的数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * point = <span class="string">&quot;.&quot;</span>;<span class="comment">//分割标示</span></span><br><span class="line">    <span class="keyword">intptr_t</span> handle;    <span class="comment">//用于查找的句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fileinfo</span>;</span>    <span class="comment">//文件信息的结构体</span></span><br><span class="line">    handle = _findfirst(to_search.<span class="built_in">data</span>(), &amp;fileinfo);    <span class="comment">//第一次查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在进行%s\n&quot;</span>, fileinfo.name); </span><br><span class="line">    finename.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(<span class="built_in">strtok</span>(fileinfo.name, point)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!_findnext(handle, &amp;fileinfo)) &#123;    <span class="comment">//循环查找其它符合的文件，直到找不到其它的为止</span></span><br><span class="line">        finename.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(<span class="built_in">strtok</span>(fileinfo.name, point)));</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;正在进行%s\n&quot;</span>, fileinfo.name); </span><br><span class="line">    &#125;</span><br><span class="line">    _findclose(handle);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有可能会报错，比如0x00007FFC70CB0B2D (ntdll.dll)处(位于 Cutton_Dlg.exe 中)引发的异常: 0xC0000005: 写入位置 0xFFFFFFFFAE1B1940 时发生访问冲突。</p>
<p>解决方法： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span>	handle;</span><br><span class="line">`改成`</span><br><span class="line"><span class="keyword">intptr_t</span>	handle;</span><br></pre></td></tr></table></figure>

<h1 id="某个磁盘的大小"><a href="#某个磁盘的大小" class="headerlink" title="某个磁盘的大小"></a>某个磁盘的大小</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="function">quint64 <span class="title">getDiskFreeSpace</span><span class="params">(QString driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPCWSTR lpcwstrDriver = (LPCWSTR)driver.<span class="built_in">utf16</span>();</span><br><span class="line">    ULARGE_INTEGER liFreeBytesAvailable, liTotalBytes, liTotalFreeBytes;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetDiskFreeSpaceEx</span>(lpcwstrDriver, &amp;liFreeBytesAvailable, &amp;liTotalBytes, &amp;liTotalFreeBytes))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (quint64)liTotalFreeBytes.QuadPart / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> qyh &#123;</span><br><span class="line">    CDiskInfo::<span class="built_in">CDiskInfo</span>(<span class="keyword">const</span> std::string&amp; _path) :</span><br><span class="line">            <span class="built_in">disk_total_capacity</span>(<span class="number">0</span>), <span class="built_in">disk_used_capacity</span>(<span class="number">0</span>), <span class="built_in">disk_free_capacity</span>(<span class="number">0</span>), <span class="built_in">disk_format</span>(</span><br><span class="line">                    DISK_FORMAT_UNKNOW), <span class="built_in">path</span>(_path) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">statfs</span>(path.<span class="built_in">c_str</span>(), &amp;buf);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;get disk infomation faild\n&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (buf.f_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4d44</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_FAT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x5346544e</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0X65735546</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_NTFS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEF53</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEF51</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_EXT2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_UNKNOW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            disk_total_capacity = (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize</span><br><span class="line">                    * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_blocks) );</span><br><span class="line">            disk_free_capacity =</span><br><span class="line">                    (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bfree));</span><br><span class="line">            disk_used_capacity = disk_total_capacity - disk_free_capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CDiskInfo::~<span class="built_in">CDiskInfo</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CDiskInfo::refreshInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">statfs</span>(path.<span class="built_in">c_str</span>(), &amp;buf);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;refresh get disk infomation faild\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (buf.f_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x4d44</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_FAT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x5346544e</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0X65735546</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_NTFS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xEF53</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xEF51</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_EXT2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_UNKNOW;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        disk_total_capacity = (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_blocks));</span><br><span class="line">        disk_free_capacity = (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bfree));</span><br><span class="line">        disk_used_capacity = disk_total_capacity - disk_free_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CDiskInfo::getTotalSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_total_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CDiskInfo::getUsedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_used_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CDiskInfo::getLeftSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_free_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">DISK_FORMAT <span class="title">CDiskInfo::getDiskFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_format;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="comment">/* namespace qyh */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function">qyh::CDiskInfo <span class="title">disk</span><span class="params">(path)</span></span>;</span><br><span class="line"> leftsize=disk.<span class="built_in">getLeftSize</span>();</span><br></pre></td></tr></table></figure>



<h1 id="所占内存大小监视"><a href="#所占内存大小监视" class="headerlink" title="所占内存大小监视"></a>所占内存大小监视</h1><h2 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE handle = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line"><span class="built_in">GetProcessMemoryInfo</span>(handle, &amp;pmc, <span class="built_in"><span class="keyword">sizeof</span></span>(pmc));</span><br><span class="line"><span class="comment">//内存大于800M就自动重启</span></span><br><span class="line"><span class="keyword">if</span> (pmc.PeakWorkingSetSize /<span class="number">1024</span>/<span class="number">1024</span> &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">on_btnStop_clicked</span>();</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    qApp-&gt;<span class="built_in">exit</span>(<span class="number">888</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**  文件名称:  res_monitor.c</span></span><br><span class="line"><span class="comment">**  文件描述:  指定进程的[cpu/内存]资源使用情况监测</span></span><br><span class="line"><span class="comment">**  ===============================================================================================</span></span><br><span class="line"><span class="comment">**  创建信息:  | 2019-2-1 | LEON | 创建本模块</span></span><br><span class="line"><span class="comment">**  ===============================================================================================</span></span><br><span class="line"><span class="comment">**  修改信息:  单击此处添加....</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;printf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">// CPU占用率计算原理：</span></span><br><span class="line"><span class="comment">// 1、读取/proc/pid/stat文件，其中记录了从开机到现在，本进程所占用的CPU时间（单位jiffies）</span></span><br><span class="line"><span class="comment">// 2、然后再读取/proc/stat文件，其中记录了从开机到现在，系统所占用的CPU时间（单位jiffies）</span></span><br><span class="line"><span class="comment">// 3、取两个时间点，这两个时间点的进程耗时差，除以系统耗时差，得到的就是该进程的CPU占用率</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">// 内存占用率计算原理：</span></span><br><span class="line"><span class="comment">// 读取/proc/pid/status文件，其中以VmRSS开头的行，记录了该进程的物理内存值</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">// 下面这段话详细的解释了RSS内存的意义，及其与VSZ内存的区别</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// RSS（Resident Set Size），常驻内存集大小，表示进程在RAM中占用了多少内存，并不包含在SWAP中占用的虚拟内存</span></span><br><span class="line"><span class="comment">// 即使是在内存中的使用了共享库的内存大小也一并计算在内，包含了完整的在stack和heap中的内存</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// VSZ（Virtual Memory Size），虚拟内存大小，表明了该进程可以访问的所有内存，包括被交换的内存和共享库内存</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 如果进程A的二进制文件大小为500KB，并且链接到了2500KB的共享库，有200KB的stack/heap大小</span></span><br><span class="line"><span class="comment">// 这200KB中又有100KB位于内存中，100KB位于SWAP空间中，并且加载了1000KB的共享库和400KB的自身二进制文件。则</span></span><br><span class="line"><span class="comment">// RSS: 400K + 1000K + 100K = 1500K; VSZ: 500K + 2500K + 200K = 3200K</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">//                           模块宏定义</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_START_POS        14                                                <span class="comment">/* stat文件的有效起始行数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUF_SIZE        512                                               <span class="comment">/* 读取文件的缓存空间大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ENABLE           <span class="meta-string">&quot;logon&quot;</span>                                           <span class="comment">/* 启用日志输出的命令 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONITR_DATA_PATH     <span class="meta-string">&quot;monitor_log&quot;</span>                                     <span class="comment">/* 日志文件的子目录 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONITR_DATA_BEXT     <span class="meta-string">&quot;.log&quot;</span>                                            <span class="comment">/* 日志文件的后缀名 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">//                           模块静态变量定义</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> s_cur_pro_cpu, s_pre_pro_cpu;                                      <span class="comment">/* 指定程序的本轮/前轮CPU时间 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> s_cur_sys_cpu, s_pre_sys_cpu;                                      <span class="comment">/* 整个系统的本轮/前轮CPU时间 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  s_needlogfile;                                                     <span class="comment">/* 是否要输出到日志文件 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> s_recfilepath[<span class="number">128</span>];                                                <span class="comment">/* 日志文件的路径信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  excute_cmd</span></span><br><span class="line"><span class="comment">**  功能描述:  执行shell脚本，并解析出最终的执行结果</span></span><br><span class="line"><span class="comment">**  输入参数:  脚本命令</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  返回1表示脚本命令执行成功，返回-1表示执行失败</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">excute_cmd</span><span class="params">(<span class="keyword">char</span> *comand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    </span><br><span class="line">    status = <span class="built_in">system</span>(comand);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>) &#123;                                                        <span class="comment">/* 系统子进程创建失败 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status) == <span class="number">0</span>) &#123;                                              <span class="comment">/* shell拉起失败或未正常执行结束 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WEXITSTATUS</span>(status) != <span class="number">0</span>) &#123;                                            <span class="comment">/* mkdir命令执行失败 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  target_is_exist</span></span><br><span class="line"><span class="comment">**  功能描述:  检查目标是否存在 【目标可以是目录和文件】</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  返回1表示目标存在，返回-1表示目标不存在</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">target_is_exist</span><span class="params">(<span class="keyword">char</span> *target_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    </span><br><span class="line">    result = <span class="built_in">access</span>(target_path, F_OK);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  make_sudir</span></span><br><span class="line"><span class="comment">**  功能描述:  创建目录 【可以建立多级子目录】</span></span><br><span class="line"><span class="comment">**  输入参数:  子目录路径</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  返回0表示该目录已经存在，返回1表示创建成功，返回-1表示创建失败</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">make_sudir</span><span class="params">(<span class="keyword">char</span> *fpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *comand;</span><br><span class="line">    <span class="keyword">int</span>   pathlen, result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">target_is_exist</span>(fpath) == <span class="number">1</span>) &#123;                                      <span class="comment">/* 目标文件夹已经存在 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pathlen = <span class="built_in">strlen</span>(fpath) + <span class="number">16</span>;                                              <span class="comment">/* 16的长度是为shell命令而留 */</span></span><br><span class="line">    comand = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pathlen);</span><br><span class="line">    <span class="built_in">assert</span>(comand != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(comand, <span class="number">0</span>, pathlen);</span><br><span class="line">    <span class="built_in">sprintf</span>(comand, <span class="string">&quot;mkdir -p %s&quot;</span>, fpath);</span><br><span class="line">    result = <span class="built_in">excute_cmd</span>(comand);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(comand);                                                              <span class="comment">/* 这里要记得释放内存 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  write_recfile</span></span><br><span class="line"><span class="comment">**  功能描述:  将信息写入到日志文件中</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_recfile</span><span class="params">(<span class="keyword">char</span> *log_path, <span class="keyword">char</span> *log_text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *log_hdl;</span><br><span class="line">    </span><br><span class="line">    log_hdl = <span class="built_in">fopen</span>(log_path, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(log_hdl != <span class="literal">NULL</span>);                                                   <span class="comment">/* 打开日志记录文件 */</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fseek</span>(log_hdl, <span class="number">0</span>, SEEK_END) == <span class="number">0</span>);                                  <span class="comment">/* 定位到尾开始写入 */</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fwrite</span>(log_text, <span class="built_in">strlen</span>(log_text), <span class="number">1</span>, log_hdl) == <span class="number">1</span>);               <span class="comment">/* 写入信息内容 */</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fclose</span>(log_hdl) == <span class="number">0</span>);                                              <span class="comment">/* 关闭日志记录文件 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  generate_rfile_path</span></span><br><span class="line"><span class="comment">**  功能描述:  生成文件名路径信息</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_rfile_path</span><span class="params">(<span class="keyword">char</span> *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>   <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>        <span class="title">tm</span>;</span></span><br><span class="line">    <span class="keyword">char</span>             timestr[<span class="number">32</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(timestr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(timestr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">    tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br><span class="line">    <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%.4d%.2d%.2d_%.2d%.2d%.2d&quot;</span>, tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">make_sudir</span>(MONITR_DATA_PATH) != <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(s_recfilepath, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s_recfilepath));</span><br><span class="line">    <span class="built_in">sprintf</span>(s_recfilepath, <span class="string">&quot;%s/%s_%s%s&quot;</span>, MONITR_DATA_PATH, target, timestr, MONITR_DATA_BEXT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;log is enabled. log_file \&quot;%s\&quot;\n&quot;</span>, s_recfilepath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  record_loginfo</span></span><br><span class="line"><span class="comment">**  功能描述:  将信息记录到日志文件，并进行打印输出</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">record_loginfo</span><span class="params">(<span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>   <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>        <span class="title">tm</span>;</span></span><br><span class="line">    <span class="keyword">int</span>              tlen;</span><br><span class="line">    <span class="keyword">char</span>            *wstr;</span><br><span class="line">    </span><br><span class="line">    tlen = <span class="built_in">strlen</span>(info) + <span class="number">32</span>;                                                  <span class="comment">/* 32用于存放时间戳 */</span></span><br><span class="line">    wstr = <span class="built_in">malloc</span>(tlen);</span><br><span class="line">    <span class="built_in">assert</span>(wstr != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">    tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br><span class="line">    <span class="built_in">sprintf</span>(wstr, <span class="string">&quot;[%04d/%02d/%02d %02d:%02d:%02d] %s&quot;</span>, tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, info);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, wstr);                                                        <span class="comment">/* 输出到终端显示 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s_needlogfile &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write_recfile</span>(s_recfilepath, wstr);                                    <span class="comment">/* 记录到日志文件 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  find_pid_by_name</span></span><br><span class="line"><span class="comment">**  功能描述:  根据进程名得到进程ID</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pid_by_name</span><span class="params">(<span class="keyword">char</span>* pidName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR           *prodir;</span><br><span class="line">    FILE          *status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">char</span>          finame[READ_BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span>          tmpbuf[READ_BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span>          pcname[READ_BUF_SIZE];</span><br><span class="line">    </span><br><span class="line">    prodir = <span class="built_in">opendir</span>(<span class="string">&quot;/proc&quot;</span>);                                                 <span class="comment">/* proc中包括当前的进程信息 */</span></span><br><span class="line">    <span class="built_in">assert</span>(prodir != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((next = <span class="built_in">readdir</span>(prodir)) != <span class="literal">NULL</span>) &#123;                                 <span class="comment">/* 逐个检索所有目录 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(next-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*next-&gt;d_name)) &#123;                                         <span class="comment">/* 进程目录必须是数字的 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(finame, <span class="string">&quot;/proc/%s/status&quot;</span>, next-&gt;d_name);                      <span class="comment">/* 拼凑出完整的目录名称 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(status = <span class="built_in">fopen</span>(finame, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fgets</span>(tmpbuf, READ_BUF_SIZE - <span class="number">1</span>, status) == <span class="literal">NULL</span>) &#123;                <span class="comment">/* 读取目录下的文件 */</span></span><br><span class="line">            <span class="built_in">fclose</span>(status);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fclose</span>(status);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sscanf</span>(tmpbuf, <span class="string">&quot;%*s %s&quot;</span>, pcname);                                      <span class="comment">/* 提取出其中的有效内容 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pcname, pidName) == <span class="number">0</span>) &#123;                                    <span class="comment">/* 与所输入的进程名符合 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">strtol</span>(next-&gt;d_name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_items_by_pos</span></span><br><span class="line"><span class="comment">**  功能描述:  在字符串中寻找第N次空格出现的地方</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_items_by_pos</span><span class="params">(<span class="keyword">char</span> *buff, <span class="keyword">unsigned</span> <span class="keyword">int</span> numb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *crpos;</span><br><span class="line">    <span class="keyword">int</span>   i, ttlen, count;</span><br><span class="line">    </span><br><span class="line">    crpos = buff;</span><br><span class="line">    ttlen = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ttlen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == *crpos) &#123;                                                   <span class="comment">/* 以空格为标记符进行识别 */</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == (numb - <span class="number">1</span>)) &#123;                                         <span class="comment">/* 全部个数都找完了 */</span></span><br><span class="line">                crpos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        crpos++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> crpos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_pro_cpu_time</span></span><br><span class="line"><span class="comment">**  功能描述:  获取某个进程的CPU时间（从开机到现在，单位jiffies）</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_pro_cpu_time</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE   *fd;</span><br><span class="line">    <span class="keyword">char</span>   *vpos, buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">long</span>    utime, stime, cutime, cstime;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;/proc/%d/stat&quot;</span>, pid);                                       <span class="comment">/* 读取进程的状态文件 */</span></span><br><span class="line">    </span><br><span class="line">    fd = <span class="built_in">fopen</span>(buff, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(fd != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fgets</span>(buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), fd) != <span class="literal">NULL</span>);                             <span class="comment">/* 读取文件内容到缓冲区 */</span></span><br><span class="line">    </span><br><span class="line">    vpos = <span class="built_in">get_items_by_pos</span>(buff, CPU_START_POS);                              <span class="comment">/* 读取指定的条目内容 */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(vpos, <span class="string">&quot;%ld %ld %ld %ld&quot;</span>, &amp;utime, &amp;stime, &amp;cutime, &amp;cstime);         <span class="comment">/* 将条目内容拆分成实际的数据 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (utime + stime + cutime + cstime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_sys_cpu_time</span></span><br><span class="line"><span class="comment">**  功能描述:  获取整个系统的CPU时间（从开机到现在，单位jiffies）</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_sys_cpu_time</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE   *fd;</span><br><span class="line">    <span class="keyword">char</span>   name[<span class="number">32</span>], buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">long</span>   user, nice, syst, idle;</span><br><span class="line">    </span><br><span class="line">    fd = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/stat&quot;</span>, <span class="string">&quot;r&quot;</span>);                                             <span class="comment">/* 读取系统的状态文件 */</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fgets</span>(buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), fd) != <span class="literal">NULL</span>);                             <span class="comment">/* 读取文件内容到缓冲区 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buff, <span class="string">&quot;%s %ld %ld %ld %ld&quot;</span>, name, &amp;user, &amp;nice, &amp;syst, &amp;idle);      <span class="comment">/* 将条目内容拆分成实际的数据 */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (user + nice + syst + idle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_cpu_stat</span></span><br><span class="line"><span class="comment">**  功能描述:  获取进程的CPU使用率</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  本轮时间片里，该进程的CPU使用率，单位百分比</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_cpu_stat</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ratio;</span><br><span class="line">    </span><br><span class="line">    s_cur_pro_cpu = <span class="built_in">get_pro_cpu_time</span>(pid);</span><br><span class="line">    s_cur_sys_cpu = <span class="built_in">get_sys_cpu_time</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((s_cur_pro_cpu == s_pre_pro_cpu) || (s_cur_sys_cpu == s_pre_sys_cpu) || (s_cur_pro_cpu == <span class="number">0</span>) || (s_cur_sys_cpu == <span class="number">0</span>)) &#123;</span><br><span class="line">        ratio = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ratio = (<span class="number">100.0</span> * (s_cur_pro_cpu - s_pre_pro_cpu)) / (s_cur_sys_cpu - s_pre_sys_cpu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s_pre_pro_cpu = s_cur_pro_cpu;</span><br><span class="line">    s_pre_sys_cpu = s_cur_sys_cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ratio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_mem_stat</span></span><br><span class="line"><span class="comment">**  功能描述:  获取进程的内存使用情况</span></span><br><span class="line"><span class="comment">**  输入参数:  进程ID值</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  此刻，该进程的物理内存占用量，单位KB</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_mem_stat</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="keyword">int</span>   vmrss;</span><br><span class="line">    <span class="keyword">char</span> *valid, sbuff[<span class="number">32</span>], tbuff[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(tbuff, <span class="string">&quot;/proc/%d/status&quot;</span>, pid);                                    <span class="comment">/* 在proc目录下查找进程对应文件 */</span></span><br><span class="line">    </span><br><span class="line">    fd = <span class="built_in">fopen</span>(tbuff, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(fd != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;                                                                <span class="comment">/* 对文件内容进行逐行搜索 */</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">fgets</span>(tbuff, <span class="built_in"><span class="keyword">sizeof</span></span>(tbuff), fd) != <span class="literal">NULL</span>);                       <span class="comment">/* 文件读取出错 */</span></span><br><span class="line">        valid = <span class="built_in">strstr</span>(tbuff, <span class="string">&quot;VmRSS&quot;</span>);                                        <span class="comment">/* 在该行内容中搜索关键词 */</span></span><br><span class="line">        <span class="keyword">if</span> (valid != <span class="literal">NULL</span>) &#123;                                                   <span class="comment">/* 结果非空则表示搜索成功 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(tbuff, <span class="string">&quot;%s %d&quot;</span>, sbuff, &amp;vmrss);                                     <span class="comment">/* 将该行内容拆成符合需要的格式 */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vmrss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  main</span></span><br><span class="line"><span class="comment">**  功能描述:  主函数</span></span><br><span class="line"><span class="comment">**  输入参数:  需要监测的进程名称，刷新的频率，以及是否要输出到日志文件</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**  使用方法:  输入&quot;monitor_pc cheese 1&quot;，表示以1s的频率监控cheese进程的CPU及物理内存使用情况</span></span><br><span class="line"><span class="comment">**  使用方法:  如果需要将监控数据同步输出到日志文件，则输入&quot;monitor_pc cheese 1 logon&quot;即可</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pid, rtime;</span><br><span class="line">    <span class="keyword">char</span> *name_pos, *proc_name, sstr[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid cmd!!! should specify \&quot;proc_name\&quot; and \&quot;refresh_time\&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    proc_name = argv[<span class="number">0</span>];                                                       <span class="comment">/* 获取进程名称 */</span></span><br><span class="line">    </span><br><span class="line">    name_pos = <span class="built_in">strrchr</span>(proc_name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != name_pos)&#123;                                                     <span class="comment">/* 提取出路径最后部分的文件名 */</span></span><br><span class="line">        proc_name = name_pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;proc \&quot;%s\&quot; starting...\n&quot;</span>, proc_name);</span><br><span class="line">    </span><br><span class="line">    rtime = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);                                                     <span class="comment">/* 获取刷新时间 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((rtime == <span class="number">0</span>) || (rtime &gt; <span class="number">60</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid refresh_time(%d)!!! valid range: 0-60\n&quot;</span>, rtime);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s_needlogfile = <span class="number">0</span>;                                                         <span class="comment">/* 默认不需要启用日志输出功能 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((argc == <span class="number">4</span>) &amp;&amp; (<span class="built_in">strcmp</span>(argv[<span class="number">3</span>], LOG_ENABLE) == <span class="number">0</span>)) &#123;                   <span class="comment">/* 判断用户输入的命令是否符合要求 */</span></span><br><span class="line">        <span class="built_in">generate_rfile_path</span>(argv[<span class="number">1</span>]);                                          <span class="comment">/* 生成日志文件的路径信息 */</span></span><br><span class="line">        s_needlogfile = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pid = <span class="built_in">find_pid_by_name</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(sstr, <span class="string">&quot;proc \&quot;%s\&quot; not found...\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(sstr, <span class="string">&quot;cpu %.2f%%, mem %d KB\n&quot;</span>, <span class="built_in">get_cpu_stat</span>(pid), <span class="built_in">get_mem_stat</span>(pid));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">record_loginfo</span>(sstr);</span><br><span class="line">        <span class="built_in">sleep</span>(rtime);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="获得毫秒时间"><a href="#获得毫秒时间" class="headerlink" title="获得毫秒时间"></a>获得毫秒时间</h1><h2 id="windows-2"><a href="#windows-2" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line">    <span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">    函数名:    	</span></span><br><span class="line"><span class="comment">    gettimeofday</span></span><br><span class="line"><span class="comment">    函数描述:	获取毫秒时间</span></span><br><span class="line"><span class="comment">    输入参数:</span></span><br><span class="line"><span class="comment">    输出参数:</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">    ***************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tp, <span class="keyword">void</span> *tzp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">time_t</span> clock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line">        SYSTEMTIME wtm;</span><br><span class="line">        <span class="built_in">GetLocalTime</span>(&amp;wtm);</span><br><span class="line">        tm.tm_year = wtm.wYear - <span class="number">1900</span>;</span><br><span class="line">        tm.tm_mon = wtm.wMonth - <span class="number">1</span>;</span><br><span class="line">        tm.tm_mday = wtm.wDay;</span><br><span class="line">        tm.tm_hour = wtm.wHour;</span><br><span class="line">        tm.tm_min = wtm.wMinute;</span><br><span class="line">        tm.tm_sec = wtm.wSecond;</span><br><span class="line">        tm.tm_isdst = <span class="number">-1</span>;</span><br><span class="line">        clock = <span class="built_in">mktime</span>(&amp;tm);</span><br><span class="line">        tp-&gt;tv_sec = clock;</span><br><span class="line">        tp-&gt;tv_usec = wtm.wMilliseconds * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">    tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="linux-1"><a href="#linux-1" class="headerlink" title="linux"></a>linux</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Linux-获得进程ID"><a href="#Linux-获得进程ID" class="headerlink" title="Linux 获得进程ID"></a>Linux 获得进程ID</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程本身</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* process_name, <span class="keyword">const</span> <span class="keyword">char</span>* user = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        user = <span class="built_in">getlogin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">if</span> (user)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;pgrep %s -u %s&quot;</span>, process_name, user);</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *pstr = <span class="built_in">popen</span>(cmd,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pstr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buff));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">fgets</span>(buff, <span class="number">512</span>, pstr))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atoi</span>(buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ProID=<span class="built_in">get_pid</span>(<span class="string">&quot;NewPorject&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Sleep-毫秒"><a href="#Sleep-毫秒" class="headerlink" title="Sleep 毫秒"></a>Sleep 毫秒</h1><h2 id="windows-3"><a href="#windows-3" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">Sleep（）</span><br></pre></td></tr></table></figure>

<h2 id="linux-2"><a href="#linux-2" class="headerlink" title="linux"></a>linux</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> ms)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span>;</span></span><br><span class="line">       delay.tv_sec = <span class="number">0</span>;</span><br><span class="line">       delay.tv_usec = ms * <span class="number">1000</span>; <span class="comment">// 20 ms</span></span><br><span class="line">       <span class="built_in">select</span>(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;delay);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="windows-程序运行多长时间"><a href="#windows-程序运行多长时间" class="headerlink" title="windows 程序运行多长时间"></a>windows 程序运行多长时间</h1><p>打开运行 输入 msinfo32</p>
<p>然后在软件环境- 正在运行任务- 就能够看到运行开始的时间了.</p>
<h1 id="看windows系统信息"><a href="#看windows系统信息" class="headerlink" title="看windows系统信息"></a>看windows系统信息</h1><p>dxdiag</p>
<h1 id="configure、make、make-install-命令"><a href="#configure、make、make-install-命令" class="headerlink" title="./configure、make、make install 命令"></a>./configure、make、make install 命令</h1><p>这些都是典型的使用GNU的AUTOCONF和AUTOMAKE产生的程序的安装步骤</p>
<h2 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h2><p>　　1、./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p>
<p>　　2、make 是用来编译的，它从Makefile中读取指令，然后编译。</p>
<p>　　3、make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
<p>　　注意：AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。</p>
<h2 id="二、详细解释"><a href="#二、详细解释" class="headerlink" title="二、详细解释"></a>二、详细解释</h2><h3 id="1、configure命令"><a href="#1、configure命令" class="headerlink" title="1、configure命令"></a>1、configure命令</h3><p>　　这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p>
<p>　　<img src="/2021/06/20/%E5%85%B6%E4%BB%96/e7954280-5bba-4769-933d-f378ce5ddb59.png" alt="img"></p>
<h3 id="2、make"><a href="#2、make" class="headerlink" title="2、make"></a>2、make</h3><p>　　这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p>
<p>　　可能遇到的错误：make *** 没有指明目标并且找不到 makefile。 停止。问题很明了，没有Makefile，怎么办，原来是要先./configure 一下，再make。</p>
<h3 id="3、make-insatll"><a href="#3、make-insatll" class="headerlink" title="3、make insatll"></a>3、make insatll</h3><p>　　这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p>
<h2 id="三、扩展说明"><a href="#三、扩展说明" class="headerlink" title="三、扩展说明"></a>三、扩展说明</h2><p>　　Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。使用上述三个自动工具，就可以生成configure脚本。运行configure脚本，就可以生成Makefile文件，然后就可以运行make、make install和make clean。</p>
<p>　　configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。</p>
<p>　　这时，就可运行configure脚本了，运行configure脚本，就可产生出符合GNU规范的Makefile文件了： $ ./configure</p>
<p>到此时，就可以运行make进行编译，在运行make install进行安装了，最后运行make clean删除临时文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ make install           (注：运行这个要有足够的权限)</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<p>　　利用configure所产生的Makefile文件有几个预设的目标可供使用，其中几个重要的简述如下：</p>
<p>　　make all：产生我们设定的目标，即此范例中的可执行文件。只打make也可以，此时会开始编译原始码，然后连结，并且产生可执行文件。</p>
<p>　　make clean：清除编译产生的可执行文件及目标文件(object file，*.o)。</p>
<p>　　make distclean：除了清除可执行文件和目标文件外，把configure所产生的Makefile也清除掉。</p>
<p>　　make install：将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。如果用bin_PROGRAMS宏的话，程序会被安装至/usr/local/bin这个目录。</p>
<p>　　make dist：将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以PACKAGE-VERSION.tar.gz为名称的文件。 PACKAGE和VERSION这两个变数是根据configure.in文件中AM_INIT_AUTOMAKE(PACKAGE，VERSION)的定义。在此范例中会产生test-1.0.tar.gz的档案。</p>
<p>　　make distcheck：和make dist类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成tar.gz文件外，还会自动把这个压缩文件解开，执行 configure，并且进行make all 的动作，确认编译无误后，会显示这个tar.gz文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</p>
<h1 id="cmake-make"><a href="#cmake-make" class="headerlink" title="cmake  make"></a>cmake  make</h1><p>1.gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。<br>2.当你的程序只有一个源文件时，直接就可以用gcc命令编译它。<br>3.但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大<br>4.所以出现了make工具</p>
<p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。<br>5.makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。<br>6.makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。<br>7.makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。<br>8.这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。<br>9.可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。<br>10.到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。</p>
<p>11.当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形</p>
<p>12.接着是qmake，qmake是什么，先说一下Qt这个东西。Qt是跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。简单的说就是C++的第三方库，使用这个库你可以很容易生成windows，Linux，MAC os等等平台的图形界面。现在的Qt还包含了开发各种软件一般需要用到的功能模块（网络，数据库，XML，多线程啊等等），比你直接用C++（只带标准内裤那种）要方便和简单。</p>
<p>13.你可以用Qt简简单单就实现非常复杂的功能，是因为Qt对C++进行了扩展，你写一行代码，Qt在背后帮你写了几百上千行，而这些多出来的代码就是靠Qt专有的moc编译器（The Meta-Object Compiler）和uic编译器（User Interface Complier）来重新翻译你那一行代码。问题来了，你在进行程序编译前就必须先调用moc和uic对Qt源文件进行预处理，然后再调用编译器进行编译。上面说的那种普通makefile文件是不适用的，它没办法对qt源文件进行预处理。所以qmake就产生了。</p>
<p>14.qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。</p>
<p>15.qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。</p>
<p>16.还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -= qt 就可以了。</p>
<ol start="17">
<li>这样qmake和cmake有什么区别？不好意思，cmake也是同样支持Qt程序的，cmake也能生成针对qt 程序的那种特殊makefile，只是cmake的CMakeLists.txt 写起来相对与qmake的pro文件复杂点。qmake 是为 Qt 量身打造的，使用起来非常方便，但是cmake功能比qmake强大。一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的。当你的工程非常大的时候，又有qt部分的子工程，又有其他语言的部分子工程，据说用cmake会 方便，我也没试过。</li>
</ol>
<p>写程序大体步骤为：</p>
<p>1.用编辑器编写源代码，如.c文件。</p>
<p>2.用编译器编译代码生成目标文件，如.o。</p>
<p>3.用链接器连接目标代码生成可执行文件，如.exe。</p>
<p>但如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。</p>
<p>对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。所以在编程的世界里没有捷径可走，还是要脚踏实地的。</p>
<p>所以流程如下：</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/c320be88-dd06-4345-8148-4513a7bc43cc.png" alt="img"></p>
<h1 id="C，C-判断操作系统是Linux，windows还是Unix"><a href="#C，C-判断操作系统是Linux，windows还是Unix" class="headerlink" title="C，C++判断操作系统是Linux，windows还是Unix"></a>C，C++判断操作系统是Linux，windows还是Unix</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __unix</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linux\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __sun</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __sparc</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sun SPARC\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Sun X86\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _AIX</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;AIX\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WINVER</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Windows\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="编译器MinGW-MSVC-GCC-Clang"><a href="#编译器MinGW-MSVC-GCC-Clang" class="headerlink" title="编译器MinGW MSVC GCC Clang"></a>编译器MinGW MSVC GCC Clang</h1><ul>
<li><p><strong>MSVC</strong>：<br>即Microsoft Visual C++ Compiler，即微软自己的编译器<br>我们下载Windows下的OpenCV时，会带两个文件夹VC14，VC15（分别与Visual Studio的版本有对应关系），这两个文件夹下的库可以直接运行不需要编译<br>将VS作为Qt的开发环境也是使用这个编译器的缘故</p>
</li>
<li><p><strong>MinGW</strong>：<br>我们都知道GNU在Linux下面鼎鼎大名的gcc/g++，MinGW则是指Minimalist GNU for Windows的缩写<br>它是将GNU开发工具移植到Win32平台下的产物，即一套Windows上的GNU工具集<br>用其开发的程序不需要额外的第三方DLL支持就可以在Windows下运行，相对地，不使用动态库导致的就是编译出来的程序大很多。也是可以设置使用静态库的</p>
</li>
<li><p><strong>GCC：GNU(Gnu’s Not Unix)编译器套装(GNU Compiler Collection，GCC)，指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件</strong>，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC(特别是其中的C语言编译器)也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。</p>
<p><strong>GCC支持的语言</strong>：原名为GNU C语言编译器(GNU C Compiler)，因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。</p>
<p>许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果电脑预装的Mac OS X操作系统也采用这个编译器。</p>
<p>GCC目前由世界各地不同的数个程序员小组维护。它是移植到最多中央处理器架构以及最多操作系统的编译器。由于GCC已成为GNU系统的官方编译器(包括GNU/Linux家族)，它也成为编译与创建其他操作系统的主要编译器，包括BSD家族、Mac OS X、NeXTSTEP与BeOS。</p>
<p>GCC通常是跨平台软件的编译器首选。有别于一般局限于特定系统与运行环境的编译器，GCC在所有平台上都使用同一个前端处理程序，产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。</p>
<p><strong>GCC支持的主要处理器架构</strong>：ARM、x86、x86-64、MIPS、PowerPC等。</p>
<p>​    <strong>GCC结构</strong>：GCC的外部接口长得像一个标准的Unix编译器。用户在命令行下键入gcc之程序名，以及一些命令参数，以便决定每个输入文件使用的个别语言编译器，并为输出代码使用适合此硬件平台的汇编语言编译器，并且选择性地运行连接器以制造可执行的程序。每个语言编译器都是独立程序，此程序可处理输入的源代码，并输出汇编语言码。全部的语言编译器都拥有共通的中介架构：一个前端解析匹配此语言的源代码，并产生一抽象语法树，以及一翻译此语法树成为GCC的寄存器转换语言的后端。编译器最优化与静态代码解析技术在此阶段应用于代码上。最后，适用于此硬件架构的汇编语言代码以杰克·戴维森与克里斯·弗雷泽发明的算法产出。</p>
<p>几乎全部的GCC都由C/C++写成，除了Ada前端大部分以Ada写成。</p>
</li>
<li><p><strong>Clang：是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端</strong>。它采用了底层虚拟机(LLVM)作为其后端。它的目标是提供一个GNU编译器套装(GCC)的替代品。作者是克里斯·拉特纳(Chris Lattner)，在苹果公司的赞助支持下进行开发，而源代码授权是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang主要由C++编写。</p>
<p>Clang项目包括Clang前端和Clang静态分析器等。这个软件项目在2005年由苹果电脑发起，是LLVM(Low Level Virtual Machine)编译器工具集的前端(front-end)，目的是输出代码对应的抽象语法树(Abstract Syntax Tree, AST)，并将代码编译成LLVM Bitcode。接着在后端(back-end)使用LLVM编译成平台相关的机器语言。</p>
<p>Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右。2014年1月发行的FreeBSD10.0版将Clang/LLVM作为默认编译器。</p>
<p>​    <strong>Clang性能</strong>：测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。</p>
<p>​    <strong>GCC与Clang区别</strong>：</p>
<p>​    <strong>GCC特性</strong>：除支持C/C++/ Objective-C/Objective-C++语言外，还是支持Java/Ada/Fortran/Go等；当前的Clang的C++支持落后于GCC；支持更多平台；更流行，广泛使用，支持完备。</p>
<p>​    <strong>Clang特性</strong>：编译速度快；内存占用小；兼容GCC；设计清晰简单、容易理解，易于扩展增强；基于库的模块化设计，易于IDE集成；出错提示更友好。</p>
<p>​    <strong>Clang采用的license是BSD，而GCC是GPLv3</strong>。</p>
</li>
</ul>
<blockquote>
<p>根据完成任务不同，可以将编译器的组成部分划分为前端（Front End）与后端（Back End）。</p>
<p>前端主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间表示生成。</p>
<p>后端主要指与目标机有关的部分，包括代码优化和目标代码生成等。 </p>
</blockquote>
<h1 id="十进制与二进制的转换"><a href="#十进制与二进制的转换" class="headerlink" title="十进制与二进制的转换"></a>十进制与二进制的转换</h1><p><em>1个字节 = 8个二进制位=2个十六进制位</em></p>
<p><em>因为3个2进制位对应一个8进制值、4个2进制位对应一个16进制值</em></p>
<h2 id="整数转二进制"><a href="#整数转二进制" class="headerlink" title="整数转二进制"></a>整数转二进制</h2><ul>
<li>采用”除2取余，逆序排列”法：</li>
</ul>
<blockquote>
<p>1.首先用2整除一个十进制整数，得到一个商和余数<br>2.然后再用2去除得到的商，又会得到一个商和余数<br>3.重复操作，一直到商为小于1时为止<br>4.然后将得到的所有余数全部排列起来，再将它反过来（逆序排列），切记一定要反过来！</p>
</blockquote>
<ul>
<li>假设我们现在需要将42转为二进制，那我们怎么做呢，如下图所示：</li>
</ul>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.9182578906866533.png" alt="img"></p>
<h2 id="小数转二进制"><a href="#小数转二进制" class="headerlink" title="小数转二进制"></a>小数转二进制</h2><ul>
<li>采用”乘2取整，顺序排列”法：</li>
</ul>
<blockquote>
<p>1.用2乘十进制小数，可以得到积，将积的整数部分取出<br>2.再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出<br>3.重复操作，直到积中的小数部分为零，此时0或1为二进制的最后一位，或者达到所要求的精度为止</p>
</blockquote>
<ul>
<li>例如将0.125转换为二进制：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.125  *  2  =  0.25 ------0</span><br><span class="line"></span><br><span class="line">0.25   *  2  =  0.5   ------0</span><br><span class="line"></span><br><span class="line">0.5  *  2  =  1.0     ------1</span><br><span class="line"></span><br><span class="line">当小数部分为0就可以停止乘2了，然后正序排序就构成了二进制的小数部分：0.001</span><br></pre></td></tr></table></figure>

<ul>
<li>如果小数的整数部分有大于0的整数时，将整数部分和小数部分先单独转为二进制，再合在一起就可以了，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设要将8.125 转换为二进制</span><br><span class="line"></span><br><span class="line">现将8转为二进制：得到1000</span><br><span class="line">再将0.125转为二进制：得到0.001</span><br><span class="line"></span><br><span class="line">合并后为1000.001</span><br></pre></td></tr></table></figure>

<h2 id="二进制转换为十进制"><a href="#二进制转换为十进制" class="headerlink" title="二进制转换为十进制"></a>二进制转换为十进制</h2><p>二进制转为十进制要从右到左用二进制的每个数去乘以2的相应次方，小数点后则是从左往右。</p>
<p>如果首位是0就表示正整数，如果首位是1则表示负整数，正整数可以直接换算，负整数则需要先取反再换算。</p>
<p>因为计算机内部表示数的字节单位是定长的。如8位、16位、32位。所以位数不够时，高位补零。</p>
<ul>
<li>如要想二进制00101010转为十进制，因为以0开头，所以这是正整数，计算如下所示：</li>
</ul>
<blockquote>
<p>（0 * 2的零次方） + （1* 2的一次方）+ （0 * 2 的二次方）+（1 * 2的三次方） +（0 * 2的四次方） +（1* 2的五次方） + （0 * 2的六次方） + （0 * 2的7次方） = 0 + 2 + 0 + 8 + 0 + 32 + 0 + 0 = 42</p>
</blockquote>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.4235766275067019.png" alt="img"></p>
<ul>
<li>如果11101011想转为*<strong>负的十进制</strong>，因为最高位是1，所以先减一取反 00010101，然后计算出00010101对应的十进制为21，所以11101011最终对应的十进制为 -21。</li>
</ul>
<blockquote>
<h1 id="符号位扩展"><a href="#符号位扩展" class="headerlink" title="符号位扩展"></a><strong>符号位扩展</strong></h1></blockquote>
<ul>
<li>众所周知，每种基本数据类型都有一个固定的位数，比如byte占8位，short占16位，int占32位等。正因如此，当把一个低精度的数据类型转成一个高精度的数据类型时，必然会涉及到如何扩展位数的问题。这里有两种解决方案：</li>
<li>（1）补零扩展：填充一定位数的0。</li>
<li>（2）补符号位扩展：填充一定位数的符号位（非负数填充0，负数填充1）。</li>
<li>对于无符号类型（相当于都是非负数）与有符号类型中的非负数部分，这两种方法没有区别，都是填充0；对于有符号类型中的负数部分，这两种方法就会产生差异了，补零扩展会填充0，而补符号位扩展会填充1。下面将byte类型的-127转为int类型为例，探讨一下这两种方法的区别。</li>
<li>首先必须明确一些知识点：</li>
</ul>
<p>计算机是用补码来存储数字的；</p>
<p>正数的补码等于原码；</p>
<p>负数的补码等于反码+1；</p>
<p>一个数的补码的补码等于原码。</p>
<p>127原码1111 1111，反码1000 0000，补码1000 0001。计算机存储的是1000 0001，用十六进制表示为0x81。</p>
<p>当使用补零扩展时，结果为：</p>
<p>0000 0000 0000 0000 0000 0000 1000 0001</p>
<p>用十六进制表示为0x81。为了计算十进制值，计算它的补码，结果为：</p>
<p>0000 0000 0000 0000 0000 0000 1000 0001</p>
<p>将这个二进制数转成十进制的结果是129。</p>
<p>当使用补符号位扩展时，结果为：</p>
<p>1111 1111 1111 1111 1111 1111 1000 0001</p>
<p>用十六进制表示为0xFFFFFF81。为了计算十进制值，计算它的补码，结果为：</p>
<p>1000 0000 0000 0000 0000 0000 0111 1111</p>
<p>将这个二进制数转成十进制的结果是-127。</p>
<p>由此可以得出结论：</p>
<p>（1）使用补零扩展能够保证二进制存储的一致性，但不能保证十进制值不变。</p>
<p>（2）使用补符号位扩展能够保证十进制值不变，但不能保证二进制存储的一致性。</p>
<h2 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h2><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h2 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h2><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h2 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h2><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<h2 id="4-为何要使用原码-反码和补码"><a href="#4-为何要使用原码-反码和补码" class="headerlink" title="4. 为何要使用原码, 反码和补码"></a>4. 为何要使用原码, 反码和补码</h2><p>在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法.</p>
<p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
</blockquote>
<p>所以不需要过多解释. 但是对于负数:</p>
<blockquote>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
</blockquote>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<blockquote>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
</blockquote>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p>
<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><h2 id="一、大端模式和小端模式的起源"><a href="#一、大端模式和小端模式的起源" class="headerlink" title="一、大端模式和小端模式的起源"></a>一、大端模式和小端模式的起源</h2><p>​    关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。然后老百姓对此法令极为反感，期间发生了多次叛乱，其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。据估计，先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。这个其实讽刺当时英国和法国之间持续的冲突。Danny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。</p>
<h2 id="二、什么是大端和小端"><a href="#二、什么是大端和小端" class="headerlink" title="二、什么是大端和小端"></a>二、什么是大端和小端</h2><p>举一个例子，比如数字0x12 34 56 78在内存中的表示形式。</p>
<p><strong>1)大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</strong></p>
<p><strong>（其实<strong><strong>大端模式才是我们直观上认为的模式</strong></strong>，和字符串存储的模式差类似）</strong></p>
<p>低地址 ——————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78</p>
<p>高字节 ——————–&gt; 低字节</p>
<p><strong>2)小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</strong></p>
<p>低地址 ——————–&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12</p>
<p>低字节 ——————–&gt; 高字节</p>
<p><strong>3)下面是两个具体例子：</strong> </p>
<p>16bit宽（两个字节）的数0x1234（两位16进制表示一个字节，表示4位2进制）在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p>
<table>
<thead>
<tr>
<th><strong>内存地址</strong></th>
<th><strong>小端模式存放内容</strong></th>
<th><strong>大端模式存放内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x4000</strong></td>
<td><strong>0x34</strong></td>
<td><strong>0x12</strong></td>
</tr>
<tr>
<td><strong>0x4001</strong></td>
<td><strong>0x12</strong></td>
<td><strong>0x34</strong></td>
</tr>
</tbody></table>
<p>32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p>
<table>
<thead>
<tr>
<th><strong>内存地址</strong></th>
<th><strong>小端模式存放内容</strong></th>
<th><strong>大端模式存放内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x4000</strong></td>
<td><strong>0x78</strong></td>
<td><strong>0x12</strong></td>
</tr>
<tr>
<td><strong>0x4001</strong></td>
<td><strong>0x56</strong></td>
<td><strong>0x34</strong></td>
</tr>
<tr>
<td><strong>0x4002</strong></td>
<td><strong>0x34</strong></td>
<td><strong>0x56</strong></td>
</tr>
<tr>
<td><strong>0x4003</strong></td>
<td><strong>0x12</strong></td>
<td>**0x78 **</td>
</tr>
</tbody></table>
<p> <strong>4)大端小端没有谁优谁劣，各自优势便是对方劣势：</strong></p>
<p>小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。（对高端字节删掉或扩充，所以不需要调整字节内容）<br>大端模式 ：符号位的判定固定为第一个字节，容易判断正负。</p>
<h2 id="三、数组在大端小端情况下的存储："><a href="#三、数组在大端小端情况下的存储：" class="headerlink" title="三、数组在大端小端情况下的存储："></a>三、数组在大端小端情况下的存储：</h2><p>　　以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：<br>　　Big-Endian: 低地址存放高位，如下：<br>高地址<br>    -————–<br>    buf[3] (0x78) – 低位<br>    buf[2] (0x56)<br>    buf[1] (0x34)<br>    buf[0] (0x12) – 高位<br>    -————–<br>低地址</p>
<p>Little-Endian: 低地址存放低位，如下：<br>高地址<br>    -————–<br>    buf[3] (0x12) – 高位<br>    buf[2] (0x34)<br>    buf[1] (0x56)<br>    buf[0] (0x78) – 低位<br>    -————-<br>低地址</p>
<p>所以如果我们要取两个字节的数的12位:</p>
<p>小端模式，取12位，value &amp; 0x0fff（0000 1111 1111 1111），取后12位</p>
<p>如果是大端模式存储，取12位，是不是就要&amp;3ffc，也就是1111 1111 1111 0000，取前12位？</p>
<h2 id="四、为什么会有大小端模式之分呢？"><a href="#四、为什么会有大小端模式之分呢？" class="headerlink" title="四、为什么会有大小端模式之分呢？"></a>四、为什么会有大小端模式之分呢？</h2><p>   这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p>
<blockquote>
<p><em>我们知道计算机正常的内存增长方式是从低到高(当然栈不是)，取数据方式是从基址根据偏移找到他们的位置。</em></p>
<p><em>从大/小端的存储方式可以看出，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。</em></p>
<p><em>而小端存储 第一个字节是它的低位，符号位在最后一个字节，这样在做数值四则运算时，从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效。</em></p>
<p><em>所以大端和小端有其各自的优势。</em></p>
</blockquote>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>前面的大端和小端都是在说计算机自己，也被称作主机字节序HBO(Host Byte Order)。其实，只要自己能够自圆其说是没啥问题的。问题是，网络的出现使得计算机可以通信了。通信，就意味着相处，相处必须得有共同语言啊，得说普通话，要不然就容易会错意，下了一个小时的小电影发现打不开，理解错误了！</p>
<p>但是每种计算机体系都有自己的主机字节序啊，还都不依不饶，坚持做自己，怎么办？</p>
<p>TCP/IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序NBO(Network Byte Order)。</p>
<p>其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化。</p>
<p>为了程序的兼容，你会看到，程序员们每次发送和接受数据都要进行转换，这样做的目的是保证代码在任何计算机上执行时都能达到预期的效果。</p>
<p>这么常用的操作，BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。当然，有了上面的理论基础，也可以编写自己的转换函数。</p>
<blockquote>
<p>网络字节顺序(NBO)<br>NBO(Network Byte Order)：按照从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。TCP/IP中规定好的一种数据表示格式，与具体的 CPU 类型、操作系统等无关。从而保证数据在不同主机之间传输时能够被正确解释。</p>
<p>主机字节顺序(HBO)<br>HBO(Host Byte Order)：不同机器 HBO 不相同，与 CPU 有关。计算机存储数据有两种字节优先顺序：Big Endian 和 Little Endian。Internet 以 Big Endian 顺序在网络上传输，所以对于在内部是以 Little Endian 方式存储数据的机器，在网络通信时就需要进行转换。</p>
<p>除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
</blockquote>
<h2 id="五、如何判断机器的字节序"><a href="#五、如何判断机器的字节序" class="headerlink" title="五、如何判断机器的字节序"></a>五、如何判断机器的字节序</h2><p>可以编写一个小的测试程序来判断机器的字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsBigEndian</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;  </span><br><span class="line">    <span class="keyword">char</span> b =  *(<span class="keyword">char</span> *)&amp;a;  <span class="comment">//通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分  </span></span><br><span class="line">    <span class="keyword">if</span>( b == <span class="number">0x12</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> FALSE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsBigEndian</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">NUM</span>  </span></span><br><span class="line"><span class="class">    &#123;</span>  </span><br><span class="line">        <span class="keyword">int</span> a;  </span><br><span class="line">        <span class="keyword">char</span> b;  </span><br><span class="line">    &#125;num;  </span><br><span class="line">    num.a = <span class="number">0x1234</span>;  </span><br><span class="line">    <span class="keyword">if</span>( num.b == <span class="number">0x12</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> FALSE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、常见的字节序"><a href="#六、常见的字节序" class="headerlink" title="六、常见的字节序"></a>六、常见的字节序</h2><p>一般操作系统都是小端，而通讯协议是大端的。</p>
<h6 id="4-1-常见CPU的字节序"><a href="#4-1-常见CPU的字节序" class="headerlink" title="4.1 常见CPU的字节序"></a>4.1 常见CPU的字节序</h6><p>Big Endian : PowerPC、IBM、Sun<br>Little Endian : x86、DEC<br>ARM既可以工作在大端模式，也可以工作在小端模式。</p>
<h6 id="4-2-常见文件的字节序"><a href="#4-2-常见文件的字节序" class="headerlink" title="4.2 常见文件的字节序"></a>4.2 常见文件的字节序</h6><p>Adobe PS – Big Endian<br>BMP – Little Endian<br>DXF(AutoCAD) – Variable<br>GIF – Little Endian<br>JPEG – Big Endian<br>MacPaint – Big Endian<br>RTF – Little Endian</p>
<p>另外，Java和所有的网络通讯协议都是使用Big-Endian的编码。</p>
<h2 id="七、如何进行转换"><a href="#七、如何进行转换" class="headerlink" title="七、如何进行转换"></a>七、如何进行转换</h2><p>对于字数据（16位）：（程序中的“\”表示当前行和下一行是同一行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define BigtoLittle16(A)   (( ((uint16)(A) &amp; 0xff00) &gt;&gt; 8)    | \  </span><br><span class="line">                                       (( (uint16)(A) &amp; 0x00ff) &lt;&lt; 8))  </span><br></pre></td></tr></table></figure>

<p>对于双字数据（32位）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define BigtoLittle32(A)   ((( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \  </span><br><span class="line">                                       (( (uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8)   | \  </span><br><span class="line">                                       (( (uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8)   | \  </span><br><span class="line">                                       (( (uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))  </span><br></pre></td></tr></table></figure>

<h2 id="八、从软件的角度理解端模式"><a href="#八、从软件的角度理解端模式" class="headerlink" title="八、从软件的角度理解端模式"></a>八、从软件的角度理解端模式</h2><p>​    从软件的角度上，不同端模式的处理器进行数据传递时必须要考虑端模式的不同。如进行网络数据传递时，必须要考虑端模式的转换。在Socket接口编程中，以下几个函数用于大小端字节序的转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换  </span><br><span class="line">#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换  </span><br><span class="line">#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换  </span><br><span class="line">#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  </span><br></pre></td></tr></table></figure>

<p>其中互联网使用的网络字节顺序采用大端模式进行编址，而主机字节顺序根据处理器的不同而不同，如PowerPC处理器使用大端模式，而Pentuim处理器使用小端模式。<br>    大端模式处理器的字节序到网络字节序不需要转换，此时ntohs(n)=n，ntohl = n；而小端模式处理器的字节序到网络字节必须要进行转换，此时ntohs(n) = __swab16(n)，ntohl = __swab32(n)。__swab16与__swab32函数定义如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___swab16(x)  </span></span><br><span class="line">&#123;  </span><br><span class="line">            __u16 __x = (x);  </span><br><span class="line">            ((__u16)(  </span><br><span class="line">                        (((__u16)(__x) &amp; (__u16)<span class="number">0x00ff</span>U) &lt;&lt; <span class="number">8</span>) |  </span><br><span class="line">                        (((__u16)(__x) &amp; (__u16)<span class="number">0xff00</span>U) &gt;&gt; <span class="number">8</span>) ));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___swab32(x)  </span></span><br><span class="line">&#123;  </span><br><span class="line">            __u32 __x = (x);  </span><br><span class="line">            ((__u32)(  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0x000000ff</span>UL) &lt;&lt; <span class="number">24</span>) |  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0x0000ff00</span>UL) &lt;&lt; <span class="number">8</span>) |  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0x00ff0000</span>UL) &gt;&gt; <span class="number">8</span>) |  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0xff000000</span>UL) &gt;&gt; <span class="number">24</span>) ));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> PowerPC处理器提供了lwbrx，lhbrx，stwbrx，sthbrx四条指令用于处理字节序的转换以优化__swab16和__swap32这类函数。此外PowerPC处理器中的rlwimi指令也可以用来实现__swab16和__swap32这类函数。</p>
<p>​    在对普通文件进行处理也需要考虑端模式问题。在大端模式的处理器下对文件的32，16位读写操作所得到的结果与小端模式的处理器不同。单纯从软件的角度理解上远远不能真正理解大小端模式的区别。事实上，真正的理解大小端模式的区别，必须要从系统的角度，从指令集，寄存器和数据总线上深入理解，大小端模式的区别。</p>
<h2 id="九、从系统的角度理解端模式"><a href="#九、从系统的角度理解端模式" class="headerlink" title="九、从系统的角度理解端模式"></a>九、从系统的角度理解端模式</h2><p>先补充两个关键词，MSB和LSB：<br>    MSB:MoST Significant Bit ——- 最高有效位<br>    LSB:Least Significant Bit ——- 最低有效位</p>
<p>​    处理器在硬件上由于端模式问题在设计中有所不同。从系统的角度上看，端模式问题对软件和硬件的设计带来了不同的影响，当一个处理器系统中大小端模式同时存在时，必须要对这些不同端模式的访问进行特殊的处理。<br>​    PowerPC处理器主导网络市场，可以说绝大多数的通信设备都使用PowerPC处理器进行协议处理和其他控制信息的处理，这也可能也是在网络上的绝大多数协议都采用大端编址方式的原因。因此在有关网络协议的软件设计中，使用小端方式的处理器需要在软件中处理端模式的转变。而Pentium主导个人机市场，因此多数用于个人机的外设都采用小端模式，包括一些在网络设备中使用的PCI总线，Flash等设备，这也要求在硬件设计中注意端模式的转换。<br>​    本文提到的小端外设是指这种外设中的寄存器以小端方式进行存储，如PCI设备的配置空间，NOR FLASH中的寄存器等等。对于有些设备，如DDR颗粒，没有以小端方式存储的寄存器，因此从逻辑上讲并不需要对端模式进行转换。在设计中，只需要将双方数据总线进行一一对应的互连，而不需要进行数据总线的转换。<br>​    如果从实际应用的角度说，采用小端模式的处理器需要在软件中处理端模式的转换，因为采用小端模式的处理器在与小端外设互连时，不需要任何转换。而采用大端模式的处理器需要在硬件设计时处理端模式的转换。大端模式处理器需要在寄存器，指令集，数据总线及数据总线与小端外设的连接等等多个方面进行处理，以解决与小端外设连接时的端模式转换问题。在寄存器和数据总线的位序定义上，基于大小端模式的处理器有所不同。<br>​    一个采用大端模式的32位处理器，如基于E500内核的MPC8541，将其寄存器的最高位msb（most significant bit）定义为0，最低位lsb（lease significant bit）定义为31；而小端模式的32位处理器，将其寄存器的最高位定义为31，低位地址定义为0。与此向对应，采用大端模式的32位处理器数据总线的最高位为0，最高位为31；采用小端模式的32位处理器的数据总线的最高位为31，最低位为0。<br>​    大小端模式处理器外部总线的位序也遵循着同样的规律，根据所采用的数据总线是32位，16位和8位，大小端处理器外部总线的位序有所不同。大端模式下32位数据总线的msb是第0位，MSB是数据总线的第0<del>7的字段；而lsb是第31位，LSB是第24</del>31字段。小端模式下32位总线的msb是第31位，MSB是数据总线的第31<del>24位，lsb是第0位，LSB是7</del>0字段。大端模式下16位数据总线的msb是第0位，MSB是数据总线的第0<del>7的字段；而lsb是第15位，LSB是第8</del>15字段。小端模式下16位总线的msb是第15位，MSB是数据总线的第15<del>7位，lsb是第0位，LSB是7</del>0字段。大端模式下8位数据总线的msb是第0位，MSB是数据总线的第0<del>7的字段；而lsb是第7位，LSB是第0</del>7字段。小端模式下8位总线的msb是第7位，MSB是数据总线的第7<del>0位，lsb是第0位，LSB是7</del>0字段。<br>​     由上分析，我们可以得知对于8位，16位和32位宽度的数据总线，采用大端模式时数据总线的msb和MSB的位置都不会发生变化，而采用小端模式时数据总线的lsb和LSB位置也不会发生变化。<br>​     为此，大端模式的处理器对8位，16位和32位的内存访问（包括外设的访问）一般都包含第0<del>7字段，即MSB。小端模式的处理器对8位，16位和32位的内存访问都包含第7</del>0位，小端方式的第7~0字段，即LSB。由于大小端处理器的数据总线其8位，16位和32位宽度的数据总线的定义不同，因此需要分别进行讨论在系统级别上如何处理端模式转换。在一个大端处理器系统中，需要处理大端处理器对小端外设的访问。</p>
<h2 id="十、实际中的例子"><a href="#十、实际中的例子" class="headerlink" title="十、实际中的例子"></a>十、实际中的例子</h2><p>​    虽然很多时候，字节序的工作已由编译器完成了，但是在一些小的细节上，仍然需要去仔细揣摩考虑，尤其是在以太网通讯、MODBUS通讯、软件移植性方面。这里，举一个MODBUS通讯的例子。在MODBUS中，数据需要组织成数据报文，该报文中的数据都是大端模式，即低地址存高位，高地址存低位。假设有一16位缓冲区m_RegMW[256]，因为是在x86平台上，所以内存中的数据为小端模式：m_RegMW[0].low、m_RegMW[0].high、m_RegMW[1].low、m_RegMW[1].high……<br>为了方便讨论，假设m_RegMW[0] = 0x3456; 在内存中为0x56、0x34。<br>​    现要将该数据发出，如果不进行数据转换直接发送，此时发送的数据为0x56,0x34。而Modbus是大端的，会将该数据解释为0x5634而非原数据0x3456，此时就会发生灾难性的错误。所以，在此之前，需要将小端数据转换成大端的，即进行高字节和低字节的交换，此时可以调用步骤五中的函数BigtoLittle16(m_RegMW[0])，之后再进行发送才可以得到正确的数据。</p>
<h2 id="十一、附float和long类型的大小端转换"><a href="#十一、附float和long类型的大小端转换" class="headerlink" title="十一、附float和long类型的大小端转换"></a>十一、附float和long类型的大小端转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">函数名:        BLEndianFloat2</span></span><br><span class="line"><span class="comment">函数描述:    float类型数据，小端转大端</span></span><br><span class="line"><span class="comment">输入参数:    小端float</span></span><br><span class="line"><span class="comment">输出参数:    大端float</span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment">***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">BLEndianFloat2</span><span class="params">(<span class="keyword">float</span> fValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>        s[<span class="number">4</span>], t[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">float</span>                fResult;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(s, &amp;fValue, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">    </span><br><span class="line">    t[<span class="number">0</span>] = s[<span class="number">3</span>];</span><br><span class="line">    t[<span class="number">1</span>] = s[<span class="number">2</span>];</span><br><span class="line">    t[<span class="number">2</span>] = s[<span class="number">1</span>];</span><br><span class="line">    t[<span class="number">3</span>] = s[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fResult, t, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">函数名:        Customhtonll</span></span><br><span class="line"><span class="comment">函数描述:    long long类型数据，小端转大端</span></span><br><span class="line"><span class="comment">输入参数:    小端long long</span></span><br><span class="line"><span class="comment">输出参数:    大端long long</span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment">***************************************************/</span></span><br><span class="line"><span class="function">UINT64 <span class="title">Customhtonll</span><span class="params">(UINT64 fValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>        s[<span class="number">8</span>], t[<span class="number">8</span>];</span><br><span class="line">    UINT64                fResult;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(s, &amp;fValue, <span class="built_in"><span class="keyword">sizeof</span></span>(UINT64));</span><br><span class="line"></span><br><span class="line">    t[<span class="number">0</span>] = s[<span class="number">7</span>];</span><br><span class="line">    t[<span class="number">1</span>] = s[<span class="number">6</span>];</span><br><span class="line">    t[<span class="number">2</span>] = s[<span class="number">5</span>];</span><br><span class="line">    t[<span class="number">3</span>] = s[<span class="number">4</span>];</span><br><span class="line">    t[<span class="number">4</span>] = s[<span class="number">3</span>];</span><br><span class="line">    t[<span class="number">5</span>] = s[<span class="number">2</span>];</span><br><span class="line">    t[<span class="number">6</span>] = s[<span class="number">1</span>];</span><br><span class="line">    t[<span class="number">7</span>] = s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fResult, t, <span class="built_in"><span class="keyword">sizeof</span></span>(UINT64));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>IP（Internet Protocol Address）地址由网络号+主机号构成，网络号相当于电话区号，主机号相当于电话号码，Ipv4分为A、B、C、D、E五类地址，任何一个Ipv4的IP地址由共由32位二进制数构成，每段8位，共4段，点分式IP地址十进制的表示为a.b.c.d格式。</p>
<p>A类IP地址由1字节（每个字节是8位）的网络号和3个字节主机号组成，A类地址范围是(1.0.0.0至127.255.255.254,至于为什么请继续往下看，A类网络号前1位从0开始，A类IP的地址第一个字段范围是（00000000<del>011111111）0</del>127，但是由于全0和全1的地址用作特殊用途，实际可指派的第一个字段范围是1~126。（0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。127.0.0.1属于{127}集合中的一个，而所有网络号为127的地址都被称之为回环地址，所以回环地址！=127.0.0.1,它们是包含关系，即回环地址包含127.0.0.1 。</p>
<p>B类IP地址由2字节（每个字节是8位）的网络号和2个字节主机号组成，B类网络号从前2位10开始，B类IP的地址第一个字段范围是（10000000<del>101111111）128</del>191, B类地址范围：128.0.0.0到191.255.255.255。</p>
<p>C类IP地址由3字节（每个字节是8位）的网络号和1个字节主机号组成，C类网络号前3位从110开始，所以C类IP地址的的一个字段范围是：（11000000<del>11011111）192</del>223， C类地址范围：192.0.0.0到223.255.255.255。</p>
<p>D类IP地址不分网络号和主机号，D类网络号前4位从1110开始，所以D类IP地址的的一个字段范围是：（11100000<del>11101111）224</del>239，D类地址范围是224.0.0.0至239.255.255.255。</p>
<p>E类IP地址不分网络号和主机号，E类网络号前5位从11110开始，所以E类IP地址的的一个字段范围是：（11110000<del>11110111）240</del>247，E类地址范围是240.0.0.0至247.255.255.255。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.4547502593382962.png" alt="img">IP地址分类</p>
<p>子网掩码：子网掩码又叫网络掩码，是一个32位地址，用于屏蔽IP地址的一部分以区别网络号和主机标号，子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。</p>
<p>网络地址：IP地址和子网掩码进行与运算，将运算结果中的网络地址不变，主机地址变为0，即主机号全0是网络地址。示例: 如果是192的C段地址，那么网络地址就是：192.168.1.0，地址掩码是：255.255.255.0；如果地址掩码是：255.255.0.0，那么网络地址就是：192.168.0.0；网络地址很大一部分是由地址掩码决定的。</p>
<p><em><strong>广播地址：将运算结果中的网络地址不变，主机地址变为1，结果就是广播地址。</strong></em></p>
<p>1、　192.168.1.53/27需要计算具体的子网掩码、子网数、可用的主机数、最大可容纳主机数、网络地址、广播地址。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.9771714244178368.png" alt="img">结果</p>
<p>注意:在计算网络中的主机数量时，应当比2^x（x指用于标识主机号的位数,8 16 32 ）少2。原来主机号部分全为0或1（指二进制）的IP地址，只能用于网络内的广播，即利用该地址将该信息传送至网络内的每一台主机，因此是不能分配给某个特定的主机使用的。所以在实际每个网络中所容纳的主机必然是“2x-2”台。</p>
<p>来源： <a href="https://baijiahao.baidu.com/s?id=1618548971082312617&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1618548971082312617&amp;wfr=spider&amp;for=pc</a></p>
<p>2、继续以　192.168.1.53/27　为例讲解</p>
<p>我们需要了解正常C网的网络号及位数是多少？</p>
<p>平时大家用的是192.168.0.*或192.168.1.*网段，子网掩码是255.255.255.0</p>
<p>那么子网掩码10进制转换到2进制就是：</p>
<p>11111111.11111111.11111111.00000000</p>
<p>前面24位表示网络号，后面8位表示主机数，具体的各参数容量可以参考步骤1.</p>
<p>所以192.168.1.53/27 的相应掩码是</p>
<p>11111111.11111111.11111111.11100000</p>
<p>由于网络号数量不足，所以得向右的主机数借位，主机数的可用数量减少。</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/b21c8701a18b87d62d91611a0b0828381e30fde0"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.08722543690292633.png" alt="img"></a></p>
<p>3、由步骤2，我们得知192.168.1.53/27 的相应掩码是</p>
<p>11111111.11111111.11111111.11100000</p>
<p>所有可用的主机数为主机号所剩下的5位掩码中算出。</p>
<p>注：8位主机号减少网络号借去的3位，所剩下5位。即n=8-m=5</p>
<p>其中m为网络号位数，n为主机号位数。</p>
<p>即最多可以容纳的主机数为　32　</p>
<p>可用的主机数为　　　　　　30　　　</p>
<p>计算公式如下图所示：　</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/4d086e061d950a7b159e85c106d162d9f2d3c908"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.4027877775547382.png" alt="img"></a></p>
<p>4、我们已经算出192.168.1.53/27 ，每个网段最大容纳的主机数和可以主机数了，下面我们来计算子网掩码的10进制数是多少。</p>
<p>由步骤2，我们得知192.168.1.53/27 的相应掩码是</p>
<p>11111111.11111111.11111111.11100000</p>
<p>即转换成相应的10进制数是255.255.255.224</p>
<p>转换公式如下图：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/ac6eddc451da81cbf67348c85e66d0160924311a"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.8880934507151076.png" alt="img"></a></p>
<p>5、我们也计算出了192.168.1.53/27的掩码是255.255.255.224了</p>
<p>子网数是8个。</p>
<p>现在我们来算算并找出网络地址和广播地址。</p>
<p>其中网络地址是192.168.1.32</p>
<p>广播地址是192.168.1.63</p>
<p>如下图：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/9f2f070828381f30e746b8afa5014c086e06f05c"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.33273960839110994.png" alt="img"></a></p>
<p><a href="https://iknow-pic.cdn.bcebos.com/e4dde71190ef76c6d8d7ce2d9116fdfaaf5167aa"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.947406924669754.png" alt="img"></a></p>
<p>6、总结　步骤1的要求，通过计算。各参数如下图所示：</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/3b292df5e0fe992530915d5638a85edf8db17112"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.1071117507652827.png" alt="img"></a></p>
<p>来源： <a href="https://zhidao.baidu.com/question/1116507203928197699.html">https://zhidao.baidu.com/question/1116507203928197699.html</a></p>
<p>多播的地址是特定的，D类地址用于多播。D类IP地址就是多播IP地址，即224.0.0.0至239.255.255.255之间的IP地址，并被划分为局部连接多播地址、预留多播地址和管理权限多播地址3类：</p>
<p>　　1、局部多播地址：在224.0.0.0～224.0.0.255之间，这是为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包。</p>
<p>　　2、预留多播地址：在224.0.1.0～238.255.255.255之间，可用于全球范围（如Internet）或网络协议。</p>
<p>　　3、管理权限多播地址：在239.0.0.0～239.255.255.255之间，可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围。</p>
<p>来源： <a href="https://www.cnblogs.com/lidabo/p/5865045.html">https://www.cnblogs.com/lidabo/p/5865045.html</a></p>
<h1 id="帧数和显示屏刷新率"><a href="#帧数和显示屏刷新率" class="headerlink" title="帧数和显示屏刷新率"></a>帧数和显示屏刷新率</h1><p>显示屏刷新率是固定的，而帧数生成是不固定的，显示屏刷新永远获取最新的一帧，所以说，60hz的显示器，如果帧数高的话，帧生成短，会降低延迟，而感到更流畅一些。而144hz的显示器刷新要比60hz要快很多，配合高帧数能看到更多？</p>
<p>帧数就是在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）表示。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象。高的帧率可以得到更流畅、更逼真的动画。每秒钟帧数 (fps)高，所显示的动作就会愈流畅。</p>
<p>显示器刷新率：显卡所渲染出来的画面与我们直接的视觉感官之间，需要用显示器来进行传递，所以显示器刷新率对我们的视觉体验有很大影响。显示器刷新率就是指每秒刷新画面的次数，也就是频率，单位是Hz。现在我们所用的液晶显示器，一般都是60Hz的刷新率，也有更高的适用于电竞游戏的85Hz、144Hz甚至是240Hz。</p>
<h2 id="帧数和刷新率的关系"><a href="#帧数和刷新率的关系" class="headerlink" title="帧数和刷新率的关系"></a>帧数和刷新率的关系</h2><p>电脑每显示一张画面是分两个步骤完成的，第一步是CPU和显卡把所要显示的画面数据计算出来，第二步是示器把这些数据写入到屏幕上去。这两步都是需要时间的，并且两个过程可以同时完成（因为具体实现这两个过程的硬件是相对独立的）。 但是这两个过程所花费的时间并不是相同的。显卡每秒能计算出的画面数量是根据硬件性能决定的，而显示器的每秒刷新频率是固定的。比如一个60Hz的显示器，每过16.67ms（毫秒）就会刷新一次。所以这时就产生了一个问题，显卡输出画面的数量低于或者高于显示器刷新率会怎么样呢？这就引出了另一个概念：垂直同步。</p>
<blockquote>
<p>垂直同步是做什么的？</p>
</blockquote>
<p>如果我们开启垂直同步，显卡绘制3D图形前会等待垂直同步信号，当该信号到达时，显卡开始绘制3D图形，如果显卡性能较为强劲，在下个垂直同步信号到来之前已经完成了对该帧的渲染，显卡就会暂停处理，等下个垂直同步信号到来后才开始渲染下一帧。通俗的来讲，垂直同步就是让显卡每秒输出的帧数等于显示器的刷新率。垂直同步是用来防止画面撕裂的，反之，关闭垂直同步就会出现撕裂、跳帧的情况。<br>下面来说一下上面提出的问题。垂直同步会把显卡帧率锁定为预期的显示器刷新率（通常是60Hz），当我们显卡输出的帧数高于显示器刷新率时，会有一部分的帧数不会呈现在显示器上，也就是会有浪费帧的情况。如果我们的显卡功能不够每秒渲染60幅画面的能力，垂直同步功能会把显卡帧率下调到能整除60的数字，可能是30或者更低，这时也就没有再开启垂直同步的必要了。<br>其实显示器刷新的时候，并非是整个屏幕同时进行，而是从最上面的一行像素开始，逐行向下刷新，所以从顶端到最底部是有时间差的，虽然这个时间很短，但是在高速运动的游戏当中，就会被放大并且被我们感知到，特别是在帧数高于刷新率的时候尤为明显。所以就会出现当显示靠上部分开始显示下一帧时，靠下的部分还停留在上一帧的图像，也就是画面撕裂。所以这时需要垂直同步技术，也就是等到整个画面在垂直方向上完全刷新完成，电脑才会渲染下一帧的图像，以保证每幅画面都能完整的显示出来。<br>怎么避免撕裂感？ 从上面的解释来看，开启垂直同步可以让我们从视觉上有更为流畅的体验，所以是不是开启了垂直同步就会更好呢？这个问题很难回答，就要因人而异了，每个人的电脑与显示器性能不同，感知能力和所处的环境也不尽相同，当你感觉画面裂的没法看时，可能别人并不觉得，所以当我们不觉得画面有撕裂感时，就可以不用打开垂直同步。<br>即使垂直同步的概念不是所有人都有深入的了解，但是在大家平时进行游戏时，或多或少都会从网上看到一些信息，或是听朋友建议不要打开垂直同步。虽说垂直同步能在一定程度上减轻画面撕裂，但会给我们操作上带来延迟，在FPS类的竞技游戏中，这种现象尤为明显。所以很少人会去开启这项功能。<br>如果我们想要去追求更高的帧数和刷新率的话，在选择更好的显卡和高刷新率的显示器同时，还要注意选择支持G-Sync和Free-Sync功能的显示器。<br>其实如果我们很少去玩FPS竞技类游戏，60Hz的显示器是完全足够我们使用的，若想要追求极致的画面，可以选择2K甚至4K的设备。</p>
<h2 id="垂直同步介绍"><a href="#垂直同步介绍" class="headerlink" title="垂直同步介绍"></a>垂直同步介绍</h2><p>要理解垂直同步技术，首先要理解两个概念：「逐行扫描」和「缓冲」。</p>
<p>「逐行扫描」就是说，显示器显示画面并不是“蹭”一下就打出一张画面来，而是从上到下一行一行显示出来的，只不过是显示得比较快所以肉眼看不出来而已。</p>
<p>「缓冲」则是指显卡渲染好一张画面之后，就会把这张画面储存在显存中，然后去渲染下一张画面。如果显卡每秒钟可以产生 120 张画面会发生什么呢？结果就是每 1/120 秒就会有一张画面进入缓冲中，下一个 1/120 秒，下一张画面就会把上一张给取代掉。</p>
<p>目前还有很多显示器刷新率是 60Hz，也就是每秒钟要显示 60 张画面，也就是每 1/60 秒要显示一张画面。所以显示器会每隔 1/60 秒从显存中提取一次画面。</p>
<p>那么问题来了，如果显卡每秒产生 120 张画面，而显示器每秒只读取 60 张，这会出现什么问题呢？</p>
<p>显示器提取画面的时候会从上到下一行一行（逐行扫描）把画面显示出来，本来要 1/60 秒才能显示完，然而显示了一半（1/120 秒）下一张画面就塞进来了。这时候显示器并不会停止工作，而是囫囵吞枣地把上一张画面的一半与下一张画面都显示出来。</p>
<p>由于两张画面不一样，结果就是上面半截是第一张画面，下面半截是第二张画面，也就是所谓的****画面撕裂****。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/wps1.png" alt="img"> </p>
<p>怎么解决呢？打开垂直同步。</p>
<p>垂直同步打开后，显卡的渲染速度强制锁定在最高每秒 60 张画面，这样显示器每次读取的时候都可以顺利读完。</p>
<p>然而打开垂直同步又会引发一个问题。如果一个跑步健将博尔特第 0 秒在起跑线上，第 1/60 秒就跑到了终点，那每秒渲染 60 张画面就完全看不到他中间的跑步过程！一开始就直接跑完。这就是所谓的****「卡顿」****，画面并不连贯。</p>
<p>于是你会发现不少游戏下面还有一个****「双重缓冲」****的开关，也就是多开设一个缓冲区。显卡依旧每秒渲染 120 张画面，第一张存在缓冲区1，第二张存在缓冲区2。显示器来读取画面的时候按顺序先从缓冲区 1 那里读完，再从缓冲区 2 那里读。这样就不会撕裂也不会卡顿了啊~</p>
<p>然而这又出现一个问题。本来博尔特 1/60 秒就把比赛跑完了，显卡也把中间过程给渲染出来了，双重缓冲打开了之后，显示器从缓冲区 1 中读取第 0 秒的画面，再从缓冲区 2 中读取第 1/120 秒的画面，再又回到缓冲区 1 中读取第 1/60 秒一共三张画面。显示器每 1/60 秒读取一张，所以一共用时 3/60 秒。</p>
<p>结果就是博尔牛寺活生生花了 3/60 秒才跑完，这就是所谓的****「画面延迟」****。</p>
<p>总而言之，如果你的显卡渲染速度达不到每秒 60 张，画面就不流畅；超过了每秒 60 张，又面临撕裂、卡顿和延迟的问题。只有显卡渲染速度超过每秒 60 张，显示器刷新率也高于 60 Hz，而显卡渲染速度又低于显示器刷新率的时候，以上的问题才能彻底解决。</p>
<h1 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h1><h2 id="1、TGA格式"><a href="#1、TGA格式" class="headerlink" title="1、TGA格式"></a>1、TGA格式</h2><p>TGA图像格式最大的特点是可以做出不规则形状的图形、图像文件，一般图形、图像文件都为四方形，若需要有圆形、菱形甚至是缕空的图像文件时，TGA可就派上用场了! TGA格式支持压缩，使用不失真的压缩算法。是一种比较好的图片格式。</p>
<h2 id="2、WMF格式"><a href="#2、WMF格式" class="headerlink" title="2、WMF格式"></a>2、WMF格式</h2><p>WMF（Windows Metafile Format）是Windows中常见的一种图元文件格式，属于矢量文件格式。它具有文件短小、图案造型化的特点，整个图形常由各个独立的组成部分拼接而成，其图形往往较粗糙。</p>
<h2 id="3、BMP格式"><a href="#3、BMP格式" class="headerlink" title="3、BMP格式"></a>3、BMP格式</h2><p><a href="https://www.baidu.com/s?wd=BMP%E6%A0%BC%E5%BC%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">BMP格式</a>是一种与硬件设备无关的图像文件格式，使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/6609c93d70cf3bc726c500f8de00baa1cc112ad9"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.40985815401599873.png" alt="img"></a></p>
<p>由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准，因此在Windows环境中运行的图形图像软件都支持BMP图像格式。</p>
<h2 id="4、TIF格式"><a href="#4、TIF格式" class="headerlink" title="4、TIF格式"></a>4、TIF格式</h2><p> <a href="https://www.baidu.com/s?wd=TIFF%E6%A0%BC%E5%BC%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">TIFF格式</a>灵活易变，它又定义了四类不同的格式：TIFF-B适用于二值图像：TIFF-G适用于黑白灰度图像；TIFF-P适用于带调色板的彩色图像：TIFF-R适用于RGB真彩图像。</p>
<p>TIFF支持多种编码方法，其中包括RGB压缩、RLE压缩、JPEG压缩等。</p>
<p>TIFF是现存图像文件格式中最复杂的一种，它具有扩展性、方便性、可改性，可以提供给IBMPC等环境中运行、图像编辑程序。</p>
<h2 id="5、GIF格式"><a href="#5、GIF格式" class="headerlink" title="5、GIF格式"></a>5、GIF格式</h2><p>是一种基于LZW算法的连续色调的无损压缩格式。其压缩率一般在50%左右，它不属于任何应用程序。几乎所有相关软件都支持它，公共领域有大量的软件在使用GIF图像文件。</p>
<p>GIF图像文件的数据是经过压缩的，而且是采用了可变长度等压缩算法。所以GIF的图像深度从lbit到8bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p>
<h2 id="6、JPEG格式"><a href="#6、JPEG格式" class="headerlink" title="6、JPEG格式"></a>6、JPEG格式</h2><p>JPEG格式是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。</p>
<p>但是JPEG压缩技术十分先进，它用有损压缩方式去除冗余的图像数据，在获得极高的压缩率的同时能展现十分丰富生动的图像，换句话说，就是可以用最少的磁盘空间得到较好的图像品质。</p>
<h2 id="7、PSD格式"><a href="#7、PSD格式" class="headerlink" title="7、PSD格式"></a>7、PSD格式</h2><p>这是Photoshop图像处理软件的专用文件格式，文件扩展名是．psd，可以支持图层、通道、蒙板和不同色彩模式的各种图像特征，是一种非压缩的原始文件保存格式。</p>
<p>扫描仪不能直接生成该种格式的文件。PSD文件有时容量会很大，但由于可以保留所有原始信息，在图像处理中对于尚未制作完成的图像，选用 PSD格式保存是最佳的选择。</p>
<h2 id="8、PNG小透明"><a href="#8、PNG小透明" class="headerlink" title="8、PNG小透明"></a>8、PNG小透明</h2><p>“可移植网络图形格式“，是图像文件存储格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。对于图片本身质量的减损非常低。因其能够支持压缩不失真、透明背景、渐变图像的制作要求，PNG格式也是各大制图软件例如PS、InDesign输出或编辑的原始格式。PNG文件非常适合在互联网上使用。但它也不足以用作专业印刷。优点：能够相容半透明 / 透明图像，缺点：档案比 JPEG 大，不能用于印刷PNG</p>
<h1 id="经纬度"><a href="#经纬度" class="headerlink" title="经纬度"></a>经纬度</h1><p>度(DDD)：E 108.90593度  N 34.21630度</p>
<p>  如何将度(DDD):： 108.90593度换算成度分秒(DMS)东经E 108度54分22.2秒?转换方法是将108.90593整数位不变取108(度),用0.90593<em>60=54.3558,取整数位54(分),0.3558</em>60=21.348再取整数位21(秒),故转化为108度54分21秒.</p>
<p>  同样将度分秒(DMS):东经E 108度54分22.2秒 换算成度(DDD)的方法如下:108度54分22.2秒=108+(54/60)+(22.2/3600)=108.90616度</p>
<p>因为计算时小数位保留的原因，导致正反计算存在一定误差，但误差影响不是很大。1秒的误差就是几米的样子。</p>
<p>经纬度换算成米</p>
<p>纬度分为60分，每一分再分为60秒以及秒的小数。</p>
<p>纬度线投射在图上看似水平的平行线，但实际上是不同半径的圆。有相同特定纬度的所有位置都在同一个纬线上。<br>赤道的纬度为0°，将行星平分为南半球和北半球。<br>纬度是指某点与地球球心的连线和地球赤道面所成的线面角，其数值在0至90度之间。位于赤道以北的点的纬度叫北纬，记为N，位于赤道以南的点的纬度称南纬，记为S。<br>纬度数值在0至30度之间的地区称为低纬地区，纬度数值在30至60度之间的地区称为中纬地区，纬度数值在60至90度之间的地区称为高纬地区。<br>赤道、南回归线、北回归线、南极圈和北极圈是特殊的纬线。<br>纬度1秒的长度<br>地球的子午线总长度大约40008km。平均：<br>纬度1度 = 大约111km<br>纬度1分 = 大约1.85km<br>纬度1秒 = 大约30.9m </p>
<p>所以：经度120.00001，精确的距离计算方式是：先进0.00001<em>111</em>1000=1.11m。</p>
<p>来源： <a href="https://www.cnblogs.com/ggz19/p/7551088.html">https://www.cnblogs.com/ggz19/p/7551088.html</a></p>
<p>计算经纬度之间的距离与夹角</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EARTH_RADIUS 6378.137</span></span><br><span class="line"><span class="comment">//两点的距离（纬度，经度）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_distance</span><span class="params">(<span class="keyword">double</span> lat1, <span class="keyword">double</span> lng1, <span class="keyword">double</span> lat2, <span class="keyword">double</span> lng2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radLat1 = lat1 * PI / <span class="number">180.0</span>;   <span class="comment">//角度1? = π / 180</span></span><br><span class="line">    <span class="keyword">double</span> radLat2 = lat2 * PI / <span class="number">180.0</span>;   <span class="comment">//角度1? = π / 180</span></span><br><span class="line">    <span class="keyword">double</span> a = radLat1 - radLat2;<span class="comment">//纬度之差</span></span><br><span class="line">    <span class="keyword">double</span> b = lng1 * PI / <span class="number">180.0</span> - lng2* PI / <span class="number">180.0</span>;  <span class="comment">//经度之差</span></span><br><span class="line">    <span class="keyword">double</span> dst = <span class="number">2</span> * <span class="built_in">asin</span>((<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">sin</span>(a / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">cos</span>(radLat1) * <span class="built_in">cos</span>(radLat2) * <span class="built_in">pow</span>(<span class="built_in">sin</span>(b / <span class="number">2</span>), <span class="number">2</span>))));</span><br><span class="line">    dst = dst * EARTH_RADIUS;</span><br><span class="line">    dst = <span class="built_in">round</span>(dst * <span class="number">10000</span>) / <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算角度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_angle</span><span class="params">(<span class="keyword">double</span> lat1, <span class="keyword">double</span> lng1, <span class="keyword">double</span> lat2, <span class="keyword">double</span> lng2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = lat1 - lat2;<span class="comment">//t d</span></span><br><span class="line">    <span class="keyword">double</span> y = lng1 - lng2;<span class="comment">//z y</span></span><br><span class="line">    <span class="keyword">int</span> angle = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span>) angle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span>) angle = <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="number">270</span>;</span><br><span class="line">    <span class="keyword">if</span> (angle == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dislat = <span class="built_in">get_distance</span>(lat1, lng2, lat2, lng2);</span><br><span class="line">        <span class="keyword">double</span> dislng = <span class="built_in">get_distance</span>(lat2, lng1, lat2, lng2);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislng, dislat) / PI * <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislat, dislng) / PI * <span class="number">180</span> + <span class="number">90</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislng, dislat) / PI * <span class="number">180</span> + <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislat, dislng) / PI * <span class="number">180</span> + <span class="number">270</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> angle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ARM与X86-CPU架构区别"><a href="#ARM与X86-CPU架构区别" class="headerlink" title="ARM与X86 CPU架构区别"></a>ARM与X86 CPU架构区别</h1><p>所谓的X86 ARM 说的都是指令集。 </p>
<p>CISC(复杂指令集计算机)和RISC(精简指令集计算机)是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。早期的CPU全部是CISC架构，它的设计目的是 CISC要用最少的机器语言指令来完成所需的计算任务。 </p>
<p>RISC和CISC是设计制造微处理器的两种典型技术，虽然它们都是试图在体系结构、操作运行、软件硬件、编译时间和运行时间等诸多因素中做出某种平衡，以求达到高效的目的，但采用的方法不同，因此，在很多方面差异很大。</p>
<blockquote>
<p><strong>x86架构采用CISC，而ARM采用RISC。</strong> </p>
</blockquote>
<p>ARM成立于1991年，是一家出售IP（技术知识产权）的公司，所谓的技术知识产权，有点像卖房屋的结构设计图，至于要怎么修改，哪边开窗户，以及要怎么添加其它的花园，则由买了设计图的厂商自己决定。 </p>
<p>而ARM的架构是采用RISC架构，如同它的名称一样，Advanced RISC Machines，RISC架构在当初的PC架构争霸战虽然败给Intel所主导的x86处理器架构，却默默在另外的领域成长壮大；小到硬盘转速控制、电信基地台的计算、汽车喷射引擎的控制、音响系统、相机引擎，大到电动机具的控制等等，都能够看见采用ARM授权架构处理器的身影。 </p>
<p>而有了设计图，当然还要有把设计图实现的厂商，而这些就是ARM架构的授权客户群。包括： </p>
<p>TI OMAP、Qualcomm Snapdragon、三星的蜂鸟（Hummingbird）、猎户座（Orion）、飞思卡尔（Freescale）的i.MX，或是ST-Ericsson的应用处理器、Freescale、联发科、Telechip、新岸线等。 </p>
<p>X86是英特尔Intel首先开发制造的一种微处理器体系结构的泛称，包括Intel8086、80186、80286、80386以及80486以86结尾系列，英特尔统治整个CPU产业链长达数十年。但是，Intel以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。 </p>
<p>ARM（Advanced RISC Machines）公司是苹果、Acorn、VLSI、Technology等公司的合资企业。ARM采用将芯片的设计方案授权（licensing）给其他公司生产的模式，在世界范围结成了超过100个的合作伙伴（Partners），将封闭设计的Intel公司变成全民公敌。</p>
<p>ARM处理器非常适用于移动通信领域，具有 <mark class="hl-label blue">低成本、高性能和低耗电</mark>  的特性，ARM的高性价比和低耗能在移动市场比英特尔更具优势。 </p>
<p>ARM的架构相较于x86有哪些特点？相较于基于CISC的x86架构处理器，由于为了满足电脑产业发展而不断加入指令集，使得处理器日益庞大，但每个指令集用到的频率也越差越大，许多指令到后来已经相当少用，甚至是可以被新的指令所取代。</p>
<p>而ARM架构则大幅简化架构，仅保留所需要的指令，可以让整个处理器更为简化，拥有小体积、高效能的特性。 </p>
<p>另外，ARM的架构老早就已经做到高密度整合，由于ARM授权的弹性以及核心架构的单纯，ARM处理器架构可以很容易与其它专职的特殊核心，像GPU、多媒体译码核心、基频调制解调器、I/O控制等架构整合，透过SoC（System On a Chip，系统单芯片）的方式，一颗小小的ARM架构应用处理器，完成近年x86架构处理器积极跨足的单芯片设计，并且通过各种不同的核心分工各司其职。</p>
<p>ARM架构应用处理器的核心负担相较传统x86处理器低了许多，并且因为早前应用处理器的需求就是以低功耗为重点，即便如今效能不断提升，仍是以保有省电的特性为前提发展条件。 </p>
<p>ARM架构的另一个优点是自由性，只要向ARM买下核心授权，就可以与其它IP公司的方案以及这家授权客户本身的优势技术整合，虽同为同一世代的ARM核心架构，即便频率相同，结果也不同。</p>
<p>不过这也使得ARM应用处理器光从基本规格不一定能看出其操作效能，例如同样隶属高通Snapdragon，频率1GHz的第一世代旗舰QSD8x50甚至不敌频率仅800MHz的第二世代MSM7230。 </p>
<p>ARM的架构之所以能够在智能手机以及平板领域迅速窜红，苹果iOS可说是大功臣，在苹果之前，智能手机在市场上一直载浮载沉，虽然有着号称智能手机平台市占率第一的Nokia Symbian，以及Windows Mobile、Palm OS、BlackBerry等系统，不过当时的环境缺乏移动网络为后盾，在线商店的概念还未发展成型；</p>
<p>一直到苹果以iPhone打响新世代智能手机第一炮后，市场才真正体会到智能手机原来可以是这么容易使用。 </p>
<p>iPhone的出现也间接带起市场对于ARM架构应用处理器的需求，不过光是苹果也无法带起市场对于ARM处理器的需求，还有WM（WP7)手机与Symbian也纷纷加入新一代智能手机战局。</p>
<p>但是真正成为关键的是Google Android宣布参战后，其它手机厂商取得一个相较过去成熟的通用智能手机平台，而各厂商又为了进行产品差异化，开始针对ARM架构应用处理器的效能以及硬件支持要求，使得过去发展缓慢的ARM架构一下子热络起来，也让ARM一夕之间成为火热话题。 </p>
<p>GOOGLE的Android系统和苹果的IPAD、IPHONE推出后，ARM架构的电脑系统（特别是在终端方面应用）受到用户的广泛支持和追捧，ARM+Android成为IT、通信领域最热门的话题，众多芯片厂商纷纷推出具有各种独特应用功能基于ARM结构开发的产品，近期最新形成的“异构概念”更成为电脑今后发展主要方向。</p>
<p>在IT行业推崇了20多年的“性价比“概念受到根本的动摇和冲击，“适用的才是最好的”已经被越来越多的用户接受。 </p>
<p>我们就ARM架构的系统与X86架构系统的特性进行一个系统分析，方便用户在选择系统时进行理性、合理的比价分析。 </p>
<h2 id="一、性能："><a href="#一、性能：" class="headerlink" title="一、性能："></a>一、性能：</h2><p>X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，这几年才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面，ARM根本不是X86的对手。 </p>
<p><strong>但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。</strong> </p>
<h2 id="二、扩展能力"><a href="#二、扩展能力" class="headerlink" title="二、扩展能力"></a>二、扩展能力</h2><p>X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。 </p>
<p>ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则。 </p>
<h2 id="三、操作系统的兼容性"><a href="#三、操作系统的兼容性" class="headerlink" title="三、操作系统的兼容性"></a>三、操作系统的兼容性</h2><p>X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。 </p>
<p>ARM系统几乎都采用Linux操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的Android系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力。 </p>
<h2 id="四、软件开发的方便性及可使用工具的多样性"><a href="#四、软件开发的方便性及可使用工具的多样性" class="headerlink" title="四、软件开发的方便性及可使用工具的多样性"></a>四、软件开发的方便性及可使用工具的多样性</h2><p>X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。 </p>
<p>ARM结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成ARM结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。 </p>
<p>对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比ARM结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。 </p>
<p>从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：功耗.</p>
<h2 id="五、功耗"><a href="#五、功耗" class="headerlink" title="五、功耗"></a>五、功耗</h2><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能 + 速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑无法相比。 </p>
<p>ARM的设计及发展思路是：满足某个特殊方面的应用即可，在某一专项领域是最强的，（哪怕在其他方面一无是处），这样ARM以其不是最强的技术，同样也不是很高级制程的制造工艺，生产出性能不是很强的电脑系统，但在某个专业应用方面则是最好的，特别是在众多终端应用，尤其在移动终端应用上占有绝对优势的统治地位，这个原因就是：功耗。 </p>
<p>高功耗导致了一系列X86系统无法解决的问题出现：系统的续航能力弱、体积无法缩小、稳定性差、对使用环境要求高等问题。从这里我们可以看到X86系统与ARM系统是在两个完全不同领域方面的应用，他们之间根本不存在替换性，在服务器、工作站以及其他高性能运算等应用方面，可以不考虑功耗和使用环境等条件时，X86系统占了绝对优势；</p>
<p>但受功耗、环境等条件制约且工作任务固定的情况下ARM占有很大的优势，在手持式移动终端领域，X86的功耗更使他英雄毫无用武之地。 </p>
<p>但在很多的应用终端领域，现正成为两大阵营争夺的重点，ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 </p>
<p>我们今天讨论的重点就是在两大阵营都能可以覆盖的终端应用领域进行对比、分析。这类型的应用一定是终端应用，通常有下面几个特征： </p>
<blockquote>
<p>1、系统的工作性质比较固定（如：POS、ATM、车载电脑系统、多媒体广告播放系统、视频监控系统，以及众多的信息接收、控制系统和专业的工控系统等等）； </p>
</blockquote>
<blockquote>
<p>2、应用环境比较恶劣，如：温度变化很大，高温超过40度，低温达零下20度；多尘、潮湿等； </p>
</blockquote>
<blockquote>
<p>3、有一定的应用数量，但数量不是很大。 </p>
</blockquote>
<p>这部分的应用领域传统上是由X86结构的低功耗工控机（系统）实现的，但近几年ARM系统的飞速发展，特别是Android操作系统出现后，ARM + Android大有取代x86系统占领（低功耗）终端应用领域的趋势。我们在考虑这种应用对比时根据ARM和X86的特性，主要还考虑以下因素： </p>
<p>1、性能： </p>
<p>如果ARM系统的性能能满足应用需求时，建议尽可能采用ARM结构的产品，否则考虑X86的产品。注意在这里我们要强调的是：不要将两个系统的绝对性能进行比较，而是以能否您的应用特点为标准进行分析。 </p>
<p>2、应用数量： </p>
<p>如果您的应用数量太少，您可能根本不值得独立开发一套应用系统，但如果您的应用数量达到几百甚至过千时，您是值得考虑自己开发一套新的系统的。因为：ARM的开发成本和制造成本相对比较低，如果有几百个以上终端应用，应该可以分摊掉开发成本。 </p>
<p>如果选用X86结构的系统，根本不应该考虑单独开发一套专用系统（因为开发成本太高，可能是ARM的10倍），而是在市场上筛选出最接近您需求的产品，以避免高昂的硬件开发成本，和今后的制造成本。</p>
<p>3、操作系统 </p>
<p>ARM的操作系统通常是单独建立一个自己的Linux系统，且系统与系统间不能兼容，这严重制约了ARM的应用扩展，但Android出现后，系统兼容的屏障正逐步消失，促进了系统以及应用软件的兼容，大大扩大了ARM应用软件的的数量同时扩大了其应用空间。 </p>
<p>4、功耗以及功耗延伸的系列问题 </p>
<p>ARM的优势是功耗低，其实低功耗还意味着： </p>
<p>1）稳定性高：因为功耗越高电子元器件的稳定性和可靠性越差，对低功耗的产品只要选择好外围元件的品质，系统的稳定性不会有太大问题； </p>
<p>2）散热成本低和可以考虑更小的产品体积：对高功耗的产品不可避免要考虑散热问题，而散热设备（或器件）的存在，有制约了产品的体积，对某些场合的应用构成致命的制约。但ARM的功耗 &lt; 1W，完全不用考虑散热问题。 </p>
<p>3）功耗低对供电电源的要求低：几乎所有电子产品，（在同等条件下）功耗越高对电源的要求越高，电源的成本就越高。 </p>
<p>4）功耗低电池的续航时间长。</p>
<p>5）功耗低对抗环境伤害的能力强：低功耗产品因为不用考虑散热，可以将产品密封保护起来，但高功耗产品必须散热，甚至需要风扇帮助散热，这样必然使很多的元件和线路裸露在空气中，被空气中的尘埃、湿气、酸碱物质等腐蚀。 </p>
<p>5、软件开发成本问题 </p>
<p>ARM的操作系统很小（精简）不可能带很多工具，通常基于ARM的软件大多用C或JAVA开发，其成本会比基于X86系统的高。而且对大多数ARM而言，因其操作系统不一样，软件业不能在两个系统中自由互换使用，但一般来说：用C或JAVA编写的软件只需在ARM平台的操作系统中编译一下就可以移植过去。 </p>
<p>但对Android系统开发的软件，只要能在某台ARM设备中运行，就可以在另一台基于同样系统的设备中运行。 </p>
<p>6、硬件的开发成本 </p>
<p>ARM实际上在CPU芯片中已经整合了几乎所有功能，几乎所有线路按原理图直接拉出就可以了，需要扩展的部分一般不多，所以其开发成本会比较低，通常三五万就可以了。 </p>
<p>但X86的外围线路很多，需要相当经验的工程师，而且还有BIOS等设计，所以X86主板的设计费用会比较高，通常要二三十万。 </p>
<p>7、硬件的制造及应用成本 </p>
<p>无论ARM或X86主板其制造成本都是由元件和加工费构成，通常一片ARM的主板价格与一片X86主板的价格差不多，但ARM是一片可以独立使用的产品，x86主板通常还要加上：CPU、内存、硬盘甚至还有显卡。 </p>
<p>另外X86还要配上一个电源，这个电源比ARM的电源要贵很多。 </p>
<p>所以：明显X86在硬件方面的成本比ARM高得多。 </p>
<p>总结上面对比，X86系统和ARM系统应该是两个完全不同领域的应用，如果功能单一又受到环境制约的应用，如：POS、ATM、多媒体广告机（现已经有ARM+DSP的产品）、车载电脑终端等应用，应该首先考虑ARM方案，ARM方案与X86相比，其功耗和成本占有很大优势。</p>
<p>来源： <a href="https://www.cnblogs.com/CZM-/p/9611312.html">https://www.cnblogs.com/CZM-/p/9611312.html</a></p>
<p>  如图所示，从上到下，计算机系统分为四个层次，分别为应用软件、基础软件、逻辑硬件和物理载体。软件以指令形式运行在CPU硬件上，而指令系统介于软件和硬件之间，是软硬件交互的界面，或者说，CPU是以指令集中的一条指令为最小单位来定义cpu的硬件结构的（注意，x86引入微码之后，应该是以微码为最小单位定义和设计cpu硬件结构的），简单来说就是，一条指令直接一一对应一部分硬件芯片功能。</p>
<p>  指令集是指在处理器内被处理的程序，指令集为汇编语言的设计师和编译器所见。指令集包含execution model，寄存器，地址以及数据格式。微体系结构包含处理器内部的构成以及这些构成起来的部分如何运行指令集架构。微体系结构通常被表示成流程图，以描述机器内部组件的链接状况，从一个闸或是寄存器，到算术逻辑单元（ALU）。图上分布着数据路径（可以显示数据在微架构的位置）以及控制路径（显示数据该被什么指令所处理）。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210620212605497.png" alt="image-20210620212605497"></p>
<p>  Computer architect（也叫计算机体系结构，计算机系统结构，计算机结构），它是指令系统（ISA）与微体系结构（microarchitecture）的总称。个人认为，这就是我们作为的 “ 架构 ”一词的意思。CPU是一个执行部件，它之所以能执行，也是因为人们在里面制作了执行各种功能的硬件电路，然后再用一定的逻辑让它按照一定的顺序工作，这样就能完成人们给它的任务。也就是说，如果把CPU看作一个人，首先它要有正常的工作能力（既执行能力），然后又有足够的逻辑能力（能明白做事的顺序,这就是指微架构），最后还要听的懂别人的话（既指令集），才能正常工作。而这些集中在一起就构成了所谓的“架构”，它可以理解为一套“工具”、“方法”和“规范”的集合。不同的架构之间，工具可能不同，方法可能不同，规范也可能不同，这也造成了它们之间的不兼容——你给一个意大利泥瓦匠看一份中文写成的烹饪指南，他当然不知道应该干什么了。所以X86 ARM MIPS是不同指令集，那么使用它们的体系结构（也就是架构）也就是不同的架构。</p>
<p>  那么这两个指令集的区别又在哪里呢？从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。</p>
<p>  这就是“复杂指令集”和“精简指令集”的逻辑区别。可能有人说，明显是精简指令集好啊，但是我们不好去判断它们之间到底谁好谁坏，因为目前他们两种指令集都在蓬勃发展，而且都很成功——X86是复杂指令集（CISC）的代表，而ARM则是精简指令集（RISC）的代表，甚至ARM的名字就直接表明了它的技术：Advanced RISC Machine——高级RISC机。</p>
<p>  到了这里你就应该明白为什么RISC和CISC之间不好直接比较性能了，因为它们之间的设计思路差异太大。这样的思路导致了CISC和RISC分道扬镳——前者更加专注于高性能但同时高功耗的实现，而后者则专注于小尺寸低功耗领域。实际上也有很多事情CISC更加合适，而另外一些事情则是RISC更加合适，比如在执行高密度的运算任务的时候CISC就更具备优势，而在执行简单重复劳动的时候RISC就能占到上风，比如假设我们是在举办吃饭大赛，那么CISC只需要不停的喊“吃饭吃饭吃饭”就行了，而RISC则要一遍一遍重复吃饭流程，负责喊话的人如果嘴巴不够快（即内存带宽不够大），那么RISC就很难吃的过CISC。但是如果我们只是要两个人把饭舀出来，那么CISC就麻烦得多，因为CISC里没有这么简单的舀饭动作，而RISC就只需要不停喊“舀饭舀饭舀饭”就OK。</p>
<p>  这就是CISC和RISC之间的区别。但是在实际情况中问题要比这复杂许许多多，因为各个阵营的设计者都想要提升自家架构的性能。这里面最普遍的就是所谓的“发射”概念。什么叫发射？发射就是同时可以执行多少指令的意思，例如双发射就意味着CPU可以同时拾取两条指令，三发射则自然就是三条了。现代高级处理器已经很少有单发射的实现，例如Cortex A8和A9都是双发射的RISC，而Cortex A15则是三发射。ATOM是双发射CISC，Core系列甚至做到了四发射——这个方面大家倒是不相上下，但是不要忘了CISC的指令更加复杂，也就意味着指令更加强大，还是吃饭的例子，CISC只需要1个指令，而RISC需要5个，那么在内存带宽相同的情况下，CISC能达到的性能是要超过RISC的（就吃饭而言是5倍），而实际中CISC的Core i处理器内存带宽已经超过了100GB/s，而ARM还在为10GB/s而苦苦奋斗，一个更加吃带宽的架构，带宽却只有别人的十分之一，性能自然会受到非常大的制约。为什么说ARM和X86不好比，这也是很重要的一个原因，因为不同的应用对带宽需求是不同的。一旦遇到带宽瓶颈，哪怕ARM处理器已经达到了很高的运算性能，实际上根本发挥不出来，自然也就会落败了。</p>
<p>  说到这儿大家应该也已经明白CISC和RISC的区别和特色了。简而言之，CISC实际上是以增加处理器本身复杂度作为代价，去换取更高的性能，而RISC则是将复杂度交给了编译器，牺牲了程序大小和指令带宽，换取了简单和低功耗的硬件实现。但如果事情就这样发展下去，为了提升性能，CISC的处理器将越来越大，而RISC需要的内存带宽则会突破天际，这都是受到技术限制的。所以进十多年来，关于CISC和RISC的区分已经慢慢的在模糊，例如自P6体系（即Pentium Pro）以来，作为CISC代表的X86架构引入了微码概念，与此对应的，处理器内部也增加了所谓的译码器，负责将传统的CISC指令“拆包”为更加短小的微码（uOPs）。一条CISC指令进来以后，会被译码器拆分为数量不等的微码，然后送入处理器的执行管线——这实际上可以理解为RISC内核+CISC解码器。而RISC也引入了指令集这个就逻辑角度而言非常不精简的东西，来增加运算性能。正常而言，一条X86指令会被拆解为2～4个uOPs，平均来看就是3个，因此同样的指令密度下，目前X86的实际指令执行能力应该大约是ARM的3倍左右。不过不要忘了这是基于“同样指令密度”下的一个假设，实际上X86可以达到的指令密度是十倍甚至百倍于ARM的。</p>
<p>  最后一个需要考虑的地方就是指令集。这个东西的引入，是为了加速处理器在某些特定应用上性能而设计的，已经有了几十年的历史了。而实际上在目前的应用环境内，起到决定作用的很多时候是指令集而不是CPU核心。X86架构的强大，很多时候也源于指令集的强大，比如我们知道的ATOM，虽然它的X86核心非常羸弱，但是由于它支持SSE3，在很多时候性能甚至可以超过核心性能远远强大于它的Pentium M，这就是指令集的威力。目前X86指令集已经从MMX，发展到了SSE，AVX，而ARM依然还只有简单而基础的NEON。它们之间不成比例的差距造成了实际应用中成百上千倍的性能落差，例如即便是现今最强大的ARM内核依然还在为软解1080p H.264而奋斗，但一颗普通的中端Core i处理器却可以用接近十倍播放速度的速度去压缩1080p H.264视频。至少在这点上，说PC处理器的性能百倍于ARM是无可辩驳的，而实际中这样的例子比比皆是。这也是为什么我在之前说平均下来ARM只有X86几十分之一的性能的原因。</p>
<p>  然现在ARM很强大，但它距离X86还是非常遥远，并没有因为这几年的进步而缩短，实际上反而在被更快的拉大。毕竟它们设计的出发点不一样，因此根本不具备多少可比性，X86无法做到ARM的功耗，而ARM也无法做到X86的性能。</p>
<h1 id="内核模式和用户模式"><a href="#内核模式和用户模式" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h1><p>首先我们要解释一个概念——进程（Process）。简单来说，<strong>一个可执行程序就是一个进程</strong>，我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。</p>
<p>严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个<strong>静态</strong>的概念；进程是程序加载到内存运行后一些列的活动，是一个<strong>动态</strong>的概念。</p>
<p>“程序的地址空间”的说法，这其实是不严谨的，应该说“进程的地址空间”。<strong>一个进程对应一个地址空间，而一个程序可能会创建多个进程</strong>。</p>
<h2 id="内核模式和用户模式-1"><a href="#内核模式和用户模式-1" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h2><p>内核空间存放的是操作系统内核代码和数据，是被所有程序<strong>共享</strong>的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。</p>
<p>要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。</p>
<p><strong>用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。</strong></p>
<p><strong>用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。</strong></p>
<p>计算机会经常在内核模式和用户模式之间切换：<br>·当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；</p>
<p>·操作完成后，继续执行应用程序的代码，就又回到了用户模式。</p>
<p>总结：<strong>用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。</strong></p>
<h2 id="为什么要区分两种模式"><a href="#为什么要区分两种模式" class="headerlink" title="为什么要区分两种模式"></a>为什么要区分两种模式</h2><p>内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。</p>
<p>从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以<strong>运行在 ring0 ~ ring3 四个不同的权限级别</strong>，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<p>·一个是<strong>内核模式，对应 ring0 级</strong>，操作系统的核心部分和设备驱动都运行在该模式下。<br>·另一个是<strong>用户模式，对应 ring3 级</strong>，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。</p>
<h2 id="为什么内核和用户程序要共用地址空间"><a href="#为什么内核和用户程序要共用地址空间" class="headerlink" title="为什么内核和用户程序要共用地址空间"></a>为什么内核和用户程序要共用地址空间</h2><p>既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？</p>
<p><strong>让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。</strong></p>
<p>而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。</p>
<h1 id="bat"><a href="#bat" class="headerlink" title="bat"></a>bat</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@echo off </span><br><span class="line">echo 当前位置 </span><br><span class="line">set curdir=%~dp0</span><br><span class="line">cd /d %curdir%</span><br><span class="line"></span><br><span class="line">echo %curdir%</span><br><span class="line">echo ******************</span><br><span class="line">rem 查询是否存在必要的文件</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist testCrack.<span class="built_in">exe</span> ( </span><br><span class="line">	echo 不存在testCrack.exe</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist SPxCrack.<span class="built_in">dll</span> ( </span><br><span class="line">	echo 不存在SPxCrack.dll</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist RecordCPR.<span class="built_in">exe</span> ( </span><br><span class="line">	echo 不存在RecordCPR.exe</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line">rem 删除旧版本的破解文件</span><br><span class="line"><span class="keyword">if</span> exist *.<span class="built_in">lic</span> ( </span><br><span class="line">	del *.lic</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist RecordCPR_Crack.<span class="built_in">exe</span> ( </span><br><span class="line">	del RecordCPR_Crack.exe</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rem 启动另外的程序，后面跟的是传入的参数，start表示不等待子线程，没有start表示要等待子线程结束</span><br><span class="line">testCrack.exe %curdir%RecordCPR.exe </span><br><span class="line">echo *******************</span><br><span class="line">rem 检测是否破解成功</span><br><span class="line"><span class="keyword">if</span> %errorlevel%==<span class="number">1</span> (</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist cp-spx.<span class="built_in">lic</span> ( </span><br><span class="line">	echo 没有生成.lic</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist RecordCPR_Crack.<span class="built_in">exe</span> (  rem 前括号要放这</span><br><span class="line">	echo 没有生成_Crack.exe</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line">) <span class="built_in"><span class="keyword">else</span></span> (  rem <span class="keyword">else</span>要和<span class="keyword">if</span>的后括号在一行</span><br><span class="line">	 echo crack失败 </span><br><span class="line">	 pause</span><br><span class="line">	 exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">echo 切换至release_y</span><br><span class="line">set desdir=%cd%\release_y</span><br><span class="line">cd /d %desdir%</span><br><span class="line">echo %desdir%</span><br><span class="line"></span><br><span class="line">rem 删除旧版本的破解文件</span><br><span class="line"><span class="keyword">if</span> exist *.<span class="built_in">lic</span> ( </span><br><span class="line">	echo 已删除旧版本lic</span><br><span class="line">	del *.lic</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist RecordCPR_Crack.<span class="built_in">exe</span> ( </span><br><span class="line">	echo 已删除旧版本_Crack.exe</span><br><span class="line">	del RecordCPR_Crack.exe</span><br><span class="line">)</span><br><span class="line">rem 拷贝新的破解文件</span><br><span class="line">copy %curdir%cp-spx.lic %desdir%</span><br><span class="line">copy %curdir%RecordCPR_Crack.exe %desdir%</span><br><span class="line">echo 已拷贝新版本_Crack.exe与lic</span><br><span class="line">rem 删除破解位置的文件，避免混淆</span><br><span class="line">del %curdir%RecordCPR_Crack.exe</span><br><span class="line">del %curdir%cp-spx.lic</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist SPxErrors.<span class="built_in">txt</span> ( </span><br><span class="line">	del SPxErrors.txt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rem 创建快捷方式</span><br><span class="line">rem mshta VBScript:<span class="built_in">Execute</span>(<span class="string">&quot;Set a=CreateObject(&quot;</span><span class="string">&quot;WScript.Shell&quot;</span><span class="string">&quot;):Set b=a.CreateShortcut(a.SpecialFolders(&quot;</span><span class="string">&quot;Desktop&quot;</span><span class="string">&quot;) &amp; &quot;</span><span class="string">&quot;\快捷方式名字.lnk&quot;</span><span class="string">&quot;):b.TargetPath=&quot;</span><span class="string">&quot;程序路径&quot;</span><span class="string">&quot;:b.WorkingDirectory=&quot;</span><span class="string">&quot;%~dp0&quot;</span><span class="string">&quot;:b.Save:close&quot;</span>)</span><br><span class="line">rem https:<span class="comment">//blog.csdn.net/mimishy2000/article/details/88533858</span></span><br><span class="line">mshta VBScript:<span class="built_in">Execute</span>(<span class="string">&quot;Set a=CreateObject(&quot;</span><span class="string">&quot;WScript.Shell&quot;</span><span class="string">&quot;):Set b=a.CreateShortcut(a.SpecialFolders(&quot;</span><span class="string">&quot;Desktop&quot;</span><span class="string">&quot;) &amp; &quot;</span><span class="string">&quot;\RecordCPR_Crack.exe.lnk&quot;</span><span class="string">&quot;):b.TargetPath=&quot;</span><span class="string">&quot;%desdir%\RecordCPR_Crack.exe&quot;</span><span class="string">&quot;:b.WorkingDirectory=&quot;</span><span class="string">&quot;%desdir%&quot;</span><span class="string">&quot;:b.Save:close&quot;</span>)</span><br><span class="line">echo 已创建快捷方式至桌面</span><br><span class="line">echo *************整个过程已结束*************</span><br><span class="line">pause</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="指定进制输出"><a href="#指定进制输出" class="headerlink" title="指定进制输出"></a>指定进制输出</h1><h2 id="1-C中指定进制输出"><a href="#1-C中指定进制输出" class="headerlink" title="1.C中指定进制输出"></a>1.C中指定进制输出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05o\n&quot;</span>,<span class="number">35</span>);    <span class="comment">//按八进制格式输出，保留5位高位补零</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%03d\n&quot;</span>,<span class="number">35</span>);    <span class="comment">//按十进制格式输出，保留3位高位补零</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05x\n&quot;</span>,<span class="number">35</span>);    <span class="comment">//按十六进制格式输出，保留5位高位补零</span></span><br></pre></td></tr></table></figure>

<h2 id="2-C-中指定进制输出"><a href="#2-C-中指定进制输出" class="headerlink" title="2.C++中指定进制输出"></a>2.C++中指定进制输出</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的8进制:&quot;</span> &lt;&lt; std::oct &lt;&lt; <span class="number">35</span>&lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的10进制&quot;</span> &lt;&lt; std::dec &lt;&lt; <span class="number">35</span> &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的16进制:&quot;</span> &lt;&lt; std::hex &lt;&lt; <span class="number">35</span> &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的2进制: &quot;</span> &lt;&lt; bitset&lt;8&gt;(<span class="number">35</span>) &lt;&lt; endl;      <span class="comment">//&lt;8&gt;：表示保留8位输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">使用cout输出时，hex控制符只对整数有效，所以需要先将<span class="number">16</span>进制转成整数，再输出。</span><br></pre></td></tr></table></figure>

<h1 id="指定格式输出"><a href="#指定格式输出" class="headerlink" title="指定格式输出"></a>指定格式输出</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输出<span class="keyword">unsigned</span> <span class="keyword">short</span> ,<span class="keyword">unsigned</span> <span class="keyword">int</span> 一般用 %u</span><br><span class="line">像<span class="keyword">unsigned</span> <span class="keyword">long</span> 输出的话一bai般用%lu</span><br><span class="line"></span><br><span class="line">d 以十进制形式输出带符号整数(正数不输出符号)</span><br><span class="line">o 以八进制形式输出无符号整数(不输出前缀<span class="number">0</span>)</span><br><span class="line">x,X 以十六进制形式输出无符号整数(不输出前缀Ox)</span><br><span class="line">u 以十进制形式输出无符号整数</span><br><span class="line">f 以小数形式输出单、双精度实数</span><br><span class="line">e,E 以指数形式输出单、双精度实数</span><br><span class="line">g,G 以%f或%e中较短的输出宽度输出单、双精度实数</span><br><span class="line">c 输出单个字符</span><br><span class="line">s 输出字符串</span><br></pre></td></tr></table></figure>

<h1 id="获得屏幕区域的所有RGB值，保存成JPG图片"><a href="#获得屏幕区域的所有RGB值，保存成JPG图片" class="headerlink" title="获得屏幕区域的所有RGB值，保存成JPG图片"></a><a href="https://blog.csdn.net/zerocnd/article/details/4503939">获得屏幕区域的所有RGB值，保存成JPG图片</a></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	LPRECT lpRect=<span class="keyword">new</span> RECT;</span><br><span class="line">	lpRect-&gt;left = m_radarWidget-&gt;<span class="built_in">getXMouse</span>() - <span class="number">130</span>;</span><br><span class="line">	lpRect-&gt;top = m_radarWidget-&gt;<span class="built_in">getYMouse</span>() - <span class="number">130</span>;</span><br><span class="line">	lpRect-&gt;right = m_radarWidget-&gt;<span class="built_in">getXMouse</span>() + <span class="number">130</span>;</span><br><span class="line">	lpRect-&gt;bottom = m_radarWidget-&gt;<span class="built_in">getYMouse</span>() + <span class="number">130</span>;</span><br><span class="line"></span><br><span class="line">	HDC hScrDC;	<span class="comment">//声明屏幕设备描述表</span></span><br><span class="line"></span><br><span class="line">	hScrDC = <span class="built_in">CreateDC</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;DISPLAY&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	                  <span class="comment">//为屏幕创建设备描述表</span></span><br><span class="line">	<span class="built_in">gdiRectangle</span>(hScrDC, lpRect, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MainWindow::gdiRectangle</span><span class="params">(HDC hdc,<span class="keyword">const</span> RECT *rect,COLORREF color, <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BYTE *g_pBits;</span><br><span class="line">	HDC g_hMemDC;</span><br><span class="line">	HBITMAP g_hBmp, g_hOldBmp;</span><br><span class="line">	<span class="keyword">if</span>(!rect || !hdc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xMin = rect-&gt;left;</span><br><span class="line">	<span class="keyword">int</span> yMin = rect-&gt;top;</span><br><span class="line">	<span class="keyword">int</span> xMax = rect-&gt;right;</span><br><span class="line">	<span class="keyword">int</span> yMax = rect-&gt;bottom;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	byte r = <span class="built_in">GetRValue</span>(color);</span><br><span class="line">	byte g = <span class="built_in">GetGValue</span>(color);</span><br><span class="line">	byte b = <span class="built_in">GetBValue</span>(color);</span><br><span class="line">	COLORREF clSrc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> rSrc;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> gSrc;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> bSrc;</span><br><span class="line"></span><br><span class="line">	g_hMemDC = ::<span class="built_in">CreateCompatibleDC</span>(hdc);</span><br><span class="line">	<span class="keyword">if</span> (!g_hMemDC)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">DeleteDC</span>(hdc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> iWidth = rect-&gt;right - rect-&gt;left;</span><br><span class="line">	<span class="keyword">int</span> iHeight = rect-&gt;bottom - rect-&gt;top;</span><br><span class="line">	BYTE bmibuf[<span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFO) + <span class="number">256</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD)];</span><br><span class="line">	<span class="built_in">memset</span>(bmibuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(bmibuf));</span><br><span class="line">	BITMAPINFO* pbmi = (BITMAPINFO*)bmibuf;</span><br><span class="line">	<span class="comment">// BITMAPINFO pbmi;­</span></span><br><span class="line">	pbmi-&gt;bmiHeader.biSize = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER);</span><br><span class="line">	pbmi-&gt;bmiHeader.biWidth = iWidth;</span><br><span class="line">	pbmi-&gt;bmiHeader.biHeight = iHeight;</span><br><span class="line">	pbmi-&gt;bmiHeader.biPlanes = <span class="number">1</span>;</span><br><span class="line">	pbmi-&gt;bmiHeader.biBitCount = <span class="number">24</span>;</span><br><span class="line">	pbmi-&gt;bmiHeader.biCompression = BI_RGB;</span><br><span class="line"></span><br><span class="line">	g_hBmp = ::<span class="built_in">CreateDIBSection</span>(g_hMemDC, pbmi, DIB_RGB_COLORS, (<span class="keyword">void</span> **)&amp;g_pBits, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!g_hBmp)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">DeleteDC</span>(g_hMemDC);</span><br><span class="line">	&#125;</span><br><span class="line">	g_hOldBmp = (HBITMAP)::<span class="built_in">SelectObject</span>(g_hMemDC, g_hBmp);</span><br><span class="line">	<span class="built_in">BitBlt</span>(g_hMemDC,<span class="number">0</span>,<span class="number">0</span> , iWidth, iHeight, hdc, rect-&gt;left, rect-&gt;top, SRCCOPY);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * data = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[iWidth*iWidth * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//这的数据要处理，第一行变成最后一行，第二行变成倒数第二行...</span></span><br><span class="line">	<span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; iHeight; y++)</span><br><span class="line">	&#123;</span><br><span class="line">		i = iHeight - y - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; iWidth; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span>+ x * <span class="number">4</span>] = g_pBits[y * iWidth * <span class="number">3</span> + x * <span class="number">3</span>];</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span> + x * <span class="number">4</span> + <span class="number">1</span>] = g_pBits[y * iWidth * <span class="number">3</span> + x * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span> + x * <span class="number">4</span> + <span class="number">2</span>] = g_pBits[y * iWidth * <span class="number">3</span> + x * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span> + x * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">/*rSrc = g_pBits[y * iWidth * 3 + x * 3 + 2];</span></span><br><span class="line"><span class="comment">			gSrc = g_pBits[y * iWidth * 3 + x * 3 + 1];</span></span><br><span class="line"><span class="comment">			bSrc = g_pBits[y * iWidth * 3 + x * 3];</span></span><br><span class="line"><span class="comment">			qDebug() &lt;&lt; rSrc&lt;&lt;&quot; &quot;&lt;&lt; gSrc&lt;&lt;&quot; &quot; &lt;&lt; bSrc &lt;&lt; &quot; &quot; &lt;&lt; endl;*/</span></span><br><span class="line">			<span class="comment">/*rSrc = (rSrc * alpha + r * (255 - alpha)) &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">			gSrc = (gSrc * alpha + g * (255 - alpha)) &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">			bSrc = (bSrc * alpha + b * (255 - alpha)) &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">			g_pBits[y * iWidth * 3 + x * 3 + 2] = rSrc;</span></span><br><span class="line"><span class="comment">			g_pBits[y * iWidth * 3 + x * 3 + 1] = gSrc;</span></span><br><span class="line"><span class="comment">			g_pBits[y * iWidth * 3 + x * 3] = bSrc;*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	data[iWidth*iWidth * <span class="number">4</span>] = <span class="built_in">string</span>(<span class="string">&quot;/0&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">	QImage desImage = <span class="built_in">QImage</span>(data, iWidth, iHeight, QImage::Format_RGB32); <span class="comment">//RGB24</span></span><br><span class="line">	desImage.<span class="built_in">save</span>(<span class="string">&quot;222.jpg&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">BitBlt</span>(hdc, <span class="number">0</span>, <span class="number">0</span>, iWidth, iHeight, g_hMemDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line">	<span class="built_in">SelectObject</span>(g_hMemDC,g_hOldBmp);</span><br><span class="line">	<span class="built_in">DeleteObject</span>(g_hBmp);</span><br><span class="line">	<span class="built_in">DeleteDC</span>(g_hMemDC);</span><br><span class="line">	<span class="built_in">ReleaseDC</span>(<span class="literal">NULL</span>, hdc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个奇慢无比</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXY 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXX 100</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> R[MAXY][MAXX], G[MAXY][MAXX], B[MAXY][MAXX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrgb</span><span class="params">(LPRECT lpRect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = lpRect-&gt;left; x &lt; lpRect-&gt;right; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = lpRect-&gt;top; y &lt; lpRect-&gt;bottom; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            COLORREF color = <span class="built_in">GetPixel</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), x, y);</span><br><span class="line">            <span class="keyword">int</span> Y = y - lpRect-&gt;top;</span><br><span class="line">            <span class="keyword">int</span> X = x - lpRect-&gt;left;</span><br><span class="line">            R[Y][X] = <span class="built_in">GetRValue</span>(color);</span><br><span class="line">            G[Y][X] = <span class="built_in">GetGValue</span>(color);</span><br><span class="line">            B[Y][X] = <span class="built_in">GetBValue</span>(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="if-中同时出现赋值语句和判断"><a href="#if-中同时出现赋值语句和判断" class="headerlink" title="if 中同时出现赋值语句和判断"></a>if 中同时出现赋值语句和判断</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span> &gt; res;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">if</span> ((iter = map1.<span class="built_in">find</span>(complement) )!= map1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        map1[nums[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制台程序，接收键盘信息"><a href="#控制台程序，接收键盘信息" class="headerlink" title="控制台程序，接收键盘信息"></a>控制台程序，接收键盘信息</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="keyword">if</span> (_kbhit()) <span class="comment">/*检测是否有键盘键被按下。*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">getchar</span>()) <span class="comment">//才处理 游戏都是du用非中断函数</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Program is a!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Program is b!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h1 id="防止头文件被重复包含"><a href="#防止头文件被重复包含" class="headerlink" title="防止头文件被重复包含"></a>防止头文件被重复包含</h1><p>#Program once  和 #ifndef  #define A #endif 的功能是一样的，前者是C++，后者是C</p>
<h1 id="C标准输入输出流"><a href="#C标准输入输出流" class="headerlink" title="C标准输入输出流"></a>C标准输入输出流</h1><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220151665.png" alt="image-20210720220151665"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220215699.png" alt="image-20210720220215699"></p>
<h2 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h2><p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220227511.png" alt="image-20210720220227511"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220235388.png" alt="image-20210720220235388"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220239415.png" alt="image-20210720220239415"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220243923.png" alt="image-20210720220243923"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220248508.png" alt="image-20210720220248508"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220252976.png" alt="image-20210720220252976"></p>
<h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220313769.png" alt="image-20210720220313769"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220319088.png" alt="image-20210720220319088"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220325466.png" alt="image-20210720220325466"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220335240.png" alt="image-20210720220335240"></p>
<h1 id="三角函数与反三角函数"><a href="#三角函数与反三角函数" class="headerlink" title="三角函数与反三角函数"></a>三角函数与反三角函数</h1><p>（是以相对于圆心的）</p>
<p>角度 / 180 * π = 弧度。</p>
<p>弧度* 180 / π = 角度 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtMath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是弧度，结果是比例值</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;cos(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">cos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qCos(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qCos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;sin(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">sin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qSin(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qSin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tan(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">tan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qTan(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qTan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是比例值，结果是弧度，需要转成角度</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;acos(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">acos</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAcos(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">qAcos</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;asin(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">asin</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAsin(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">qAsin</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;atan(1)=&quot;</span>&lt;&lt;<span class="built_in">atan</span>(<span class="number">1</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAtan(1)=&quot;</span>&lt;&lt;<span class="built_in">qAtan</span>(<span class="number">1</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">qCos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">qSin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">1</span></span><br><span class="line"><span class="built_in">qTan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">1</span></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAcos</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAsin</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAtan</span>(<span class="number">1</span>)= <span class="number">45</span></span><br></pre></td></tr></table></figure>

<h1 id="exe不在工具栏里显示图标"><a href="#exe不在工具栏里显示图标" class="headerlink" title="exe不在工具栏里显示图标"></a>exe不在工具栏里显示图标</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> QWidget* parent = new QWidget;</span><br><span class="line"> MainWindow *w= new MainWindow(parent);</span><br><span class="line"> QDesktopWidget *desktop = QApplication::desktop();</span><br><span class="line"> //       QRect screen1=desktop-&gt;screenGeometry(0);//主显示器</span><br><span class="line"> //       QRect screen2=desktop-&gt;screenGeometry(1);//扩展显示器</span><br><span class="line"></span><br><span class="line">//获得当前程序所在屏幕的编号</span><br><span class="line">int curWidgetScreenNum=desktop-&gt;screenNumber(0);</span><br><span class="line">//当前程序所在屏幕的编号获取屏幕分辨率</span><br><span class="line">QRect rect = desktop-&gt;availableGeometry(curWidgetScreenNum);</span><br><span class="line">//qDebug()&lt;&lt;&quot;****************&quot;&lt;&lt;rect;</span><br><span class="line">w-&gt;parentWidget()-&gt;move(rect.height()*5/4,rect.height()/2);</span><br><span class="line">w-&gt;parentWidget()-&gt;resize(rect.width()-rect.height()*5/4, rect.height()/2);</span><br></pre></td></tr></table></figure>

<h1 id="linux和windows目录相互映射"><a href="#linux和windows目录相互映射" class="headerlink" title="linux和windows目录相互映射"></a>linux和windows目录相互映射</h1><p><a href="https://blog.csdn.net/weixin_39318565/article/details/121753417">https://blog.csdn.net/weixin_39318565/article/details/121753417</a></p>
<p>一、linux文件夹映射到windows**</p>
<p>安装samba<br>yum install -y samba</p>
<p>将root用户添加到samba中<br>smbpasswd -a root</p>
<p>设置selinux:（或者关闭selinux）<br>chcon -t samba_share_t /home/work/ -R</p>
<p>修改配置文件<br>etc/samba/smb.conf<br>增加<br>[work]<br>comment = work<br>path =/home/work/<br>valid users = @root<br>read list = @root<br>write list = root<br>public = no<br>printable = no</p>
<p>重启服务<br>service smb restart</p>
<p>在windows下网络右键选择”映射网络驱动器”</p>
<p><img src="https://img-blog.csdnimg.cn/b15866cb3f9f4eef816c27316ff9598d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluX3BhbmRh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/93c8886e2b3e44bb955e4414176da06f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluX3BhbmRh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>二、windows文件夹映射到linux</p>
<p>在windows下设置共享文件夹 共享work_git</p>
<p><img src="https://img-blog.csdnimg.cn/e41665f7bd9d42698e9f230472c213fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluX3BhbmRh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>在linux下新建work文件夹</p>
<p>mkdir work</p>
<p>在linux下挂载<br>sudo mount -t cifs -o uid=1000,gid=1000,username=1,password=password //192.168.5.10/work_git work</p>
<h1 id="获取浏览器的下载记录"><a href="#获取浏览器的下载记录" class="headerlink" title="获取浏览器的下载记录"></a>获取浏览器的下载记录</h1><p><a href="https://blog.csdn.net/Demonslzh/article/details/125062240">https://blog.csdn.net/Demonslzh/article/details/125062240</a></p>
<p>Edge和Chrome均在用户目录下生成记录数据库，在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\History</span><br><span class="line">C:\Users\Administrator\AppData\Local\Microsoft\Edge\User Data\Default\History</span><br></pre></td></tr></table></figure>

<p>里面有所有的操作记录，但是在打开状态下不能使用，会被锁住，因此使用的时候先拷贝再读取！</p>
<h1 id="生成GIF"><a href="#生成GIF" class="headerlink" title="生成GIF"></a>生成GIF</h1><p><a href="https://github.com/charlietangora/gif-h">https://github.com/charlietangora/gif-h</a></p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p><a href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool">https://www.w3cschool.cn/tools/index?name=decode_encode_tool</a></p>
<h2 id="350-257-267-346-202-250"><a href="#350-257-267-346-202-250" class="headerlink" title="\350\257\267\346\202\250\"></a>\350\257\267\346\202\250\</h2><p>UTF-8编码</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/08/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><p>产品库</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRUCT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRUCT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ItemRepository</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//注2:这里的整型数组是一个缓冲区，这是生产者消费者的一个重大核心。缓冲区是生产者和消费者数据交互的渠道。生产者生产的数据存入此数组中，然后消费者从此数组中取出数据。</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; item_buffer;</span><br><span class="line">    <span class="comment">//注4:此处的锁是操作整型数组缓冲区的锁，防止多线程操作时候，缓冲区发生混乱。</span></span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="comment">//注5:此处状态变量也算是一个生产者消费者的核心内容之一。生产者生产的数据存满了缓冲区，要进行通知消费者进行消费。</span></span><br><span class="line">    std::condition_variable repo_not_full; <span class="comment">// 条件变量, 指示产品缓冲区不满</span></span><br><span class="line">    std::condition_variable repo_not_empty; <span class="comment">// 条件变量, 指示产品缓冲区不为空.</span></span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// 产品库全局变量, 生产者和消费者操作该变量.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// STRUCT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main函数，创建生产者消费者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;producer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;consumer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kItemRepositorySize = <span class="number">5</span>; <span class="comment">// 队列大小(容量)</span></span><br><span class="line"><span class="comment">//注1:此锁是多线程输出同步锁，你会发现在所有的cout上面都有一行加锁的语句std::lock_guard&lt;std::mutex&gt;lock(mutex);</span></span><br><span class="line"><span class="comment">//这里的锁是为了防止多个线程向屏幕输出的时候会出现打印错乱交叉的情况。加上此锁，一个线程输出的同时，另一个线程就在等着，这样有效的避免了输出混乱。</span></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;producer_consumer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ItemRepository</span> <span class="title">ItemRepository</span>;</span></span><br><span class="line"></span><br><span class="line">    producer m_producer;</span><br><span class="line">    consumer m_consumer;</span><br><span class="line">    consumer m_consumer1;</span><br><span class="line">    consumer m_consumer2;</span><br><span class="line">    m_producer.m_ItemRepository=&amp;ItemRepository;</span><br><span class="line">    m_consumer.m_ItemRepository=&amp;ItemRepository;</span><br><span class="line">    m_consumer1.m_ItemRepository=&amp;ItemRepository;</span><br><span class="line">    m_consumer2.m_ItemRepository=&amp;ItemRepository;</span><br><span class="line"></span><br><span class="line">    m_producer.<span class="built_in">start</span>();</span><br><span class="line">    m_consumer.<span class="built_in">start</span>();</span><br><span class="line">    m_consumer1.<span class="built_in">start</span>();</span><br><span class="line">    m_consumer2.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONSUMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSUMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">consumer</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">consumer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ConsumeItem</span><span class="params">()</span></span>;</span><br><span class="line">    ItemRepository *m_ItemRepository=<span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CONSUMER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;consumer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> kItemRepositorySize; <span class="comment">// 队列大小(容量)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> kItemsToProduce;   <span class="comment">// 待生产的数量</span></span><br><span class="line"><span class="comment">//注1:此锁是多线程输出同步锁，你会发现在所有的cout上面都有一行加锁的语句std::lock_guard&lt;std::mutex&gt;lock(mutex);</span></span><br><span class="line"><span class="comment">//这里的锁是为了防止多个线程向屏幕输出的时候会出现打印错乱交叉的情况。加上此锁，一个线程输出的同时，另一个线程就在等着，这样有效的避免了输出混乱。</span></span><br><span class="line"><span class="keyword">extern</span> std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line">consumer::<span class="built_in">consumer</span>():<span class="built_in">QThread</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注9：这里使用了线程中的延时函数，让消费者线程延时1秒。其目的是让生产者线程在线程起来之后有足够的时间生产数据，因为此函数缓冲区设置为3，所以在及短的时间里缓冲区就满了，而此时消费者再去消费，此时的逻辑是缓冲区永远是差一个数据就发生溢出，然后生产一个数据，缓冲区溢出，通知消费者消费，然后缓冲区不为满，再生产，再溢出，再消费。</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> item = <span class="built_in">ConsumeItem</span>(); <span class="comment">// 消费一个产品.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; QThread::<span class="built_in">currentThread</span>()&lt;&lt;<span class="string">&quot; Consume No.&quot;</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; Product.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consumer::ConsumeItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_ItemRepository-&gt;mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (m_ItemRepository-&gt;item_buffer.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;<span class="comment">//超过作用域自动解锁</span></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;缓冲区空，等待生产者生成产品\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        (m_ItemRepository-&gt;repo_not_empty).<span class="built_in">wait</span>(lock); <span class="comment">// 消费者等待&quot;产品库缓冲区不为空&quot;这一条件发生.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = m_ItemRepository-&gt;item_buffer.<span class="built_in">front</span>(); <span class="comment">// 读取某一产品</span></span><br><span class="line">    m_ItemRepository-&gt;item_buffer.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    (m_ItemRepository-&gt;repo_not_full).<span class="built_in">notify_all</span>(); <span class="comment">// 通知消费者产品库不为满.</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>(); <span class="comment">// 解锁.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回产品.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRODUCER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;struct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">producer</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">producer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProduceItem</span><span class="params">(<span class="keyword">int</span> item)</span></span>;</span><br><span class="line">    ItemRepository *m_ItemRepository=<span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PRODUCER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;producer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> kItemRepositorySize; <span class="comment">// 队列大小(容量)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> kItemsToProduce;   <span class="comment">// 待生产的数量</span></span><br><span class="line"><span class="comment">//注1:此锁是多线程输出同步锁，你会发现在所有的cout上面都有一行加锁的语句std::lock_guard&lt;std::mutex&gt;lock(mutex);</span></span><br><span class="line"><span class="comment">//这里的锁是为了防止多个线程向屏幕输出的时候会出现打印错乱交叉的情况。加上此锁，一个线程输出的同时，另一个线程就在等着，这样有效的避免了输出混乱。</span></span><br><span class="line"><span class="keyword">extern</span> std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line">producer::<span class="built_in">producer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">/*i &lt;= kItemsToProduce*/</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ProduceItem</span>(i); <span class="comment">// 循环生产 kItemsToProduce 个产品.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Produce No.&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; Product.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer::ProduceItem</span><span class="params">( <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_ItemRepository-&gt;mtx)</span></span>;</span><br><span class="line">    <span class="comment">//注6：此处是生产是否为满的判断条件，当生产者生产一个数据write_position加1，当write_position为2的时候，说明生产了0、1、2总共三个数据，若缓冲区是3，则（2+1）%3为0，则判断为生产满的状态。</span></span><br><span class="line">    <span class="keyword">while</span> (m_ItemRepository-&gt;item_buffer.<span class="built_in">size</span>()&gt;kItemRepositorySize)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处注释和注1相呼应，但是有没有发现这里多了一个大括号&#123;&#125;，这个大括号是加锁的括号，说明加锁的作用域只在此大括号里面。</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;<span class="comment">//超过作用域自动解锁</span></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;缓冲区满，等待缓冲区不满\n&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注8:当注6的判断条件成立之后，则说明缓冲区满了，然后在这里等待，如果没有收到消费者线程的通知消息，此线程就一直在等待。</span></span><br><span class="line">        (m_ItemRepository-&gt;repo_not_full).<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_ItemRepository-&gt;item_buffer.<span class="built_in">push</span>(item); <span class="comment">// 写入产品.</span></span><br><span class="line"></span><br><span class="line">    (m_ItemRepository-&gt;repo_not_empty).<span class="built_in">notify_all</span>(); <span class="comment">// 通知消费者产品库不为空.</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>(); <span class="comment">//解锁.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>谈谈为什么要使用工厂类的设计模式</p>
<p>第 1 个问题：我们经常一些<strong>功能类似</strong>的类，所以我们的思路是进行抽象，使用接口暴露公共的方法，使用抽象类来提供<strong>公共</strong>的实现。</p>
<p>第 2 个问题：这些功能类似的类的实例化成为了一个问题，每个类的构造方法参数还不一样，每次 new 对象很麻烦，封装成<strong>简单工厂模式</strong>。</p>
<p>第 3 个问题：简单工厂模式不利于拓展，违背了<strong>开闭原则</strong>，每次添加一个类，都要修改工厂类（如果是工厂类和业务类是两个小伙伴分开写的，那不是要花很多时间来沟通…）,所以就有<strong>工厂方法模式</strong>,其原理就是对简单工厂也进行抽象。</p>
<p>第 4 个问题：突然发现有些糟糕了，因为代码变得很多了，因为功能类似的产品我们进行 3 层抽象，针对每个产品我们还抽象出了 2 层的工厂类。但是我们在某个具体的业务场景中，不单单是只实例化一个类啊。举一个例子，在游戏中，我们要一个战士配装备，首先我们需要配一把枪械（枪械有很多，步枪，狙击枪等，使用问题 1 进行抽象），但是配了枪械之后，我们还需要配子弹啊（继续使用问题 1 的方法进行抽象），好了，现在可以抽象出 2 层的工厂类了，针对现在的情况我们是不是可以让一个工厂既生产枪械，又生产子弹呢？ 这就是<strong>抽象工厂模式</strong>。简单来说，<strong>可以把有一些有联系或者相近的产品，放到一个工厂去生产，没有必要单独再开一个工厂了</strong>。</p>
<p>主要解决接口选择的问题。</p>
<p>1.工厂模式的目的是为了实现解耦，将对象的创建和使用分开，即应用程序将对象的创建和初始化职责交给工厂对象。若一个对象A想要调用对象B时，如果直接通过new关键字来创建一个B实例，然后调用B实例，这样做的不好处是，当需求变更，要将B实例换成C实例时，则需要修改所有new了该实例的方法。</p>
<p>2.降低代码重复。如果对象B的创建过程比较复杂，并且很多地方都用到了，那么很可能出现很多重复的代码，通过统一将创建对象B的代码放到工厂里面统一管理，可以减少代码的重复率，同时也方便维护。相比于构造函数来说，复杂的初始化，会使得构造函数非常的复杂。</p>
<p>由于创建过程都由工厂统一的管理，有利于当业务发生变化之后的修改</p>
<p>3.工厂模式将创建和使用分离，使用者不需要知道具体的创建过程，只需要使用即可。</p>
<p>4.类本身有很多子类，并且经常性发生变化。</p>
<p>(</p>
<p>创建对象需要大量重复的代码。</p>
<p>创建对象需要访问某些信息，而这些信息不应该包含在复合类中。</p>
<p>创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。</p>
<p>)</p>
<ul>
<li>简单工厂模式，，需要去修改工厂类，这违背了开闭法则。</li>
<li>工厂方式模式和抽象工厂模式，都需要增加一个对应的产品的具体工厂类，这就会增大了代码的编写量。</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * 使用了C++多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</span></span><br><span class="line"><span class="comment"> * 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</span></span><br><span class="line"><span class="comment"> * 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 简单工厂模式的结构组成：</span></span><br><span class="line"><span class="comment"> * 工厂类(ShoesFactory)：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。</span></span><br><span class="line"><span class="comment"> * 抽象产品类(Shoes)：是具体产品类的继承的父类或实现的接口。</span></span><br><span class="line"><span class="comment"> * 具体产品类(NiKeShoes\AdidasShoes\LiNingShoes)：工厂类所创建的对象就是此具体产品实例。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 简单工厂模式的特点：</span></span><br><span class="line"><span class="comment"> * 工厂类封装了创建具体产品对象的函数。</span></span><br><span class="line"><span class="comment"> * 需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 简单工厂模式的缺陷：</span></span><br><span class="line"><span class="comment"> * 扩展性非常差，新增产品的时候，需要去修改工厂类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ***************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鞋子-抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiNingShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是李宁球鞋，我的广告语：Everything is possible&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SHOES_TYPE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NIKE,</span><br><span class="line">    LINING,</span><br><span class="line">    ADIDAS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总鞋厂-工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoesFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据鞋子类型创建对应的鞋子对象</span></span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">(SHOES_TYPE type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> NIKE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LINING:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ADIDAS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造工厂对象</span></span><br><span class="line">    ShoesFactory shoesFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pNikeShoes = shoesFactory.<span class="built_in">CreateShoes</span>(NIKE);</span><br><span class="line">    <span class="keyword">if</span> (pNikeShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">        pNikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pNikeShoes;</span><br><span class="line">        pNikeShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pLiNingShoes = shoesFactory.<span class="built_in">CreateShoes</span>(LINING);</span><br><span class="line">    <span class="keyword">if</span> (pLiNingShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 李宁球鞋广告喊起</span></span><br><span class="line">        pLiNingShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pLiNingShoes;</span><br><span class="line">        pLiNingShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从鞋工厂对象创建阿迪达斯鞋对象</span></span><br><span class="line">    Shoes *pAdidasShoes = shoesFactory.<span class="built_in">CreateShoes</span>(ADIDAS);</span><br><span class="line">    <span class="keyword">if</span> (pAdidasShoes != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阿迪达斯球鞋广告喊起</span></span><br><span class="line">        pAdidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> pAdidasShoes;</span><br><span class="line">        pAdidasShoes = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * 使用了C++多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</span></span><br><span class="line"><span class="comment"> * 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</span></span><br><span class="line"><span class="comment"> * 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工厂方法模式的结构组成：</span></span><br><span class="line"><span class="comment"> * 抽象工厂类（ShoesFactory）：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</span></span><br><span class="line"><span class="comment"> * 具体工厂类（NiKeProducer\AdidasProducer\LiNingProducer）：继承于抽象工厂，实现创建对应具体产品对象的方式。</span></span><br><span class="line"><span class="comment"> * 抽象产品类（Shoes）：它是具体产品继承的父类（基类）。</span></span><br><span class="line"><span class="comment"> * 具体产品类（NiKeShoes\AdidasShoes\LiNingShoes）：具体工厂所创建的对象，就是此类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 工厂方法模式的特点：</span></span><br><span class="line"><span class="comment"> * 工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。</span></span><br><span class="line"><span class="comment"> * 工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 工厂方法模式的缺陷：</span></span><br><span class="line"><span class="comment"> * 每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。</span></span><br><span class="line"><span class="comment"> * 一条生产线只能一个产品。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ***************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鞋子-抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是阿迪达斯球鞋，我的广告语:Impossible is nothing&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiNingShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是李宁球鞋，我的广告语：Everything is possible&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总鞋厂-抽象工厂类，提供了创建具体鞋子产品的纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoesFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShoesFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链-具体工厂类，实现对应具体鞋子产品对象的创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeProducer</span> :</span> <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿迪达斯生产者/生产链-具体工厂类，实现对应具体鞋子产品对象的创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdidasProducer</span> :</span> <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AdidasShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李宁生产者/生产链-具体工厂类，实现对应具体鞋子产品对象的创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiNingProducer</span> :</span> <span class="keyword">public</span> ShoesFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LiNingShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//main函数针对每种类型的鞋子，构造了每种类型的生产线，再由每个生产线生产出对应的鞋子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;================ 生产耐克流程 ==================== &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">    ShoesFactory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line">    <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">    Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">    nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">    <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================ 生产阿迪达斯流程 ==================== //</span></span><br><span class="line">    <span class="comment">// 鞋厂开设阿迪达斯生产者</span></span><br><span class="line">    ShoesFactory *adidasProducer = <span class="keyword">new</span> <span class="built_in">AdidasProducer</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯生产线产出球鞋</span></span><br><span class="line">    Shoes *adidasShoes = adidasProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">    <span class="comment">// 阿迪达斯球鞋广喊起</span></span><br><span class="line">    adidasShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> adidasShoes;</span><br><span class="line">    <span class="keyword">delete</span> adidasProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * 使用了C++多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</span></span><br><span class="line"><span class="comment"> * 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</span></span><br><span class="line"><span class="comment"> * 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 抽象工厂模式的结构组成：</span></span><br><span class="line"><span class="comment"> * 抽象工厂类（ShoesFactory）：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</span></span><br><span class="line"><span class="comment"> * 具体工厂类（NiKeProducer\AdidasProducer\LiNingProducer）：继承于抽象工厂，实现创建对应具体产品对象的方式。</span></span><br><span class="line"><span class="comment"> * 抽象产品类（Shoes）：它是具体产品继承的父类（基类）。</span></span><br><span class="line"><span class="comment"> * 具体产品类（NiKeShoes\AdidasShoes\LiNingShoes）：具体工厂所创建的对象，就是此类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 抽象工厂模式的特点：</span></span><br><span class="line"><span class="comment"> * 提供一个接口，可以创建多个产品族中的产品对象。如创建耐克工厂，则可以创建耐克鞋子产品、衣服产品、裤子产品等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 抽象工厂模式的缺陷：</span></span><br><span class="line"><span class="comment"> * 同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ***************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 基类 衣服</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克衣服</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeClothe</span> :</span> <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克衣服，时尚我最在行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 鞋子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，让你酷起来&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总厂-抽象工厂，提供了创建鞋子CreateShoes()和衣服产品CreateClothe()对象的接口。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shoes *<span class="title">CreateShoes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Clothe *<span class="title">CreateClothe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克生产者/生产链-具体工厂，实现了创建耐克鞋子和耐克衣服的方式。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeProducer</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shoes *<span class="title">CreateShoes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeShoes</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothe *<span class="title">CreateClothe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NiKeClothe</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数，构造耐克工厂对象，通过耐克工厂对象再创建耐克产品族的衣服和鞋子对象。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;================ 生产耐克流程 ==================== &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">// 鞋厂开设耐克生产线</span></span><br><span class="line">        Factory *niKeProducer = <span class="keyword">new</span> <span class="built_in">NiKeProducer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 耐克生产线产出球鞋</span></span><br><span class="line">        Shoes *nikeShoes = niKeProducer-&gt;<span class="built_in">CreateShoes</span>();</span><br><span class="line">        <span class="comment">// 耐克生产线产出衣服</span></span><br><span class="line">        Clothe *nikeClothe = niKeProducer-&gt;<span class="built_in">CreateClothe</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 耐克球鞋广告喊起</span></span><br><span class="line">        nikeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">        <span class="comment">// 耐克衣服广告喊起</span></span><br><span class="line">        nikeClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">delete</span> nikeShoes;</span><br><span class="line">        <span class="keyword">delete</span> nikeClothe;</span><br><span class="line">        <span class="keyword">delete</span> niKeProducer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模板工厂"><a href="#模板工厂" class="headerlink" title="模板工厂"></a>模板工厂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * 使用了C++多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。</span></span><br><span class="line"><span class="comment"> * 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</span></span><br><span class="line"><span class="comment"> * 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工厂方法模式的结构组成：</span></span><br><span class="line"><span class="comment"> * 抽象工厂类（ShoesFactory）：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。</span></span><br><span class="line"><span class="comment"> * 具体工厂类（NiKeProducer\AdidasProducer\LiNingProducer）：继承于抽象工厂，实现创建对应具体产品对象的方式。</span></span><br><span class="line"><span class="comment"> * 抽象产品类（Shoes）：它是具体产品继承的父类（基类）。</span></span><br><span class="line"><span class="comment"> * 具体产品类（NiKeShoes\AdidasShoes\LiNingShoes）：具体工厂所创建的对象，就是此类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 工厂方法模式的特点：</span></span><br><span class="line"><span class="comment"> * 工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。</span></span><br><span class="line"><span class="comment"> * 工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 工厂方法模式的缺陷：</span></span><br><span class="line"><span class="comment"> * 每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。</span></span><br><span class="line"><span class="comment"> * 一条生产线只能一个产品。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 针对工厂方法模式封装成模板工厂类，那么这样在新增产品时，是不需要新增具体的工厂类，减少了代码的编写量。</span></span><br><span class="line"><span class="comment"> * 把产品注册的功能封装成产品注册模板类。注册的产品对象保存在工厂模板类的std::map，便于产品对象的获取。</span></span><br><span class="line"><span class="comment"> * 把获取产品对象的功能封装成工厂模板类。为了能随时随地获取指定产品对象，则把工厂设计成单例模式。</span></span><br><span class="line"><span class="comment"> * ***************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鞋子-抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shoes</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 耐克鞋子-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiKeShoes</span> :</span> <span class="keyword">public</span> Shoes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是耐克球鞋，我的广告语：Just do it&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 衣服-抽象产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clothe</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优衣库衣服-具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqloClothe</span> :</span> <span class="keyword">public</span> Clothe</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我是优衣库衣服，我的广告语：I am Uniqlo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IProductRegistrar为产品注册抽象类，模板参数 ProductType_t 表示的类是产品抽象类（如Shoes、Clothe）。提供了产品对象创建的纯虚函数CreateProduct。</span></span><br><span class="line"><span class="comment">//ProductFactory为工厂模板类，模板参数 ProductType_t 表示的类是产品抽象类（如Shoes、Clothe）。用于保存注册产品对象到std::map中和获取对应的产品对象。</span></span><br><span class="line"><span class="comment">//ProductRegistrar为产品注册模板类，模板参数 ProductType_t 表示的类是产品抽象类（如Shoes、Clothe），ProductImpl_t 表示的类是具体产品（如NikeShoes、UniqloClothe）。用于注册产品到工厂类和创建产品实例对象。</span></span><br><span class="line"><span class="comment">// 基类，产品注册模板接口类</span></span><br><span class="line"><span class="comment">// 模板参数 ProductType_t 表示的类是产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ProductType_t</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProductRegistrar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取产品对象抽象接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductType_t *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造和虚构, 子类的&quot;内部&quot;的其他函数可以调用</span></span><br><span class="line">    <span class="built_in">IProductRegistrar</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IProductRegistrar</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部拷贝和赋值操作</span></span><br><span class="line">    <span class="built_in">IProductRegistrar</span>(<span class="keyword">const</span> IProductRegistrar &amp;);</span><br><span class="line">    <span class="keyword">const</span> IProductRegistrar &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> IProductRegistrar &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模板类，用于获取和注册产品对象</span></span><br><span class="line"><span class="comment">// 模板参数 ProductType_t 表示的类是产品抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ProductType_t</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取工厂单例，工厂的实例是唯一的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ProductFactory&lt;ProductType_t&gt; &amp;<span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ProductFactory&lt;ProductType_t&gt; instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产品注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterProduct</span><span class="params">(IProductRegistrar&lt;ProductType_t&gt; *registrar, std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ProductRegistry[name] = registrar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名字name，获取对应具体的产品对象</span></span><br><span class="line">    <span class="function">ProductType_t *<span class="title">GetProduct</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 从map找到已经注册过的产品，并返回产品对象</span></span><br><span class="line">        <span class="keyword">if</span> (m_ProductRegistry.<span class="built_in">find</span>(name) != m_ProductRegistry.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_ProductRegistry[name]-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未注册的产品，则报错未找到</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No product found for &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造和虚构</span></span><br><span class="line">    <span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ProductFactory</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止外部拷贝和赋值操作</span></span><br><span class="line">    <span class="built_in">ProductFactory</span>(<span class="keyword">const</span> ProductFactory &amp;);</span><br><span class="line">    <span class="keyword">const</span> ProductFactory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ProductFactory &amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存注册过的产品，key:产品名字 , value:产品类型</span></span><br><span class="line">    std::map&lt;std::string, IProductRegistrar&lt;ProductType_t&gt; *&gt; m_ProductRegistry;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品注册模板类，用于创建具体产品和从工厂里注册产品</span></span><br><span class="line"><span class="comment">// 模板参数 ProductType_t 表示的类是产品抽象类（基类），ProductImpl_t 表示的类是具体产品（产品种类的子类）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ProductType_t</span>, <span class="keyword">class</span> <span class="title">ProductImpl_t</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductRegistrar</span> :</span> <span class="keyword">public</span> IProductRegistrar&lt;ProductType_t&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，用于注册产品到工厂，只能显示调用</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ProductRegistrar</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂单例把产品注册到工厂</span></span><br><span class="line">        ProductFactory&lt;ProductType_t&gt;::<span class="built_in">Instance</span>().<span class="built_in">RegisterProduct</span>(<span class="keyword">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建具体产品对象指针</span></span><br><span class="line">    <span class="function">ProductType_t *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductImpl_t</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数针对每种类型的鞋子，构造了每种类型的生产线，再由每个生产线生产出对应的鞋子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;================ 生产耐克流程 ==================== &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 注册产品种类为Shoes（基类），产品为NiKe（子类）到工厂，产品名为nike</span></span><br><span class="line">    <span class="function">ProductRegistrar&lt;Shoes, NiKeShoes&gt; <span class="title">nikeShoes</span><span class="params">(<span class="string">&quot;nike&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 从工厂获取产品种类为Shoes，名称为nike的产品对象</span></span><br><span class="line">    Shoes *pNiKeShoes = ProductFactory&lt;Shoes&gt;::<span class="built_in">Instance</span>().<span class="built_in">GetProduct</span>(<span class="string">&quot;nike&quot;</span>);</span><br><span class="line">    <span class="comment">// 显示产品的广告语</span></span><br><span class="line">    pNiKeShoes-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (pNiKeShoes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pNiKeShoes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================== 生产优衣库衣服过程 ===========================//</span></span><br><span class="line">    <span class="comment">// 注册产品种类为Clothe（基类），产品为UniqloClothe（子类）到工厂，产品名为uniqlo</span></span><br><span class="line">    <span class="function">ProductRegistrar&lt;Clothe, UniqloClothe&gt; <span class="title">adidasShoes</span><span class="params">(<span class="string">&quot;uniqlo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 从工厂获取产品种类为Shoes，名称为adidas的产品对象</span></span><br><span class="line">    Clothe *pUniqloClothe = ProductFactory&lt;Clothe&gt;::<span class="built_in">Instance</span>().<span class="built_in">GetProduct</span>(<span class="string">&quot;uniqlo&quot;</span>);</span><br><span class="line">    <span class="comment">// 显示产品的广告语</span></span><br><span class="line">    pUniqloClothe-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (pUniqloClothe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pUniqloClothe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************</span></span><br><span class="line"><span class="comment"> * 策略模式是指定义一系列的算法，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而变化，也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色环境角色表现出不同的行为。</span></span><br><span class="line"><span class="comment"> * 相比于使用大量的if...else，使用策略模式可以降低复杂度，使得代码更容易维护。</span></span><br><span class="line"><span class="comment"> * 缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ******************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceAlgorithm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Replace</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三种具体的替换算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU_ReplaceAlgorithm</span> :</span> <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Least Recently Used replace algorithm&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFO_ReplaceAlgorithm</span> :</span> <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;First in First out replace algorithm&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Random_ReplaceAlgorithm</span>:</span> <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Random replace algorithm&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cache需要用到替换算法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RA</span> &#123;</span>LRU, FIFO, RANDOM&#125;; <span class="comment">//标签</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ReplaceAlgorithm *m_ra = <span class="literal">NULL</span> ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>(<span class="keyword">enum</span> RA ra)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ra == LRU)</span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">LRU_ReplaceAlgorithm</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == FIFO)</span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">FIFO_ReplaceAlgorithm</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == RANDOM)</span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">Random_ReplaceAlgorithm</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m_ra = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>() &#123; <span class="keyword">if</span>(m_ra) <span class="keyword">delete</span> m_ra; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(m_ra) m_ra-&gt;<span class="built_in">Replace</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(LRU)</span></span>; <span class="comment">//指定标签即可</span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;<span class="comment">//删除默认函数</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;<span class="comment">//删除默认函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//C++11标准中的Magic Static特性</span></span><br><span class="line">        <span class="comment">//如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。</span></span><br><span class="line">        <span class="comment">//这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</span></span><br><span class="line">        <span class="keyword">static</span> Singleton instance; <span class="comment">//局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;std::cout&lt;&lt;<span class="string">&quot;Show something.&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    Singleton&amp; instance_1 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    instance_1.<span class="built_in">Show</span>();</span><br><span class="line">    Singleton&amp; instance_2 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    instance_2.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>//建造者模式很简单，其核心还是面向接口编程~<br>//以造汽车为例，现在需要造3种品牌的汽车</p>
<p>//haval<br>//benz<br>//bmw</p>
<ol>
<li>汽车需要轮子、引擎及车身，定义如下类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class car&#123;</span><br><span class="line">    public:</span><br><span class="line">    car()=default;</span><br><span class="line">    car(string wheel_in,string engine_in,string carbody_in)</span><br><span class="line">    :wheel&#123;wheel_in&#125;</span><br><span class="line">    ,engine&#123;engine_in&#125;</span><br><span class="line">    ,carbody&#123;carbody_in&#125;&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    string wheel;   //车轮</span><br><span class="line">    string engine;  //引擎</span><br><span class="line">    string carbody; //车身</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>carbuilder类</li>
</ol>
<p>假设：</p>
<ul>
<li>哈佛是固特异轮胎、丰田发动机</li>
<li>奔驰是米琪林轮胎、奔驰发动机</li>
<li>宝马是固特异轮胎、宝马发动机</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class carbuilder&#123;</span><br><span class="line">public:</span><br><span class="line">    car buildHAVALcar()&#123;</span><br><span class="line">        return car(&quot;goodyear&quot;,&quot;Toyato&quot;,&quot;haval&quot;);</span><br><span class="line">    &#125;  </span><br><span class="line">    car buildBENZcar()&#123;</span><br><span class="line">        return car(&quot;michelin&quot;,&quot;benz&quot;,&quot;benz&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    car buildBMWcar()&#123;</span><br><span class="line">        return car(&quot;goodyear&quot;,&quot;bmw&quot;,&quot;bmw&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用时</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    carbuilder builder;</span><br><span class="line">    auto benzcar=builder.buildBENZcar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写代码是没问题的，只是如果我们现在想生产吉利汽车，那我们不得不去修改carbuilder类，修改的时候我们不确定会不会引入新的bug</p>
<p>so, 建造者模式应运而生</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面向接口编程，抽出接口builderinterface</span></span><br><span class="line"><span class="comment">//1.所有汽车都需要轮胎、引擎及车身</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">builderinterface</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">buildWheel</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">buildEngine</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">buildCarbody</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">builderinterface</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 实现各自的继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">havalbuilder</span>:</span><span class="keyword">public</span> builderinterface&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">buildWheel</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;goodyear&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">buildEngine</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;Toyato&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">buildCarbody</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;haval&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">benzbuilder</span>:</span><span class="keyword">public</span> builderinterface&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">buildWheel</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;michelin&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">buildEngine</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;benz&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">buildCarbody</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;benz&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bmwbuilder</span>:</span><span class="keyword">public</span> builderinterface&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">buildWheel</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;goodyear&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">buildEngine</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;bmw&quot;</span>;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">buildCarbody</span><span class="params">()</span><span class="keyword">override</span></span>&#123;<span class="keyword">return</span> <span class="string">&quot;bmw&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">car</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">car</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">car</span>(string wheel_in,string engine_in,string carbody_in)</span><br><span class="line">        :wheel&#123;wheel_in&#125;</span><br><span class="line">        ,engine&#123;engine_in&#125;</span><br><span class="line">        ,carbody&#123;carbody_in&#125;&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    string wheel;   <span class="comment">//车轮</span></span><br><span class="line">    string engine;  <span class="comment">//引擎</span></span><br><span class="line">    string carbody; <span class="comment">//车身</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. director类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">director</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">director</span>(builderinterface* builder)&#123;</span><br><span class="line">        _pBuilder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">car <span class="title">bulidCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">car</span>(_pBuilder-&gt;<span class="built_in">buildWheel</span>(),_pBuilder-&gt;<span class="built_in">buildEngine</span>(),_pBuilder-&gt;<span class="built_in">buildCarbody</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">director</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_pBuilder) <span class="keyword">delete</span> _pBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    builderinterface *_pBuilder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 随需而变的业务，想建造一个吉利汽车，我们只需要新建一个继承类即可，而不必修改原来的类</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">director <span class="title">dir</span><span class="params">(<span class="keyword">new</span> havalbuilder)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> haval=dir.<span class="built_in">bulidCar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">director <span class="title">dir1</span><span class="params">(<span class="keyword">new</span> benzbuilder)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> benz=dir.<span class="built_in">bulidCar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">director <span class="title">dir2</span><span class="params">(<span class="keyword">new</span> bmwbuilder)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> bmw=dir.<span class="built_in">bulidCar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="克隆模式"><a href="#克隆模式" class="headerlink" title="克隆模式"></a>克隆模式</h1><p>(1) 创建新对象成本较大（如一些初始化需要较长时间，占用太多的CPU资源或网络资源），并且新的对象可以通过原型模式对已有对象进行复制来获得，如有必要可稍作修改。</p>
<p>(2) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>
<p><strong>优点</strong>：<br>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，提高新实例的创建效率。</p>
<p>(2) 扩展性较好，模式中提供了抽象原型类，具体原型类可根据需要扩展。</p>
<p>(3) 原型模式提供了简化的创建结构，模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p>
<p><strong>缺点</strong>：<br>(1) 需要为每一个类配备一个克隆方法，该克隆方法位于一个类的内部，改造已有类时需要修改源代码，违背开闭原则；</p>
<p>(2) 在实现深克隆时需要编写较为复杂的代码，并且如果对象嵌套很多引用时，为了实现深拷贝每一层嵌套都必须支持深克隆。</p>
<p><strong>抽象原型类（AbstractPrototype）</strong>：规定了具体原型对象必须实现的接口（如果要提供深拷贝，则必须具有实现clone的规定）<br><strong>具体原型类（ConcretePrototype）</strong>：从抽象原型派生而来，是客户程序使用的对象，即被复制的对象，需要实现抽象原型角色所要求的接口。<br><strong>客户端（Client）</strong>：客户端中声明一个抽象原型类，根据客户需求clone具体原型类对象实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 抽象原型类（AbstractPrototype）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractPrototypeMail</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractPrototypeMail</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractPrototypeMail *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showMail</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">changeTitle</span><span class="params">(std::string title)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">changeSender</span><span class="params">(std::string sender)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">changeRecipients</span><span class="params">(std::string rec)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">changeBody</span><span class="params">(std::string body)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">changeAtt</span><span class="params">(std::string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">AbstractPrototypeMail</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 附件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Attachment</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Attachment Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Attachment</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Attachment Bye&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeName</span><span class="params">(<span class="keyword">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">        nameAtt = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nameAtt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string nameAtt; <span class="comment">/// 附件名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 具体原型类（ConcretePrototype）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeMail</span> :</span> <span class="keyword">public</span> AbstractPrototypeMail &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcretePrototypeMail</span>(<span class="keyword">const</span> std::string &amp;title,<span class="keyword">const</span> std::string &amp;sender,<span class="keyword">const</span> std::string &amp;rec,<span class="keyword">const</span> std::string &amp;body, <span class="keyword">const</span> std::string &amp;nameAtt=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcretePrototypeMail Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        mailTitle = title;</span><br><span class="line">        mailSender = sender;</span><br><span class="line">        mailRecipients = rec;</span><br><span class="line">        mailBody = body;</span><br><span class="line">        <span class="keyword">if</span> (!nameAtt.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            mailAtta = <span class="keyword">new</span> <span class="built_in">Attachment</span>();</span><br><span class="line">            mailAtta-&gt;<span class="built_in">changeName</span>(nameAtt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ConcretePrototypeMail</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ConcretePrototypeMail Bye&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (mailAtta!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">delete</span></span>(mailAtta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractPrototypeMail *<span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> *newMail = <span class="keyword">new</span> <span class="built_in">ConcretePrototypeMail</span>(mailTitle,mailSender,mailRecipients,mailBody,mailAtta-&gt;<span class="built_in">getName</span>());</span><br><span class="line">        <span class="keyword">return</span> newMail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showMail</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MailTitle: &quot;</span> &lt;&lt; mailTitle &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MailSender: &quot;</span> &lt;&lt; mailSender &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MailRecipients: &quot;</span> &lt;&lt; mailRecipients &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MailBody: &quot;</span> &lt;&lt; mailBody &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MailAttachment: &quot;</span> &lt;&lt; mailAtta-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeTitle</span><span class="params">(<span class="keyword">const</span> std::string title)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mailTitle = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeSender</span><span class="params">(<span class="keyword">const</span> std::string sender)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mailSender = sender;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeRecipients</span><span class="params">(<span class="keyword">const</span> std::string rec)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mailRecipients = rec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBody</span><span class="params">(<span class="keyword">const</span> std::string body)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mailBody = body;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeAtt</span><span class="params">(<span class="keyword">const</span> std::string name)</span> <span class="keyword">override</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mailAtta!= <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">delete</span></span>(mailAtta);</span><br><span class="line">        &#125;</span><br><span class="line">        mailAtta = <span class="keyword">new</span> <span class="built_in">Attachment</span>();</span><br><span class="line">        mailAtta-&gt;<span class="built_in">changeName</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string mailTitle;</span><br><span class="line">    std::string mailSender;</span><br><span class="line">    std::string mailRecipients; <span class="comment">/// 按理说 收件人应该有多个 可改为list等其他数据结构，这里采用std::string用于演示</span></span><br><span class="line">    std::string mailBody;</span><br><span class="line">    Attachment *mailAtta = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//浅拷贝：</span></span><br><span class="line">    <span class="comment">// 用于复用的初始邮件创建</span></span><br><span class="line">    <span class="keyword">auto</span> *originalMail_A = <span class="keyword">new</span> <span class="built_in">ConcretePrototypeMail</span>(<span class="string">&quot;original_title&quot;</span>,<span class="string">&quot;original_sender&quot;</span>,<span class="string">&quot;original_rec&quot;</span>,<span class="string">&quot;original_body&quot;</span>,<span class="string">&quot;original_attachment&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;originalMail_A address: &quot;</span>&lt;&lt; originalMail_A &lt;&lt; std::endl;</span><br><span class="line">    originalMail_A-&gt;<span class="built_in">showMail</span>();</span><br><span class="line">    <span class="comment">/// 浅拷贝</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====浅拷贝====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> *copyMail_A = originalMail_A;</span><br><span class="line">    copyMail_A-&gt;<span class="built_in">changeTitle</span>(<span class="string">&quot;copymail_title&quot;</span>);</span><br><span class="line">    copyMail_A-&gt;<span class="built_in">changeSender</span>(<span class="string">&quot;copymail_sender&quot;</span>);</span><br><span class="line">    copyMail_A-&gt;<span class="built_in">changeRecipients</span>(<span class="string">&quot;copymail_rec&quot;</span>);</span><br><span class="line">    copyMail_A-&gt;<span class="built_in">changeBody</span>(<span class="string">&quot;copymail_body&quot;</span>);</span><br><span class="line">    copyMail_A-&gt;<span class="built_in">changeAtt</span>(<span class="string">&quot;copymail_attachment&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====copyMail_A====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;copyMail_A address: &quot;</span>&lt;&lt; copyMail_A &lt;&lt; std::endl;</span><br><span class="line">    copyMail_A-&gt;<span class="built_in">showMail</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====originalMail_A====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    originalMail_A-&gt;<span class="built_in">showMail</span>();</span><br><span class="line">    <span class="keyword">delete</span> originalMail_A;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;--------------------------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;--------------------------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;--------------------------------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/// 深拷贝</span></span><br><span class="line">    <span class="keyword">auto</span> *originalMail_B = <span class="keyword">new</span> <span class="built_in">ConcretePrototypeMail</span>(<span class="string">&quot;original_title&quot;</span>,<span class="string">&quot;original_sender&quot;</span>,<span class="string">&quot;original_rec&quot;</span>,<span class="string">&quot;original_body&quot;</span>,<span class="string">&quot;original_attachment&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;originalMail_B address: &quot;</span>&lt;&lt; originalMail_B &lt;&lt; std::endl;</span><br><span class="line">    originalMail_B-&gt;<span class="built_in">showMail</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====深拷贝====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> *copyMail_B = originalMail_B-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    copyMail_B-&gt;<span class="built_in">changeTitle</span>(<span class="string">&quot;copymail_title&quot;</span>);</span><br><span class="line">    copyMail_B-&gt;<span class="built_in">changeSender</span>(<span class="string">&quot;copymail_sender&quot;</span>);</span><br><span class="line">    copyMail_B-&gt;<span class="built_in">changeRecipients</span>(<span class="string">&quot;copymail_rec&quot;</span>);</span><br><span class="line">    copyMail_B-&gt;<span class="built_in">changeBody</span>(<span class="string">&quot;copymail_body&quot;</span>);</span><br><span class="line">    copyMail_B-&gt;<span class="built_in">changeAtt</span>(<span class="string">&quot;copymail_attachment&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====originalMail_B====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;copyMail_B address: &quot;</span>&lt;&lt; copyMail_B &lt;&lt; std::endl;</span><br><span class="line">    copyMail_B-&gt;<span class="built_in">showMail</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====originalMail_B====&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    originalMail_B-&gt;<span class="built_in">showMail</span>();</span><br><span class="line">    <span class="keyword">delete</span> originalMail_B;</span><br><span class="line">    <span class="keyword">delete</span> copyMail_B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>面试</title>
    <url>/2021/07/13/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="五、C-构造函数以及析构函数的若干面试问题"><a href="#五、C-构造函数以及析构函数的若干面试问题" class="headerlink" title="五、C++构造函数以及析构函数的若干面试问题"></a>五、C++构造函数以及析构函数的若干面试问题</h2><p> Q1：构造函数能否重载，析构函数能否重载，为什么？<br> A1：构造函数可以，析构函数不可以。</p>
<p> Q2：析构函数为什么一般情况下要声明为虚函数？</p>
<p> A2：虚函数是实现多态的基础，当我们通过基类的指针是析构子类对象时候，如果不定义成虚函数，那只调用基类的析构函数，子类的析构函数将不会被调用。如果定义为虚函数，则子类父类的析构函数都会被调用。</p>
<p> Q3：什么情况下必须定义拷贝构造函数？</p>
<p> A3：当类的对象用于函数值传递时（值参数，返回类对象），拷贝构造函数会被调用。如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。例如大的堆栈数据拷贝。如果定义了拷贝构造函数，那也必须重载赋值操作符。</p>
<h2 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h2><p>局部变量 new 指针出来（比如double ），实际上是申请了4+8个大小空间，4表示指针大小，指向的是8个字节地址的首地址，8才是实际变量，比如double变量存88.8,8个字节里就会存储88.8的内存值，4个字节存储指向这8个字节的首地址。</p>
<p>函数结束没有delete时，释放的是4个字节的栈空间，而8个字节的堆空间没有被释放。</p>
<p>如果将局部变量的地址给别人，函数结束后，栈被回收，这8个字节的地址就无法被访问到，而且，别人在用这个指针的时候会继续使用原来栈上的4字节对应地址的数据，很有可能会是错的。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>转换</title>
    <url>/2021/06/20/%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h1><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QDateTime dt = QDateTime::<span class="built_in">fromTime_t</span>(extRpt-&gt;msgTimeSecs);</span><br><span class="line">QString strDate = dt.<span class="built_in">toString</span>(<span class="string">&quot;yyyy/MM/dd hh:mm:ss&quot;</span>);<span class="comment">//日期格式自定义</span></span><br><span class="line"></span><br><span class="line">QDateTime::<span class="built_in">fromTime_t</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toTime_t</span>()).<span class="built_in">toString</span>(<span class="string">&quot;yyyy_MM_dd_hh_mm_ss&quot;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">QString strTime = <span class="string">&quot;2020-10-30 08:42:58&quot;</span>;</span><br><span class="line">QString fromat = <span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>;</span><br><span class="line">QDateTime time = QDateTime::<span class="built_in">fromString</span>(strTime, fromat);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果，strTime是utc时间，转换为本地时间</span></span><br><span class="line">time.<span class="built_in">setTimeSpec</span>(Qt::UTC);</span><br><span class="line">QDateTime localTime = time.<span class="built_in">toLocalTime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果，strTime是本地时间，转换为utc时间</span></span><br><span class="line">time.<span class="built_in">setTimeSpec</span>(Qt::LocalTime);</span><br><span class="line">QDateTime utcTime = time.<span class="built_in">toUTC</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;time:      &quot;</span>&lt;&lt;time.<span class="built_in">toString</span>(fromat);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;localTime: &quot;</span>&lt;&lt;localTime.<span class="built_in">toString</span>(fromat);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;utcTime:   &quot;</span>&lt;&lt;utcTime.<span class="built_in">toString</span>(fromat);</span><br><span class="line"></span><br><span class="line"><span class="comment">//time:       &quot;2020-10-30 08:42:58&quot;</span></span><br><span class="line"><span class="comment">//localTime:  &quot;2020-10-30 16:42:58&quot;</span></span><br><span class="line"><span class="comment">//utcTime:    &quot;2020-10-30 00:42:58&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="从时间戳到常规时间："><a href="#从时间戳到常规时间：" class="headerlink" title="从时间戳到常规时间："></a>从时间戳到常规时间：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unixTime2Str</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> strTime[], <span class="keyword">int</span> bufLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span> =</span> *<span class="built_in">localtime</span>((<span class="keyword">time_t</span> *)&amp;n);</span><br><span class="line"><span class="built_in">strftime</span>(strTime, bufLen - <span class="number">1</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;tm);</span><br><span class="line">strTime[bufLen - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> strTime[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1444401700</span>;</span><br><span class="line"><span class="built_in">unixTime2Str</span>(now, strTime, <span class="built_in"><span class="keyword">sizeof</span></span>(strTime));</span><br><span class="line">cout &lt;&lt; strTime &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：2015-10-09 22:41:40</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tm_sec;   <span class="comment">// seconds after the minute - [0, 60] including leap second</span></span><br><span class="line">    <span class="keyword">int</span> tm_min;   <span class="comment">// minutes after the hour - [0, 59]</span></span><br><span class="line">    <span class="keyword">int</span> tm_hour;  <span class="comment">// hours since midnight - [0, 23]</span></span><br><span class="line">    <span class="keyword">int</span> tm_mday;  <span class="comment">// day of the month - [1, 31]</span></span><br><span class="line">    <span class="keyword">int</span> tm_mon;   <span class="comment">// months since January - [0, 11]</span></span><br><span class="line">    <span class="keyword">int</span> tm_year;  <span class="comment">// years since 1900</span></span><br><span class="line">    <span class="keyword">int</span> tm_wday;  <span class="comment">// days since Sunday - [0, 6]</span></span><br><span class="line">    <span class="keyword">int</span> tm_yday;  <span class="comment">// days since January 1 - [0, 365]</span></span><br><span class="line">    <span class="keyword">int</span> tm_isdst; <span class="comment">// daylight savings time flag</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> tick = (<span class="keyword">time_t</span>)RadarReturn.time_sec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">tm = *<span class="built_in">localtime</span>(&amp;tick);</span><br><span class="line"><span class="built_in">strftime</span>(s, <span class="built_in"><span class="keyword">sizeof</span></span>(s), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;tm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> tick = (<span class="keyword">time_t</span>)tv.tv_sec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span> =</span> *<span class="built_in">localtime</span>(&amp;tick);</span><br><span class="line"><span class="built_in">strftime</span>(name, <span class="number">128</span>, <span class="string">&quot;%Y-%m-%d-%H-%M-%S.cpr&quot;</span>, &amp;time);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">tm* t_tm = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line"><span class="comment">// 把 now 转换为字符串形式</span></span><br><span class="line"><span class="comment">//char* dt = ctime(&amp;now);</span></span><br><span class="line"></span><br><span class="line">string tim =  <span class="built_in">to_string</span>(t_tm-&gt;tm_year + <span class="number">1900</span>) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_mon + <span class="number">1</span>) + <span class="string">&quot;_&quot;</span>  +<span class="built_in">to_string</span>(t_tm-&gt;tm_mday) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_hour) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_min) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_sec);</span><br></pre></td></tr></table></figure>



<h3 id="常规时间到时间戳的转换："><a href="#常规时间到时间戳的转换：" class="headerlink" title="常规时间到时间戳的转换："></a>常规时间到时间戳的转换：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">strTime2unix</span><span class="params">(<span class="keyword">char</span> timeStamp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;tm, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tm));</span><br><span class="line"><span class="built_in">sscanf</span>(timeStamp, <span class="string">&quot;%d-%d-%d %d:%d:%d&quot;</span>,</span><br><span class="line">&amp;tm.tm_year, &amp;tm.tm_mon, &amp;tm.tm_mday,</span><br><span class="line">&amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec);</span><br><span class="line">tm.tm_year -= <span class="number">1900</span>;</span><br><span class="line">tm.tm_mon--;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mktime</span>(&amp;tm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> timeStamp[<span class="number">100</span>] = <span class="string">&quot;2015-10-09 22:41:40&quot;</span>;</span><br><span class="line"><span class="keyword">time_t</span> t = <span class="built_in">strTime2unix</span>(timeStamp);</span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"><span class="comment">// additional</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">ctime</span>(&amp;t) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果为：</p>
<p>1444401700</p>
<p>Fri Oct 09 22:41:40 2015</p>
<h2 id="WebKit时间戳-和-Unix时间戳"><a href="#WebKit时间戳-和-Unix时间戳" class="headerlink" title="WebKit时间戳 和 Unix时间戳"></a>WebKit时间戳 和 Unix时间戳</h2><p><a href="https://cloud.tencent.com/developer/article/2211531">https://cloud.tencent.com/developer/article/2211531</a></p>
<p>WebKit时间戳：从1601年1月1日（UTC/GMT的午夜）开始所经过的<strong>微秒</strong>数</p>
<p>Unix时间戳：从1970年1月1日（UTC/GMT的午夜）开始所经过的<strong>秒/毫秒</strong>数</p>
<p><strong>相差其实是固定的11644473600秒</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">date_from_webkit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> webkit_timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QDate <span class="title">date</span><span class="params">(<span class="number">1601</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    QDateTime epoch_start;</span><br><span class="line">    epoch_start.<span class="built_in">setDate</span>(date);</span><br><span class="line">    epoch_start = epoch_start.<span class="built_in">addMSecs</span>(webkit_timestamp);</span><br><span class="line">    QString time=epoch_start.<span class="built_in">toString</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>  time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">webkit_from_date</span><span class="params">(QDateTime time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//秒 计算1970年1月1日到1601年1月1日间隔的秒/毫秒数（其实是固定的11644473600秒）</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> webkit_timestamp= time.<span class="built_in">toSecsSinceEpoch</span>()+<span class="number">11644473600</span>;</span><br><span class="line">    <span class="keyword">return</span> webkit_timestamp*<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="string-转-LPCWSTR"><a href="#string-转-LPCWSTR" class="headerlink" title="string 转 LPCWSTR"></a><strong>string 转 LPCWSTR</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LPCWSTR  <span class="title">StringToLPCWSTR</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> origsize = str.<span class="built_in">length</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> newsize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">size_t</span> convertedChars = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span> *wcstring = (<span class="keyword">wchar_t</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">wchar_t</span>)*(str.<span class="built_in">length</span>() - <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">mbstowcs_s</span>(&amp;convertedChars, wcstring, origsize, str.<span class="built_in">c_str</span>(), _TRUNCATE);</span><br><span class="line">    <span class="keyword">return</span> wcstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const-char-’转-LPCWSTR"><a href="#const-char-’转-LPCWSTR" class="headerlink" title="const char *’转 LPCWSTR"></a>const char *’转 LPCWSTR</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT（）</span><br></pre></td></tr></table></figure>



<h2 id="Char-转TChar"><a href="#Char-转TChar" class="headerlink" title="Char * 转TChar*"></a><strong>Char * 转TChar*</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_bstr_t strVideo=_bstr_t(ui.cbxDshow_Device-&gt;currentText().toLocal8Bit().data());</span><br></pre></td></tr></table></figure>

<h2 id="cstring转wchar"><a href="#cstring转wchar" class="headerlink" title="cstring转wchar *"></a>cstring转wchar *</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> *str = (<span class="keyword">wchar_t</span> *)strline.*GetBufferSetLength*(strline.*GetLength*());</span><br></pre></td></tr></table></figure>

<h2 id="string转wstring"><a href="#string转wstring" class="headerlink" title="string转wstring"></a><strong>string转wstring</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 wstring</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, filename.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">wchar_t</span> *wide = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[num];</span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, filename.<span class="built_in">c_str</span>(), <span class="number">-1</span>, wide, num);</span><br><span class="line"><span class="function">std::wstring <span class="title">w_str</span><span class="params">(wide)</span></span>;</span><br><span class="line"><span class="keyword">delete</span>[] wide;</span><br></pre></td></tr></table></figure>

<h2 id="wchar-转-int"><a href="#wchar-转-int" class="headerlink" title="wchar 转 int"></a><strong>wchar 转 int</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*_ttoi()*</span><br></pre></td></tr></table></figure>



<h2 id="char-转-int"><a href="#char-转-int" class="headerlink" title="char 转 int"></a>char 转 int</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*atoi()*</span><br></pre></td></tr></table></figure>

<h1 id="YUV-转-RGB"><a href="#YUV-转-RGB" class="headerlink" title="YUV 转 RGB"></a>YUV 转 RGB</h1><p>海康摄像机回调解码后的视频数据格式为YV12,顺便说一下YV12的数据格式  YYYY  V U.  我这个是720P,即1280 * 720分辨率. 那么Y分量的数量为 1280 * 720 = 921600 字节, V = U 数量为Y的1/4, 即921600 / 4 =  230400字节,所以一帧720P的YV12数据量为1382400字节,与断点调试查看nSize一致.</p>
<p>这篇博客实现方法均来自网上找的代码,不是自己写的.仅作为一个记录.有一篇博客<a href="http://www.cnblogs.com/dwdxdy/p/3713990.html">YUV与RGB格式转换 </a>里面就是YV12转到BGR的实现,看着它的代码改的.</p>
<p>1.用opencv  颜色空间转换函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mat pImgYCrCb, pImg;</span><br><span class="line">pImgYCrCb.create(720, 1280,CV_8UC3);</span><br><span class="line">pImg.create(720, 1280,CV_8UC3);</span><br><span class="line">yv12toYUV(pImgYCrCb.data, (uchar*)pBuf, pFrameInfo-&gt;nWidth,pFrameInfo-&gt;nHeight,pImgYCrCb.step);	</span><br><span class="line">cvtColor(pImgYCrCb, pImg, CV_YCrCb2RGB);//转化为RGB图像,pImg是输出的帧</span><br><span class="line">void yv12toYUV(uchar *outYuv, uchar *inYv12, int width, int height,int widthStep)  </span><br><span class="line">&#123;  </span><br><span class="line">	int col,row;  </span><br><span class="line">	unsigned int Y,U,V;  </span><br><span class="line">	int tmp;  </span><br><span class="line">	int idx;  </span><br><span class="line">	for (row=0; row&lt;height; row++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		idx=row * widthStep;  </span><br><span class="line">		int rowptr=row*width;  </span><br><span class="line">		for (col=0; col&lt;width; col++)  </span><br><span class="line">		&#123;  </span><br><span class="line">			tmp = (row/2)*(width/2)+(col/2);  </span><br><span class="line">			Y=(unsigned int) inYv12[row*width+col];  </span><br><span class="line">			U=(unsigned int) inYv12[width*height+width*height/4+tmp];  </span><br><span class="line">			V=(unsigned int) inYv12[width*height+tmp];  </span><br><span class="line"> </span><br><span class="line">			outYuv[idx+col*3]   = Y;  </span><br><span class="line">			outYuv[idx+col*3+1] = U;  </span><br><span class="line">			outYuv[idx+col*3+2] = V;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.另一种opencv cvtColor实现,较为简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mat dst(pFrameInfo-&gt;nHeight,pFrameInfo-&gt;nWidth,CV_8UC3);//这里nHeight为720,nWidth为1280,8UC3表示8bit uchar 无符号类型,3通道值</span><br><span class="line">Mat src(pFrameInfo-&gt;nHeight + pFrameInfo-&gt;nHeight/2,pFrameInfo-&gt;nWidth,CV_8UC1,(uchar*)pBuf);</span><br><span class="line">cvtColor(src,dst,CV_YUV2BGR_YV12);</span><br><span class="line">imshow(&quot;bgr&quot;,dst);</span><br><span class="line">waitKey(1);</span><br></pre></td></tr></table></figure>



<p>3.只保留Y分量,观看黑白视频</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uchar Y[921600];</span><br><span class="line">memcpy(Y, pBuf, 921600);</span><br><span class="line">if (Videofile==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    sprintf_s(filename,&quot;is_Y.yuv&quot;,0);</span><br><span class="line">    fopen_s(&amp;Videofile,filename,&quot;wb&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fwrite(Y,921600,1,Videofile);来源： https://blog.csdn.net/shangtao1989/article/details/50260661</span><br></pre></td></tr></table></figure>

<h1 id="各种进制转换库函数"><a href="#各种进制转换库函数" class="headerlink" title="各种进制转换库函数"></a>各种进制转换库函数</h1><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h3 id="1-任意2-36进制数转化为10进制"><a href="#1-任意2-36进制数转化为10进制" class="headerlink" title="1.任意2~36进制数转化为10进制"></a>1.任意2~36进制数转化为10进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">自己实现函数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Atoint</span><span class="params">(string s,<span class="keyword">int</span> radix)</span>    <span class="comment">//s是给定的radix进制字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> t=s[i];</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;t&lt;=<span class="string">&#x27;9&#x27;</span>) ans=ans*radix+t-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ans=ans*radix+t-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strol</span>()函数：</span><br><span class="line">函数原型：<span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">strtol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr, <span class="keyword">char</span> **endptr, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function">格式：base是要转化的数的进制，非法字符会赋值给endptr，nptr是要转化的字符，</span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">20</span>]=<span class="string">&quot;10549stend#12&quot;</span>;  </span><br><span class="line">    <span class="keyword">char</span> *stop;  </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="built_in">strtol</span>(a, &amp;stop, <span class="number">8</span>);   <span class="comment">//将八进制数1054转成十进制，后面均为非法字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, stop);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出556</span></span><br><span class="line">*注意：</span><br><span class="line"><span class="number">1</span>）如果base为<span class="number">0</span>，且字符串不是以<span class="number">0</span>x(或者<span class="number">0</span>X)开头，则按十进制进行转化。</span><br><span class="line"><span class="number">2</span>）如果base为<span class="number">0</span>或者<span class="number">16</span>，并且字符串以<span class="number">0</span>x（或者<span class="number">0</span>X）开头，那么，x（或者X）被忽略，字符串按<span class="number">16</span>进制转化。</span><br><span class="line"><span class="number">3</span>）如果base不等于<span class="number">0</span>和<span class="number">16</span>，并且字符串以<span class="number">0</span>x(或者<span class="number">0</span>X)开头，那么x被视为非法字符。</span><br><span class="line"><span class="number">4</span>）对于nptr指向的字符串，其开头和结尾处的空格被忽视，字符串中间的空格被视为非法字符 。</span><br></pre></td></tr></table></figure>

<h3 id="2-将10进制数转换为任意的n进制数，结果为char型。"><a href="#2-将10进制数转换为任意的n进制数，结果为char型。" class="headerlink" title="2.将10进制数转换为任意的n进制数，结果为char型。"></a>2.将10进制数转换为任意的n进制数，结果为char型。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">自己实现函数</span><br><span class="line"><span class="function">string <span class="title">intToA</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> radix)</span>    <span class="comment">//n是待转数字，radix是指定的进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=n%radix;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=<span class="number">0</span>&amp;&amp;t&lt;=<span class="number">9</span>)    ans+=t+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ans+=t<span class="number">-10</span>+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        n/=radix;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n!=<span class="number">0</span>);    <span class="comment">//使用do&#123;&#125;while（）以防止输入为0的情况</span></span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>）itoa（）函数（可以将一个<span class="number">10</span>进制数转换为任意的<span class="number">2</span><span class="number">-36</span>进制字符串）:</span><br><span class="line">函数原型：<span class="function"><span class="keyword">char</span>*<span class="title">itoa</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">char</span>*string,<span class="keyword">int</span> radix)</span></span>;</span><br><span class="line">格式：<span class="built_in">itoa</span>(num, str, <span class="number">2</span>); num是一个<span class="keyword">int</span>型的，是要转化的<span class="number">10</span>进制数，str是转化结果，后面的值为目标进制。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];  </span><br><span class="line">    _itoa(num, str, <span class="number">2</span>);  <span class="comment">//c++中一般用_itoa，用itoa也行,</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>）<span class="built_in">sprintf</span>()函数（可以将一个<span class="number">10</span>进制数转换为指定格式的n进制字符串）</span><br><span class="line">函数原型：<span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format, [ argument] … )</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, <span class="number">123</span>); <span class="comment">//十进制输出产生&quot;123&quot;</span></span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%4d%4d&quot;</span>, <span class="number">123</span>, <span class="number">4567</span>); <span class="comment">//指定宽度不足的左边补空格，产生：&quot; 1234567&quot;</span></span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%8o&quot;</span>, <span class="number">123</span>);    <span class="comment">//八进制输出，宽度占8个位置</span></span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%8x&quot;</span>, <span class="number">4567</span>); <span class="comment">//小写16 进制，宽度占8 个位置，右对齐</span></span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%10.3f&quot;</span>, <span class="number">3.1415626</span>); <span class="comment">//产生：&quot; 3.142&quot;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.2f&quot;</span>, i);    <span class="comment">//注意这是不对的</span></span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.2f&quot;</span>, (<span class="keyword">double</span>)i);    <span class="comment">//要按照这种方式才行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(s,<span class="string">&quot;%02x &quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)serial_byte_stream.<span class="built_in">at</span>(i));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="3-使用字符串流string，stream"><a href="#3-使用字符串流string，stream" class="headerlink" title="3.使用字符串流string，stream"></a>3.使用字符串流string，stream</h3><p>1）8,16-&gt;10</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;20&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;hex&lt;&lt;s;    <span class="comment">//以16进制读入流中</span></span><br><span class="line">    ss&gt;&gt;a;        <span class="comment">//10进制int型输出</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：32</span></span><br></pre></td></tr></table></figure>

<p>2)10-&gt;8,16</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">30</span>;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;oct&lt;&lt;a;        <span class="comment">//10进制转成八进制读入流中，再以字符串输出</span></span><br><span class="line">    ss&gt;&gt;s1;            </span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;        <span class="comment">//输出：36</span></span><br><span class="line">    ss.<span class="built_in">clear</span>();        <span class="comment">//不清空可能会出错。</span></span><br><span class="line">    ss&lt;&lt;hex&lt;&lt;a;         <span class="comment">//10进制转成十六进制读入流中，，再以字符串输出</span></span><br><span class="line">    ss&gt;&gt;s2;            </span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;        <span class="comment">//输出：1e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="qt"><a href="#qt" class="headerlink" title="qt"></a>qt</h2><h3 id="10进制转16进制的字符串"><a href="#10进制转16进制的字符串" class="headerlink" title="10进制转16进制的字符串"></a>10进制转16进制的字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">两种方式：</span><br><span class="line">第一种：</span><br><span class="line"><span class="keyword">int</span> m_networkNo = <span class="number">6300</span>;</span><br><span class="line">Log::<span class="built_in">debug</span>(QString::<span class="built_in">number</span>(m_networkNo, <span class="number">16</span>));<span class="comment">//这里的log::debug是打印日志（自定义），可换成qDebug</span></span><br><span class="line">带符号十进制 转 两字节十六进制</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">-665</span>;<span class="comment">//正负皆可</span></span><br><span class="line">    QString qnum= QString::<span class="built_in">number</span>(num,<span class="number">16</span>).<span class="built_in">right</span>(<span class="number">4</span>);<span class="comment">//裁剪字符串前面多余的f</span></span><br><span class="line">    std::cout&lt;&lt;qnum.<span class="built_in">toUpper</span>().<span class="built_in">toStdString</span>()&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：FD67</span><br><span class="line"></span><br><span class="line">第二种</span><br><span class="line"><span class="function">QString <span class="title">QString::arg</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> fieldWidth = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>, QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">fieldWidth：字符串指定长度</span></span><br><span class="line"><span class="function">fillChar：不够长度用这个字符进行填充</span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> m_networkNo </span>= <span class="number">6300</span>;</span><br><span class="line"> Log::<span class="built_in">debug</span>(<span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(m_networkNo, <span class="number">6</span>, <span class="number">16</span>, <span class="built_in">QLatin1Char</span>(<span class="string">&#x27;0&#x27;</span>)));</span><br></pre></td></tr></table></figure>

<p>共有三种形式</p>
<p>形式一：显示十六进制的格式<br>收到字符“123”，显示为0x31, 0x32, 0x33</p>
<p>形式二：只显示十六进制的数字<br>收到字符“123”，显示为313233</p>
<p>形式三：显示字符<br>收到字符“123”，显示为123</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString disp_string,S;</span><br><span class="line">QByteArray readComData = serialPort-&gt;<span class="built_in">readAll</span>();</span><br><span class="line"><span class="comment">//形式一：显示十六进制的格式</span></span><br><span class="line"><span class="keyword">if</span>(ui-&gt;checkBox_Hex_disp-&gt;<span class="built_in">isChecked</span>()&amp;&amp;ui-&gt;checkBox_add_char-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;readComData.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        S.<span class="built_in">sprintf</span>(<span class="string">&quot;0x%02x, &quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)readComData.<span class="built_in">at</span>(i));</span><br><span class="line">        disp_string += S;</span><br><span class="line">    &#125;</span><br><span class="line">    ui-&gt;textEdit_Receive-&gt;<span class="built_in">insertPlainText</span>(disp_string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//形式二：只显示十六进制的数字</span></span><br><span class="line">    <span class="keyword">if</span>(ui-&gt;checkBox_Hex_disp-&gt;<span class="built_in">isChecked</span>())</span><br><span class="line">        ui-&gt;textEdit_Receive-&gt;<span class="built_in">insertPlainText</span>(readComData.<span class="built_in">toHex</span>());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//形式三：显示字符</span></span><br><span class="line">    	ui-&gt;textEdit_Receive-&gt;<span class="built_in">insertPlainText</span>(readComData);</span><br><span class="line">ui-&gt;textEdit_Receive-&gt;<span class="built_in">moveCursor</span>(QTextCursor::End);</span><br></pre></td></tr></table></figure>

<h3 id="16-gt-10"><a href="#16-gt-10" class="headerlink" title="16-&gt;10"></a>16-&gt;10</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ok;</span><br><span class="line">QString hex = 16;</span><br><span class="line">int dec = hex.toInt(&amp;ok, 16);</span><br></pre></td></tr></table></figure>

<h3 id="QString-16进制转二进制的char"><a href="#QString-16进制转二进制的char" class="headerlink" title="QString 16进制转二进制的char*"></a>QString 16进制转二进制的char*</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>*   <span class="title">myHexToBin</span><span class="params">(QString inStr, <span class="keyword">char</span> *dest, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=inStr.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;size &amp;&amp; j&lt;len;i+=<span class="number">2</span>,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> tempC,bcd;</span><br><span class="line">        tempC=inStr.<span class="built_in">at</span>(i).<span class="built_in">toLatin1</span>();</span><br><span class="line">        <span class="keyword">if</span> (tempC&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; tempC&lt;=<span class="string">&#x27;f&#x27;</span>) tempC=tempC-<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        bcd = ( tempC&gt;=<span class="string">&#x27;A&#x27;</span>? tempC - <span class="string">&#x27;A&#x27;</span>+ <span class="number">0x0a</span>:tempC - <span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        tempC=inStr.<span class="built_in">at</span>(i+<span class="number">1</span>).<span class="built_in">toLatin1</span>();</span><br><span class="line">        <span class="keyword">if</span> (tempC&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; tempC&lt;=<span class="string">&#x27;f&#x27;</span>) tempC=tempC-<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        bcd += tempC&gt;=<span class="string">&#x27;A&#x27;</span>? tempC - <span class="string">&#x27;A&#x27;</span>+ <span class="number">0x0a</span>:tempC - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(dest+j, <span class="string">&quot;%c&quot;</span>,bcd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//16-&gt;10</span></span><br><span class="line">QString hex = <span class="string">&quot;16&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> dec = hex.<span class="built_in">toInt</span>(&amp;ok, <span class="number">16</span>);</span><br><span class="line"><span class="comment">//10-&gt;16</span></span><br><span class="line">hex = QString::<span class="built_in">number</span>(dec, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<h1 id="内存数组或者Mat转CImage"><a href="#内存数组或者Mat转CImage" class="headerlink" title="内存数组或者Mat转CImage"></a>内存数组或者Mat转CImage</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatToCImage</span><span class="params">(cv::Mat &amp;mat, CImage &amp;cImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//create new CImage</span></span><br><span class="line">	<span class="keyword">int</span> width = mat.cols;</span><br><span class="line">	<span class="keyword">int</span> height = mat.rows;</span><br><span class="line">	<span class="keyword">int</span> channels = mat.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line">	cImage.<span class="built_in">Destroy</span>(); <span class="comment">//clear</span></span><br><span class="line">	cImage.<span class="built_in">Create</span>(width, height, <span class="number">8</span> * <span class="number">3</span>); <span class="comment">//默认图像像素单通道占用1个字节，3通道</span></span><br><span class="line"></span><br><span class="line">												<span class="comment">//copy values</span></span><br><span class="line">	uchar* ps;</span><br><span class="line">	uchar* pimg = (uchar*)cImage.<span class="built_in">GetBits</span>(); <span class="comment">//A pointer to the bitmap buffer</span></span><br><span class="line">	<span class="keyword">int</span> step = cImage.<span class="built_in">GetPitch</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ps = (mat.ptr&lt;uchar&gt;(i));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">			&#123;</span><br><span class="line">				*(pimg + i*step + j * <span class="number">3</span> + k) = ps[height*i+j * <span class="number">4</span> + k];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CUDP2FileMFCDlg::dataToCImage</span><span class="params">(Uint8 *out_buffer_Video, CImage &amp;cImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//create new CImage</span></span><br><span class="line">	<span class="keyword">int</span> width = pVideoCodecCtx-&gt;width;</span><br><span class="line">	<span class="keyword">int</span> height = pVideoCodecCtx-&gt;height;</span><br><span class="line">	<span class="comment">//int channels = mat.channels();</span></span><br><span class="line"></span><br><span class="line">	cImage.<span class="built_in">Destroy</span>(); <span class="comment">//clear</span></span><br><span class="line">	cImage.<span class="built_in">Create</span>(width, height, <span class="number">8</span> * <span class="number">3</span>); <span class="comment">//默认图像像素单通道占用1个字节</span></span><br><span class="line"></span><br><span class="line">										 <span class="comment">//copy values</span></span><br><span class="line">	uchar* pimg = (uchar*)cImage.<span class="built_in">GetBits</span>(); <span class="comment">//A pointer to the bitmap buffer</span></span><br><span class="line">	<span class="keyword">int</span> step = cImage.<span class="built_in">GetPitch</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)</span><br><span class="line">			&#123;</span><br><span class="line">				*(pimg + i*step + j * <span class="number">3</span> + k) = out_buffer_Video[width*i*<span class="number">4</span> + j * <span class="number">4</span> + k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="QImage转cv-Mat"><a href="#QImage转cv-Mat" class="headerlink" title="QImage转cv::Mat"></a>QImage转cv::Mat</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">QImage2cvMat</span><span class="params">(<span class="keyword">const</span> QImage &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat mat;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(image.format())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_Grayscale8: <span class="comment">//灰度图，每个像素点1个字节（8位）</span></span><br><span class="line">        <span class="comment">//Mat构造：行数，列数，存储结构，数据，step每行多少字节</span></span><br><span class="line">        mat = cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC1, (<span class="keyword">void</span>*)image.<span class="built_in">constBits</span>(), image.<span class="built_in">bytesPerLine</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_ARGB32: <span class="comment">//32位存储0xAARRGGBB，pc一般小端存储低位在前，所以字节顺序就成了BGRA</span></span><br><span class="line">    <span class="keyword">case</span> QImage::Format_RGB32: <span class="comment">//Alpha为FF</span></span><br><span class="line">    <span class="keyword">case</span> QImage::Format_ARGB32_Premultiplied:</span><br><span class="line">        mat = cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC4, (<span class="keyword">void</span>*)image.<span class="built_in">constBits</span>(), image.<span class="built_in">bytesPerLine</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_RGB888: <span class="comment">//RR,GG,BB字节顺序存储</span></span><br><span class="line">        mat = cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_8UC3, (<span class="keyword">void</span>*)image.<span class="built_in">constBits</span>(), image.<span class="built_in">bytesPerLine</span>());</span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(mat, mat, cv::COLOR_RGB2BGR); <span class="comment">//opencv需要转为BGR的字节顺序</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QImage::Format_RGBA64: <span class="comment">//64为存储，顺序和Format_ARGB32相反</span></span><br><span class="line">        mat = cv::<span class="built_in">Mat</span>(image.<span class="built_in">height</span>(), image.<span class="built_in">width</span>(), CV_16UC4, (<span class="keyword">void</span>*)image.<span class="built_in">constBits</span>(), image.<span class="built_in">bytesPerLine</span>());</span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(mat, mat, cv::COLOR_RGB2BGR); <span class="comment">//opencv需要转为BGR的字节顺序</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="cv-Mat转QImage"><a href="#cv-Mat转QImage" class="headerlink" title="cv::Mat转QImage"></a>cv::Mat转QImage</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QImage <span class="title">cvMat2QImage</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QImage image;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(mat.<span class="built_in">type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC1:</span><br><span class="line">        <span class="comment">//QImage构造：数据，宽度，高度，每行多少字节，存储结构</span></span><br><span class="line">        image = <span class="built_in">QImage</span>((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*)mat.data, mat.cols, mat.rows, mat.cols, QImage::Format_Grayscale8);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC3:</span><br><span class="line">        image = <span class="built_in">QImage</span>((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*)mat.data, mat.cols, mat.rows, mat.cols * <span class="number">3</span>, QImage::Format_RGB888);</span><br><span class="line">        image = image.<span class="built_in">rgbSwapped</span>(); <span class="comment">//BRG转为RGB</span></span><br><span class="line">        <span class="comment">//Qt5.14增加了Format_BGR888</span></span><br><span class="line">        <span class="comment">//image = QImage((const unsigned char*)mat.data, mat.cols, mat.rows, mat.cols * 3, QImage::Format_BGR888);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC4:</span><br><span class="line">        image = <span class="built_in">QImage</span>((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*)mat.data, mat.cols, mat.rows, mat.cols * <span class="number">4</span>, QImage::Format_ARGB32);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Qt-二进制与图片互转"><a href="#Qt-二进制与图片互转" class="headerlink" title="Qt 二进制与图片互转"></a>Qt 二进制与图片互转</h1><h2 id="QImage写入缓存（压缩较高）"><a href="#QImage写入缓存（压缩较高）" class="headerlink" title="QImage写入缓存（压缩较高）"></a>QImage写入缓存（压缩较高）</h2><p>QByteArray转化为 QImage:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage image;</span><br><span class="line">QByteArray ba;</span><br><span class="line">image.<span class="built_in">loadFromData</span>(ba);</span><br></pre></td></tr></table></figure>
<p>QImage转化为 QByteArray:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage image;</span><br><span class="line">QByteArray imageArray;</span><br><span class="line">QBuffer buffer;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">image.<span class="built_in">save</span>(&amp;buffer,<span class="string">&quot;PNG&quot;</span>);</span><br><span class="line">imageArray.<span class="built_in">append</span>(buffer.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage image;</span><br><span class="line">QByteArray ba;</span><br><span class="line"><span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;ba)</span></span>;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">image.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;PNG&quot;</span>); <span class="comment">// write image into ba in PNG format</span></span><br></pre></td></tr></table></figure>
<p>转自 How to Store and Retrieve Image on SQLite:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPixmap inPixmap;<span class="comment">//store it in a QByteArray</span></span><br><span class="line">QByteArray inByteArray;</span><br><span class="line"><span class="function">QBuffer <span class="title">inBuffer</span><span class="params">( &amp;inByteArray )</span></span>;</span><br><span class="line">inBuffer.<span class="built_in">open</span>( QIODevice::WriteOnly );</span><br><span class="line">inPixmap.<span class="built_in">save</span>( &amp;inBuffer, <span class="string">&quot;PNG&quot;</span> ); <span class="comment">// write inPixmap into inByteArray in PNG format</span></span><br></pre></td></tr></table></figure>

<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;1.jpg&quot;</span>)</span></span>;</span><br><span class="line">QByteArray bitimg;</span><br><span class="line">file.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">bitimg = file.<span class="built_in">readAll</span>();</span><br></pre></td></tr></table></figure>

<h2 id="不压缩RGB"><a href="#不压缩RGB" class="headerlink" title="不压缩RGB"></a>不压缩RGB</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QImage <span class="title">img</span><span class="params">(<span class="string">&quot;1.jpg&quot;</span>)</span></span>;                                                           </span><br><span class="line"><span class="function">QByteArray <span class="title">bitimg1</span><span class="params">((<span class="keyword">char</span> *)img.bits(),img.width()*img.height()*img.depth()/<span class="number">8</span>)</span></span>; </span><br></pre></td></tr></table></figure>



<h1 id="python-二进制与图片互转"><a href="#python-二进制与图片互转" class="headerlink" title="python 二进制与图片互转"></a>python 二进制与图片互转</h1><p><a href="https://blog.csdn.net/weixin_37763340/article/details/116717743">https://blog.csdn.net/weixin_37763340/article/details/116717743</a></p>
<h2 id="PIL格式转二进制（压缩较高，可以用qt的缓存直接转换成图片）"><a href="#PIL格式转二进制（压缩较高，可以用qt的缓存直接转换成图片）" class="headerlink" title="PIL格式转二进制（压缩较高，可以用qt的缓存直接转换成图片）"></a>PIL格式转二进制（压缩较高，可以用qt的缓存直接转换成图片）</h2><p>先读取为PIL格式，再转为二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image2byte</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    图片转byte</span></span><br><span class="line"><span class="string">    image: 必须是PIL格式</span></span><br><span class="line"><span class="string">    image_bytes: 二进制</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 创建一个字节流管道</span></span><br><span class="line">    img_bytes = io.BytesIO()</span><br><span class="line">    <span class="comment"># 将图片数据存入字节流管道， format可以按照具体文件的格式填写</span></span><br><span class="line">    image.save(img_bytes, <span class="built_in">format</span>=<span class="string">&quot;JPEG&quot;</span>)</span><br><span class="line">    <span class="comment"># 从字节流管道中获取二进制</span></span><br><span class="line">    image_bytes = img_bytes.getvalue()</span><br><span class="line">    <span class="keyword">return</span> image_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2image</span>(<span class="params">byte_data</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    byte转为图片</span></span><br><span class="line"><span class="string">    byte_data: 二进制</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(io.BytesIO(byte_data))</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<p>调用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_path = <span class="string">&quot;img/3.jpg&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">byte_data = image2byte(image)</span><br><span class="line">image2 = byte2image(byte_data)</span><br></pre></td></tr></table></figure>

<h2 id="数组转二进制"><a href="#数组转二进制" class="headerlink" title="数组转二进制"></a>数组转二进制</h2><p>先用opencv读取为数组格式，再转为二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numpy2byte</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    数组转二进制</span></span><br><span class="line"><span class="string">    image : numpy矩阵/cv格式图片</span></span><br><span class="line"><span class="string">    byte_data：二进制数据</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#对数组的图片格式进行编码</span></span><br><span class="line">    success,encoded_image = cv2.imencode(<span class="string">&quot;.jpg&quot;</span>,image)</span><br><span class="line">    <span class="comment">#将数组转为bytes</span></span><br><span class="line">    byte_data = encoded_image.tobytes()</span><br><span class="line">    <span class="keyword">return</span> byte_data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2numpy</span>(<span class="params">byte_data</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    byte转numpy矩阵/cv格式</span></span><br><span class="line"><span class="string">    byte_data：二进制数据</span></span><br><span class="line"><span class="string">    image : numpy矩阵/cv格式图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    image = np.asarray(<span class="built_in">bytearray</span>(byte_data), dtype=<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line">    image = cv2.imdecode(image, cv2.IMREAD_COLOR)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<p>调用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_path = <span class="string">&quot;img/3.jpg&quot;</span></span><br><span class="line">image = cv2.imread(image_path)</span><br><span class="line">byte_data = numpy2byte(image)</span><br><span class="line">image2 = byte2numpy(byte_data)</span><br></pre></td></tr></table></figure>

<h2 id="图片转二进制"><a href="#图片转二进制" class="headerlink" title="图片转二进制"></a>图片转二进制</h2><p>直接读取图片为二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read2byte</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    图片转二进制</span></span><br><span class="line"><span class="string">    path：图片路径</span></span><br><span class="line"><span class="string">    byte_data：二进制数据</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        byte_data = f.read()</span><br><span class="line">    <span class="keyword">return</span> byte_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2numpy</span>(<span class="params">byte_data</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    byte转numpy矩阵/cv格式</span></span><br><span class="line"><span class="string">    byte_data：二进制数据</span></span><br><span class="line"><span class="string">    image : numpy矩阵/cv格式图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    image = np.asarray(<span class="built_in">bytearray</span>(byte_data), dtype=<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line">    image = cv2.imdecode(image, cv2.IMREAD_COLOR)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<p>调用代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_path = <span class="string">&quot;img/3.jpg&quot;</span></span><br><span class="line">byte_data = read2byte(image_path)</span><br><span class="line">image = byte2numpy(byte_data)</span><br></pre></td></tr></table></figure>

<h1 id="python-图片和base64互转的三种方式"><a href="#python-图片和base64互转的三种方式" class="headerlink" title="python 图片和base64互转的三种方式"></a>python 图片和base64互转的三种方式</h1><p><a href="https://blog.csdn.net/weixin_37763340/article/details/121349492">https://blog.csdn.net/weixin_37763340/article/details/121349492</a></p>
<h2 id="通过cv2进行转换"><a href="#通过cv2进行转换" class="headerlink" title="通过cv2进行转换"></a>通过cv2进行转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_base64</span>(<span class="params">img_array</span>):</span></span><br><span class="line">    <span class="comment"># 传入图片为RGB格式numpy矩阵，传出的base64也是通过RGB的编码</span></span><br><span class="line">    img_array = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR) <span class="comment">#RGB2BGR，用于cv2编码</span></span><br><span class="line">    encode_image = cv2.imencode(<span class="string">&quot;.jpg&quot;</span>, img_array)[<span class="number">1</span>] <span class="comment">#用cv2压缩/编码，转为一维数组</span></span><br><span class="line">    byte_data = encode_image.tobytes() <span class="comment">#转换为二进制</span></span><br><span class="line">    base64_str = base64.b64encode(byte_data).decode(<span class="string">&quot;ascii&quot;</span>) <span class="comment">#转换为base64</span></span><br><span class="line">    <span class="keyword">return</span> base64_str</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_to_img</span>(<span class="params">base64_str</span>):</span></span><br><span class="line">    <span class="comment"># 传入为RGB格式下的base64，传出为RGB格式的numpy矩阵</span></span><br><span class="line">    byte_data = base64.b64decode(base64_str)<span class="comment">#将base64转换为二进制</span></span><br><span class="line">    encode_image = np.asarray(<span class="built_in">bytearray</span>(byte_data), dtype=<span class="string">&quot;uint8&quot;</span>)<span class="comment"># 二进制转换为一维数组</span></span><br><span class="line">    img_array = cv2.imdecode(encode_image, cv2.IMREAD_COLOR)<span class="comment"># 用cv2解码为三通道矩阵</span></span><br><span class="line">    img_array = cv2.cvtColor(img_array, cv2.COLOR_BGR2RGB)<span class="comment"># BGR2RGB</span></span><br><span class="line">    <span class="keyword">return</span> img_array</span><br></pre></td></tr></table></figure>

<p>方法调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">100</span>,<span class="number">100</span>,<span class="number">3</span>), dtype=np.uint8)</span><br><span class="line">img[:,:,<span class="number">2</span>]=<span class="number">255</span></span><br><span class="line">base64_img = img_to_base64(img)</span><br><span class="line">img_from_base64 = base64_to_img(base64_img)</span><br></pre></td></tr></table></figure>


<p>结果显示：</p>
<p><img src="https://img-blog.csdnimg.cn/6ef7b635f6714f54bc828bcfe2750e47.png#pic_left" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/842073352a3d40a8aeceb0950204f1da.png#pic_left" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/7034605d3967422989e252578affecdd.png#pic_left" alt="img"></p>
<h2 id="通过PIL进行转换"><a href="#通过PIL进行转换" class="headerlink" title="通过PIL进行转换"></a>通过PIL进行转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_to_base64</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="comment"># 输入为PIL读取的图片，输出为base64格式</span></span><br><span class="line">    byte_data = BytesIO()<span class="comment"># 创建一个字节流管道</span></span><br><span class="line">    image.save(byte_data, <span class="built_in">format</span>=<span class="string">&quot;JPEG&quot;</span>)<span class="comment"># 将图片数据存入字节流管道</span></span><br><span class="line">    byte_data = byte_data.getvalue()<span class="comment"># 从字节流管道中获取二进制</span></span><br><span class="line">    base64_str = base64.b64encode(byte_data).decode(<span class="string">&quot;ascii&quot;</span>)<span class="comment"># 二进制转base64</span></span><br><span class="line">    <span class="keyword">return</span> base64_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_to_image</span>(<span class="params">base64_str</span>):</span></span><br><span class="line">    <span class="comment"># 输入为base64格式字符串，输出为PIL格式图片</span></span><br><span class="line">    byte_data = base64.b64decode(base64_str) <span class="comment"># base64转二进制</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(BytesIO(byte_data)) <span class="comment"># 将二进制转为PIL格式图片</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<p>方法调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = np.zeros((<span class="number">100</span>,<span class="number">100</span>,<span class="number">3</span>),dtype=np.uint8)</span><br><span class="line">img[:,:,<span class="number">2</span>]=<span class="number">255</span></span><br><span class="line">image = Image.fromarray(img)</span><br><span class="line">base64_str = image_to_base64(image)</span><br><span class="line">image_from_base64=base64_to_image(base64_str)</span><br></pre></td></tr></table></figure>

<p>结果显示：</p>
<p><img src="https://img-blog.csdnimg.cn/4e402ffedf2f4c6e8667254f4814a824.png#pic_left" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/179a519c37c840fd9a983dfa4170a41c.png#pic_left" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/d51ca610862b4b599519218a36cee655.png#pic_left" alt="img"></p>
<p>直接读取图片方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path2base64</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        byte_data = f.read()</span><br><span class="line">    base64_str = base64.b64encode(byte_data).decode(<span class="string">&quot;ascii&quot;</span>)<span class="comment"># 二进制转base64</span></span><br><span class="line">    <span class="keyword">return</span> base64_str</span><br></pre></td></tr></table></figure>


<p>方法调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base64_img = path2base64(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">img_from_base64 = base64_to_img(base64_img)</span><br></pre></td></tr></table></figure>

<p>总结<br>无论使用哪种方式进行图片和base64的互相转换，都需要中间变量——二进制格式。<br>基本过程都为：base64 &lt;——&gt; 二进制 &lt;——&gt; 图片</p>
<h1 id="QByteArray-转换为-16进制字符串QString"><a href="#QByteArray-转换为-16进制字符串QString" class="headerlink" title="QByteArray 转换为 16进制字符串QString"></a>QByteArray 转换为 16进制字符串QString</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">ByteArrayToHexString</span><span class="params">(QByteArray data)</span></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">ret</span><span class="params">(data.toHex().toUpper())</span></span>;</span><br><span class="line">    <span class="keyword">int</span> len = ret.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;len;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        qDebug()&lt;&lt;i;</span></span><br><span class="line">        ret.<span class="built_in">insert</span>(<span class="number">2</span>*i+i<span class="number">-1</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="QByteArray-转为unsigned-char"><a href="#QByteArray-转为unsigned-char" class="headerlink" title="QByteArray 转为unsigned char *"></a>QByteArray 转为unsigned char *</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QByteArray byteArray;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> * p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)byteArray.<span class="built_in">data</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="char-转换成-QString"><a href="#char-转换成-QString" class="headerlink" title="char* 转换成 QString"></a>char* 转换成 QString</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">QString c=<span class="built_in">QString</span>(p);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="QString-转换为-Hex-ByteArray"><a href="#QString-转换为-Hex-ByteArray" class="headerlink" title="QString 转换为 Hex ByteArray"></a><a href="https://so.csdn.net/so/search?q=QString&spm=1001.2101.3001.7020">QString</a> 转换为 Hex ByteArray</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SimSerialPort::convertStringToHex</span><span class="params">(<span class="keyword">const</span> QString &amp;str, QByteArray &amp;byteData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hexdata,lowhexdata;</span><br><span class="line">    <span class="keyword">int</span> hexdatalen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    byteData.<span class="built_in">resize</span>(len/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span> lstr,hstr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//char lstr,</span></span><br><span class="line">        hstr=str[i].<span class="built_in">toLatin1</span>();</span><br><span class="line">        <span class="keyword">if</span>(hstr == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        lstr = str[i].<span class="built_in">toLatin1</span>();</span><br><span class="line">        hexdata = <span class="built_in">convertCharToHex</span>(hstr);</span><br><span class="line">        lowhexdata = <span class="built_in">convertCharToHex</span>(lstr);</span><br><span class="line">        <span class="keyword">if</span>((hexdata == <span class="number">16</span>) || (lowhexdata == <span class="number">16</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hexdata = hexdata*<span class="number">16</span>+lowhexdata;</span><br><span class="line">        i++;</span><br><span class="line">        byteData[hexdatalen] = (<span class="keyword">char</span>)hexdata;</span><br><span class="line">        hexdatalen++;</span><br><span class="line">    &#125;</span><br><span class="line">    byteData.<span class="built_in">resize</span>(hexdatalen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">SimSerialPort::convertCharToHex</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((ch &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (ch &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">         <span class="keyword">return</span> ch<span class="number">-0x30</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>((ch &gt;= <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (ch &lt;= <span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">         <span class="keyword">return</span> ch-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>((ch &gt;= <span class="string">&#x27;a&#x27;</span>) &amp;&amp; (ch &lt;= <span class="string">&#x27;f&#x27;</span>))</span><br><span class="line">         <span class="keyword">return</span> ch-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="QString字符串转QByteArray方法"><a href="#QString字符串转QByteArray方法" class="headerlink" title="QString字符串转QByteArray方法"></a>QString字符串转QByteArray方法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt5.3.2</span></span><br><span class="line"><span class="function">QString <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  </span><br><span class="line">QByteArray bytes = str.<span class="built_in">toUtf8</span>(); <span class="comment">// QString转QByteArray方法1 </span></span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  </span><br><span class="line">QByteArray bytes = str.<span class="built_in">toLatin1</span>();  <span class="comment">// QString转QByteArray方法2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="16进制字符串QString转换QByteArray"><a href="#16进制字符串QString转换QByteArray" class="headerlink" title="16进制字符串QString转换QByteArray"></a>16进制字符串QString转换QByteArray</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @breif 将16进制字符串转换为对应的字节序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">QByteArray <span class="title">MainWindow::HexStringToByteArray</span><span class="params">(QString HexString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ok;</span><br><span class="line">    QByteArray ret;</span><br><span class="line">    HexString = HexString.<span class="built_in">trimmed</span>();</span><br><span class="line">    HexString = HexString.<span class="built_in">simplified</span>();</span><br><span class="line">    QStringList sl = HexString.<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    foreach (QString s, sl) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.<span class="built_in">toInt</span>(&amp;ok,<span class="number">16</span>)&amp;<span class="number">0xFF</span>;</span><br><span class="line">            <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">                ret.<span class="built_in">append</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;非法的16进制字符：&quot;</span>&lt;&lt;s;</span><br><span class="line">                QMessageBox::<span class="built_in">warning</span>(<span class="number">0</span>,<span class="built_in">tr</span>(<span class="string">&quot;错误：&quot;</span>),<span class="built_in">QString</span>(<span class="string">&quot;非法的16进制字符: \&quot;%1\&quot;&quot;</span>).<span class="built_in">arg</span>(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>视频</title>
    <url>/2021/07/13/%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h1><p>所谓码率，是指每秒时间内的数据流量。码率越高，对画面的描述就越精细，画质的损失就越小，所得到的画面就越接近于原始画面。但同时也需要更大的存贮空间来存放这些数据，也就是说，码率越高，碟片上可装载的节目时间就越短。</p>
<p>基本上网络电视都是300KBPS 也就是需要大概每秒38K/S的传输带宽</p>
<p>所以码率只是一个描述网络电视每秒的数据流量，如果码率很高的，则需要更高的网络带宽支持，如果不够的话，则可能造成画面延迟或丢失。</p>
<p>码率设置多少合适?</p>
<p>1、视频码率一般设定在2500k即可，如果视频码率设置过高会导致，会导致眼睛的疲劳感加重影响观影效果，所以一般设置成2500k，不会造成眼睛疲劳。</p>
<p>2、视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。</p>
<h1 id="YV12-转-RGB"><a href="#YV12-转-RGB" class="headerlink" title="YV12 转 RGB"></a>YV12 转 RGB</h1><p>海康摄像机回调解码后的视频数据格式为YV12,顺便说一下YV12的数据格式  YYYY  V U.  这个是720P,即1280 * 720分辨率. 那么Y分量的数量为 1280 * 720 = 921600 字节, V = U 数量为Y的1/4, 即921600 / 4 =  230400字节,所以一帧720P的YV12数据量为1382400字节,与断点调试查看nSize一致.</p>
<p>这篇博客实现方法均来自网上找的代码,不是自己写的.仅作为一个记录.有一篇博客<a href="http://www.cnblogs.com/dwdxdy/p/3713990.html">YUV与RGB格式转换 </a>里面就是YV12转到BGR的实现,看着它的代码改的.</p>
<h2 id="1-用opencv-颜色空间转换函数"><a href="#1-用opencv-颜色空间转换函数" class="headerlink" title="1.用opencv  颜色空间转换函数"></a>1.用opencv  颜色空间转换函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat pImgYCrCb, pImg;</span><br><span class="line">pImgYCrCb.<span class="built_in">create</span>(<span class="number">720</span>, <span class="number">1280</span>,CV_8UC3);</span><br><span class="line">pImg.<span class="built_in">create</span>(<span class="number">720</span>, <span class="number">1280</span>,CV_8UC3);</span><br><span class="line"><span class="built_in">yv12toYUV</span>(pImgYCrCb.data, (uchar*)pBuf, pFrameInfo-&gt;nWidth,pFrameInfo-&gt;nHeight,pImgYCrCb.step);	</span><br><span class="line"><span class="built_in">cvtColor</span>(pImgYCrCb, pImg, CV_YCrCb2RGB);<span class="comment">//转化为RGB图像,pImg是输出的帧</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yv12toYUV</span><span class="params">(uchar *outYuv, uchar *inYv12, <span class="keyword">int</span> width, <span class="keyword">int</span> height,<span class="keyword">int</span> widthStep)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> col,row;  </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> Y,U,V;  </span><br><span class="line">	<span class="keyword">int</span> tmp;  </span><br><span class="line">	<span class="keyword">int</span> idx;  </span><br><span class="line">	<span class="keyword">for</span> (row=<span class="number">0</span>; row&lt;height; row++)  </span><br><span class="line">	&#123;  </span><br><span class="line">		idx=row * widthStep;  </span><br><span class="line">		<span class="keyword">int</span> rowptr=row*width;  </span><br><span class="line">		<span class="keyword">for</span> (col=<span class="number">0</span>; col&lt;width; col++)  </span><br><span class="line">		&#123;  </span><br><span class="line">			tmp = (row/<span class="number">2</span>)*(width/<span class="number">2</span>)+(col/<span class="number">2</span>);  </span><br><span class="line">			Y=(<span class="keyword">unsigned</span> <span class="keyword">int</span>) inYv12[row*width+col];  </span><br><span class="line">			U=(<span class="keyword">unsigned</span> <span class="keyword">int</span>) inYv12[width*height+width*height/<span class="number">4</span>+tmp];  </span><br><span class="line">			V=(<span class="keyword">unsigned</span> <span class="keyword">int</span>) inYv12[width*height+tmp];  </span><br><span class="line"> </span><br><span class="line">			outYuv[idx+col*<span class="number">3</span>]   = Y;  </span><br><span class="line">			outYuv[idx+col*<span class="number">3</span>+<span class="number">1</span>] = U;  </span><br><span class="line">			outYuv[idx+col*<span class="number">3</span>+<span class="number">2</span>] = V;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-另一种opencv-cvtColor实现-较为简单"><a href="#2-另一种opencv-cvtColor实现-较为简单" class="headerlink" title="2.另一种opencv cvtColor实现,较为简单"></a>2.另一种opencv cvtColor实现,较为简单</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">dst</span><span class="params">(pFrameInfo-&gt;nHeight,pFrameInfo-&gt;nWidth,CV_8UC3)</span></span>;<span class="comment">//这里nHeight为720,nWidth为1280,8UC3表示8bit uchar 无符号类型,3通道值</span></span><br><span class="line"><span class="function">Mat <span class="title">src</span><span class="params">(pFrameInfo-&gt;nHeight + pFrameInfo-&gt;nHeight/<span class="number">2</span>,pFrameInfo-&gt;nWidth,CV_8UC1,(uchar*)pBuf)</span></span>;</span><br><span class="line"><span class="built_in">cvtColor</span>(src,dst,CV_YUV2BGR_YV12);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;bgr&quot;</span>,dst);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-只保留Y分量-观看黑白视频"><a href="#3-只保留Y分量-观看黑白视频" class="headerlink" title="3.只保留Y分量,观看黑白视频"></a>3.只保留Y分量,观看黑白视频</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uchar Y[<span class="number">921600</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(Y, pBuf, <span class="number">921600</span>);</span><br><span class="line"><span class="keyword">if</span> (Videofile==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf_s</span>(filename,<span class="string">&quot;is_Y.yuv&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fopen_s</span>(&amp;Videofile,filename,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwrite</span>(Y,<span class="number">921600</span>,<span class="number">1</span>,Videofile);</span><br></pre></td></tr></table></figure>

<h1 id="linux-使用海康库-流模式"><a href="#linux-使用海康库-流模式" class="headerlink" title="linux 使用海康库  流模式"></a><a href="https://blog.csdn.net/weixin_41869700/article/details/104259008">linux 使用海康库  流模式</a></h1><blockquote>
<p>调用过程和chm中说的一样，只是头文件不一样！！！！！！！</p>
<p>Windows下面直接使用plaympeg4.h,但是Linux下面不是，要搜索一下，是LinuxPlayM4.h,转换函数(ConverPictureFun)的写法有点不一样，同时，还需要一个GeneralDef.h文件</p>
</blockquote>
<p>调用过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;plaympeg4.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">LONG lPort; <span class="comment">//全局的播放库port号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> linux</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">ConverPictureFun</span><span class="params">(<span class="keyword">int</span> nPort, <span class="keyword">char</span> * pBuf, <span class="keyword">int</span> nSize, FRAME_INFO * pFrameInfo,  <span class="keyword">void</span> * nReserved1, <span class="keyword">int</span> nReserved2)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">ConverPictureFun</span><span class="params">(<span class="keyword">long</span> nPort, <span class="keyword">char</span> * pBuf, <span class="keyword">long</span> nSize, FRAME_INFO * pFrameInfo, <span class="keyword">long</span> nReserved1, <span class="keyword">long</span> nReserved2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="function">cv::Mat <span class="title">srcImage</span><span class="params">(pFrameInfo-&gt;nHeight<span class="comment">/* + pFrameInfo-&gt;nHeight/2*/</span>,pFrameInfo-&gt;nWidth,CV_8UC1,(uchar*)pBuf)</span></span>;</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;DataCallBack&quot;&lt;&lt;nPort&lt;&lt;nSize&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">g_RealDataCallBack_V30</span><span class="params">(LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND hWnd = <span class="built_in">GetConsoleWindow</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (dwDataType)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> NET_DVR_SYSHEAD: <span class="comment">//系统头</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">PlayM4_GetPort</span>(&amp;lPort))  <span class="comment">//获取播放库未使用的通道号</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//m_iPort = lPort; //第一次回调的是系统头，将获取的播放库port号赋值给全局port，下次回调数据时即使用此port号播放</span></span><br><span class="line">		<span class="keyword">if</span> (dwBufSize &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">PlayM4_SetStreamOpenMode</span>(lPort, STREAME_REALTIME))  <span class="comment">//设置实时流播放模式</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">PlayM4_OpenStream</span>(lPort, pBuffer, dwBufSize, <span class="number">1024</span>*<span class="number">1024</span>)) <span class="comment">//打开流接口</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">PlayM4_SetDecCallBack</span>(lPort, ConverPictureFun))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;	</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">PlayM4_Play</span>(lPort, hWnd)) <span class="comment">//播放开始</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> NET_DVR_STREAMDATA:   <span class="comment">//码流数据</span></span><br><span class="line">		<span class="keyword">if</span> (dwBufSize &gt; <span class="number">0</span> &amp;&amp; lPort != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">PlayM4_InputData</span>(lPort, pBuffer, dwBufSize))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">g_ExceptionCallBack</span><span class="params">(DWORD dwType, LONG lUserID, LONG lHandle, <span class="keyword">void</span> *pUser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tempbuf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(dwType) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> EXCEPTION_RECONNECT:    <span class="comment">//预览时重连</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------reconnect--------%d\n&quot;</span>, <span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------------------------------------</span></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="built_in">NET_DVR_Init</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//---------------------------------------</span></span><br><span class="line">  <span class="comment">// 注册设备</span></span><br><span class="line">  LONG lUserID;</span><br><span class="line">  NET_DVR_DEVICEINFO_V30 struDeviceInfo;</span><br><span class="line">  lUserID = <span class="built_in">NET_DVR_Login_V30</span>(<span class="string">&quot;172.0.0.100&quot;</span>, <span class="number">8000</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;12345&quot;</span>, &amp;struDeviceInfo);</span><br><span class="line">  <span class="keyword">if</span> (lUserID &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Login error, %d\n&quot;</span>, <span class="built_in">NET_DVR_GetLastError</span>());</span><br><span class="line">       <span class="built_in">NET_DVR_Cleanup</span>();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------------------------------------</span></span><br><span class="line">  <span class="comment">//设置异常消息回调函数</span></span><br><span class="line">  <span class="built_in">NET_DVR_SetExceptionCallBack_V30</span>(<span class="number">0</span>, <span class="literal">NULL</span>,g_ExceptionCallBack, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------------------------------------</span></span><br><span class="line">  <span class="comment">//启动预览并设置回调数据流</span></span><br><span class="line">  LONG lRealPlayHandle;</span><br><span class="line">  NET_DVR_CLIENTINFO ClientInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ClientInfo.hPlayWnd = <span class="literal">NULL</span>;         <span class="comment">//需要SDK解码时句柄设为有效值，仅取流不解码时可设为空</span></span><br><span class="line">  ClientInfo.lChannel     = <span class="number">1</span>;       <span class="comment">//预览通道号</span></span><br><span class="line">  ClientInfo.lLinkMode    = <span class="number">0</span>;       <span class="comment">//最高位(31)为0表示主码流，为1表示子码流0～30位表示连接方式：0－TCP方式；1－UDP方式；2－多播方式；3－RTP方式;</span></span><br><span class="line">  ClientInfo.sMultiCastIP = <span class="literal">NULL</span>;   <span class="comment">//多播地址，需要多播预览时配置</span></span><br><span class="line">  </span><br><span class="line">  BOOL bPreviewBlock = <span class="literal">false</span>;       <span class="comment">//请求码流过程是否阻塞，0：否，1：是</span></span><br><span class="line">  lRealPlayHandle = <span class="built_in">NET_DVR_RealPlay_V30</span>(lUserID, &amp;ClientInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lRealPlayHandle &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;NET_DVR_RealPlay_V30 error\n&quot;</span>);</span><br><span class="line">	  <span class="built_in">NET_DVR_Logout</span>(lUserID);</span><br><span class="line">      <span class="built_in">NET_DVR_Cleanup</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">NET_DVR_SetRealDataCallBack</span>(lRealPlayHandle, g_RealDataCallBack_V30, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;NET_DVR_SetRealDataCallBack error\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//---------------------------------------</span></span><br><span class="line">  <span class="comment">//关闭预览</span></span><br><span class="line">  <span class="built_in">NET_DVR_StopRealPlay</span>(lRealPlayHandle);</span><br><span class="line">  <span class="comment">//注销用户</span></span><br><span class="line">  <span class="built_in">NET_DVR_Logout_V30</span>(lUserID);</span><br><span class="line">  <span class="built_in">NET_DVR_Cleanup</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="视频容器与编码"><a href="#视频容器与编码" class="headerlink" title="视频容器与编码"></a>视频容器与编码</h1><h2 id="视频容器格式"><a href="#视频容器格式" class="headerlink" title="视频容器格式"></a>视频容器格式</h2><p>又叫封装格式,就是把已经编码封装好的视频、音频按照一定的规范放到一起。</p>
<p>当然里面可能还有字幕、脚本之类的。例如有些格式规定文件内容分为头部、主体、索引三部分。</p>
<p>所谓容器顾名思义像装东西的器具,里面可以装不同类型的东西,当然了每种容器只适合放某些类型的东西,杯子适合装水、饮料,不适合装瓜子、糖果。</p>
<p>同一种容器格式中可以放不同编码的视频，不过一种视频容器格式一般是只支持某几类编码格式的视频。</p>
<p>常见的容器格式有: MP4、rmvb、rm、flv、AVI、mov、WMV、mkv</p>
<h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p>放在容器格式里的视频可以用不同的编码格式,编码格式简单的理解就是用特定的压缩技术把视频做些处理。不过容器其实也可以做些压缩处理。所以视频是可以在编码格式、容器格式中做两次压缩。</p>
<p>常见的编码格式有:mpeg-2、mpeg-4、h.263、h.264、RV40</p>
<h1 id="接收RTSP，点对点UDP推流"><a href="#接收RTSP，点对点UDP推流" class="headerlink" title="接收RTSP，点对点UDP推流"></a>接收RTSP，点对点UDP推流</h1><p>只把容器解开，不对264解码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> <span class="comment">//#include &lt;thread&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_FORMAT_MACROS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavformat/avformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/pixfmt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libswscale/swscale.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wtypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil\time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CustomConfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AVFormatContext *inputContext = <span class="literal">nullptr</span>;</span><br><span class="line">AVFormatContext * outputContext;</span><br><span class="line"><span class="keyword">int64_t</span> lastReadPacktTime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interrupt_cb</span><span class="params">(<span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  timeout = <span class="number">100</span>;  <span class="comment">//比如拉取湖南卫视的rtmp流，可能延时比较长</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">av_gettime</span>() - lastReadPacktTime &gt; timeout * <span class="number">1000</span> * <span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenInput</span><span class="params">(string inputUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inputContext = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line"></span><br><span class="line">	AVDictionary *avdic = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*char option_key[] = &quot;rtsp_transport&quot;;</span></span><br><span class="line"><span class="comment">	char option_value[] = &quot;tcp&quot;;</span></span><br><span class="line"><span class="comment">	av_dict_set(&amp;avdic, option_key, option_value, 0);</span></span><br><span class="line"><span class="comment">	char option_key2[] = &quot;max_delay&quot;;</span></span><br><span class="line"><span class="comment">	char option_value2[] = &quot;100&quot;;</span></span><br><span class="line"><span class="comment">	av_dict_set(&amp;avdic, option_key2, option_value2, 0);*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//av_dict_set(&amp;avdic, &quot;buffer_size&quot;, &quot;1024000&quot;, 0);</span></span><br><span class="line">	<span class="comment">//av_dict_set(&amp;avdic, &quot;stimeout&quot;, &quot;10000&quot;, 0);</span></span><br><span class="line"></span><br><span class="line">	lastReadPacktTime = <span class="built_in">av_gettime</span>();</span><br><span class="line">	inputContext-&gt;interrupt_callback.callback = interrupt_cb;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">avformat_open_input</span>(&amp;inputContext, inputUrl.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, &amp;avdic);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Input file open input failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>  ret;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">avformat_find_stream_info</span>(inputContext, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Find input file stream inform failed\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Open input file  %s success\n&quot;</span>, inputUrl.<span class="built_in">c_str</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">av_dict_free</span>(&amp;avdic);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;AVPacket&gt; <span class="title">ReadPacketFromSource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;AVPacket&gt; <span class="title">packet</span><span class="params">(<span class="keyword">static_cast</span>&lt;AVPacket*&gt;(av_malloc(<span class="keyword">sizeof</span>(AVPacket))), [&amp;](AVPacket *p) &#123; <span class="comment">//av_packet_free(&amp;p);</span></span></span></span><br><span class="line"><span class="params"><span class="function">	av_freep(&amp;p); &#125;)</span></span>;</span><br><span class="line">	<span class="built_in">av_init_packet</span>(packet.<span class="built_in">get</span>());</span><br><span class="line">	lastReadPacktTime = <span class="built_in">av_gettime</span>();</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">av_read_frame</span>(inputContext, packet.<span class="built_in">get</span>());</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> packet;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">av_packet_rescale_ts</span><span class="params">(AVPacket *pkt, AVRational src_tb, AVRational dst_tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">		pkt-&gt;pts = <span class="built_in">av_rescale_q</span>(pkt-&gt;pts, src_tb, dst_tb);</span><br><span class="line">	<span class="keyword">if</span> (pkt-&gt;dts != AV_NOPTS_VALUE)</span><br><span class="line">		pkt-&gt;dts = <span class="built_in">av_rescale_q</span>(pkt-&gt;dts, src_tb, dst_tb);</span><br><span class="line">	<span class="keyword">if</span> (pkt-&gt;duration &gt; <span class="number">0</span>)</span><br><span class="line">		pkt-&gt;duration = <span class="built_in">av_rescale_q</span>(pkt-&gt;duration, src_tb, dst_tb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_dts;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WritePacket</span><span class="params">(shared_ptr&lt;AVPacket&gt; packet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> inputStream = inputContext-&gt;streams[packet-&gt;stream_index];</span><br><span class="line">	<span class="keyword">auto</span> outputStream = outputContext-&gt;streams[packet-&gt;stream_index];</span><br><span class="line">	<span class="built_in">av_packet_rescale_ts</span>(packet.<span class="built_in">get</span>(), inputStream-&gt;time_base, outputStream-&gt;time_base);</span><br><span class="line">	cout &lt;&lt; packet.<span class="built_in">get</span>()-&gt;dts &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">av_interleaved_write_frame</span>(outputContext, packet.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OpenOutput</span><span class="params">(string outUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">avformat_alloc_output_context2</span>(&amp;outputContext, <span class="literal">nullptr</span>, <span class="string">&quot;mpegts&quot;</span>, outUrl.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;open output context failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">avio_open2</span>(&amp;outputContext-&gt;pb, outUrl.<span class="built_in">c_str</span>(), AVIO_FLAG_WRITE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;open avio failed&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputContext-&gt;nb_streams; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		AVStream * stream = <span class="built_in">avformat_new_stream</span>(outputContext, inputContext-&gt;streams[i]-&gt;codec-&gt;codec);</span><br><span class="line">		ret = <span class="built_in">avcodec_copy_context</span>(stream-&gt;codec, inputContext-&gt;streams[i]-&gt;codec);</span><br><span class="line">		outputContext-&gt;streams[i]-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;copy coddec context failed&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> Error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">avformat_write_header</span>(outputContext, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;format write header failed&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot; Open output file success %s\n&quot;</span>, outUrl.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">Error:</span><br><span class="line">	<span class="keyword">if</span> (outputContext)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outputContext-&gt;nb_streams; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">avcodec_close</span>(outputContext-&gt;streams[i]-&gt;codec);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">avformat_close_input</span>(&amp;outputContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (inputContext != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">avformat_close_input</span>(&amp;inputContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseOutput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (outputContext != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outputContext-&gt;nb_streams; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			AVCodecContext *codecContext = outputContext-&gt;streams[i]-&gt;codec;</span><br><span class="line">			<span class="comment">//avcodec_parameters_to_context(codecContext, outputContext-&gt;streams[i]-&gt;codecpar);</span></span><br><span class="line">			<span class="built_in">avcodec_close</span>(codecContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">avformat_close_input</span>(&amp;outputContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">av_register_all</span>();</span><br><span class="line">	<span class="built_in">avformat_network_init</span>();</span><br><span class="line">	<span class="built_in">av_log_set_level</span>(AV_LOG_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">OpenInput</span>(<span class="string">&quot;rtsp://admin@admin1234@192.168.1.214/media2/video1/video&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="built_in">OpenOutput</span>(<span class="string">&quot;udp://127.0.0.1:12345&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> Error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> _count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;WritePacket Success!&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Sleep(40);</span></span><br><span class="line">		<span class="keyword">auto</span> packet = <span class="built_in">ReadPacketFromSource</span>();</span><br><span class="line">		<span class="keyword">if</span> (packet)</span><br><span class="line">		&#123;</span><br><span class="line">			ret = <span class="built_in">WritePacket</span>(packet);</span><br><span class="line">			<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				_count++;</span><br><span class="line">				<span class="keyword">if</span> (_count&gt;<span class="number">1000</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;WritePacket Success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">					_count = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;WritePacket failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line">	<span class="built_in">CloseInput</span>();</span><br><span class="line">	<span class="built_in">CloseOutput</span>();</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="接收RTSP，一对多UDP推流"><a href="#接收RTSP，一对多UDP推流" class="headerlink" title="接收RTSP，一对多UDP推流"></a>接收RTSP，一对多UDP推流</h1><blockquote>
<p>ffmpeg -re -i udp://239.192.43.78:4380 -c:v libx264 -an -f tee -map 0:v “[f=mpegts]udp://127.0.0.1:1253|[f=mpegts]udp://127.0.0.1:1254 “</p>
</blockquote>
<p>只把容器解开，不对264解码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FFMPEG_TRANSCODE_H__  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FFMPEG_TRANSCODE_H__  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavformat/avformat.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavformat/avio.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavcodec/avcodec.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libswscale/swscale.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/avutil.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/mathematics.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libswresample/swresample.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/opt.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/channel_layout.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/samplefmt.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavdevice/avdevice.h&quot;</span>  <span class="comment">//摄像头所用  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavfilter/avfilter.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/error.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/mathematics.h&quot;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/time.h&quot;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/fifo.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/audio_fifo.h&quot;</span>   <span class="comment">//这里是做分片时候重采样编码音频用的  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inttypes.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdint.h&quot;</span>  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;opencv2/opencv.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avformat.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avcodec.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avdevice.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avfilter.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;avutil.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;postproc.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;swresample.lib&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;swscale.lib&quot;</span>)  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_AUDIO_ID            1  <span class="comment">//packet 中的ID ，如果先加入音频 pocket 则音频是 0  视频是1，否则相反(影响add_out_stream顺序)  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_VIDEO_ID            0  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多路输出每一路的信息结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Out_stream_info_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//user info</span></span><br><span class="line">	<span class="keyword">int</span> user_stream_id;                 <span class="comment">//多路输出每一路的ID</span></span><br><span class="line">										<span class="comment">//video param  </span></span><br><span class="line">	<span class="keyword">int</span> m_dwWidth;</span><br><span class="line">	<span class="keyword">int</span> m_dwHeight;</span><br><span class="line">	<span class="keyword">double</span> m_dbFrameRate;               <span class="comment">//帧率                                                    </span></span><br><span class="line">	<span class="keyword">int</span> m_video_codecID;</span><br><span class="line">	<span class="keyword">int</span> m_video_pixelfromat;</span><br><span class="line">	<span class="keyword">int</span> m_bit_rate;                     <span class="comment">//码率</span></span><br><span class="line">	<span class="keyword">int</span> m_gop_size;</span><br><span class="line">	<span class="keyword">int</span> m_max_b_frame;</span><br><span class="line">	<span class="keyword">int</span> m_thread_count;                 <span class="comment">//用cpu内核数目  </span></span><br><span class="line">										<span class="comment">//audio param  </span></span><br><span class="line">	<span class="keyword">int</span> m_dwChannelCount;               <span class="comment">//声道  </span></span><br><span class="line">	<span class="keyword">int</span> m_dwFrequency;                  <span class="comment">//采样率  </span></span><br><span class="line">	<span class="keyword">int</span> m_audio_codecID;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ffmpeg out pram</span></span><br><span class="line">	AVAudioFifo * m_audiofifo;          <span class="comment">//音频存放pcm数据  </span></span><br><span class="line">	<span class="keyword">int64_t</span> m_first_audio_pts;          <span class="comment">//第一帧的音频pts  </span></span><br><span class="line">	<span class="keyword">int</span> m_is_first_audio_pts;           <span class="comment">//是否已经记录第一帧音频时间戳  </span></span><br><span class="line">	AVFormatContext* m_ocodec;         <span class="comment">//输出流context  </span></span><br><span class="line">	<span class="keyword">int</span> m_writeheader_seccess;          <span class="comment">//写头成功也就是写的头支持里面填写的音视频格式例如采样率等等</span></span><br><span class="line">	AVStream* m_ovideo_st;</span><br><span class="line">	AVStream* m_oaudio_st;</span><br><span class="line">	AVCodec * m_audio_codec;</span><br><span class="line">	AVCodec * m_video_codec;</span><br><span class="line">	AVPacket m_pkt;</span><br><span class="line">	AVBitStreamFilterContext * m_vbsf_aac_adtstoasc;     <span class="comment">//aac-&gt;adts to asc过滤器  </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> * <span class="title">m_img_convert_ctx_video</span>;</span></span><br><span class="line">	<span class="keyword">int</span> m_sws_flags;                    <span class="comment">//差值算法,双三次 </span></span><br><span class="line">	AVFrame * m_pout_video_frame;</span><br><span class="line">	AVFrame * m_pout_audio_frame;</span><br><span class="line">	SwrContext * m_swr_ctx;</span><br><span class="line">	<span class="keyword">char</span> m_outurlname[<span class="number">256</span>];             <span class="comment">//输出的url地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Out_stream_info_t</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//user info</span></span><br><span class="line">		user_stream_id = <span class="number">0</span>;             <span class="comment">//多路输出每一路的ID</span></span><br><span class="line">										<span class="comment">//video param  </span></span><br><span class="line">		m_dwWidth = <span class="number">1280</span>;</span><br><span class="line">		m_dwHeight = <span class="number">720</span>;</span><br><span class="line">		m_dbFrameRate = <span class="number">15</span>;  <span class="comment">//帧率                                                    </span></span><br><span class="line">		m_video_codecID = (<span class="keyword">int</span>)AV_CODEC_ID_H264;</span><br><span class="line">		m_video_pixelfromat = (<span class="keyword">int</span>)AV_PIX_FMT_YUV420P;</span><br><span class="line">		m_bit_rate = <span class="number">400000</span>;                <span class="comment">//码率</span></span><br><span class="line">		m_gop_size = <span class="number">12</span>;</span><br><span class="line">		m_max_b_frame = <span class="number">0</span>;</span><br><span class="line">		m_thread_count = <span class="number">2</span>;                 <span class="comment">//用cpu内核数目  </span></span><br><span class="line">											<span class="comment">//audio param  </span></span><br><span class="line">		m_dwChannelCount = <span class="number">2</span>;               <span class="comment">//声道  </span></span><br><span class="line">		m_dwFrequency = <span class="number">44100</span>;              <span class="comment">//采样率  </span></span><br><span class="line">		m_audio_codecID = (<span class="keyword">int</span>)AV_CODEC_ID_AAC;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//ffmpeg out pram  </span></span><br><span class="line">		m_audiofifo = <span class="literal">NULL</span>;                 <span class="comment">//音频存放pcm数据  </span></span><br><span class="line">		m_first_audio_pts = <span class="number">0</span>;              <span class="comment">//第一帧的音频pts  </span></span><br><span class="line">		m_is_first_audio_pts = <span class="number">0</span>;           <span class="comment">//是否已经记录第一帧音频时间戳  </span></span><br><span class="line">		m_ocodec = <span class="literal">NULL</span>;                    <span class="comment">//输出流context </span></span><br><span class="line">		m_writeheader_seccess = <span class="number">0</span>;</span><br><span class="line">		m_ovideo_st = <span class="literal">NULL</span>;</span><br><span class="line">		m_oaudio_st = <span class="literal">NULL</span>;</span><br><span class="line">		m_audio_codec = <span class="literal">NULL</span>;</span><br><span class="line">		m_video_codec = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//m_pkt;     </span></span><br><span class="line">		m_vbsf_aac_adtstoasc = <span class="literal">NULL</span>;        <span class="comment">//aac-&gt;adts to asc过滤器  </span></span><br><span class="line">		m_img_convert_ctx_video = <span class="literal">NULL</span>;</span><br><span class="line">		m_sws_flags = SWS_BICUBIC;          <span class="comment">//差值算法,双三次  </span></span><br><span class="line">		m_pout_video_frame = <span class="literal">NULL</span>;</span><br><span class="line">		m_pout_audio_frame = <span class="literal">NULL</span>;</span><br><span class="line">		m_swr_ctx = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">memset</span>(m_outurlname, <span class="number">0</span>, <span class="number">256</span>);         <span class="comment">//清零</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;Out_stream_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化demux</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_init_demux</span><span class="params">(<span class="keyword">char</span> * inurlname, AVFormatContext ** iframe_c)</span></span>;</span><br><span class="line"><span class="comment">//释放demux</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_uinit_demux</span><span class="params">(AVFormatContext * iframe_c)</span></span>;</span><br><span class="line"><span class="comment">//初始化mux:list,原始流只需要copy的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_init_mux</span><span class="params">(map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; list_out_stream_info)</span></span>;</span><br><span class="line"><span class="comment">//释放mux,原始流只需要copy的不用打开编码器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_uinit_mux</span><span class="params">(map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; list_out_stream_info)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for mux copy </span></span><br><span class="line"><span class="function">AVStream * <span class="title">ffmpeg_add_out_stream</span><span class="params">(AVFormatContext* output_format_context, AVMediaType <span class="keyword">codec_type_t</span>)</span></span>;</span><br><span class="line"><span class="comment">//转码数据,原始流只需要copy的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_transcode</span><span class="params">(<span class="keyword">int</span> original_user_stream_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ffmpeg_write_frame</span><span class="params">(Out_stream_info * out_stream_info, <span class="keyword">int</span> ID, AVPacket <span class="keyword">pkt_t</span>)</span></span>;        <span class="comment">//copy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">AVFormatContext* m_icodec = <span class="literal">NULL</span>;                            <span class="comment">//输入流context  </span></span><br><span class="line"><span class="keyword">int</span> m_in_dbFrameRate = <span class="number">0</span>;                                    <span class="comment">//输入流的帧率</span></span><br><span class="line"><span class="keyword">int</span> m_in_video_stream_idx = <span class="number">-1</span>;                              <span class="comment">//输入流的视频序列号  </span></span><br><span class="line"><span class="keyword">int</span> m_in_video_starttime = <span class="number">0</span>;                                <span class="comment">//输入流的视频起始时间</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; m_list_out_stream_info;           <span class="comment">//多路输出的list</span></span><br><span class="line">AVFrame *pFrame;</span><br><span class="line">AVFrame  *pFrameYUV;</span><br><span class="line"><span class="keyword">uint8_t</span> *out_buffer_Video;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">img_convert_ctx</span>;</span></span><br><span class="line">AVCodecContext  *pVideoCodecCtx;</span><br><span class="line"><span class="keyword">int</span> ret, got_picture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_init_demux</span><span class="params">(<span class="keyword">char</span> * inurlname, AVFormatContext ** iframe_c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	ret = <span class="built_in">avformat_open_input</span>(iframe_c, inurlname, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Call avformat_open_input function failed!\n&quot;</span>);</span><br><span class="line">		Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Call avformat_open_input function failed!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">avformat_find_stream_info</span>(*iframe_c, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Call av_find_stream_info function failed!\n&quot;</span>);</span><br><span class="line">		Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Call av_find_stream_info function failed!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出视频信息  </span></span><br><span class="line">	<span class="built_in">av_dump_format</span>(*iframe_c, <span class="number">-1</span>, inurlname, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加音频信息到输出context  </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (*iframe_c)-&gt;nb_streams; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*iframe_c)-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">double</span> FrameRate = (*iframe_c)-&gt;streams[i]-&gt;r_frame_rate.num / (<span class="keyword">double</span>)(*iframe_c)-&gt;streams[i]-&gt;r_frame_rate.den;</span><br><span class="line">			m_in_dbFrameRate = (<span class="keyword">int</span>)(FrameRate + <span class="number">0.5</span>);</span><br><span class="line">			m_in_video_stream_idx = i;</span><br><span class="line">			m_in_video_starttime = (*iframe_c)-&gt;streams[i]-&gt;start_time;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (m_in_video_stream_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">		Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Didn&#x27;t find a video stream.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pVideoCodecCtx = (*iframe_c)-&gt;streams[m_in_video_stream_idx]-&gt;codec;</span><br><span class="line">	AVCodec *pCodec = <span class="built_in">avcodec_find_decoder</span>(pVideoCodecCtx-&gt;codec_id);<span class="comment">//查找解码器</span></span><br><span class="line">	<span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Codec not found.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pVideoCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;<span class="comment">//打开解码器</span></span><br><span class="line">		Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Could not open codec.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">	pFrameYUV = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">	out_buffer_Video = (<span class="keyword">uint8_t</span> *)<span class="built_in">av_malloc</span>(<span class="built_in">avpicture_get_size</span>(AV_PIX_FMT_RGB32, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height));</span><br><span class="line">	<span class="built_in">avpicture_fill</span>((AVPicture *)pFrameYUV, out_buffer_Video, AV_PIX_FMT_RGB32, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height);</span><br><span class="line">	<span class="comment">//Output Info-----------------------------</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	img_convert_ctx = <span class="built_in">sws_getContext</span>(pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, pVideoCodecCtx-&gt;pix_fmt,</span><br><span class="line">		pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, AV_PIX_FMT_RGB32, SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;video decode finished!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_uinit_demux</span><span class="params">(AVFormatContext * iframe_c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* free the stream */</span></span><br><span class="line">	<span class="built_in">av_free</span>(iframe_c);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_init_mux</span><span class="params">(map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; list_out_stream_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (list_out_stream_info.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; ::iterator result_all;</span><br><span class="line">		Out_stream_info * out_stream_info_all = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (result_all = list_out_stream_info.<span class="built_in">begin</span>(); result_all != list_out_stream_info.<span class="built_in">end</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			out_stream_info_all = result_all-&gt;second;</span><br><span class="line">			<span class="comment">//如果存在输出</span></span><br><span class="line">			<span class="keyword">if</span> (out_stream_info_all)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* allocate the output media context */</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strstr</span>(out_stream_info_all-&gt;m_outurlname, <span class="string">&quot;rtmp&quot;</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">avformat_alloc_output_context2</span>(&amp;out_stream_info_all-&gt;m_ocodec, <span class="literal">NULL</span>, <span class="string">&quot;flv&quot;</span>, out_stream_info_all-&gt;m_outurlname);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">avformat_alloc_output_context2</span>(&amp;out_stream_info_all-&gt;m_ocodec, <span class="literal">NULL</span>, <span class="string">&quot;mpegts&quot;</span>, out_stream_info_all-&gt;m_outurlname);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!out_stream_info_all-&gt;m_ocodec)</span><br><span class="line">				&#123;</span><br><span class="line">					Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Call avformat_alloc_output_context2 function failed!&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				AVOutputFormat* ofmt = <span class="literal">NULL</span>;</span><br><span class="line">				ofmt = out_stream_info_all-&gt;m_ocodec-&gt;oformat;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* open the output file, if needed */</span></span><br><span class="line">				<span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;out_stream_info_all-&gt;m_ocodec-&gt;pb, out_stream_info_all-&gt;m_outurlname, AVIO_FLAG_WRITE) &lt; <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;Could not open &#x27;%s&#x27;\n&quot;</span>, out_stream_info_all-&gt;m_outurlname);</span><br><span class="line">						Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Could not open &quot;</span> + <span class="built_in">string</span>(out_stream_info_all-&gt;m_outurlname));</span><br><span class="line">						<span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//添加视频信息到输出context  </span></span><br><span class="line">				<span class="keyword">if</span> (m_in_video_stream_idx != <span class="number">-1</span>)<span class="comment">//如果存在视频  </span></span><br><span class="line">				&#123;</span><br><span class="line">					out_stream_info_all-&gt;m_ovideo_st = <span class="built_in">ffmpeg_add_out_stream</span>(out_stream_info_all-&gt;m_ocodec, AVMEDIA_TYPE_VIDEO);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//写头</span></span><br><span class="line">				ret = <span class="built_in">avformat_write_header</span>(out_stream_info_all-&gt;m_ocodec, <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					out_stream_info_all-&gt;m_writeheader_seccess = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Call avformat_write_header function failed.user_stream_id : %d\n&quot;</span>, out_stream_info_all-&gt;user_stream_id);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					out_stream_info_all-&gt;m_writeheader_seccess = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//输出信息</span></span><br><span class="line">				<span class="built_in">av_dump_format</span>(out_stream_info_all-&gt;m_ocodec, <span class="number">0</span>, out_stream_info_all-&gt;m_outurlname, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			result_all++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_uinit_mux</span><span class="params">(map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; list_out_stream_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_list_out_stream_info.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; ::iterator result_all;</span><br><span class="line">		Out_stream_info * out_stream_info_all = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (result_all = m_list_out_stream_info.<span class="built_in">begin</span>(); result_all != m_list_out_stream_info.<span class="built_in">end</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			out_stream_info_all = result_all-&gt;second;</span><br><span class="line">			<span class="comment">//如果存在输出</span></span><br><span class="line">			<span class="keyword">if</span> (out_stream_info_all &amp;&amp; out_stream_info_all-&gt;m_writeheader_seccess == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ret = <span class="built_in">av_write_trailer</span>(out_stream_info_all-&gt;m_ocodec);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Call av_write_trailer function failed\n&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (out_stream_info_all-&gt;m_vbsf_aac_adtstoasc != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">av_bitstream_filter_close</span>(out_stream_info_all-&gt;m_vbsf_aac_adtstoasc);</span><br><span class="line">					out_stream_info_all-&gt;m_vbsf_aac_adtstoasc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">av_dump_format</span>(out_stream_info_all-&gt;m_ocodec, <span class="number">-1</span>, out_stream_info_all-&gt;m_outurlname, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Free the streams. */</span></span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_stream_info_all-&gt;m_ocodec-&gt;nb_streams; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">av_freep</span>(&amp;out_stream_info_all-&gt;m_ocodec-&gt;streams[i]-&gt;codec);</span><br><span class="line">					<span class="built_in">av_freep</span>(&amp;out_stream_info_all-&gt;m_ocodec-&gt;streams[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!(out_stream_info_all-&gt;m_ocodec-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* Close the output file. */</span></span><br><span class="line">					<span class="built_in">avio_close</span>(out_stream_info_all-&gt;m_ocodec-&gt;pb);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">av_free</span>(out_stream_info_all-&gt;m_ocodec);</span><br><span class="line">				</span><br><span class="line">				out_stream_info_all-&gt;m_writeheader_seccess = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			result_all++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVStream * <span class="title">ffmpeg_add_out_stream</span><span class="params">(AVFormatContext* output_format_context, AVMediaType <span class="keyword">codec_type_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	AVStream * in_stream = <span class="literal">NULL</span>;</span><br><span class="line">	AVStream * output_stream = <span class="literal">NULL</span>;</span><br><span class="line">	AVCodecContext* output_codec_context = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (<span class="keyword">codec_type_t</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">		in_stream = m_icodec-&gt;streams[m_in_video_stream_idx];</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	output_stream = <span class="built_in">avformat_new_stream</span>(output_format_context, in_stream-&gt;codec-&gt;codec);</span><br><span class="line">	<span class="keyword">if</span> (!output_stream)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//原来这没有注释</span></span><br><span class="line">	<span class="comment">//output_stream-&gt;id = output_format_context-&gt;nb_streams - 1;</span></span><br><span class="line">	output_codec_context = output_stream-&gt;codec;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">avcodec_copy_context</span>(output_stream-&gt;codec, in_stream-&gt;codec);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed to copy context from input to output stream codec context\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个很重要，要么纯复用解复用，不做编解码写头会失败,  </span></span><br><span class="line">	<span class="comment">//另或者需要编解码如果不这样，生成的文件没有预览图，还有添加下面的header失败，置0之后会重新生成extradata  </span></span><br><span class="line">	output_codec_context-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if(! strcmp( output_format_context-&gt; oformat-&gt; name,  &quot;mp4&quot; ) ||  </span></span><br><span class="line">	<span class="comment">//!strcmp (output_format_context -&gt;oformat -&gt;name , &quot;mov&quot; ) ||  </span></span><br><span class="line">	<span class="comment">//!strcmp (output_format_context -&gt;oformat -&gt;name , &quot;3gp&quot; ) ||  </span></span><br><span class="line">	<span class="comment">//!strcmp (output_format_context -&gt;oformat -&gt;name , &quot;flv&quot;))  </span></span><br><span class="line">	<span class="keyword">if</span> (AVFMT_GLOBALHEADER &amp; output_format_context-&gt;oformat-&gt;flags)</span><br><span class="line">	&#123;</span><br><span class="line">		output_codec_context-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> output_stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ffmpeg_write_frame</span><span class="params">(Out_stream_info * out_stream_info, <span class="keyword">int</span> ID, AVPacket <span class="keyword">pkt_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int64_t</span> pts = <span class="number">0</span>, dts = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ID == OUT_VIDEO_ID)</span><br><span class="line">	&#123;</span><br><span class="line">		AVPacket <span class="keyword">videopacket_t</span>;</span><br><span class="line">		<span class="built_in">av_init_packet</span>(&amp;<span class="keyword">videopacket_t</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">videopacket_t</span>.pts = <span class="keyword">pkt_t</span>.pts;<span class="comment">// av_rescale_q_rnd(pkt_t.pts, m_icodec-&gt;streams[m_in_video_stream_idx]-&gt;time_base, out_stream_info-&gt;m_ovideo_st-&gt;time_base, AV_ROUND_NEAR_INF);</span></span><br><span class="line">		<span class="keyword">videopacket_t</span>.dts = <span class="keyword">pkt_t</span>.dts;<span class="comment">// av_rescale_q_rnd(pkt_t.dts, m_icodec-&gt;streams[m_in_video_stream_idx]-&gt;time_base, out_stream_info-&gt;m_ovideo_st-&gt;time_base, AV_ROUND_NEAR_INF);</span></span><br><span class="line">		<span class="keyword">videopacket_t</span>.duration = <span class="keyword">pkt_t</span>.duration;<span class="comment">// av_rescale_q(pkt_t.duration, m_icodec-&gt;streams[m_in_video_stream_idx]-&gt;time_base, out_stream_info-&gt;m_ovideo_st-&gt;time_base);</span></span><br><span class="line">		<span class="keyword">videopacket_t</span>.flags = <span class="keyword">pkt_t</span>.flags;</span><br><span class="line">		<span class="keyword">videopacket_t</span>.stream_index = OUT_VIDEO_ID; <span class="comment">//这里add_out_stream顺序有影响，去掉了音频，所以从0开始</span></span><br><span class="line">		<span class="keyword">videopacket_t</span>.data = <span class="keyword">pkt_t</span>.data;</span><br><span class="line">		<span class="keyword">videopacket_t</span>.size = <span class="keyword">pkt_t</span>.size;</span><br><span class="line">		<span class="keyword">videopacket_t</span>.pos = <span class="number">-1</span>;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">videopacket_t</span>.pts &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">int64_t</span> timestamp = <span class="keyword">videopacket_t</span>.pts;</span><br><span class="line">		ret = <span class="built_in">av_interleaved_write_frame</span>(out_stream_info-&gt;m_ocodec, &amp;<span class="keyword">videopacket_t</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;error av_interleaved_write_frame _ video\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 解码一帧视频图像</span></span><br><span class="line">		ret = <span class="built_in">avcodec_decode_video2</span>(pVideoCodecCtx, pFrame, &amp;got_picture, &amp;<span class="keyword">videopacket_t</span>);<span class="comment">//解码一帧压缩数据</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Decode Error.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">			<span class="comment">//int64_t timestamp = videopacket_t.pts;// *1000000 * inputContext-&gt;streams[packet.get()-&gt;stream_index]-&gt;time_base.num / inputContext-&gt;streams[packet.get()-&gt;stream_index]-&gt;time_base.den;</span></span><br><span class="line">			<span class="comment">//            qDebug()&lt;&lt;&quot;timestamp=&quot;&lt;&lt;timestamp&lt;&lt;endl;</span></span><br><span class="line">			<span class="built_in">sws_scale</span>(img_convert_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pVideoCodecCtx-&gt;height,</span><br><span class="line">				pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//Cfg::get()-&gt;SetLog(to_string(timestamp));</span></span><br><span class="line">			cout &lt;&lt; timestamp &lt;&lt; endl;</span><br><span class="line">			cv::Mat _mat(pVideoCodecCtx-&gt;height, pVideoCodecCtx-&gt;width, CV_8UC4, (uchar *)out_buffer_Video);</span><br><span class="line">			<span class="comment">//cv::imwrite(to_string(timestamp) + &quot;.jpg&quot;, _mat);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//QImage((uchar *)out_buffer_Video, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, QImage::Format_RGB32).save(QString::fromStdString(to_string(timestamp) + &quot;.jpg&quot;));</span></span><br><span class="line">			<span class="comment">//把这个RGB数据 用QImage加载</span></span><br><span class="line">			<span class="comment">//emit sig_GetOneFrame(timestamp,QImage((uchar *)out_buffer_Video, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, QImage::Format_RGB32));  //发送信号</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">av_free_packet</span>(&amp;<span class="keyword">videopacket_t</span>);</span><br><span class="line">		<span class="comment">//printf(&quot;video\n&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ffmpeg_transcode</span><span class="params">(<span class="keyword">int</span> original_user_stream_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> is_audio_decodefinish = <span class="number">0</span>;           <span class="comment">//音频解码成功</span></span><br><span class="line">	<span class="keyword">int</span> is_video_decodefinish = <span class="number">0</span>;           <span class="comment">//视频解码成功</span></span><br><span class="line">	<span class="comment">//开始解包  </span></span><br><span class="line">	Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;开始解包&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AVPacket m_in_pkt;                                           <span class="comment">//读取输入文件packet</span></span><br><span class="line">		<span class="built_in">av_init_packet</span>(&amp;m_in_pkt);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">av_read_frame</span>(m_icodec, &amp;m_in_pkt) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//视频  </span></span><br><span class="line">		<span class="keyword">if</span> (m_in_pkt.stream_index == m_in_video_stream_idx)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (m_list_out_stream_info.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; ::iterator result_all;</span><br><span class="line">				Out_stream_info * out_stream_info_all = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">for</span> (result_all = m_list_out_stream_info.<span class="built_in">begin</span>(); result_all != m_list_out_stream_info.<span class="built_in">end</span>();)</span><br><span class="line">				&#123;</span><br><span class="line">					out_stream_info_all = result_all-&gt;second;</span><br><span class="line">					<span class="comment">//如果有输出流</span></span><br><span class="line">					<span class="keyword">if</span> (out_stream_info_all)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">ffmpeg_write_frame</span>(out_stream_info_all, OUT_VIDEO_ID, m_in_pkt);</span><br><span class="line">						</span><br><span class="line">					&#125;</span><br><span class="line">					result_all++;</span><br><span class="line">				&#125;</span><br><span class="line">				is_video_decodefinish = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">av_free_packet</span>(&amp;m_in_pkt);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">av_register_all</span>();</span><br><span class="line">	<span class="built_in">avformat_network_init</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ffmpeg_init_demux</span>(<span class="string">&quot;rtsp://admin@admin1234@192.168.1.214/media2/video1/video&quot;</span>, &amp;m_icodec);</span><br><span class="line"></span><br><span class="line">    Out_stream_info *out_stream_info1 = <span class="literal">NULL</span>;</span><br><span class="line">	out_stream_info1 = <span class="keyword">new</span> <span class="built_in">Out_stream_info</span>();</span><br><span class="line">	out_stream_info1-&gt;user_stream_id = <span class="number">0</span>;</span><br><span class="line">    out_stream_info1-&gt;m_outurlname=<span class="string">&quot;udp://127.0.0.1:12345&quot;</span>;</span><br><span class="line">    <span class="comment">//申请map</span></span><br><span class="line">    m_list_out_stream_info[out_stream_info1-&gt;user_stream_id] = (out_stream_info);</span><br><span class="line">    </span><br><span class="line">    Out_stream_info *out_stream_info1 = <span class="literal">NULL</span>;</span><br><span class="line">    out_stream_info1 = <span class="keyword">new</span> <span class="built_in">Out_stream_info</span>();</span><br><span class="line">    out_stream_info1-&gt;user_stream_id = <span class="number">1</span>;</span><br><span class="line">    out_stream_info1-&gt;m_outurlname=<span class="string">&quot;udp://127.0.0.1:12346&quot;</span>;</span><br><span class="line">    <span class="comment">//申请map</span></span><br><span class="line">    m_list_out_stream_info[out_stream_info1-&gt;user_stream_id] = (out_stream_info1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ffmpeg_init_mux</span>(m_list_out_stream_info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------程序运行开始----------\n&quot;</span>);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="built_in">ffmpeg_transcode</span>(<span class="comment">/*out_stream_info1-&gt;user_stream_id*/</span><span class="number">1</span>);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="built_in">ffmpeg_uinit_mux</span>(m_list_out_stream_info);</span><br><span class="line">	<span class="built_in">ffmpeg_uinit_demux</span>(m_icodec);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放map</span></span><br><span class="line">	<span class="keyword">if</span> (m_list_out_stream_info.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		map&lt;<span class="keyword">int</span>, Out_stream_info*&gt; ::iterator result_all;</span><br><span class="line">		Out_stream_info * out_stream_info_all = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (result_all = m_list_out_stream_info.<span class="built_in">begin</span>(); result_all != m_list_out_stream_info.<span class="built_in">end</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			out_stream_info_all = result_all-&gt;second;</span><br><span class="line">			<span class="keyword">if</span> (out_stream_info_all)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> out_stream_info_all;</span><br><span class="line">				out_stream_info_all = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m_list_out_stream_info.<span class="built_in">erase</span>(result_all++);</span><br><span class="line">		&#125;</span><br><span class="line">		m_list_out_stream_info.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------程序运行结束----------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-------请按任意键退出---------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接收RTSP流，解码成一张一张图片"><a href="#接收RTSP流，解码成一张一张图片" class="headerlink" title="接收RTSP流，解码成一张一张图片"></a>接收RTSP流，解码成一张一张图片</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDL_MAIN_HANDLED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VIDEOPLAYER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEOPLAYER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_FORMAT_MACROS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QImage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavcodec/avcodec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavformat/avformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil/pixfmt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libswscale/swscale.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wtypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavutil\time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/opt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/channel_layout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/samplefmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswresample/swresample.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StructPackets.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="comment">//1.ffmpeg接收视频流；UDP接收图片</span></span><br><span class="line"><span class="comment">/*****************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UDPreceiveThread</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UDPreceiveThread</span>(QObject *parent = <span class="literal">NULL</span>);</span><br><span class="line">    ~<span class="built_in">UDPreceiveThread</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInputUrl</span><span class="params">(QString url)</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Threadrun</span><span class="params">()</span></span>;<span class="comment">//开启接收线程</span></span><br><span class="line">    <span class="comment">/////////////////ffmpeg接收视频流//////////////////////////////////</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sig_GetOneFrame</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>,QImage)</span></span>;</span><br><span class="line">    <span class="comment">//发送结束信号，在VideoWidget里释放该类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">OpenInput</span><span class="params">(string inputUrl)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;AVPacket&gt; <span class="title">ReadPacketFromSource</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">av_packet_rescale_ts</span><span class="params">(AVPacket *pkt, AVRational src_tb, AVRational dst_tb)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SavePic</span><span class="params">(string savename)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">WritePacket</span><span class="params">(shared_ptr&lt;AVPacket&gt; packet)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">OpenOutput</span><span class="params">(string outUrl)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseInput</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseVideodecode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseSwSdecode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseAudiodecode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloseOutput</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deinit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Videodecode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Audiodecode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swsfill</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_Run;<span class="comment">//是否暂时停止接收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_inputString;</span><br><span class="line">    AVFormatContext *inputContext;</span><br><span class="line">    AVFormatContext * outputContext;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    AVCodecContext  *pVideoCodecCtx;</span><br><span class="line">    AVFrame  *pFrameYUV;</span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer_Video;</span><br><span class="line">    <span class="keyword">int</span> ret, got_picture;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">img_convert_ctx</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    i, videoindex, audioindex;</span><br><span class="line">    <span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//audio</span></span><br><span class="line">    AVCodecContext  *pAudioCodecCtx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">au_convert_ctx</span>;</span></span><br><span class="line">    <span class="keyword">int</span> out_buffer_Audio_size;</span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer_Audio;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UDPreceiveThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CustomConfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_CODEC_FLAG_GLOBAL_HEADER (1 &lt;&lt; 22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODEC_FLAG_GLOBAL_HEADER AV_CODEC_FLAG_GLOBAL_HEADER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_RAWPICTURE 0x0020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;sdl2/SDL.h&quot;</span></span><br><span class="line"><span class="comment">//#include &lt;sdl2/SDL_main.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000 <span class="comment">// 1 second of 48khz 32bit audio</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_CONSTANT_MACROS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNREFERENCED_VALUE(P)          (P)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER&gt;=1900</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span> </span></span><br><span class="line">_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(<span class="keyword">unsigned</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">FILE* __cdecl __iob_func(<span class="keyword">unsigned</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> __acrt_iob_func(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MSC_VER&gt;=1900 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QMessageBox&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mutex&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">frame</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>, CV_8UC1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">cvMat_to_QImage</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;mat)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (mat.<span class="built_in">type</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 8-bit, 4 channel</span></span><br><span class="line">    <span class="keyword">case</span> CV_8UC4:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QImage</span>(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_RGB32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8-bit, 3 channel</span></span><br><span class="line">    <span class="keyword">case</span> CV_8UC3:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QImage <span class="title">image</span><span class="params">(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_RGB888)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QImage</span>(image.<span class="built_in">rgbSwapped</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8-bit, 1 channel</span></span><br><span class="line">    <span class="keyword">case</span> CV_8UC1:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> QVector&lt;QRgb&gt;  sColorTable;</span><br><span class="line">        <span class="comment">// only create our color table once</span></span><br><span class="line">        <span class="keyword">if</span> (sColorTable.<span class="built_in">isEmpty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">                sColorTable.<span class="built_in">push_back</span>(<span class="built_in">qRgb</span>(i, i, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">QImage <span class="title">image</span><span class="params">(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_Indexed8)</span></span>;</span><br><span class="line">        image.<span class="built_in">setColorTable</span>(sColorTable);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">qDebug</span>(<span class="string">&quot;Image format is not supported: depth=%d and %d channels\n&quot;</span>, mat.<span class="built_in">depth</span>(), mat.<span class="built_in">channels</span>());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QImage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UDPreceiveThread::<span class="built_in">UDPreceiveThread</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UDPreceiveThread::~<span class="built_in">UDPreceiveThread</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    Cfg::get()-&gt;SetLog(&quot;UDPreceiveThread dead&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::setInputUrl</span><span class="params">(QString url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_inputString = url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  region</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int64_t lastReadPacktTime;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RTSP 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_SDL 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Buffer:</span></span><br><span class="line"><span class="comment">//|-----------|-------------|</span></span><br><span class="line"><span class="comment">//chunk-------pos---len-----|</span></span><br><span class="line"><span class="comment">//static  Uint8  *audio_chunk;</span></span><br><span class="line"><span class="comment">//static  Uint32  audio_len;</span></span><br><span class="line"><span class="comment">//static  Uint8  *audio_pos;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The audio function callback takes the following parameters:</span></span><br><span class="line"><span class="comment">* stream: A pointer to the audio buffer to be filled</span></span><br><span class="line"><span class="comment">* len: The length (in bytes) of the audio buffer</span></span><br><span class="line"><span class="comment">* 回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//void  fill_audio(void *udata, Uint8 *stream,  int len) &#123;</span></span><br><span class="line"><span class="comment">//	UNREFERENCED_VALUE(udata);</span></span><br><span class="line"><span class="comment">//	//SDL 2.0</span></span><br><span class="line"><span class="comment">//	SDL_memset(stream, 0, len);</span></span><br><span class="line"><span class="comment">//	if (audio_len == 0)</span></span><br><span class="line"><span class="comment">//		return;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	len = (len &gt; audio_len ? audio_len : len);	/*  Mix  as  much  data  as  possible  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span></span><br><span class="line"><span class="comment">//	audio_pos += len;</span></span><br><span class="line"><span class="comment">//	audio_len -= len;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interrupt_cb</span><span class="params">(<span class="keyword">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  timeout = <span class="number">10</span>;  <span class="comment">//比如拉取湖南卫视的rtmp流，可能延时比较长</span></span><br><span class="line">    <span class="comment">//    if (av_gettime() - lastReadPacktTime &gt; timeout * 1000 * 1000)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        return -1;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::OpenInput</span><span class="params">(string inputUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RTSP </span></span><br><span class="line">    AVDictionary *avdic = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> option_key[] = <span class="string">&quot;rtsp_transport&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> option_value[] = <span class="string">&quot;tcp&quot;</span>;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;avdic, option_key, option_value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> option_key2[] = <span class="string">&quot;max_delay&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> option_value2[] = <span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;avdic, option_key2, option_value2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;avdic, <span class="string">&quot;buffer_size&quot;</span>, <span class="string">&quot;1024000&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//av_dict_set(&amp;avdic, &quot;stimeout&quot;, &quot;10000&quot;, 0);</span></span><br><span class="line"></span><br><span class="line">    inputContext = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    lastReadPacktTime = <span class="built_in">av_gettime</span>();</span><br><span class="line">    inputContext-&gt;interrupt_callback.callback = interrupt_cb;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">avformat_open_input</span>(&amp;inputContext, inputUrl.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, &amp;avdic);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    inputContext = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    <span class="comment">//	lastReadPacktTime = av_gettime();</span></span><br><span class="line">    <span class="comment">//	inputContext-&gt;interrupt_callback.callback = interrupt_cb;</span></span><br><span class="line">    AVDictionary *avdic = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;avdic, <span class="string">&quot;buffer_size&quot;</span>, <span class="string">&quot;1024000&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> option_key2[] = <span class="string">&quot;max_delay&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> option_value2[] = <span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;avdic, option_key2, option_value2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">avformat_open_input</span>(&amp;inputContext, inputUrl.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, &amp;avdic);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Input file open input failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">avformat_find_stream_info</span>(inputContext, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Find input file stream inform failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Open input file  &quot;</span> + inputUrl + <span class="string">&quot; success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;avdic);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RTSP</span></span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;avdic);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::OpenOutput</span><span class="params">(string outUrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">avformat_alloc_output_context2</span>(&amp;outputContext, <span class="literal">nullptr</span>, <span class="string">&quot;mpegts&quot;</span>, outUrl.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;open output context failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">avio_open2</span>(&amp;outputContext-&gt;pb, outUrl.<span class="built_in">c_str</span>(), AVIO_FLAG_WRITE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;open avio failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    for (int i = 0; i &lt; inputContext-&gt;nb_streams; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AVStream * stream = <span class="built_in">avformat_new_stream</span>(outputContext, inputContext-&gt;streams[videoindex]-&gt;codec-&gt;codec);</span><br><span class="line">        ret = <span class="built_in">avcodec_copy_context</span>(stream-&gt;codec, inputContext-&gt;streams[videoindex]-&gt;codec);</span><br><span class="line">        outputContext-&gt;streams[videoindex]-&gt;codec-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;copy coddec context failed&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> Error;</span><br><span class="line">        &#125;</span><br><span class="line">        stream-&gt;codec-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">avformat_write_header</span>(outputContext, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;format write header failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot; Open output file success %s\n&quot;</span>, outUrl.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">Error:</span><br><span class="line">    <span class="keyword">if</span> (outputContext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outputContext-&gt;nb_streams; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">avcodec_close</span>(outputContext-&gt;streams[i]-&gt;codec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;outputContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">shared_ptr&lt;AVPacket&gt; <span class="title">UDPreceiveThread::ReadPacketFromSource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;AVPacket&gt; <span class="title">packet</span><span class="params">(<span class="keyword">static_cast</span>&lt;AVPacket*&gt;(av_malloc(<span class="keyword">sizeof</span>(AVPacket))), [&amp;](AVPacket *p) &#123; <span class="comment">//av_packet_free(&amp;p);</span></span></span></span><br><span class="line"><span class="params"><span class="function">        av_freep(&amp;p); &#125;)</span></span>;</span><br><span class="line">    <span class="built_in">av_init_packet</span>(packet.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">//    lastReadPacktTime = av_gettime();</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">av_read_frame</span>(inputContext, packet.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//        qDebug()&lt;&lt;&quot;av_read_frame(inputContext, packet.get());&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> packet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">av_free_packet</span>(packet.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::av_packet_rescale_ts</span><span class="params">(AVPacket *pkt, AVRational src_tb, AVRational dst_tb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">        pkt-&gt;pts = <span class="built_in">av_rescale_q</span>(pkt-&gt;pts, src_tb, dst_tb);</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;dts != AV_NOPTS_VALUE)</span><br><span class="line">        pkt-&gt;dts = <span class="built_in">av_rescale_q</span>(pkt-&gt;dts, src_tb, dst_tb);</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;duration &gt; <span class="number">0</span>)</span><br><span class="line">        pkt-&gt;duration = <span class="built_in">av_rescale_q</span>(pkt-&gt;duration, src_tb, dst_tb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::SavePic</span><span class="params">(string savename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    savename = <span class="string">&quot;.\\&quot;</span> + savename + <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (pVideoCodecCtx==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//QMessageBox::information(NULL, &quot;Error&quot;, &quot;save Picture Error,pVideoCodecCtx=NULL.&quot;);</span></span><br><span class="line"><span class="comment">//        Cfg::get()-&gt;SetLog(&quot;save Picture Error,pVideoCodecCtx=NULL.&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QImage <span class="title">tmpImg</span><span class="params">((uchar *)out_buffer_Video, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, QImage::Format_RGB32)</span></span>;</span><br><span class="line">    tmpImg.<span class="built_in">save</span>(savename.<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::WritePacket</span><span class="params">(shared_ptr&lt;AVPacket&gt; packet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    auto inputStream = inputContext-&gt;streams[packet-&gt;stream_index];</span></span><br><span class="line">    <span class="comment">//    auto outputStream = outputContext-&gt;streams[packet-&gt;stream_index];</span></span><br><span class="line">    <span class="comment">//    av_packet_rescale_ts(packet.get(), inputStream-&gt;time_base, outputStream-&gt;time_base);</span></span><br><span class="line">    <span class="comment">//    av_interleaved_write_frame(outputContext, packet.get());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (packet-&gt;stream_index == videoindex) &#123;</span><br><span class="line">        ret = <span class="built_in">avcodec_decode_video2</span>(pVideoCodecCtx, pFrame, &amp;got_picture, packet.<span class="built_in">get</span>());<span class="comment">//解码一帧压缩数据</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Decode Error.&quot;</span>);</span><br><span class="line">            <span class="built_in">av_free_packet</span>(packet.<span class="built_in">get</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> timestamp=packet.<span class="built_in">get</span>()-&gt;pts;<span class="comment">//*1000000*inputContext-&gt;streams[packet.get()-&gt;stream_index]-&gt;time_base.num/inputContext-&gt;streams[packet.get()-&gt;stream_index]-&gt;time_base.den;</span></span><br><span class="line">            <span class="comment">//            qDebug()&lt;&lt;&quot;timestamp=&quot;&lt;&lt;timestamp&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">sws_scale</span>(img_convert_ctx,(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pVideoCodecCtx-&gt;height,</span><br><span class="line">                      pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//            Cfg::get()-&gt;SetLog(to_string(timestamp));</span></span><br><span class="line">            <span class="comment">//            Cfg::get()-&gt;SetLog(to_string(inputContext-&gt;streams[packet.get()-&gt;stream_index]-&gt;time_base.num));</span></span><br><span class="line">            <span class="comment">//            Cfg::get()-&gt;SetLog(to_string(inputContext-&gt;streams[packet.get()-&gt;stream_index]-&gt;time_base.den));</span></span><br><span class="line">            <span class="comment">//            QImage((uchar *)out_buffer_Video, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, QImage::Format_RGB32).save(QString::fromStdString(to_string(timestamp)+&quot;.jpg&quot;));</span></span><br><span class="line">            <span class="comment">//把这个RGB数据 用QImage加载</span></span><br><span class="line">            <span class="function">emit <span class="title">sig_GetOneFrame</span><span class="params">(timestamp,QImage((uchar *)out_buffer_Video, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, QImage::Format_RGB32))</span></span>;  <span class="comment">//发送信号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (audioindex!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == audioindex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">avcodec_decode_audio4</span>(pAudioCodecCtx, pFrame, &amp;ret, packet.<span class="built_in">get</span>());</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//                /Cfg::get()-&gt;SetLog(&quot;audio decodec error!&quot;);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swr_convert</span>(au_convert_ctx, &amp;out_buffer_Audio, MAX_AUDIO_FRAME_SIZE, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//SDL------------------</span></span><br><span class="line">            <span class="comment">//#if USE_SDL</span></span><br><span class="line">            <span class="comment">//			while (audio_len &gt; 0)//Wait until finish</span></span><br><span class="line">            <span class="comment">//				SDL_Delay(1);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//			//Set audio buffer (PCM data)</span></span><br><span class="line">            <span class="comment">//			audio_chunk = (Uint8 *)out_buffer_Audio;</span></span><br><span class="line">            <span class="comment">//			//Audio buffer length</span></span><br><span class="line">            <span class="comment">//			audio_len = out_buffer_Audio_size;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//			audio_pos = audio_chunk;</span></span><br><span class="line">            <span class="comment">//#endif</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_free_packet</span>(packet.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::CloseOutput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputContext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outputContext-&gt;nb_streams; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            AVCodecContext *codecContext = outputContext-&gt;streams[i]-&gt;codec;</span><br><span class="line">            <span class="comment">//avcodec_parameters_to_context(codecContext, outputContext-&gt;streams[i]-&gt;codecpar);</span></span><br><span class="line">            <span class="built_in">avcodec_close</span>(codecContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;outputContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::CloseInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputContext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">avformat_close_input</span>(&amp;inputContext);</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(inputContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::CloseVideodecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">avcodec_close</span>(pVideoCodecCtx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::CloseSwSdecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_free</span>(out_buffer_Video);</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;pFrameYUV);</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;pFrame);</span><br><span class="line">    <span class="comment">//	for (int i = 0; i &lt; outputContext-&gt;nb_streams; i++)</span></span><br><span class="line">    <span class="comment">//	&#123;</span></span><br><span class="line">    <span class="comment">//		AVCodecContext *codecContext = outputContext-&gt;streams[i]-&gt;codec;</span></span><br><span class="line">    <span class="comment">//		//avcodec_parameters_to_context(codecContext, outputContext-&gt;streams[i]-&gt;codecpar);</span></span><br><span class="line">    <span class="comment">//		avcodec_close(codecContext);</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    <span class="built_in">sws_freeContext</span>(img_convert_ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::CloseAudiodecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_free</span>(out_buffer_Audio);</span><br><span class="line">    <span class="built_in">avcodec_close</span>(pAudioCodecCtx);</span><br><span class="line">    <span class="built_in">swr_free</span>(&amp;au_convert_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#if USE_SDL</span></span><br><span class="line">    <span class="comment">//	SDL_CloseAudio();//Close SDL</span></span><br><span class="line">    <span class="comment">//	SDL_Quit();</span></span><br><span class="line">    <span class="comment">//#endif</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_register_all</span>();</span><br><span class="line">    <span class="comment">//avfilter_register_all();</span></span><br><span class="line">    <span class="built_in">avformat_network_init</span>();</span><br><span class="line">    <span class="built_in">av_log_set_level</span>(AV_LOG_ERROR);</span><br><span class="line"></span><br><span class="line">    m_Run = <span class="literal">true</span>;</span><br><span class="line">    inputContext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    pFrame = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    pVideoCodecCtx = <span class="literal">nullptr</span>;</span><br><span class="line">    pFrameYUV = <span class="literal">nullptr</span>;</span><br><span class="line">    videoindex = <span class="number">-1</span>;</span><br><span class="line">    out_buffer_Video = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    img_convert_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    pAudioCodecCtx = <span class="literal">nullptr</span>;</span><br><span class="line">    au_convert_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    audioindex = <span class="number">-1</span>;</span><br><span class="line">    out_buffer_Audio = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::Deinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">avformat_network_deinit</span>();</span><br><span class="line"></span><br><span class="line">    inputContext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    pFrame = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    pVideoCodecCtx = <span class="literal">nullptr</span>;</span><br><span class="line">    pFrameYUV = <span class="literal">nullptr</span>;</span><br><span class="line">    videoindex = <span class="number">-1</span>;</span><br><span class="line">    out_buffer_Video = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    img_convert_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    pAudioCodecCtx = <span class="literal">nullptr</span>;</span><br><span class="line">    au_convert_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    audioindex = <span class="number">-1</span>;</span><br><span class="line">    out_buffer_Audio = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::Videodecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    videoindex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span>  <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputContext-&gt;nb_streams; i++)</span><br><span class="line">        <span class="keyword">if</span> (inputContext-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            videoindex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (videoindex == <span class="number">-1</span>) &#123;</span><br><span class="line">        Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Didn&#x27;t find a video stream.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pVideoCodecCtx = inputContext-&gt;streams[videoindex]-&gt;codec;</span><br><span class="line">    AVCodec *pCodec = <span class="built_in">avcodec_find_decoder</span>(pVideoCodecCtx-&gt;codec_id);<span class="comment">//查找解码器</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Codec not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pVideoCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;<span class="comment">//打开解码器</span></span><br><span class="line">        Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;Could not open codec.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::swsfill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    pFrameYUV = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    out_buffer_Video = (<span class="keyword">uint8_t</span> *)<span class="built_in">av_malloc</span>(<span class="built_in">avpicture_get_size</span>(AV_PIX_FMT_RGB32, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height));</span><br><span class="line">    <span class="built_in">avpicture_fill</span>((AVPicture *)pFrameYUV, out_buffer_Video, AV_PIX_FMT_RGB32, pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height);</span><br><span class="line">    <span class="comment">//Output Info-----------------------------</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;pVideoCodecCtx-&gt;width&lt;&lt;pVideoCodecCtx-&gt;height&lt;&lt;<span class="string">&quot;-------------------------------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pVideoCodecCtx-&gt;width &lt;=<span class="number">0</span> || pVideoCodecCtx-&gt;height &lt;<span class="number">0</span> ||</span><br><span class="line">            pVideoCodecCtx-&gt;width &gt;= <span class="number">2000</span> || pVideoCodecCtx-&gt;height &gt;<span class="number">2000</span>     )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    img_convert_ctx = <span class="built_in">sws_getContext</span>(pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, pVideoCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                     pVideoCodecCtx-&gt;width, pVideoCodecCtx-&gt;height, AV_PIX_FMT_RGB32, SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//    qDebug()&lt;&lt;&quot;-------------------------------------------------\n&quot;;</span></span><br><span class="line">    Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;video decode finished!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UDPreceiveThread::Audiodecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取流下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputContext-&gt;nb_streams; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputContext-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO)</span><br><span class="line">        &#123;</span><br><span class="line">            audioindex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (audioindex == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Cfg::get()-&gt;SetLog(&quot;find audio stream failed!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找解码器</span></span><br><span class="line">    pAudioCodecCtx = inputContext-&gt;streams[audioindex]-&gt;codec;</span><br><span class="line">    AVCodec *pCodec = <span class="built_in">avcodec_find_decoder</span>(pAudioCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pCodec)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Cfg::get()-&gt;SetLog(&quot;avcode find decoder failed!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pAudioCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        Cfg::get()-&gt;SetLog(&quot;avcode open failed!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Out Audio Param</span></span><br><span class="line">    <span class="keyword">uint64_t</span> out_channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">    <span class="comment">//AAC:1024  MP3:1152</span></span><br><span class="line">    <span class="keyword">int</span> out_nb_samples = pAudioCodecCtx-&gt;frame_size;</span><br><span class="line">    AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = <span class="number">44100</span>;<span class="comment">// pAudioCodecCtx-&gt;bit_rate / 2;//这个地方要注意</span></span><br><span class="line">    <span class="keyword">int</span> out_channels = <span class="built_in">av_get_channel_layout_nb_channels</span>(out_channel_layout);</span><br><span class="line">    <span class="comment">//Out Buffer Size</span></span><br><span class="line">    out_buffer_Audio_size = <span class="built_in">av_samples_get_buffer_size</span>(<span class="literal">NULL</span>, out_channels, out_nb_samples, out_sample_fmt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    out_buffer_Audio = (<span class="keyword">uint8_t</span> *)<span class="built_in">av_malloc</span>(MAX_AUDIO_FRAME_SIZE * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//	//SDL------------------</span></span><br><span class="line">    <span class="comment">//#if USE_SDL</span></span><br><span class="line">    <span class="comment">//	//Init</span></span><br><span class="line">    <span class="comment">//	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span></span><br><span class="line">    <span class="comment">//		Cfg::get()-&gt;SetLog(&quot;Could not initialize SDL &quot;);</span></span><br><span class="line">    <span class="comment">//		return 1;</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    <span class="comment">//	//SDL_AudioSpec</span></span><br><span class="line">    <span class="comment">//	SDL_AudioSpec wanted_spec;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.freq = out_sample_rate;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.format = AUDIO_S16SYS;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.channels = out_channels;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.silence = 0;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.samples = out_nb_samples;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.callback = fill_audio;</span></span><br><span class="line">    <span class="comment">//	wanted_spec.userdata = pAudioCodecCtx;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//	if (SDL_OpenAudio(&amp;wanted_spec, NULL) &lt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//		Cfg::get()-&gt;SetLog(&quot;can&#x27;t open audio.&quot;);</span></span><br><span class="line">    <span class="comment">//		return 1;</span></span><br><span class="line">    <span class="comment">//	&#125;</span></span><br><span class="line">    <span class="comment">//#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//FIX:Some Codec&#x27;s Context Information is missing</span></span><br><span class="line">    <span class="keyword">int64_t</span> in_channel_layout = <span class="built_in">av_get_default_channel_layout</span>(pAudioCodecCtx-&gt;channels);</span><br><span class="line">    <span class="comment">//Swr</span></span><br><span class="line"></span><br><span class="line">    au_convert_ctx = <span class="built_in">swr_alloc</span>();</span><br><span class="line">    au_convert_ctx = <span class="built_in">swr_alloc_set_opts</span>(au_convert_ctx, out_channel_layout, out_sample_fmt, out_sample_rate,</span><br><span class="line">                                        in_channel_layout, pAudioCodecCtx-&gt;sample_fmt, pAudioCodecCtx-&gt;sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">swr_init</span>(au_convert_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//	//Play</span></span><br><span class="line">    <span class="comment">//	SDL_PauseAudio(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    Cfg::get()-&gt;SetLog(&quot;audio decode finished!&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UDPreceiveThread::Threadrun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;start connect &quot;</span>+m_inputString.<span class="built_in">toStdString</span>());</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;***start connect***&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    if(m_inputString.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//        m_inputString = QString::fromStdString(Cfg::get()-&gt;valS(&quot;UDPSource&quot;));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;***OpenInput***&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        ret = <span class="built_in">OpenInput</span>(m_inputString.<span class="built_in">toStdString</span>());<span class="comment">//(&quot;rtsp://192.168.1.168/0&quot;);// udp://239.192.43.78:4377</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;m_inputString&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">CloseInput</span>();</span><br><span class="line">            Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;OpenInput failed!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;***Videodecode*** &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">            ret = <span class="built_in">Videodecode</span>();</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">CloseVideodecode</span>();</span><br><span class="line">            <span class="built_in">CloseInput</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;***swsfill***&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ret=<span class="built_in">swsfill</span>();</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;count = &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">CloseSwSdecode</span>();</span><br><span class="line">            <span class="built_in">CloseVideodecode</span>();</span><br><span class="line">            <span class="built_in">CloseInput</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;***Audiodecode***&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">        ret = <span class="built_in">Audiodecode</span>();</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">CloseAudiodecode</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cfg::<span class="built_in">get</span>()-&gt;<span class="built_in">SetLog</span>(<span class="string">&quot;start while&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;start while &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Run)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> packet = <span class="built_in">ReadPacketFromSource</span>();</span><br><span class="line">            <span class="keyword">if</span> (packet)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">WritePacket</span>(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Cfg::get()-&gt;SetLog(&quot;over while&quot;);</span></span><br><span class="line">    <span class="built_in">CloseSwSdecode</span>();</span><br><span class="line">    <span class="built_in">CloseAudiodecode</span>();</span><br><span class="line">    <span class="built_in">CloseVideodecode</span>();</span><br><span class="line">    <span class="built_in">CloseInput</span>();</span><br><span class="line">    <span class="comment">//    CloseOutput();</span></span><br><span class="line">    <span class="built_in">Deinit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  endregion</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="windows-GDI-录屏"><a href="#windows-GDI-录屏" class="headerlink" title="windows GDI 录屏"></a>windows GDI 录屏</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SCREENCAPTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCREENCAPTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenCaption</span>:</span>QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScreenCaption</span>();</span><br><span class="line">    ~<span class="built_in">ScreenCaption</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetRect</span><span class="params">(<span class="keyword">int</span> top, <span class="keyword">int</span> left, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    QTimer *m_Screen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">OnTimer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SCREENCAPTION_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ScreenCaption.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line">ScreenCaption::<span class="built_in">ScreenCaption</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScreenCaption::~<span class="built_in">ScreenCaption</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavcodec\avcodec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libavformat\avformat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libswscale\swscale.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wingdi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> bottom;</span><br><span class="line">&#125;RECORD_DESKTOP_RECT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flush_encoder</span><span class="params">(AVFormatContext *fmt_ctx, <span class="keyword">unsigned</span> <span class="keyword">int</span> stream_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBmp24</span><span class="params">(PBYTE pImg, INT nWidth, INT nHeight, LPCSTR strFile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_width;</span><br><span class="line"><span class="keyword">int</span> m_height;</span><br><span class="line"><span class="keyword">int</span> m_left;</span><br><span class="line"><span class="keyword">int</span> m_top;</span><br><span class="line"><span class="comment">// �癸拷锟斤拷</span></span><br><span class="line"></span><br><span class="line">HICON m_hIcon;</span><br><span class="line"><span class="keyword">int</span>  m_ibits;</span><br><span class="line"><span class="keyword">int</span> m_frame;</span><br><span class="line"><span class="keyword">int</span> numBytes;</span><br><span class="line"></span><br><span class="line">AVCodecContext* pCodecCtx;</span><br><span class="line">AVPacket pkt;</span><br><span class="line">AVStream* video_st;</span><br><span class="line">AVFormatContext* pFormatCtx;</span><br><span class="line">AVFrame *pFrame;</span><br><span class="line">AVFrame* picture;</span><br><span class="line"><span class="keyword">uint8_t</span>* picture_buf;</span><br><span class="line"><span class="keyword">uint8_t</span>* buffer;</span><br><span class="line">SwsContext *img_convert_ctx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UPDATETIME 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  TimerNum 111</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitOutFile</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CloseCaptureFile</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WriteFrame</span><span class="params">(LPBITMAPINFOHEADER bmp, <span class="keyword">int</span> pts)</span></span>;</span><br><span class="line"><span class="function">LPBITMAPINFOHEADER <span class="title">captureScreenFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> tempDisableRect)</span></span>;</span><br><span class="line"><span class="function">HANDLE <span class="title">Bitmap2Dib</span><span class="params">(HBITMAP hbitmap, UINT bits)</span></span>;</span><br><span class="line"><span class="function">HCURSOR <span class="title">OnQueryDragIcon</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_cursor</span><span class="params">(HDC hdc)</span></span>;</span><br><span class="line"></span><br><span class="line">CURSORINFO _ci;</span><br><span class="line"><span class="keyword">bool</span> _draw_cursor;</span><br><span class="line">RECORD_DESKTOP_RECT _rect;</span><br><span class="line"><span class="keyword">int</span> frameNumber=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HCURSOR <span class="title">OnQueryDragIcon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;HCURSOR&gt;(m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_cursor</span><span class="params">(HDC hdc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(_ci.flags &amp; CURSOR_SHOWING))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////is cursor in the tartet zone</span></span><br><span class="line">    <span class="comment">//if (_ci.ptScreenPos.x &lt; _rect.left ||</span></span><br><span class="line">    <span class="comment">//	_ci.ptScreenPos.x &gt; _rect.right ||</span></span><br><span class="line">    <span class="comment">//	_ci.ptScreenPos.y &lt; _rect.top ||</span></span><br><span class="line">    <span class="comment">//	_ci.ptScreenPos.y &gt; _rect.bottom</span></span><br><span class="line">    <span class="comment">//	)</span></span><br><span class="line">    <span class="comment">//	return;</span></span><br><span class="line"></span><br><span class="line">    HICON icon;</span><br><span class="line">    ICONINFO ii;</span><br><span class="line"></span><br><span class="line">    icon = <span class="built_in">CopyIcon</span>(_ci.hCursor);</span><br><span class="line">    <span class="keyword">if</span> (!icon)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetIconInfo</span>(icon, &amp;ii)) &#123;</span><br><span class="line">        POINT pos;</span><br><span class="line">        <span class="built_in">DrawIconEx</span>(hdc, _ci.ptScreenPos.x - m_left, _ci.ptScreenPos.y - m_top, icon, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, DI_NORMAL);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DeleteObject</span>(ii.hbmColor);</span><br><span class="line">        <span class="built_in">DeleteObject</span>(ii.hbmMask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DestroyIcon</span>(icon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LPBITMAPINFOHEADER <span class="title">captureScreenFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> tempDisableRect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HDC hScreenDC = <span class="built_in">CreateDC</span>(<span class="string">L&quot;DISPLAY&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HDC hMemDC = ::<span class="built_in">CreateCompatibleDC</span>(hScreenDC);</span><br><span class="line">    HBITMAP hbm;</span><br><span class="line">    hbm = <span class="built_in">CreateCompatibleBitmap</span>(hScreenDC, width, height);</span><br><span class="line">    HBITMAP oldbm = (HBITMAP)<span class="built_in">SelectObject</span>(hMemDC, hbm);</span><br><span class="line">    <span class="comment">//BitBlt(hMemDC, 0, 0, width, height, hScreenDC, left, top, SRCCOPY);</span></span><br><span class="line">    <span class="comment">//ver 1.6</span></span><br><span class="line">    DWORD bltFlags = SRCCOPY;</span><br><span class="line">    <span class="comment">//bltFlags |= CAPTUREBLT;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****************************https://blog.csdn.net/peilinok/article/details/103721317 *************************************/</span></span><br><span class="line">    <span class="built_in">BitBlt</span>(hMemDC, <span class="number">0</span>, <span class="number">0</span>, width, height, hScreenDC, top,left , SRCCOPY<span class="comment">/*| CAPTUREBLT*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****************************添加鼠标指针*************************************/</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;_ci, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(CURSORINFO));</span><br><span class="line">    _ci.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(CURSORINFO);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetCursorInfo</span>(&amp;_ci)) &#123;</span><br><span class="line">        <span class="built_in">draw_cursor</span>(hMemDC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SelectObject</span>(hMemDC, oldbm);</span><br><span class="line">    LPBITMAPINFOHEADER pBM_HEADER = (LPBITMAPINFOHEADER)<span class="built_in">GlobalLock</span>(<span class="built_in">Bitmap2Dib</span>(hbm, <span class="number">32</span>));</span><br><span class="line">    <span class="comment">//LPBITMAPINFOHEADER pBM_HEADER = (LPBITMAPINFOHEADER)GlobalLock(Bitmap2Dib(hbm, 24));</span></span><br><span class="line">    <span class="keyword">if</span> (pBM_HEADER == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeleteObject</span>(hbm);</span><br><span class="line">    <span class="built_in">DeleteDC</span>(hMemDC);</span><br><span class="line">    ::<span class="built_in">ReleaseDC</span>(<span class="literal">NULL</span>, hScreenDC);</span><br><span class="line">    <span class="keyword">return</span> pBM_HEADER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HANDLE <span class="title">Bitmap2Dib</span><span class="params">(HBITMAP hbitmap, UINT bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE              hdib = <span class="literal">NULL</span>;</span><br><span class="line">    HDC                 hdc;</span><br><span class="line">    BITMAP              bitmap;</span><br><span class="line">    UINT                wLineLen;</span><br><span class="line">    DWORD               dwSize;</span><br><span class="line">    DWORD               wColSize;</span><br><span class="line">    LPBITMAPINFOHEADER  lpbi;</span><br><span class="line">    LPBYTE              lpBits;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetObject</span>(hbitmap, <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAP), &amp;bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DWORD align the width of the DIB</span></span><br><span class="line">    <span class="comment">// Figure out the size of the colour table</span></span><br><span class="line">    <span class="comment">// Calculate the size of the DIB</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    wLineLen = (bitmap.bmWidth*bits + (bits - <span class="number">1</span>)) / (bits)* (bits / <span class="number">8</span>);</span><br><span class="line">    wColSize = <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD)*((bits &lt;= <span class="number">8</span>) ? <span class="number">1</span> &lt;&lt; bits : <span class="number">0</span>);</span><br><span class="line">    dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER) + wColSize +</span><br><span class="line">        (DWORD)(UINT)wLineLen*(DWORD)(UINT)bitmap.bmHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Allocate room for a DIB and set the LPBI fields</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    hdib = <span class="built_in">GlobalAlloc</span>(GHND, dwSize);</span><br><span class="line">    <span class="keyword">if</span> (!hdib)</span><br><span class="line">        <span class="keyword">return</span> hdib;</span><br><span class="line"></span><br><span class="line">    lpbi = (LPBITMAPINFOHEADER)<span class="built_in">GlobalLock</span>(hdib);</span><br><span class="line"></span><br><span class="line">    lpbi-&gt;biSize = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER);</span><br><span class="line">    lpbi-&gt;biWidth = bitmap.bmWidth;</span><br><span class="line">    lpbi-&gt;biHeight = bitmap.bmHeight;</span><br><span class="line">    lpbi-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">    lpbi-&gt;biBitCount = (WORD)bits;</span><br><span class="line">    lpbi-&gt;biCompression = BI_RGB;</span><br><span class="line">    lpbi-&gt;biSizeImage = dwSize - <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER) - wColSize;</span><br><span class="line">    lpbi-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">    lpbi-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">    lpbi-&gt;biClrUsed = (bits &lt;= <span class="number">8</span>) ? <span class="number">1</span> &lt;&lt; bits : <span class="number">0</span>;</span><br><span class="line">    lpbi-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Get the bits from the bitmap and stuff them after the LPBI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    lpBits = (LPBYTE)(lpbi + <span class="number">1</span>) + wColSize;</span><br><span class="line"></span><br><span class="line">    hdc = <span class="built_in">CreateCompatibleDC</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GetDIBits</span>(hdc, hbitmap, <span class="number">0</span>, bitmap.bmHeight, lpBits, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************截图***************************/</span></span><br><span class="line">    <span class="comment">//BITMAPFILEHEADER bf;</span></span><br><span class="line">    <span class="comment">//bf.bfType = 0x4d42;</span></span><br><span class="line">    <span class="comment">//bf.bfReserved1 = 0;</span></span><br><span class="line">    <span class="comment">//bf.bfReserved2 = 0;</span></span><br><span class="line">    <span class="comment">//bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);</span></span><br><span class="line">    <span class="comment">//bf.bfSize = bf.bfOffBits + 1920 * 1080 * 4;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//BITMAPINFOHEADER   bi;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bi.biSize = sizeof(BITMAPINFOHEADER);</span></span><br><span class="line">    <span class="comment">//bi.biWidth = 1920;</span></span><br><span class="line">    <span class="comment">//bi.biHeight = 1080 * (-1);</span></span><br><span class="line">    <span class="comment">//bi.biPlanes = 1;</span></span><br><span class="line">    <span class="comment">//bi.biBitCount = 32;//should get from system</span></span><br><span class="line">    <span class="comment">//bi.biCompression = BI_RGB;</span></span><br><span class="line">    <span class="comment">//bi.biSizeImage = 0;</span></span><br><span class="line">    <span class="comment">//bi.biXPelsPerMeter = 0;</span></span><br><span class="line">    <span class="comment">//bi.biYPelsPerMeter = 0;</span></span><br><span class="line">    <span class="comment">//bi.biClrUsed = 0;</span></span><br><span class="line">    <span class="comment">//bi.biClrImportant = 0;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//FILE *fp = fopen(&quot;save.bmp&quot;, &quot;wb+&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fwrite(&amp;bf, 1, sizeof(bf), fp);</span></span><br><span class="line">    <span class="comment">//fwrite(&amp;bi, 1, sizeof(bi), fp);</span></span><br><span class="line">    <span class="comment">//fwrite(lpBits, 1, bf.bfSize, fp);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fflush(fp);</span></span><br><span class="line">    <span class="comment">//fclose(fp);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lpbi-&gt;biClrUsed = (bits &lt;= <span class="number">8</span>) ? <span class="number">1</span> &lt;&lt; bits : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeleteDC</span>(hdc);</span><br><span class="line">    <span class="built_in">GlobalUnlock</span>(hdib);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hdib;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScreenCaption::OnTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPBITMAPINFOHEADER alpbi = <span class="literal">NULL</span>;</span><br><span class="line">    alpbi = <span class="built_in">captureScreenFrame</span>(m_left, m_top, m_width, m_height, TRUE);</span><br><span class="line">    <span class="built_in">WriteFrame</span>(alpbi, m_frame);</span><br><span class="line">    m_frame = m_frame + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GlobalFree</span>(alpbi);</span><br><span class="line">    <span class="comment">//qDebug()&lt;&lt;&quot;OnTimer&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitOutFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_register_all</span>();</span><br><span class="line">    AVOutputFormat* fmt;</span><br><span class="line"></span><br><span class="line">    AVCodec* pCodec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    tm* t_tm = <span class="keyword">new</span> tm;</span><br><span class="line">    <span class="built_in">localtime_s</span>(t_tm, &amp;now);</span><br><span class="line">    <span class="comment">//char* dt = ctime(&amp;now);</span></span><br><span class="line"></span><br><span class="line">    string tim = <span class="built_in">to_string</span>(t_tm-&gt;tm_year + <span class="number">1900</span>) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_mon + <span class="number">1</span>) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_mday) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_hour) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_min) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(t_tm-&gt;tm_sec) + <span class="string">&quot;.avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* out_file = tim.<span class="built_in">data</span>();</span><br><span class="line">    pFormatCtx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    fmt = <span class="built_in">av_guess_format</span>(<span class="literal">NULL</span>, out_file, <span class="literal">NULL</span>);</span><br><span class="line">    pFormatCtx-&gt;oformat = fmt;</span><br><span class="line">    <span class="comment">//注意输出路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avio_open</span>(&amp;pFormatCtx-&gt;pb, out_file, AVIO_FLAG_READ_WRITE) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//MessageBox(&quot;输出文件打开失败&quot;);</span></span><br><span class="line">        <span class="comment">//QMessageBox::warning(NULL, &quot;输出文件打开失败&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    video_st = <span class="built_in">avformat_new_stream</span>(pFormatCtx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (video_st == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    pCodecCtx = video_st-&gt;codec;</span><br><span class="line">    pCodecCtx-&gt;codec_id = AV_CODEC_ID_MPEG4;</span><br><span class="line">    <span class="comment">//pCodecCtx-&gt;vcodec = ;</span></span><br><span class="line">    pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    pCodecCtx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;<span class="comment">//AV_PIX_FMT_RGB24;</span></span><br><span class="line">    pCodecCtx-&gt;width = m_width;</span><br><span class="line">    pCodecCtx-&gt;height = m_height;</span><br><span class="line">    pCodecCtx-&gt;time_base.num = <span class="number">1</span>;</span><br><span class="line">    pCodecCtx-&gt;time_base.den = <span class="number">8</span>;</span><br><span class="line">    pCodecCtx-&gt;bit_rate = <span class="number">3000000</span>;</span><br><span class="line">    pCodecCtx-&gt;global_quality = <span class="number">300</span>;</span><br><span class="line">    <span class="comment">// 	pCodecCtx-&gt;gop_size=80;</span></span><br><span class="line">    <span class="comment">// 	pCodecCtx-&gt;qmin = 10;</span></span><br><span class="line">    <span class="comment">// 	pCodecCtx-&gt;qmax = 51;</span></span><br><span class="line">    <span class="comment">//输出格式信息</span></span><br><span class="line">    <span class="built_in">av_dump_format</span>(pFormatCtx, <span class="number">0</span>, out_file, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pCodec = <span class="built_in">avcodec_find_encoder</span>(AV_CODEC_ID_MPEG4);</span><br><span class="line">    <span class="keyword">if</span> (!pCodec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//MessageBox(&quot;没有找到合适的编码器！&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//MessageBox(&quot;编码器打开失败！&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写文件头</span></span><br><span class="line">    <span class="built_in">avformat_write_header</span>(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    picture = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    size = <span class="built_in">avpicture_get_size</span>(pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    picture_buf = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size];</span><br><span class="line">    <span class="built_in">avpicture_fill</span>((AVPicture *)picture, picture_buf, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pFrame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    numBytes = <span class="built_in">avpicture_get_size</span>(AV_PIX_FMT_RGB32, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[numBytes];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height;</span><br><span class="line">    <span class="built_in">av_new_packet</span>(&amp;pkt, y_size * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    img_convert_ctx = <span class="built_in">sws_getContext</span>(pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_RGB32, pCodecCtx-&gt;width,</span><br><span class="line">        pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CloseCaptureFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Flush Encoder</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">flush_encoder</span>(pFormatCtx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flushing encoder failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写文件尾</span></span><br><span class="line">    <span class="built_in">av_write_trailer</span>(pFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理</span></span><br><span class="line">    <span class="keyword">if</span> (video_st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">avcodec_close</span>(video_st-&gt;codec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">avio_close</span>(pFormatCtx-&gt;pb);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(pFormatCtx);</span><br><span class="line">    <span class="built_in">av_free</span>(picture);</span><br><span class="line">    <span class="keyword">delete</span>[] picture_buf;</span><br><span class="line">    <span class="built_in">av_free</span>(pFrame);</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    frameNumber=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WriteFrame</span><span class="params">(LPBITMAPINFOHEADER bmp, <span class="keyword">int</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, numBytes);</span><br><span class="line">    <span class="keyword">uint8_t</span>* tmpBuf = (<span class="keyword">uint8_t</span>*)(bmp + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pCodecCtx-&gt;height; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer + i * (pCodecCtx-&gt;width * <span class="number">4</span>), (tmpBuf + (pCodecCtx-&gt;width * <span class="number">4</span>)*(pCodecCtx-&gt;height - i - <span class="number">1</span>)), (pCodecCtx-&gt;width * <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret1 = <span class="built_in">avpicture_fill</span>((AVPicture *)pFrame, buffer, AV_PIX_FMT_RGB32, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sws_scale</span>(img_convert_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, picture-&gt;data, picture-&gt;linesize);</span><br><span class="line"></span><br><span class="line">    picture-&gt;pkt_duration = <span class="number">0</span>;</span><br><span class="line">    picture-&gt;pkt_pos = <span class="number">-1</span>;</span><br><span class="line">    picture-&gt;pkt_dts = picture-&gt;pts = <span class="built_in">av_rescale_q_rnd</span>(frameNumber, pCodecCtx-&gt;time_base, video_st-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">    <span class="comment">//picture-&gt;pkt_dts = picture-&gt;pts = frameNumber * pCodecCtx-&gt;time_base.num * video_st-&gt;time_base.den / (pCodecCtx-&gt;time_base.den *  video_st-&gt;time_base.num);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//PTS</span></span><br><span class="line"><span class="comment">//    picture-&gt;pts = pts;</span></span><br><span class="line"><span class="comment">//    picture-&gt;pkt_duration = 125;</span></span><br><span class="line"><span class="comment">//    pkt.dts = pts;</span></span><br><span class="line">    <span class="keyword">int</span> got_picture = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//av_init_packet(&amp;pkt);</span></span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">avcodec_encode_video2</span>(pCodecCtx, &amp;pkt, picture, &amp;got_picture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//QMessageBox::warning(NULL, &quot;编码错误&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (got_picture == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pkt.stream_index = video_st-&gt;index;</span><br><span class="line">        frameNumber++;</span><br><span class="line">        ret = <span class="built_in">av_write_frame</span>(pFormatCtx, &amp;pkt);</span><br><span class="line">        <span class="comment">//delete[] pkt.data;</span></span><br><span class="line">        <span class="built_in">av_free_packet</span>(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flush_encoder</span><span class="params">(AVFormatContext *fmt_ctx, <span class="keyword">unsigned</span> <span class="keyword">int</span> stream_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> got_frame;</span><br><span class="line">    AVPacket enc_pkt;</span><br><span class="line">    <span class="keyword">if</span> (!(fmt_ctx-&gt;streams[stream_index]-&gt;codec-&gt;codec-&gt;capabilities &amp;</span><br><span class="line">        AV_CODEC_CAP_DELAY))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Flushing stream #%u encoder\n&quot;</span>, stream_index);</span><br><span class="line">        <span class="comment">//ret = encode_write_frame(NULL, stream_index, &amp;got_frame);</span></span><br><span class="line">        enc_pkt.data = <span class="literal">NULL</span>;</span><br><span class="line">        enc_pkt.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">av_init_packet</span>(&amp;enc_pkt);</span><br><span class="line">        ret = <span class="built_in">avcodec_encode_video2</span>(fmt_ctx-&gt;streams[stream_index]-&gt;codec, &amp;enc_pkt,</span><br><span class="line">            <span class="literal">NULL</span>, &amp;got_frame);</span><br><span class="line">        <span class="built_in">av_frame_free</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!got_frame)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;编码成功1帧&quot;</span>);</span><br><span class="line">        <span class="comment">/* mux encoded frame */</span></span><br><span class="line">        ret = <span class="built_in">av_write_frame</span>(fmt_ctx, &amp;enc_pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBmp24</span><span class="params">(PBYTE pImg, INT nWidth, INT nHeight, LPCSTR strFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pImg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE hf = (HANDLE)::<span class="built_in">CreateFile</span>((LPCWSTR)strFile, GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == hf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BITMAPFILEHEADER bfh;</span><br><span class="line">    DWORD dwLength = nWidth*nHeight * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;bfh, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(bfh));</span><br><span class="line">    bfh.bfType = <span class="string">&#x27;MB&#x27;</span>;</span><br><span class="line">    bfh.bfSize = <span class="built_in"><span class="keyword">sizeof</span></span>(bfh) + dwLength + <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER);</span><br><span class="line">    bfh.bfOffBits = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER) + <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPFILEHEADER);</span><br><span class="line"></span><br><span class="line">    DWORD Written = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteFile</span>(hf, &amp;bfh, <span class="built_in"><span class="keyword">sizeof</span></span>(bfh), &amp;Written, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    BITMAPINFOHEADER bih;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;bih, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(bih));</span><br><span class="line">    bih.biSize = <span class="built_in"><span class="keyword">sizeof</span></span>(bih);</span><br><span class="line">    bih.biWidth = nWidth;</span><br><span class="line">    bih.biHeight = nHeight;</span><br><span class="line">    bih.biPlanes = <span class="number">1</span>;</span><br><span class="line">    bih.biBitCount = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    Written = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WriteFile</span>(hf, &amp;bih, <span class="built_in"><span class="keyword">sizeof</span></span>(bih), &amp;Written, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    dwLength = nHeight*nWidth * <span class="number">3</span>;</span><br><span class="line">    Written = <span class="number">0</span>;</span><br><span class="line">    BOOL  Ret = <span class="built_in">WriteFile</span>(hf, pImg, dwLength, &amp;Written, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScreenCaption::SetRect</span><span class="params">(<span class="keyword">int</span> top, <span class="keyword">int</span> left, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_width = width;</span><br><span class="line">    m_height = height;</span><br><span class="line">    m_left = left;</span><br><span class="line">    m_top = top;</span><br><span class="line"></span><br><span class="line">    m_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_width == <span class="number">0</span> &amp;&amp; m_height == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitOutFile</span>();</span><br><span class="line"></span><br><span class="line">    m_Screen = <span class="keyword">new</span> QTimer;</span><br><span class="line">    m_Screen-&gt;<span class="built_in">setInterval</span>(<span class="number">125</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_Screen, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">OnTimer</span>()));</span><br><span class="line">    m_Screen-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScreenCaption::finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_Screen-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    <span class="built_in">disconnect</span>(m_Screen, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">OnTimer</span>()));</span><br><span class="line">    <span class="keyword">delete</span> m_Screen;</span><br><span class="line">    <span class="built_in">CloseCaptureFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
