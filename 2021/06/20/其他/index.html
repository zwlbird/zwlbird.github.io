<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>其他 | .oOo.</title><meta name="keywords" content="Qt,C++"><meta name="author" content="Smt"><meta name="copyright" content="Smt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一些常用的代码">
<meta property="og:type" content="article">
<meta property="og:title" content="其他">
<meta property="og:url" content="https://zwlbird.github.io/2021/06/20/%E5%85%B6%E4%BB%96/index.html">
<meta property="og:site_name" content=".oOo.">
<meta property="og:description" content="一些常用的代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/27/muMz2oUV3hWjZbE.jpg">
<meta property="article:published_time" content="2021-06-20T11:13:54.000Z">
<meta property="article:modified_time" content="2024-01-09T10:17:56.057Z">
<meta property="article:author" content="Smt">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/27/muMz2oUV3hWjZbE.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwlbird.github.io/2021/06/20/%E5%85%B6%E4%BB%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '其他',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-09 18:17:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/27/muMz2oUV3hWjZbE.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">.oOo.</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">其他</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-20T11:13:54.000Z" title="发表于 2021-06-20 19:13:54">2021-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-09T10:17:56.057Z" title="更新于 2024-01-09 18:17:56">2024-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>114分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="其他"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/06/20/%E5%85%B6%E4%BB%96/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/06/20/%E5%85%B6%E4%BB%96/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="获取程序当前目录"><a href="#获取程序当前目录" class="headerlink" title="获取程序当前目录"></a>获取程序当前目录</h1><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString path=QDir::<span class="built_in">currentPath</span>();<span class="comment">//获取程序当前目录</span></span><br><span class="line">path.<span class="built_in">replace</span>(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>);<span class="comment">//将地址中的&quot;/&quot;替换为&quot;\&quot;，因为在Windows下使用的是&quot;\&quot;。</span></span><br><span class="line">QProcess::<span class="built_in">startDetached</span>(<span class="string">&quot;explorer &quot;</span>+path);<span class="comment">//打开上面获取的目录</span></span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找当前exe的路径</span></span><br><span class="line">	TCHAR szFilePath[MAX_PATH + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFilePath, MAX_PATH);</span><br><span class="line">	(_tcsrchr(szFilePath, _T(<span class="string">&#x27;\\&#x27;</span>)))[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 删除文件名，只获得路径字串</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iLen = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">char</span>* chRtn = <span class="keyword">new</span> <span class="keyword">char</span>[iLen*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)];</span><br><span class="line">	<span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, szFilePath, <span class="number">-1</span>, chRtn, iLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h1 id="通配符模糊查询"><a href="#通配符模糊查询" class="headerlink" title="通配符模糊查询"></a>通配符模糊查询</h1><p>通配符是一种特殊语句，主要有星号(<em>)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 实际上用“</em>Not?pad”可以对应Notepad\MyNotepad【*可以代表任何字符串；?仅代表单个字符串，但此单字必须存在】;Notep[ao]d可以对应Notepad\Notepod【ao代表a与o里二选一】，其余以此类推。</p>
<p>* 匹配 0 或多个字符 a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。 ? 匹配任意一个字符 a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//查询所有文件</span></span><br><span class="line">    <span class="keyword">char</span>* to_search = <span class="string">&quot;D:/Examples/Polar_C++/x64/Release/?.png&quot;</span>;<span class="comment">//*</span></span><br><span class="line">    <span class="comment">//遍历路径下的文件，找到需要的png</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span> &gt; finename;<span class="comment">//文件名的数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * point = <span class="string">&quot;.&quot;</span>;<span class="comment">//分割标示</span></span><br><span class="line">    <span class="keyword">intptr_t</span> handle;    <span class="comment">//用于查找的句柄</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fileinfo</span>;</span>    <span class="comment">//文件信息的结构体</span></span><br><span class="line">    handle = _findfirst(to_search.<span class="built_in">data</span>(), &amp;fileinfo);    <span class="comment">//第一次查找</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;正在进行%s\n&quot;</span>, fileinfo.name); </span><br><span class="line">    finename.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(<span class="built_in">strtok</span>(fileinfo.name, point)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!_findnext(handle, &amp;fileinfo)) &#123;    <span class="comment">//循环查找其它符合的文件，直到找不到其它的为止</span></span><br><span class="line">        finename.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(<span class="built_in">strtok</span>(fileinfo.name, point)));</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;正在进行%s\n&quot;</span>, fileinfo.name); </span><br><span class="line">    &#125;</span><br><span class="line">    _findclose(handle);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有可能会报错，比如0x00007FFC70CB0B2D (ntdll.dll)处(位于 Cutton_Dlg.exe 中)引发的异常: 0xC0000005: 写入位置 0xFFFFFFFFAE1B1940 时发生访问冲突。</p>
<p>解决方法： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>	handle;</span><br><span class="line">`改成`</span><br><span class="line"><span class="keyword">intptr_t</span>	handle;</span><br></pre></td></tr></table></figure>

<h1 id="某个磁盘的大小"><a href="#某个磁盘的大小" class="headerlink" title="某个磁盘的大小"></a>某个磁盘的大小</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="function">quint64 <span class="title">getDiskFreeSpace</span><span class="params">(QString driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPCWSTR lpcwstrDriver = (LPCWSTR)driver.<span class="built_in">utf16</span>();</span><br><span class="line">    ULARGE_INTEGER liFreeBytesAvailable, liTotalBytes, liTotalFreeBytes;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetDiskFreeSpaceEx</span>(lpcwstrDriver, &amp;liFreeBytesAvailable, &amp;liTotalBytes, &amp;liTotalFreeBytes))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (quint64)liTotalFreeBytes.QuadPart / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> qyh &#123;</span><br><span class="line">    CDiskInfo::<span class="built_in">CDiskInfo</span>(<span class="keyword">const</span> std::string&amp; _path) :</span><br><span class="line">            <span class="built_in">disk_total_capacity</span>(<span class="number">0</span>), <span class="built_in">disk_used_capacity</span>(<span class="number">0</span>), <span class="built_in">disk_free_capacity</span>(<span class="number">0</span>), <span class="built_in">disk_format</span>(</span><br><span class="line">                    DISK_FORMAT_UNKNOW), <span class="built_in">path</span>(_path) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">statfs</span>(path.<span class="built_in">c_str</span>(), &amp;buf);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;get disk infomation faild\n&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (buf.f_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4d44</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_FAT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x5346544e</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0X65735546</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_NTFS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEF53</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xEF51</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_EXT2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                disk_format = DISK_FORMAT_UNKNOW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            disk_total_capacity = (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize</span><br><span class="line">                    * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_blocks) );</span><br><span class="line">            disk_free_capacity =</span><br><span class="line">                    (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bfree));</span><br><span class="line">            disk_used_capacity = disk_total_capacity - disk_free_capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CDiskInfo::~<span class="built_in">CDiskInfo</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CDiskInfo::refreshInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">statfs</span>(path.<span class="built_in">c_str</span>(), &amp;buf);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;refresh get disk infomation faild\n&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (buf.f_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x4d44</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_FAT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x5346544e</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0X65735546</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_NTFS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xEF53</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xEF51</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_EXT2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            disk_format = DISK_FORMAT_UNKNOW;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        disk_total_capacity = (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_blocks));</span><br><span class="line">        disk_free_capacity = (((<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bsize * (<span class="keyword">long</span> <span class="keyword">long</span>) buf.f_bfree));</span><br><span class="line">        disk_used_capacity = disk_total_capacity - disk_free_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CDiskInfo::getTotalSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_total_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CDiskInfo::getUsedSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_used_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CDiskInfo::getLeftSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_free_capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">DISK_FORMAT <span class="title">CDiskInfo::getDiskFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> disk_format;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="comment">/* namespace qyh */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function">qyh::CDiskInfo <span class="title">disk</span><span class="params">(path)</span></span>;</span><br><span class="line"> leftsize=disk.<span class="built_in">getLeftSize</span>();</span><br></pre></td></tr></table></figure>



<h1 id="所占内存大小监视"><a href="#所占内存大小监视" class="headerlink" title="所占内存大小监视"></a>所占内存大小监视</h1><h2 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE handle = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line"><span class="built_in">GetProcessMemoryInfo</span>(handle, &amp;pmc, <span class="built_in"><span class="keyword">sizeof</span></span>(pmc));</span><br><span class="line"><span class="comment">//内存大于800M就自动重启</span></span><br><span class="line"><span class="keyword">if</span> (pmc.PeakWorkingSetSize /<span class="number">1024</span>/<span class="number">1024</span> &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">on_btnStop_clicked</span>();</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    qApp-&gt;<span class="built_in">exit</span>(<span class="number">888</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">**  文件名称:  res_monitor.c</span></span><br><span class="line"><span class="comment">**  文件描述:  指定进程的[cpu/内存]资源使用情况监测</span></span><br><span class="line"><span class="comment">**  ===============================================================================================</span></span><br><span class="line"><span class="comment">**  创建信息:  | 2019-2-1 | LEON | 创建本模块</span></span><br><span class="line"><span class="comment">**  ===============================================================================================</span></span><br><span class="line"><span class="comment">**  修改信息:  单击此处添加....</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;printf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">// CPU占用率计算原理：</span></span><br><span class="line"><span class="comment">// 1、读取/proc/pid/stat文件，其中记录了从开机到现在，本进程所占用的CPU时间（单位jiffies）</span></span><br><span class="line"><span class="comment">// 2、然后再读取/proc/stat文件，其中记录了从开机到现在，系统所占用的CPU时间（单位jiffies）</span></span><br><span class="line"><span class="comment">// 3、取两个时间点，这两个时间点的进程耗时差，除以系统耗时差，得到的就是该进程的CPU占用率</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">// 内存占用率计算原理：</span></span><br><span class="line"><span class="comment">// 读取/proc/pid/status文件，其中以VmRSS开头的行，记录了该进程的物理内存值</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">// 下面这段话详细的解释了RSS内存的意义，及其与VSZ内存的区别</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// RSS（Resident Set Size），常驻内存集大小，表示进程在RAM中占用了多少内存，并不包含在SWAP中占用的虚拟内存</span></span><br><span class="line"><span class="comment">// 即使是在内存中的使用了共享库的内存大小也一并计算在内，包含了完整的在stack和heap中的内存</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// VSZ（Virtual Memory Size），虚拟内存大小，表明了该进程可以访问的所有内存，包括被交换的内存和共享库内存</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 如果进程A的二进制文件大小为500KB，并且链接到了2500KB的共享库，有200KB的stack/heap大小</span></span><br><span class="line"><span class="comment">// 这200KB中又有100KB位于内存中，100KB位于SWAP空间中，并且加载了1000KB的共享库和400KB的自身二进制文件。则</span></span><br><span class="line"><span class="comment">// RSS: 400K + 1000K + 100K = 1500K; VSZ: 500K + 2500K + 200K = 3200K</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">//                           模块宏定义</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_START_POS        14                                                <span class="comment">/* stat文件的有效起始行数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUF_SIZE        512                                               <span class="comment">/* 读取文件的缓存空间大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ENABLE           <span class="meta-string">&quot;logon&quot;</span>                                           <span class="comment">/* 启用日志输出的命令 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONITR_DATA_PATH     <span class="meta-string">&quot;monitor_log&quot;</span>                                     <span class="comment">/* 日志文件的子目录 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONITR_DATA_BEXT     <span class="meta-string">&quot;.log&quot;</span>                                            <span class="comment">/* 日志文件的后缀名 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="comment">//                           模块静态变量定义</span></span><br><span class="line"><span class="comment">/*************************************************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> s_cur_pro_cpu, s_pre_pro_cpu;                                      <span class="comment">/* 指定程序的本轮/前轮CPU时间 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> s_cur_sys_cpu, s_pre_sys_cpu;                                      <span class="comment">/* 整个系统的本轮/前轮CPU时间 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>  s_needlogfile;                                                     <span class="comment">/* 是否要输出到日志文件 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> s_recfilepath[<span class="number">128</span>];                                                <span class="comment">/* 日志文件的路径信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  excute_cmd</span></span><br><span class="line"><span class="comment">**  功能描述:  执行shell脚本，并解析出最终的执行结果</span></span><br><span class="line"><span class="comment">**  输入参数:  脚本命令</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  返回1表示脚本命令执行成功，返回-1表示执行失败</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">excute_cmd</span><span class="params">(<span class="keyword">char</span> *comand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    </span><br><span class="line">    status = <span class="built_in">system</span>(comand);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>) &#123;                                                        <span class="comment">/* 系统子进程创建失败 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status) == <span class="number">0</span>) &#123;                                              <span class="comment">/* shell拉起失败或未正常执行结束 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WEXITSTATUS</span>(status) != <span class="number">0</span>) &#123;                                            <span class="comment">/* mkdir命令执行失败 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  target_is_exist</span></span><br><span class="line"><span class="comment">**  功能描述:  检查目标是否存在 【目标可以是目录和文件】</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  返回1表示目标存在，返回-1表示目标不存在</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">target_is_exist</span><span class="params">(<span class="keyword">char</span> *target_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    </span><br><span class="line">    result = <span class="built_in">access</span>(target_path, F_OK);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  make_sudir</span></span><br><span class="line"><span class="comment">**  功能描述:  创建目录 【可以建立多级子目录】</span></span><br><span class="line"><span class="comment">**  输入参数:  子目录路径</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  返回0表示该目录已经存在，返回1表示创建成功，返回-1表示创建失败</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">make_sudir</span><span class="params">(<span class="keyword">char</span> *fpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *comand;</span><br><span class="line">    <span class="keyword">int</span>   pathlen, result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">target_is_exist</span>(fpath) == <span class="number">1</span>) &#123;                                      <span class="comment">/* 目标文件夹已经存在 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pathlen = <span class="built_in">strlen</span>(fpath) + <span class="number">16</span>;                                              <span class="comment">/* 16的长度是为shell命令而留 */</span></span><br><span class="line">    comand = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pathlen);</span><br><span class="line">    <span class="built_in">assert</span>(comand != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(comand, <span class="number">0</span>, pathlen);</span><br><span class="line">    <span class="built_in">sprintf</span>(comand, <span class="string">&quot;mkdir -p %s&quot;</span>, fpath);</span><br><span class="line">    result = <span class="built_in">excute_cmd</span>(comand);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(comand);                                                              <span class="comment">/* 这里要记得释放内存 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  write_recfile</span></span><br><span class="line"><span class="comment">**  功能描述:  将信息写入到日志文件中</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_recfile</span><span class="params">(<span class="keyword">char</span> *log_path, <span class="keyword">char</span> *log_text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *log_hdl;</span><br><span class="line">    </span><br><span class="line">    log_hdl = <span class="built_in">fopen</span>(log_path, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(log_hdl != <span class="literal">NULL</span>);                                                   <span class="comment">/* 打开日志记录文件 */</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fseek</span>(log_hdl, <span class="number">0</span>, SEEK_END) == <span class="number">0</span>);                                  <span class="comment">/* 定位到尾开始写入 */</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fwrite</span>(log_text, <span class="built_in">strlen</span>(log_text), <span class="number">1</span>, log_hdl) == <span class="number">1</span>);               <span class="comment">/* 写入信息内容 */</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fclose</span>(log_hdl) == <span class="number">0</span>);                                              <span class="comment">/* 关闭日志记录文件 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  generate_rfile_path</span></span><br><span class="line"><span class="comment">**  功能描述:  生成文件名路径信息</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_rfile_path</span><span class="params">(<span class="keyword">char</span> *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>   <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>        <span class="title">tm</span>;</span></span><br><span class="line">    <span class="keyword">char</span>             timestr[<span class="number">32</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(timestr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(timestr));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">    tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br><span class="line">    <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%.4d%.2d%.2d_%.2d%.2d%.2d&quot;</span>, tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">make_sudir</span>(MONITR_DATA_PATH) != <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(s_recfilepath, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s_recfilepath));</span><br><span class="line">    <span class="built_in">sprintf</span>(s_recfilepath, <span class="string">&quot;%s/%s_%s%s&quot;</span>, MONITR_DATA_PATH, target, timestr, MONITR_DATA_BEXT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;log is enabled. log_file \&quot;%s\&quot;\n&quot;</span>, s_recfilepath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  record_loginfo</span></span><br><span class="line"><span class="comment">**  功能描述:  将信息记录到日志文件，并进行打印输出</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">record_loginfo</span><span class="params">(<span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>   <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>        <span class="title">tm</span>;</span></span><br><span class="line">    <span class="keyword">int</span>              tlen;</span><br><span class="line">    <span class="keyword">char</span>            *wstr;</span><br><span class="line">    </span><br><span class="line">    tlen = <span class="built_in">strlen</span>(info) + <span class="number">32</span>;                                                  <span class="comment">/* 32用于存放时间戳 */</span></span><br><span class="line">    wstr = <span class="built_in">malloc</span>(tlen);</span><br><span class="line">    <span class="built_in">assert</span>(wstr != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">    tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br><span class="line">    <span class="built_in">sprintf</span>(wstr, <span class="string">&quot;[%04d/%02d/%02d %02d:%02d:%02d] %s&quot;</span>, tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, info);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, wstr);                                                        <span class="comment">/* 输出到终端显示 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s_needlogfile &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write_recfile</span>(s_recfilepath, wstr);                                    <span class="comment">/* 记录到日志文件 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  find_pid_by_name</span></span><br><span class="line"><span class="comment">**  功能描述:  根据进程名得到进程ID</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_pid_by_name</span><span class="params">(<span class="keyword">char</span>* pidName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR           *prodir;</span><br><span class="line">    FILE          *status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">char</span>          finame[READ_BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span>          tmpbuf[READ_BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span>          pcname[READ_BUF_SIZE];</span><br><span class="line">    </span><br><span class="line">    prodir = <span class="built_in">opendir</span>(<span class="string">&quot;/proc&quot;</span>);                                                 <span class="comment">/* proc中包括当前的进程信息 */</span></span><br><span class="line">    <span class="built_in">assert</span>(prodir != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((next = <span class="built_in">readdir</span>(prodir)) != <span class="literal">NULL</span>) &#123;                                 <span class="comment">/* 逐个检索所有目录 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(next-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*next-&gt;d_name)) &#123;                                         <span class="comment">/* 进程目录必须是数字的 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sprintf</span>(finame, <span class="string">&quot;/proc/%s/status&quot;</span>, next-&gt;d_name);                      <span class="comment">/* 拼凑出完整的目录名称 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(status = <span class="built_in">fopen</span>(finame, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fgets</span>(tmpbuf, READ_BUF_SIZE - <span class="number">1</span>, status) == <span class="literal">NULL</span>) &#123;                <span class="comment">/* 读取目录下的文件 */</span></span><br><span class="line">            <span class="built_in">fclose</span>(status);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fclose</span>(status);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sscanf</span>(tmpbuf, <span class="string">&quot;%*s %s&quot;</span>, pcname);                                      <span class="comment">/* 提取出其中的有效内容 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pcname, pidName) == <span class="number">0</span>) &#123;                                    <span class="comment">/* 与所输入的进程名符合 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">strtol</span>(next-&gt;d_name, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_items_by_pos</span></span><br><span class="line"><span class="comment">**  功能描述:  在字符串中寻找第N次空格出现的地方</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_items_by_pos</span><span class="params">(<span class="keyword">char</span> *buff, <span class="keyword">unsigned</span> <span class="keyword">int</span> numb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *crpos;</span><br><span class="line">    <span class="keyword">int</span>   i, ttlen, count;</span><br><span class="line">    </span><br><span class="line">    crpos = buff;</span><br><span class="line">    ttlen = <span class="built_in">strlen</span>(buff);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ttlen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == *crpos) &#123;                                                   <span class="comment">/* 以空格为标记符进行识别 */</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == (numb - <span class="number">1</span>)) &#123;                                         <span class="comment">/* 全部个数都找完了 */</span></span><br><span class="line">                crpos++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        crpos++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> crpos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_pro_cpu_time</span></span><br><span class="line"><span class="comment">**  功能描述:  获取某个进程的CPU时间（从开机到现在，单位jiffies）</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_pro_cpu_time</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE   *fd;</span><br><span class="line">    <span class="keyword">char</span>   *vpos, buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">long</span>    utime, stime, cutime, cstime;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">&quot;/proc/%d/stat&quot;</span>, pid);                                       <span class="comment">/* 读取进程的状态文件 */</span></span><br><span class="line">    </span><br><span class="line">    fd = <span class="built_in">fopen</span>(buff, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(fd != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fgets</span>(buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), fd) != <span class="literal">NULL</span>);                             <span class="comment">/* 读取文件内容到缓冲区 */</span></span><br><span class="line">    </span><br><span class="line">    vpos = <span class="built_in">get_items_by_pos</span>(buff, CPU_START_POS);                              <span class="comment">/* 读取指定的条目内容 */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(vpos, <span class="string">&quot;%ld %ld %ld %ld&quot;</span>, &amp;utime, &amp;stime, &amp;cutime, &amp;cstime);         <span class="comment">/* 将条目内容拆分成实际的数据 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (utime + stime + cutime + cstime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_sys_cpu_time</span></span><br><span class="line"><span class="comment">**  功能描述:  获取整个系统的CPU时间（从开机到现在，单位jiffies）</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_sys_cpu_time</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE   *fd;</span><br><span class="line">    <span class="keyword">char</span>   name[<span class="number">32</span>], buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">long</span>   user, nice, syst, idle;</span><br><span class="line">    </span><br><span class="line">    fd = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/stat&quot;</span>, <span class="string">&quot;r&quot;</span>);                                             <span class="comment">/* 读取系统的状态文件 */</span></span><br><span class="line">    <span class="built_in">assert</span>(fd != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fgets</span>(buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), fd) != <span class="literal">NULL</span>);                             <span class="comment">/* 读取文件内容到缓冲区 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(buff, <span class="string">&quot;%s %ld %ld %ld %ld&quot;</span>, name, &amp;user, &amp;nice, &amp;syst, &amp;idle);      <span class="comment">/* 将条目内容拆分成实际的数据 */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (user + nice + syst + idle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_cpu_stat</span></span><br><span class="line"><span class="comment">**  功能描述:  获取进程的CPU使用率</span></span><br><span class="line"><span class="comment">**  输入参数:  无</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  本轮时间片里，该进程的CPU使用率，单位百分比</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_cpu_stat</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ratio;</span><br><span class="line">    </span><br><span class="line">    s_cur_pro_cpu = <span class="built_in">get_pro_cpu_time</span>(pid);</span><br><span class="line">    s_cur_sys_cpu = <span class="built_in">get_sys_cpu_time</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((s_cur_pro_cpu == s_pre_pro_cpu) || (s_cur_sys_cpu == s_pre_sys_cpu) || (s_cur_pro_cpu == <span class="number">0</span>) || (s_cur_sys_cpu == <span class="number">0</span>)) &#123;</span><br><span class="line">        ratio = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ratio = (<span class="number">100.0</span> * (s_cur_pro_cpu - s_pre_pro_cpu)) / (s_cur_sys_cpu - s_pre_sys_cpu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s_pre_pro_cpu = s_cur_pro_cpu;</span><br><span class="line">    s_pre_sys_cpu = s_cur_sys_cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ratio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  get_mem_stat</span></span><br><span class="line"><span class="comment">**  功能描述:  获取进程的内存使用情况</span></span><br><span class="line"><span class="comment">**  输入参数:  进程ID值</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  此刻，该进程的物理内存占用量，单位KB</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_mem_stat</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="keyword">int</span>   vmrss;</span><br><span class="line">    <span class="keyword">char</span> *valid, sbuff[<span class="number">32</span>], tbuff[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(tbuff, <span class="string">&quot;/proc/%d/status&quot;</span>, pid);                                    <span class="comment">/* 在proc目录下查找进程对应文件 */</span></span><br><span class="line">    </span><br><span class="line">    fd = <span class="built_in">fopen</span>(tbuff, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(fd != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;                                                                <span class="comment">/* 对文件内容进行逐行搜索 */</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">fgets</span>(tbuff, <span class="built_in"><span class="keyword">sizeof</span></span>(tbuff), fd) != <span class="literal">NULL</span>);                       <span class="comment">/* 文件读取出错 */</span></span><br><span class="line">        valid = <span class="built_in">strstr</span>(tbuff, <span class="string">&quot;VmRSS&quot;</span>);                                        <span class="comment">/* 在该行内容中搜索关键词 */</span></span><br><span class="line">        <span class="keyword">if</span> (valid != <span class="literal">NULL</span>) &#123;                                                   <span class="comment">/* 结果非空则表示搜索成功 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sscanf</span>(tbuff, <span class="string">&quot;%s %d&quot;</span>, sbuff, &amp;vmrss);                                     <span class="comment">/* 将该行内容拆成符合需要的格式 */</span></span><br><span class="line">    <span class="built_in">fclose</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vmrss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************************************************</span></span><br><span class="line"><span class="comment">**  函数名称:  main</span></span><br><span class="line"><span class="comment">**  功能描述:  主函数</span></span><br><span class="line"><span class="comment">**  输入参数:  需要监测的进程名称，刷新的频率，以及是否要输出到日志文件</span></span><br><span class="line"><span class="comment">**  输出参数:  无</span></span><br><span class="line"><span class="comment">**  返回参数:  无</span></span><br><span class="line"><span class="comment">**  使用方法:  输入&quot;monitor_pc cheese 1&quot;，表示以1s的频率监控cheese进程的CPU及物理内存使用情况</span></span><br><span class="line"><span class="comment">**  使用方法:  如果需要将监控数据同步输出到日志文件，则输入&quot;monitor_pc cheese 1 logon&quot;即可</span></span><br><span class="line"><span class="comment">**************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pid, rtime;</span><br><span class="line">    <span class="keyword">char</span> *name_pos, *proc_name, sstr[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid cmd!!! should specify \&quot;proc_name\&quot; and \&quot;refresh_time\&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    proc_name = argv[<span class="number">0</span>];                                                       <span class="comment">/* 获取进程名称 */</span></span><br><span class="line">    </span><br><span class="line">    name_pos = <span class="built_in">strrchr</span>(proc_name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != name_pos)&#123;                                                     <span class="comment">/* 提取出路径最后部分的文件名 */</span></span><br><span class="line">        proc_name = name_pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;proc \&quot;%s\&quot; starting...\n&quot;</span>, proc_name);</span><br><span class="line">    </span><br><span class="line">    rtime = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);                                                     <span class="comment">/* 获取刷新时间 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((rtime == <span class="number">0</span>) || (rtime &gt; <span class="number">60</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid refresh_time(%d)!!! valid range: 0-60\n&quot;</span>, rtime);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s_needlogfile = <span class="number">0</span>;                                                         <span class="comment">/* 默认不需要启用日志输出功能 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((argc == <span class="number">4</span>) &amp;&amp; (<span class="built_in">strcmp</span>(argv[<span class="number">3</span>], LOG_ENABLE) == <span class="number">0</span>)) &#123;                   <span class="comment">/* 判断用户输入的命令是否符合要求 */</span></span><br><span class="line">        <span class="built_in">generate_rfile_path</span>(argv[<span class="number">1</span>]);                                          <span class="comment">/* 生成日志文件的路径信息 */</span></span><br><span class="line">        s_needlogfile = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pid = <span class="built_in">find_pid_by_name</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(sstr, <span class="string">&quot;proc \&quot;%s\&quot; not found...\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(sstr, <span class="string">&quot;cpu %.2f%%, mem %d KB\n&quot;</span>, <span class="built_in">get_cpu_stat</span>(pid), <span class="built_in">get_mem_stat</span>(pid));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">record_loginfo</span>(sstr);</span><br><span class="line">        <span class="built_in">sleep</span>(rtime);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="获得毫秒时间"><a href="#获得毫秒时间" class="headerlink" title="获得毫秒时间"></a>获得毫秒时间</h1><h2 id="windows-2"><a href="#windows-2" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line">    <span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">    函数名:    	</span></span><br><span class="line"><span class="comment">    gettimeofday</span></span><br><span class="line"><span class="comment">    函数描述:	获取毫秒时间</span></span><br><span class="line"><span class="comment">    输入参数:</span></span><br><span class="line"><span class="comment">    输出参数:</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">    ***************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *tp, <span class="keyword">void</span> *tzp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">time_t</span> clock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line">        SYSTEMTIME wtm;</span><br><span class="line">        <span class="built_in">GetLocalTime</span>(&amp;wtm);</span><br><span class="line">        tm.tm_year = wtm.wYear - <span class="number">1900</span>;</span><br><span class="line">        tm.tm_mon = wtm.wMonth - <span class="number">1</span>;</span><br><span class="line">        tm.tm_mday = wtm.wDay;</span><br><span class="line">        tm.tm_hour = wtm.wHour;</span><br><span class="line">        tm.tm_min = wtm.wMinute;</span><br><span class="line">        tm.tm_sec = wtm.wSecond;</span><br><span class="line">        tm.tm_isdst = <span class="number">-1</span>;</span><br><span class="line">        clock = <span class="built_in">mktime</span>(&amp;tm);</span><br><span class="line">        tp-&gt;tv_sec = clock;</span><br><span class="line">        tp-&gt;tv_usec = wtm.wMilliseconds * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> _tt=tv.tv_sec;</span><br><span class="line">    tm = <span class="built_in">localtime</span>(&amp;_tt);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="linux-1"><a href="#linux-1" class="headerlink" title="linux"></a>linux</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Linux-获得进程ID"><a href="#Linux-获得进程ID" class="headerlink" title="Linux 获得进程ID"></a>Linux 获得进程ID</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程本身</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* process_name, <span class="keyword">const</span> <span class="keyword">char</span>* user = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        user = <span class="built_in">getlogin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">if</span> (user)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;pgrep %s -u %s&quot;</span>, process_name, user);</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *pstr = <span class="built_in">popen</span>(cmd,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pstr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buff));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="built_in">fgets</span>(buff, <span class="number">512</span>, pstr))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atoi</span>(buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ProID=<span class="built_in">get_pid</span>(<span class="string">&quot;NewPorject&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Sleep-毫秒"><a href="#Sleep-毫秒" class="headerlink" title="Sleep 毫秒"></a>Sleep 毫秒</h1><h2 id="windows-3"><a href="#windows-3" class="headerlink" title="windows"></a>windows</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line">Sleep（）</span><br></pre></td></tr></table></figure>

<h2 id="linux-2"><a href="#linux-2" class="headerlink" title="linux"></a>linux</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> ms)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span>;</span></span><br><span class="line">       delay.tv_sec = <span class="number">0</span>;</span><br><span class="line">       delay.tv_usec = ms * <span class="number">1000</span>; <span class="comment">// 20 ms</span></span><br><span class="line">       <span class="built_in">select</span>(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;delay);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="windows-程序运行多长时间"><a href="#windows-程序运行多长时间" class="headerlink" title="windows 程序运行多长时间"></a>windows 程序运行多长时间</h1><p>打开运行 输入 msinfo32</p>
<p>然后在软件环境- 正在运行任务- 就能够看到运行开始的时间了.</p>
<h1 id="看windows系统信息"><a href="#看windows系统信息" class="headerlink" title="看windows系统信息"></a>看windows系统信息</h1><p>dxdiag</p>
<h1 id="configure、make、make-install-命令"><a href="#configure、make、make-install-命令" class="headerlink" title="./configure、make、make install 命令"></a>./configure、make、make install 命令</h1><p>这些都是典型的使用GNU的AUTOCONF和AUTOMAKE产生的程序的安装步骤</p>
<h2 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h2><p>　　1、./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p>
<p>　　2、make 是用来编译的，它从Makefile中读取指令，然后编译。</p>
<p>　　3、make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
<p>　　注意：AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。</p>
<h2 id="二、详细解释"><a href="#二、详细解释" class="headerlink" title="二、详细解释"></a>二、详细解释</h2><h3 id="1、configure命令"><a href="#1、configure命令" class="headerlink" title="1、configure命令"></a>1、configure命令</h3><p>　　这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p>
<p>　　<img src="/2021/06/20/%E5%85%B6%E4%BB%96/e7954280-5bba-4769-933d-f378ce5ddb59.png" alt="img"></p>
<h3 id="2、make"><a href="#2、make" class="headerlink" title="2、make"></a>2、make</h3><p>　　这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p>
<p>　　可能遇到的错误：make *** 没有指明目标并且找不到 makefile。 停止。问题很明了，没有Makefile，怎么办，原来是要先./configure 一下，再make。</p>
<h3 id="3、make-insatll"><a href="#3、make-insatll" class="headerlink" title="3、make insatll"></a>3、make insatll</h3><p>　　这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p>
<h2 id="三、扩展说明"><a href="#三、扩展说明" class="headerlink" title="三、扩展说明"></a>三、扩展说明</h2><p>　　Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。使用上述三个自动工具，就可以生成configure脚本。运行configure脚本，就可以生成Makefile文件，然后就可以运行make、make install和make clean。</p>
<p>　　configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。</p>
<p>　　这时，就可运行configure脚本了，运行configure脚本，就可产生出符合GNU规范的Makefile文件了： $ ./configure</p>
<p>到此时，就可以运行make进行编译，在运行make install进行安装了，最后运行make clean删除临时文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ make install           (注：运行这个要有足够的权限)</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure>

<p>　　利用configure所产生的Makefile文件有几个预设的目标可供使用，其中几个重要的简述如下：</p>
<p>　　make all：产生我们设定的目标，即此范例中的可执行文件。只打make也可以，此时会开始编译原始码，然后连结，并且产生可执行文件。</p>
<p>　　make clean：清除编译产生的可执行文件及目标文件(object file，*.o)。</p>
<p>　　make distclean：除了清除可执行文件和目标文件外，把configure所产生的Makefile也清除掉。</p>
<p>　　make install：将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。如果用bin_PROGRAMS宏的话，程序会被安装至/usr/local/bin这个目录。</p>
<p>　　make dist：将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以PACKAGE-VERSION.tar.gz为名称的文件。 PACKAGE和VERSION这两个变数是根据configure.in文件中AM_INIT_AUTOMAKE(PACKAGE，VERSION)的定义。在此范例中会产生test-1.0.tar.gz的档案。</p>
<p>　　make distcheck：和make dist类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成tar.gz文件外，还会自动把这个压缩文件解开，执行 configure，并且进行make all 的动作，确认编译无误后，会显示这个tar.gz文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</p>
<h1 id="cmake-make"><a href="#cmake-make" class="headerlink" title="cmake  make"></a>cmake  make</h1><p>1.gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。<br>2.当你的程序只有一个源文件时，直接就可以用gcc命令编译它。<br>3.但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大<br>4.所以出现了make工具</p>
<p>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。<br>5.makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。<br>6.makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。<br>7.makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。<br>8.这时候就出现了Cmake这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他功能，就是可以跨平台生成对应平台能用的makefile，你不用再自己去修改了。<br>9.可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。<br>10.到最后CMakeLists.txt文件谁写啊？亲，是你自己手写的。</p>
<p>11.当然如果你用IDE，类似VS这些一般它都能帮你弄好了，你只需要按一下那个三角形</p>
<p>12.接着是qmake，qmake是什么，先说一下Qt这个东西。Qt是跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。简单的说就是C++的第三方库，使用这个库你可以很容易生成windows，Linux，MAC os等等平台的图形界面。现在的Qt还包含了开发各种软件一般需要用到的功能模块（网络，数据库，XML，多线程啊等等），比你直接用C++（只带标准内裤那种）要方便和简单。</p>
<p>13.你可以用Qt简简单单就实现非常复杂的功能，是因为Qt对C++进行了扩展，你写一行代码，Qt在背后帮你写了几百上千行，而这些多出来的代码就是靠Qt专有的moc编译器（The Meta-Object Compiler）和uic编译器（User Interface Complier）来重新翻译你那一行代码。问题来了，你在进行程序编译前就必须先调用moc和uic对Qt源文件进行预处理，然后再调用编译器进行编译。上面说的那种普通makefile文件是不适用的，它没办法对qt源文件进行预处理。所以qmake就产生了。</p>
<p>14.qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。</p>
<p>15.qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。</p>
<p>16.还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -= qt 就可以了。</p>
<ol start="17">
<li>这样qmake和cmake有什么区别？不好意思，cmake也是同样支持Qt程序的，cmake也能生成针对qt 程序的那种特殊makefile，只是cmake的CMakeLists.txt 写起来相对与qmake的pro文件复杂点。qmake 是为 Qt 量身打造的，使用起来非常方便，但是cmake功能比qmake强大。一般的Qt工程你就直接使用qmake就可以了，cmake的强大功能一般人是用不到的。当你的工程非常大的时候，又有qt部分的子工程，又有其他语言的部分子工程，据说用cmake会 方便，我也没试过。</li>
</ol>
<p>写程序大体步骤为：</p>
<p>1.用编辑器编写源代码，如.c文件。</p>
<p>2.用编译器编译代码生成目标文件，如.o。</p>
<p>3.用链接器连接目标代码生成可执行文件，如.exe。</p>
<p>但如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。</p>
<p>对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。所以在编程的世界里没有捷径可走，还是要脚踏实地的。</p>
<p>所以流程如下：</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/c320be88-dd06-4345-8148-4513a7bc43cc.png" alt="img"></p>
<h1 id="C，C-判断操作系统是Linux，windows还是Unix"><a href="#C，C-判断操作系统是Linux，windows还是Unix" class="headerlink" title="C，C++判断操作系统是Linux，windows还是Unix"></a>C，C++判断操作系统是Linux，windows还是Unix</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __unix</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Linux\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __sun</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __sparc</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sun SPARC\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Sun X86\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _AIX</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;AIX\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WINVER</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Windows\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="编译器MinGW-MSVC-GCC-Clang"><a href="#编译器MinGW-MSVC-GCC-Clang" class="headerlink" title="编译器MinGW MSVC GCC Clang"></a>编译器MinGW MSVC GCC Clang</h1><ul>
<li><p><strong>MSVC</strong>：<br>即Microsoft Visual C++ Compiler，即微软自己的编译器<br>我们下载Windows下的OpenCV时，会带两个文件夹VC14，VC15（分别与Visual Studio的版本有对应关系），这两个文件夹下的库可以直接运行不需要编译<br>将VS作为Qt的开发环境也是使用这个编译器的缘故</p>
</li>
<li><p><strong>MinGW</strong>：<br>我们都知道GNU在Linux下面鼎鼎大名的gcc/g++，MinGW则是指Minimalist GNU for Windows的缩写<br>它是将GNU开发工具移植到Win32平台下的产物，即一套Windows上的GNU工具集<br>用其开发的程序不需要额外的第三方DLL支持就可以在Windows下运行，相对地，不使用动态库导致的就是编译出来的程序大很多。也是可以设置使用静态库的</p>
</li>
<li><p><strong>GCC：GNU(Gnu’s Not Unix)编译器套装(GNU Compiler Collection，GCC)，指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件</strong>，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC(特别是其中的C语言编译器)也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。</p>
<p><strong>GCC支持的语言</strong>：原名为GNU C语言编译器(GNU C Compiler)，因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。</p>
<p>许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。苹果电脑预装的Mac OS X操作系统也采用这个编译器。</p>
<p>GCC目前由世界各地不同的数个程序员小组维护。它是移植到最多中央处理器架构以及最多操作系统的编译器。由于GCC已成为GNU系统的官方编译器(包括GNU/Linux家族)，它也成为编译与创建其他操作系统的主要编译器，包括BSD家族、Mac OS X、NeXTSTEP与BeOS。</p>
<p>GCC通常是跨平台软件的编译器首选。有别于一般局限于特定系统与运行环境的编译器，GCC在所有平台上都使用同一个前端处理程序，产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。</p>
<p><strong>GCC支持的主要处理器架构</strong>：ARM、x86、x86-64、MIPS、PowerPC等。</p>
<p>​    <strong>GCC结构</strong>：GCC的外部接口长得像一个标准的Unix编译器。用户在命令行下键入gcc之程序名，以及一些命令参数，以便决定每个输入文件使用的个别语言编译器，并为输出代码使用适合此硬件平台的汇编语言编译器，并且选择性地运行连接器以制造可执行的程序。每个语言编译器都是独立程序，此程序可处理输入的源代码，并输出汇编语言码。全部的语言编译器都拥有共通的中介架构：一个前端解析匹配此语言的源代码，并产生一抽象语法树，以及一翻译此语法树成为GCC的寄存器转换语言的后端。编译器最优化与静态代码解析技术在此阶段应用于代码上。最后，适用于此硬件架构的汇编语言代码以杰克·戴维森与克里斯·弗雷泽发明的算法产出。</p>
<p>几乎全部的GCC都由C/C++写成，除了Ada前端大部分以Ada写成。</p>
</li>
<li><p><strong>Clang：是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端</strong>。它采用了底层虚拟机(LLVM)作为其后端。它的目标是提供一个GNU编译器套装(GCC)的替代品。作者是克里斯·拉特纳(Chris Lattner)，在苹果公司的赞助支持下进行开发，而源代码授权是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。Clang主要由C++编写。</p>
<p>Clang项目包括Clang前端和Clang静态分析器等。这个软件项目在2005年由苹果电脑发起，是LLVM(Low Level Virtual Machine)编译器工具集的前端(front-end)，目的是输出代码对应的抽象语法树(Abstract Syntax Tree, AST)，并将代码编译成LLVM Bitcode。接着在后端(back-end)使用LLVM编译成平台相关的机器语言。</p>
<p>Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右。2014年1月发行的FreeBSD10.0版将Clang/LLVM作为默认编译器。</p>
<p>​    <strong>Clang性能</strong>：测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。</p>
<p>​    <strong>GCC与Clang区别</strong>：</p>
<p>​    <strong>GCC特性</strong>：除支持C/C++/ Objective-C/Objective-C++语言外，还是支持Java/Ada/Fortran/Go等；当前的Clang的C++支持落后于GCC；支持更多平台；更流行，广泛使用，支持完备。</p>
<p>​    <strong>Clang特性</strong>：编译速度快；内存占用小；兼容GCC；设计清晰简单、容易理解，易于扩展增强；基于库的模块化设计，易于IDE集成；出错提示更友好。</p>
<p>​    <strong>Clang采用的license是BSD，而GCC是GPLv3</strong>。</p>
</li>
</ul>
<blockquote>
<p>根据完成任务不同，可以将编译器的组成部分划分为前端（Front End）与后端（Back End）。</p>
<p>前端主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间表示生成。</p>
<p>后端主要指与目标机有关的部分，包括代码优化和目标代码生成等。 </p>
</blockquote>
<h1 id="十进制与二进制的转换"><a href="#十进制与二进制的转换" class="headerlink" title="十进制与二进制的转换"></a>十进制与二进制的转换</h1><p><em>1个字节 = 8个二进制位=2个十六进制位</em></p>
<p><em>因为3个2进制位对应一个8进制值、4个2进制位对应一个16进制值</em></p>
<h2 id="整数转二进制"><a href="#整数转二进制" class="headerlink" title="整数转二进制"></a>整数转二进制</h2><ul>
<li>采用”除2取余，逆序排列”法：</li>
</ul>
<blockquote>
<p>1.首先用2整除一个十进制整数，得到一个商和余数<br>2.然后再用2去除得到的商，又会得到一个商和余数<br>3.重复操作，一直到商为小于1时为止<br>4.然后将得到的所有余数全部排列起来，再将它反过来（逆序排列），切记一定要反过来！</p>
</blockquote>
<ul>
<li>假设我们现在需要将42转为二进制，那我们怎么做呢，如下图所示：</li>
</ul>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.9182578906866533.png" alt="img"></p>
<h2 id="小数转二进制"><a href="#小数转二进制" class="headerlink" title="小数转二进制"></a>小数转二进制</h2><ul>
<li>采用”乘2取整，顺序排列”法：</li>
</ul>
<blockquote>
<p>1.用2乘十进制小数，可以得到积，将积的整数部分取出<br>2.再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出<br>3.重复操作，直到积中的小数部分为零，此时0或1为二进制的最后一位，或者达到所要求的精度为止</p>
</blockquote>
<ul>
<li>例如将0.125转换为二进制：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.125  *  2  =  0.25 ------0</span><br><span class="line"></span><br><span class="line">0.25   *  2  =  0.5   ------0</span><br><span class="line"></span><br><span class="line">0.5  *  2  =  1.0     ------1</span><br><span class="line"></span><br><span class="line">当小数部分为0就可以停止乘2了，然后正序排序就构成了二进制的小数部分：0.001</span><br></pre></td></tr></table></figure>

<ul>
<li>如果小数的整数部分有大于0的整数时，将整数部分和小数部分先单独转为二进制，再合在一起就可以了，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设要将8.125 转换为二进制</span><br><span class="line"></span><br><span class="line">现将8转为二进制：得到1000</span><br><span class="line">再将0.125转为二进制：得到0.001</span><br><span class="line"></span><br><span class="line">合并后为1000.001</span><br></pre></td></tr></table></figure>

<h2 id="二进制转换为十进制"><a href="#二进制转换为十进制" class="headerlink" title="二进制转换为十进制"></a>二进制转换为十进制</h2><p>二进制转为十进制要从右到左用二进制的每个数去乘以2的相应次方，小数点后则是从左往右。</p>
<p>如果首位是0就表示正整数，如果首位是1则表示负整数，正整数可以直接换算，负整数则需要先取反再换算。</p>
<p>因为计算机内部表示数的字节单位是定长的。如8位、16位、32位。所以位数不够时，高位补零。</p>
<ul>
<li>如要想二进制00101010转为十进制，因为以0开头，所以这是正整数，计算如下所示：</li>
</ul>
<blockquote>
<p>（0 * 2的零次方） + （1* 2的一次方）+ （0 * 2 的二次方）+（1 * 2的三次方） +（0 * 2的四次方） +（1* 2的五次方） + （0 * 2的六次方） + （0 * 2的7次方） = 0 + 2 + 0 + 8 + 0 + 32 + 0 + 0 = 42</p>
</blockquote>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.4235766275067019.png" alt="img"></p>
<ul>
<li>如果11101011想转为*<strong>负的十进制</strong>，因为最高位是1，所以先减一取反 00010101，然后计算出00010101对应的十进制为21，所以11101011最终对应的十进制为 -21。</li>
</ul>
<blockquote>
<h1 id="符号位扩展"><a href="#符号位扩展" class="headerlink" title="符号位扩展"></a><strong>符号位扩展</strong></h1></blockquote>
<ul>
<li>众所周知，每种基本数据类型都有一个固定的位数，比如byte占8位，short占16位，int占32位等。正因如此，当把一个低精度的数据类型转成一个高精度的数据类型时，必然会涉及到如何扩展位数的问题。这里有两种解决方案：</li>
<li>（1）补零扩展：填充一定位数的0。</li>
<li>（2）补符号位扩展：填充一定位数的符号位（非负数填充0，负数填充1）。</li>
<li>对于无符号类型（相当于都是非负数）与有符号类型中的非负数部分，这两种方法没有区别，都是填充0；对于有符号类型中的负数部分，这两种方法就会产生差异了，补零扩展会填充0，而补符号位扩展会填充1。下面将byte类型的-127转为int类型为例，探讨一下这两种方法的区别。</li>
<li>首先必须明确一些知识点：</li>
</ul>
<p>计算机是用补码来存储数字的；</p>
<p>正数的补码等于原码；</p>
<p>负数的补码等于反码+1；</p>
<p>一个数的补码的补码等于原码。</p>
<p>127原码1111 1111，反码1000 0000，补码1000 0001。计算机存储的是1000 0001，用十六进制表示为0x81。</p>
<p>当使用补零扩展时，结果为：</p>
<p>0000 0000 0000 0000 0000 0000 1000 0001</p>
<p>用十六进制表示为0x81。为了计算十进制值，计算它的补码，结果为：</p>
<p>0000 0000 0000 0000 0000 0000 1000 0001</p>
<p>将这个二进制数转成十进制的结果是129。</p>
<p>当使用补符号位扩展时，结果为：</p>
<p>1111 1111 1111 1111 1111 1111 1000 0001</p>
<p>用十六进制表示为0xFFFFFF81。为了计算十进制值，计算它的补码，结果为：</p>
<p>1000 0000 0000 0000 0000 0000 0111 1111</p>
<p>将这个二进制数转成十进制的结果是-127。</p>
<p>由此可以得出结论：</p>
<p>（1）使用补零扩展能够保证二进制存储的一致性，但不能保证十进制值不变。</p>
<p>（2）使用补符号位扩展能够保证十进制值不变，但不能保证二进制存储的一致性。</p>
<h2 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h2><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<blockquote>
<p>[+1]原 = 0000 0001</p>
<p>[-1]原 = 1000 0001</p>
</blockquote>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<blockquote>
<p>[1111 1111 , 0111 1111]</p>
</blockquote>
<p>即</p>
<blockquote>
<p>[-127 , 127]</p>
</blockquote>
<p>原码是人脑最容易理解和计算的表示方式.</p>
<h2 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h2><p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反</p>
<p>[-1] = [10000001]原 = [11111110]反</p>
</blockquote>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h2 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h2><p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<h2 id="4-为何要使用原码-反码和补码"><a href="#4-为何要使用原码-反码和补码" class="headerlink" title="4. 为何要使用原码, 反码和补码"></a>4. 为何要使用原码, 反码和补码</h2><p>在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法.</p>
<p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<blockquote>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
</blockquote>
<p>所以不需要过多解释. 但是对于负数:</p>
<blockquote>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
</blockquote>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
</blockquote>
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<blockquote>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
</blockquote>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<blockquote>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
</blockquote>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<blockquote>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
</blockquote>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p>
<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><h2 id="一、大端模式和小端模式的起源"><a href="#一、大端模式和小端模式的起源" class="headerlink" title="一、大端模式和小端模式的起源"></a>一、大端模式和小端模式的起源</h2><p>​    关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。然后老百姓对此法令极为反感，期间发生了多次叛乱，其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。据估计，先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。这个其实讽刺当时英国和法国之间持续的冲突。Danny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。</p>
<h2 id="二、什么是大端和小端"><a href="#二、什么是大端和小端" class="headerlink" title="二、什么是大端和小端"></a>二、什么是大端和小端</h2><p>举一个例子，比如数字0x12 34 56 78在内存中的表示形式。</p>
<p><strong>1)大端模式：Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</strong></p>
<p><strong>（其实<strong><strong>大端模式才是我们直观上认为的模式</strong></strong>，和字符串存储的模式差类似）</strong></p>
<p>低地址 ——————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78</p>
<p>高字节 ——————–&gt; 低字节</p>
<p><strong>2)小端模式：Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</strong></p>
<p>低地址 ——————–&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12</p>
<p>低字节 ——————–&gt; 高字节</p>
<p><strong>3)下面是两个具体例子：</strong> </p>
<p>16bit宽（两个字节）的数0x1234（两位16进制表示一个字节，表示4位2进制）在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p>
<table>
<thead>
<tr>
<th><strong>内存地址</strong></th>
<th><strong>小端模式存放内容</strong></th>
<th><strong>大端模式存放内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x4000</strong></td>
<td><strong>0x34</strong></td>
<td><strong>0x12</strong></td>
</tr>
<tr>
<td><strong>0x4001</strong></td>
<td><strong>0x12</strong></td>
<td><strong>0x34</strong></td>
</tr>
</tbody></table>
<p>32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p>
<table>
<thead>
<tr>
<th><strong>内存地址</strong></th>
<th><strong>小端模式存放内容</strong></th>
<th><strong>大端模式存放内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>0x4000</strong></td>
<td><strong>0x78</strong></td>
<td><strong>0x12</strong></td>
</tr>
<tr>
<td><strong>0x4001</strong></td>
<td><strong>0x56</strong></td>
<td><strong>0x34</strong></td>
</tr>
<tr>
<td><strong>0x4002</strong></td>
<td><strong>0x34</strong></td>
<td><strong>0x56</strong></td>
</tr>
<tr>
<td><strong>0x4003</strong></td>
<td><strong>0x12</strong></td>
<td>**0x78 **</td>
</tr>
</tbody></table>
<p> <strong>4)大端小端没有谁优谁劣，各自优势便是对方劣势：</strong></p>
<p>小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。（对高端字节删掉或扩充，所以不需要调整字节内容）<br>大端模式 ：符号位的判定固定为第一个字节，容易判断正负。</p>
<h2 id="三、数组在大端小端情况下的存储："><a href="#三、数组在大端小端情况下的存储：" class="headerlink" title="三、数组在大端小端情况下的存储："></a>三、数组在大端小端情况下的存储：</h2><p>　　以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：<br>　　Big-Endian: 低地址存放高位，如下：<br>高地址<br>    -————–<br>    buf[3] (0x78) – 低位<br>    buf[2] (0x56)<br>    buf[1] (0x34)<br>    buf[0] (0x12) – 高位<br>    -————–<br>低地址</p>
<p>Little-Endian: 低地址存放低位，如下：<br>高地址<br>    -————–<br>    buf[3] (0x12) – 高位<br>    buf[2] (0x34)<br>    buf[1] (0x56)<br>    buf[0] (0x78) – 低位<br>    -————-<br>低地址</p>
<p>所以如果我们要取两个字节的数的12位:</p>
<p>小端模式，取12位，value &amp; 0x0fff（0000 1111 1111 1111），取后12位</p>
<p>如果是大端模式存储，取12位，是不是就要&amp;3ffc，也就是1111 1111 1111 0000，取前12位？</p>
<h2 id="四、为什么会有大小端模式之分呢？"><a href="#四、为什么会有大小端模式之分呢？" class="headerlink" title="四、为什么会有大小端模式之分呢？"></a>四、为什么会有大小端模式之分呢？</h2><p>   这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p>
<blockquote>
<p><em>我们知道计算机正常的内存增长方式是从低到高(当然栈不是)，取数据方式是从基址根据偏移找到他们的位置。</em></p>
<p><em>从大/小端的存储方式可以看出，大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。</em></p>
<p><em>而小端存储 第一个字节是它的低位，符号位在最后一个字节，这样在做数值四则运算时，从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效。</em></p>
<p><em>所以大端和小端有其各自的优势。</em></p>
</blockquote>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>前面的大端和小端都是在说计算机自己，也被称作主机字节序HBO(Host Byte Order)。其实，只要自己能够自圆其说是没啥问题的。问题是，网络的出现使得计算机可以通信了。通信，就意味着相处，相处必须得有共同语言啊，得说普通话，要不然就容易会错意，下了一个小时的小电影发现打不开，理解错误了！</p>
<p>但是每种计算机体系都有自己的主机字节序啊，还都不依不饶，坚持做自己，怎么办？</p>
<p>TCP/IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序NBO(Network Byte Order)。</p>
<p>其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化。</p>
<p>为了程序的兼容，你会看到，程序员们每次发送和接受数据都要进行转换，这样做的目的是保证代码在任何计算机上执行时都能达到预期的效果。</p>
<p>这么常用的操作，BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。当然，有了上面的理论基础，也可以编写自己的转换函数。</p>
<blockquote>
<p>网络字节顺序(NBO)<br>NBO(Network Byte Order)：按照从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。TCP/IP中规定好的一种数据表示格式，与具体的 CPU 类型、操作系统等无关。从而保证数据在不同主机之间传输时能够被正确解释。</p>
<p>主机字节顺序(HBO)<br>HBO(Host Byte Order)：不同机器 HBO 不相同，与 CPU 有关。计算机存储数据有两种字节优先顺序：Big Endian 和 Little Endian。Internet 以 Big Endian 顺序在网络上传输，所以对于在内部是以 Little Endian 方式存储数据的机器，在网络通信时就需要进行转换。</p>
<p>除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
</blockquote>
<h2 id="五、如何判断机器的字节序"><a href="#五、如何判断机器的字节序" class="headerlink" title="五、如何判断机器的字节序"></a>五、如何判断机器的字节序</h2><p>可以编写一个小的测试程序来判断机器的字节序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsBigEndian</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x1234</span>;  </span><br><span class="line">    <span class="keyword">char</span> b =  *(<span class="keyword">char</span> *)&amp;a;  <span class="comment">//通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分  </span></span><br><span class="line">    <span class="keyword">if</span>( b == <span class="number">0x12</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> FALSE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsBigEndian</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">NUM</span>  </span></span><br><span class="line"><span class="class">    &#123;</span>  </span><br><span class="line">        <span class="keyword">int</span> a;  </span><br><span class="line">        <span class="keyword">char</span> b;  </span><br><span class="line">    &#125;num;  </span><br><span class="line">    num.a = <span class="number">0x1234</span>;  </span><br><span class="line">    <span class="keyword">if</span>( num.b == <span class="number">0x12</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> TRUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> FALSE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、常见的字节序"><a href="#六、常见的字节序" class="headerlink" title="六、常见的字节序"></a>六、常见的字节序</h2><p>一般操作系统都是小端，而通讯协议是大端的。</p>
<h6 id="4-1-常见CPU的字节序"><a href="#4-1-常见CPU的字节序" class="headerlink" title="4.1 常见CPU的字节序"></a>4.1 常见CPU的字节序</h6><p>Big Endian : PowerPC、IBM、Sun<br>Little Endian : x86、DEC<br>ARM既可以工作在大端模式，也可以工作在小端模式。</p>
<h6 id="4-2-常见文件的字节序"><a href="#4-2-常见文件的字节序" class="headerlink" title="4.2 常见文件的字节序"></a>4.2 常见文件的字节序</h6><p>Adobe PS – Big Endian<br>BMP – Little Endian<br>DXF(AutoCAD) – Variable<br>GIF – Little Endian<br>JPEG – Big Endian<br>MacPaint – Big Endian<br>RTF – Little Endian</p>
<p>另外，Java和所有的网络通讯协议都是使用Big-Endian的编码。</p>
<h2 id="七、如何进行转换"><a href="#七、如何进行转换" class="headerlink" title="七、如何进行转换"></a>七、如何进行转换</h2><p>对于字数据（16位）：（程序中的“\”表示当前行和下一行是同一行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define BigtoLittle16(A)   (( ((uint16)(A) &amp; 0xff00) &gt;&gt; 8)    | \  </span><br><span class="line">                                       (( (uint16)(A) &amp; 0x00ff) &lt;&lt; 8))  </span><br></pre></td></tr></table></figure>

<p>对于双字数据（32位）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BigtoLittle32(A)   ((( (uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \  </span><br><span class="line">                                       (( (uint32)(A) &amp; 0x00ff0000) &gt;&gt; 8)   | \  </span><br><span class="line">                                       (( (uint32)(A) &amp; 0x0000ff00) &lt;&lt; 8)   | \  </span><br><span class="line">                                       (( (uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))  </span><br></pre></td></tr></table></figure>

<h2 id="八、从软件的角度理解端模式"><a href="#八、从软件的角度理解端模式" class="headerlink" title="八、从软件的角度理解端模式"></a>八、从软件的角度理解端模式</h2><p>​    从软件的角度上，不同端模式的处理器进行数据传递时必须要考虑端模式的不同。如进行网络数据传递时，必须要考虑端模式的转换。在Socket接口编程中，以下几个函数用于大小端字节序的转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换  </span><br><span class="line">#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换  </span><br><span class="line">#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换  </span><br><span class="line">#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  </span><br></pre></td></tr></table></figure>

<p>其中互联网使用的网络字节顺序采用大端模式进行编址，而主机字节顺序根据处理器的不同而不同，如PowerPC处理器使用大端模式，而Pentuim处理器使用小端模式。<br>    大端模式处理器的字节序到网络字节序不需要转换，此时ntohs(n)=n，ntohl = n；而小端模式处理器的字节序到网络字节必须要进行转换，此时ntohs(n) = __swab16(n)，ntohl = __swab32(n)。__swab16与__swab32函数定义如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___swab16(x)  </span></span><br><span class="line">&#123;  </span><br><span class="line">            __u16 __x = (x);  </span><br><span class="line">            ((__u16)(  </span><br><span class="line">                        (((__u16)(__x) &amp; (__u16)<span class="number">0x00ff</span>U) &lt;&lt; <span class="number">8</span>) |  </span><br><span class="line">                        (((__u16)(__x) &amp; (__u16)<span class="number">0xff00</span>U) &gt;&gt; <span class="number">8</span>) ));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___swab32(x)  </span></span><br><span class="line">&#123;  </span><br><span class="line">            __u32 __x = (x);  </span><br><span class="line">            ((__u32)(  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0x000000ff</span>UL) &lt;&lt; <span class="number">24</span>) |  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0x0000ff00</span>UL) &lt;&lt; <span class="number">8</span>) |  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0x00ff0000</span>UL) &gt;&gt; <span class="number">8</span>) |  </span><br><span class="line">                        (((__u32)(__x) &amp; (__u32)<span class="number">0xff000000</span>UL) &gt;&gt; <span class="number">24</span>) ));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> PowerPC处理器提供了lwbrx，lhbrx，stwbrx，sthbrx四条指令用于处理字节序的转换以优化__swab16和__swap32这类函数。此外PowerPC处理器中的rlwimi指令也可以用来实现__swab16和__swap32这类函数。</p>
<p>​    在对普通文件进行处理也需要考虑端模式问题。在大端模式的处理器下对文件的32，16位读写操作所得到的结果与小端模式的处理器不同。单纯从软件的角度理解上远远不能真正理解大小端模式的区别。事实上，真正的理解大小端模式的区别，必须要从系统的角度，从指令集，寄存器和数据总线上深入理解，大小端模式的区别。</p>
<h2 id="九、从系统的角度理解端模式"><a href="#九、从系统的角度理解端模式" class="headerlink" title="九、从系统的角度理解端模式"></a>九、从系统的角度理解端模式</h2><p>先补充两个关键词，MSB和LSB：<br>    MSB:MoST Significant Bit ——- 最高有效位<br>    LSB:Least Significant Bit ——- 最低有效位</p>
<p>​    处理器在硬件上由于端模式问题在设计中有所不同。从系统的角度上看，端模式问题对软件和硬件的设计带来了不同的影响，当一个处理器系统中大小端模式同时存在时，必须要对这些不同端模式的访问进行特殊的处理。<br>​    PowerPC处理器主导网络市场，可以说绝大多数的通信设备都使用PowerPC处理器进行协议处理和其他控制信息的处理，这也可能也是在网络上的绝大多数协议都采用大端编址方式的原因。因此在有关网络协议的软件设计中，使用小端方式的处理器需要在软件中处理端模式的转变。而Pentium主导个人机市场，因此多数用于个人机的外设都采用小端模式，包括一些在网络设备中使用的PCI总线，Flash等设备，这也要求在硬件设计中注意端模式的转换。<br>​    本文提到的小端外设是指这种外设中的寄存器以小端方式进行存储，如PCI设备的配置空间，NOR FLASH中的寄存器等等。对于有些设备，如DDR颗粒，没有以小端方式存储的寄存器，因此从逻辑上讲并不需要对端模式进行转换。在设计中，只需要将双方数据总线进行一一对应的互连，而不需要进行数据总线的转换。<br>​    如果从实际应用的角度说，采用小端模式的处理器需要在软件中处理端模式的转换，因为采用小端模式的处理器在与小端外设互连时，不需要任何转换。而采用大端模式的处理器需要在硬件设计时处理端模式的转换。大端模式处理器需要在寄存器，指令集，数据总线及数据总线与小端外设的连接等等多个方面进行处理，以解决与小端外设连接时的端模式转换问题。在寄存器和数据总线的位序定义上，基于大小端模式的处理器有所不同。<br>​    一个采用大端模式的32位处理器，如基于E500内核的MPC8541，将其寄存器的最高位msb（most significant bit）定义为0，最低位lsb（lease significant bit）定义为31；而小端模式的32位处理器，将其寄存器的最高位定义为31，低位地址定义为0。与此向对应，采用大端模式的32位处理器数据总线的最高位为0，最高位为31；采用小端模式的32位处理器的数据总线的最高位为31，最低位为0。<br>​    大小端模式处理器外部总线的位序也遵循着同样的规律，根据所采用的数据总线是32位，16位和8位，大小端处理器外部总线的位序有所不同。大端模式下32位数据总线的msb是第0位，MSB是数据总线的第0<del>7的字段；而lsb是第31位，LSB是第24</del>31字段。小端模式下32位总线的msb是第31位，MSB是数据总线的第31<del>24位，lsb是第0位，LSB是7</del>0字段。大端模式下16位数据总线的msb是第0位，MSB是数据总线的第0<del>7的字段；而lsb是第15位，LSB是第8</del>15字段。小端模式下16位总线的msb是第15位，MSB是数据总线的第15<del>7位，lsb是第0位，LSB是7</del>0字段。大端模式下8位数据总线的msb是第0位，MSB是数据总线的第0<del>7的字段；而lsb是第7位，LSB是第0</del>7字段。小端模式下8位总线的msb是第7位，MSB是数据总线的第7<del>0位，lsb是第0位，LSB是7</del>0字段。<br>​     由上分析，我们可以得知对于8位，16位和32位宽度的数据总线，采用大端模式时数据总线的msb和MSB的位置都不会发生变化，而采用小端模式时数据总线的lsb和LSB位置也不会发生变化。<br>​     为此，大端模式的处理器对8位，16位和32位的内存访问（包括外设的访问）一般都包含第0<del>7字段，即MSB。小端模式的处理器对8位，16位和32位的内存访问都包含第7</del>0位，小端方式的第7~0字段，即LSB。由于大小端处理器的数据总线其8位，16位和32位宽度的数据总线的定义不同，因此需要分别进行讨论在系统级别上如何处理端模式转换。在一个大端处理器系统中，需要处理大端处理器对小端外设的访问。</p>
<h2 id="十、实际中的例子"><a href="#十、实际中的例子" class="headerlink" title="十、实际中的例子"></a>十、实际中的例子</h2><p>​    虽然很多时候，字节序的工作已由编译器完成了，但是在一些小的细节上，仍然需要去仔细揣摩考虑，尤其是在以太网通讯、MODBUS通讯、软件移植性方面。这里，举一个MODBUS通讯的例子。在MODBUS中，数据需要组织成数据报文，该报文中的数据都是大端模式，即低地址存高位，高地址存低位。假设有一16位缓冲区m_RegMW[256]，因为是在x86平台上，所以内存中的数据为小端模式：m_RegMW[0].low、m_RegMW[0].high、m_RegMW[1].low、m_RegMW[1].high……<br>为了方便讨论，假设m_RegMW[0] = 0x3456; 在内存中为0x56、0x34。<br>​    现要将该数据发出，如果不进行数据转换直接发送，此时发送的数据为0x56,0x34。而Modbus是大端的，会将该数据解释为0x5634而非原数据0x3456，此时就会发生灾难性的错误。所以，在此之前，需要将小端数据转换成大端的，即进行高字节和低字节的交换，此时可以调用步骤五中的函数BigtoLittle16(m_RegMW[0])，之后再进行发送才可以得到正确的数据。</p>
<h2 id="十一、附float和long类型的大小端转换"><a href="#十一、附float和long类型的大小端转换" class="headerlink" title="十一、附float和long类型的大小端转换"></a>十一、附float和long类型的大小端转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">函数名:        BLEndianFloat2</span></span><br><span class="line"><span class="comment">函数描述:    float类型数据，小端转大端</span></span><br><span class="line"><span class="comment">输入参数:    小端float</span></span><br><span class="line"><span class="comment">输出参数:    大端float</span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment">***************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">BLEndianFloat2</span><span class="params">(<span class="keyword">float</span> fValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>        s[<span class="number">4</span>], t[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">float</span>                fResult;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(s, &amp;fValue, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">    </span><br><span class="line">    t[<span class="number">0</span>] = s[<span class="number">3</span>];</span><br><span class="line">    t[<span class="number">1</span>] = s[<span class="number">2</span>];</span><br><span class="line">    t[<span class="number">2</span>] = s[<span class="number">1</span>];</span><br><span class="line">    t[<span class="number">3</span>] = s[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fResult, t, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fResult;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************</span></span><br><span class="line"><span class="comment">函数名:        Customhtonll</span></span><br><span class="line"><span class="comment">函数描述:    long long类型数据，小端转大端</span></span><br><span class="line"><span class="comment">输入参数:    小端long long</span></span><br><span class="line"><span class="comment">输出参数:    大端long long</span></span><br><span class="line"><span class="comment">返回值:</span></span><br><span class="line"><span class="comment">***************************************************/</span></span><br><span class="line"><span class="function">UINT64 <span class="title">Customhtonll</span><span class="params">(UINT64 fValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>        s[<span class="number">8</span>], t[<span class="number">8</span>];</span><br><span class="line">    UINT64                fResult;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(s, &amp;fValue, <span class="built_in"><span class="keyword">sizeof</span></span>(UINT64));</span><br><span class="line"></span><br><span class="line">    t[<span class="number">0</span>] = s[<span class="number">7</span>];</span><br><span class="line">    t[<span class="number">1</span>] = s[<span class="number">6</span>];</span><br><span class="line">    t[<span class="number">2</span>] = s[<span class="number">5</span>];</span><br><span class="line">    t[<span class="number">3</span>] = s[<span class="number">4</span>];</span><br><span class="line">    t[<span class="number">4</span>] = s[<span class="number">3</span>];</span><br><span class="line">    t[<span class="number">5</span>] = s[<span class="number">2</span>];</span><br><span class="line">    t[<span class="number">6</span>] = s[<span class="number">1</span>];</span><br><span class="line">    t[<span class="number">7</span>] = s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fResult, t, <span class="built_in"><span class="keyword">sizeof</span></span>(UINT64));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>IP（Internet Protocol Address）地址由网络号+主机号构成，网络号相当于电话区号，主机号相当于电话号码，Ipv4分为A、B、C、D、E五类地址，任何一个Ipv4的IP地址由共由32位二进制数构成，每段8位，共4段，点分式IP地址十进制的表示为a.b.c.d格式。</p>
<p>A类IP地址由1字节（每个字节是8位）的网络号和3个字节主机号组成，A类地址范围是(1.0.0.0至127.255.255.254,至于为什么请继续往下看，A类网络号前1位从0开始，A类IP的地址第一个字段范围是（00000000<del>011111111）0</del>127，但是由于全0和全1的地址用作特殊用途，实际可指派的第一个字段范围是1~126。（0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。127.0.0.1属于{127}集合中的一个，而所有网络号为127的地址都被称之为回环地址，所以回环地址！=127.0.0.1,它们是包含关系，即回环地址包含127.0.0.1 。</p>
<p>B类IP地址由2字节（每个字节是8位）的网络号和2个字节主机号组成，B类网络号从前2位10开始，B类IP的地址第一个字段范围是（10000000<del>101111111）128</del>191, B类地址范围：128.0.0.0到191.255.255.255。</p>
<p>C类IP地址由3字节（每个字节是8位）的网络号和1个字节主机号组成，C类网络号前3位从110开始，所以C类IP地址的的一个字段范围是：（11000000<del>11011111）192</del>223， C类地址范围：192.0.0.0到223.255.255.255。</p>
<p>D类IP地址不分网络号和主机号，D类网络号前4位从1110开始，所以D类IP地址的的一个字段范围是：（11100000<del>11101111）224</del>239，D类地址范围是224.0.0.0至239.255.255.255。</p>
<p>E类IP地址不分网络号和主机号，E类网络号前5位从11110开始，所以E类IP地址的的一个字段范围是：（11110000<del>11110111）240</del>247，E类地址范围是240.0.0.0至247.255.255.255。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.4547502593382962.png" alt="img">IP地址分类</p>
<p>子网掩码：子网掩码又叫网络掩码，是一个32位地址，用于屏蔽IP地址的一部分以区别网络号和主机标号，子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。</p>
<p>网络地址：IP地址和子网掩码进行与运算，将运算结果中的网络地址不变，主机地址变为0，即主机号全0是网络地址。示例: 如果是192的C段地址，那么网络地址就是：192.168.1.0，地址掩码是：255.255.255.0；如果地址掩码是：255.255.0.0，那么网络地址就是：192.168.0.0；网络地址很大一部分是由地址掩码决定的。</p>
<p><em><strong>广播地址：将运算结果中的网络地址不变，主机地址变为1，结果就是广播地址。</strong></em></p>
<p>1、　192.168.1.53/27需要计算具体的子网掩码、子网数、可用的主机数、最大可容纳主机数、网络地址、广播地址。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.9771714244178368.png" alt="img">结果</p>
<p>注意:在计算网络中的主机数量时，应当比2^x（x指用于标识主机号的位数,8 16 32 ）少2。原来主机号部分全为0或1（指二进制）的IP地址，只能用于网络内的广播，即利用该地址将该信息传送至网络内的每一台主机，因此是不能分配给某个特定的主机使用的。所以在实际每个网络中所容纳的主机必然是“2x-2”台。</p>
<p>来源： <a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1618548971082312617&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1618548971082312617&amp;wfr=spider&amp;for=pc</a></p>
<p>2、继续以　192.168.1.53/27　为例讲解</p>
<p>我们需要了解正常C网的网络号及位数是多少？</p>
<p>平时大家用的是192.168.0.*或192.168.1.*网段，子网掩码是255.255.255.0</p>
<p>那么子网掩码10进制转换到2进制就是：</p>
<p>11111111.11111111.11111111.00000000</p>
<p>前面24位表示网络号，后面8位表示主机数，具体的各参数容量可以参考步骤1.</p>
<p>所以192.168.1.53/27 的相应掩码是</p>
<p>11111111.11111111.11111111.11100000</p>
<p>由于网络号数量不足，所以得向右的主机数借位，主机数的可用数量减少。</p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/b21c8701a18b87d62d91611a0b0828381e30fde0"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.08722543690292633.png" alt="img"></a></p>
<p>3、由步骤2，我们得知192.168.1.53/27 的相应掩码是</p>
<p>11111111.11111111.11111111.11100000</p>
<p>所有可用的主机数为主机号所剩下的5位掩码中算出。</p>
<p>注：8位主机号减少网络号借去的3位，所剩下5位。即n=8-m=5</p>
<p>其中m为网络号位数，n为主机号位数。</p>
<p>即最多可以容纳的主机数为　32　</p>
<p>可用的主机数为　　　　　　30　　　</p>
<p>计算公式如下图所示：　</p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/4d086e061d950a7b159e85c106d162d9f2d3c908"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.4027877775547382.png" alt="img"></a></p>
<p>4、我们已经算出192.168.1.53/27 ，每个网段最大容纳的主机数和可以主机数了，下面我们来计算子网掩码的10进制数是多少。</p>
<p>由步骤2，我们得知192.168.1.53/27 的相应掩码是</p>
<p>11111111.11111111.11111111.11100000</p>
<p>即转换成相应的10进制数是255.255.255.224</p>
<p>转换公式如下图：</p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/ac6eddc451da81cbf67348c85e66d0160924311a"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.8880934507151076.png" alt="img"></a></p>
<p>5、我们也计算出了192.168.1.53/27的掩码是255.255.255.224了</p>
<p>子网数是8个。</p>
<p>现在我们来算算并找出网络地址和广播地址。</p>
<p>其中网络地址是192.168.1.32</p>
<p>广播地址是192.168.1.63</p>
<p>如下图：</p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/9f2f070828381f30e746b8afa5014c086e06f05c"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.33273960839110994.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/e4dde71190ef76c6d8d7ce2d9116fdfaaf5167aa"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.947406924669754.png" alt="img"></a></p>
<p>6、总结　步骤1的要求，通过计算。各参数如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/3b292df5e0fe992530915d5638a85edf8db17112"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.1071117507652827.png" alt="img"></a></p>
<p>来源： <a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1116507203928197699.html">https://zhidao.baidu.com/question/1116507203928197699.html</a></p>
<p>多播的地址是特定的，D类地址用于多播。D类IP地址就是多播IP地址，即224.0.0.0至239.255.255.255之间的IP地址，并被划分为局部连接多播地址、预留多播地址和管理权限多播地址3类：</p>
<p>　　1、局部多播地址：在224.0.0.0～224.0.0.255之间，这是为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包。</p>
<p>　　2、预留多播地址：在224.0.1.0～238.255.255.255之间，可用于全球范围（如Internet）或网络协议。</p>
<p>　　3、管理权限多播地址：在239.0.0.0～239.255.255.255之间，可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围。</p>
<p>来源： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lidabo/p/5865045.html">https://www.cnblogs.com/lidabo/p/5865045.html</a></p>
<h1 id="帧数和显示屏刷新率"><a href="#帧数和显示屏刷新率" class="headerlink" title="帧数和显示屏刷新率"></a>帧数和显示屏刷新率</h1><p>显示屏刷新率是固定的，而帧数生成是不固定的，显示屏刷新永远获取最新的一帧，所以说，60hz的显示器，如果帧数高的话，帧生成短，会降低延迟，而感到更流畅一些。而144hz的显示器刷新要比60hz要快很多，配合高帧数能看到更多？</p>
<p>帧数就是在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）表示。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象。高的帧率可以得到更流畅、更逼真的动画。每秒钟帧数 (fps)高，所显示的动作就会愈流畅。</p>
<p>显示器刷新率：显卡所渲染出来的画面与我们直接的视觉感官之间，需要用显示器来进行传递，所以显示器刷新率对我们的视觉体验有很大影响。显示器刷新率就是指每秒刷新画面的次数，也就是频率，单位是Hz。现在我们所用的液晶显示器，一般都是60Hz的刷新率，也有更高的适用于电竞游戏的85Hz、144Hz甚至是240Hz。</p>
<h2 id="帧数和刷新率的关系"><a href="#帧数和刷新率的关系" class="headerlink" title="帧数和刷新率的关系"></a>帧数和刷新率的关系</h2><p>电脑每显示一张画面是分两个步骤完成的，第一步是CPU和显卡把所要显示的画面数据计算出来，第二步是示器把这些数据写入到屏幕上去。这两步都是需要时间的，并且两个过程可以同时完成（因为具体实现这两个过程的硬件是相对独立的）。 但是这两个过程所花费的时间并不是相同的。显卡每秒能计算出的画面数量是根据硬件性能决定的，而显示器的每秒刷新频率是固定的。比如一个60Hz的显示器，每过16.67ms（毫秒）就会刷新一次。所以这时就产生了一个问题，显卡输出画面的数量低于或者高于显示器刷新率会怎么样呢？这就引出了另一个概念：垂直同步。</p>
<blockquote>
<p>垂直同步是做什么的？</p>
</blockquote>
<p>如果我们开启垂直同步，显卡绘制3D图形前会等待垂直同步信号，当该信号到达时，显卡开始绘制3D图形，如果显卡性能较为强劲，在下个垂直同步信号到来之前已经完成了对该帧的渲染，显卡就会暂停处理，等下个垂直同步信号到来后才开始渲染下一帧。通俗的来讲，垂直同步就是让显卡每秒输出的帧数等于显示器的刷新率。垂直同步是用来防止画面撕裂的，反之，关闭垂直同步就会出现撕裂、跳帧的情况。<br>下面来说一下上面提出的问题。垂直同步会把显卡帧率锁定为预期的显示器刷新率（通常是60Hz），当我们显卡输出的帧数高于显示器刷新率时，会有一部分的帧数不会呈现在显示器上，也就是会有浪费帧的情况。如果我们的显卡功能不够每秒渲染60幅画面的能力，垂直同步功能会把显卡帧率下调到能整除60的数字，可能是30或者更低，这时也就没有再开启垂直同步的必要了。<br>其实显示器刷新的时候，并非是整个屏幕同时进行，而是从最上面的一行像素开始，逐行向下刷新，所以从顶端到最底部是有时间差的，虽然这个时间很短，但是在高速运动的游戏当中，就会被放大并且被我们感知到，特别是在帧数高于刷新率的时候尤为明显。所以就会出现当显示靠上部分开始显示下一帧时，靠下的部分还停留在上一帧的图像，也就是画面撕裂。所以这时需要垂直同步技术，也就是等到整个画面在垂直方向上完全刷新完成，电脑才会渲染下一帧的图像，以保证每幅画面都能完整的显示出来。<br>怎么避免撕裂感？ 从上面的解释来看，开启垂直同步可以让我们从视觉上有更为流畅的体验，所以是不是开启了垂直同步就会更好呢？这个问题很难回答，就要因人而异了，每个人的电脑与显示器性能不同，感知能力和所处的环境也不尽相同，当你感觉画面裂的没法看时，可能别人并不觉得，所以当我们不觉得画面有撕裂感时，就可以不用打开垂直同步。<br>即使垂直同步的概念不是所有人都有深入的了解，但是在大家平时进行游戏时，或多或少都会从网上看到一些信息，或是听朋友建议不要打开垂直同步。虽说垂直同步能在一定程度上减轻画面撕裂，但会给我们操作上带来延迟，在FPS类的竞技游戏中，这种现象尤为明显。所以很少人会去开启这项功能。<br>如果我们想要去追求更高的帧数和刷新率的话，在选择更好的显卡和高刷新率的显示器同时，还要注意选择支持G-Sync和Free-Sync功能的显示器。<br>其实如果我们很少去玩FPS竞技类游戏，60Hz的显示器是完全足够我们使用的，若想要追求极致的画面，可以选择2K甚至4K的设备。</p>
<h2 id="垂直同步介绍"><a href="#垂直同步介绍" class="headerlink" title="垂直同步介绍"></a>垂直同步介绍</h2><p>要理解垂直同步技术，首先要理解两个概念：「逐行扫描」和「缓冲」。</p>
<p>「逐行扫描」就是说，显示器显示画面并不是“蹭”一下就打出一张画面来，而是从上到下一行一行显示出来的，只不过是显示得比较快所以肉眼看不出来而已。</p>
<p>「缓冲」则是指显卡渲染好一张画面之后，就会把这张画面储存在显存中，然后去渲染下一张画面。如果显卡每秒钟可以产生 120 张画面会发生什么呢？结果就是每 1/120 秒就会有一张画面进入缓冲中，下一个 1/120 秒，下一张画面就会把上一张给取代掉。</p>
<p>目前还有很多显示器刷新率是 60Hz，也就是每秒钟要显示 60 张画面，也就是每 1/60 秒要显示一张画面。所以显示器会每隔 1/60 秒从显存中提取一次画面。</p>
<p>那么问题来了，如果显卡每秒产生 120 张画面，而显示器每秒只读取 60 张，这会出现什么问题呢？</p>
<p>显示器提取画面的时候会从上到下一行一行（逐行扫描）把画面显示出来，本来要 1/60 秒才能显示完，然而显示了一半（1/120 秒）下一张画面就塞进来了。这时候显示器并不会停止工作，而是囫囵吞枣地把上一张画面的一半与下一张画面都显示出来。</p>
<p>由于两张画面不一样，结果就是上面半截是第一张画面，下面半截是第二张画面，也就是所谓的****画面撕裂****。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/wps1.png" alt="img"> </p>
<p>怎么解决呢？打开垂直同步。</p>
<p>垂直同步打开后，显卡的渲染速度强制锁定在最高每秒 60 张画面，这样显示器每次读取的时候都可以顺利读完。</p>
<p>然而打开垂直同步又会引发一个问题。如果一个跑步健将博尔特第 0 秒在起跑线上，第 1/60 秒就跑到了终点，那每秒渲染 60 张画面就完全看不到他中间的跑步过程！一开始就直接跑完。这就是所谓的****「卡顿」****，画面并不连贯。</p>
<p>于是你会发现不少游戏下面还有一个****「双重缓冲」****的开关，也就是多开设一个缓冲区。显卡依旧每秒渲染 120 张画面，第一张存在缓冲区1，第二张存在缓冲区2。显示器来读取画面的时候按顺序先从缓冲区 1 那里读完，再从缓冲区 2 那里读。这样就不会撕裂也不会卡顿了啊~</p>
<p>然而这又出现一个问题。本来博尔特 1/60 秒就把比赛跑完了，显卡也把中间过程给渲染出来了，双重缓冲打开了之后，显示器从缓冲区 1 中读取第 0 秒的画面，再从缓冲区 2 中读取第 1/120 秒的画面，再又回到缓冲区 1 中读取第 1/60 秒一共三张画面。显示器每 1/60 秒读取一张，所以一共用时 3/60 秒。</p>
<p>结果就是博尔牛寺活生生花了 3/60 秒才跑完，这就是所谓的****「画面延迟」****。</p>
<p>总而言之，如果你的显卡渲染速度达不到每秒 60 张，画面就不流畅；超过了每秒 60 张，又面临撕裂、卡顿和延迟的问题。只有显卡渲染速度超过每秒 60 张，显示器刷新率也高于 60 Hz，而显卡渲染速度又低于显示器刷新率的时候，以上的问题才能彻底解决。</p>
<h1 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h1><h2 id="1、TGA格式"><a href="#1、TGA格式" class="headerlink" title="1、TGA格式"></a>1、TGA格式</h2><p>TGA图像格式最大的特点是可以做出不规则形状的图形、图像文件，一般图形、图像文件都为四方形，若需要有圆形、菱形甚至是缕空的图像文件时，TGA可就派上用场了! TGA格式支持压缩，使用不失真的压缩算法。是一种比较好的图片格式。</p>
<h2 id="2、WMF格式"><a href="#2、WMF格式" class="headerlink" title="2、WMF格式"></a>2、WMF格式</h2><p>WMF（Windows Metafile Format）是Windows中常见的一种图元文件格式，属于矢量文件格式。它具有文件短小、图案造型化的特点，整个图形常由各个独立的组成部分拼接而成，其图形往往较粗糙。</p>
<h2 id="3、BMP格式"><a href="#3、BMP格式" class="headerlink" title="3、BMP格式"></a>3、BMP格式</h2><p><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=BMP%E6%A0%BC%E5%BC%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">BMP格式</a>是一种与硬件设备无关的图像文件格式，使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。</p>
<p><a target="_blank" rel="noopener" href="https://iknow-pic.cdn.bcebos.com/6609c93d70cf3bc726c500f8de00baa1cc112ad9"><img src="/2021/06/20/%E5%85%B6%E4%BB%96/0.40985815401599873.png" alt="img"></a></p>
<p>由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准，因此在Windows环境中运行的图形图像软件都支持BMP图像格式。</p>
<h2 id="4、TIF格式"><a href="#4、TIF格式" class="headerlink" title="4、TIF格式"></a>4、TIF格式</h2><p> <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=TIFF%E6%A0%BC%E5%BC%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">TIFF格式</a>灵活易变，它又定义了四类不同的格式：TIFF-B适用于二值图像：TIFF-G适用于黑白灰度图像；TIFF-P适用于带调色板的彩色图像：TIFF-R适用于RGB真彩图像。</p>
<p>TIFF支持多种编码方法，其中包括RGB压缩、RLE压缩、JPEG压缩等。</p>
<p>TIFF是现存图像文件格式中最复杂的一种，它具有扩展性、方便性、可改性，可以提供给IBMPC等环境中运行、图像编辑程序。</p>
<h2 id="5、GIF格式"><a href="#5、GIF格式" class="headerlink" title="5、GIF格式"></a>5、GIF格式</h2><p>是一种基于LZW算法的连续色调的无损压缩格式。其压缩率一般在50%左右，它不属于任何应用程序。几乎所有相关软件都支持它，公共领域有大量的软件在使用GIF图像文件。</p>
<p>GIF图像文件的数据是经过压缩的，而且是采用了可变长度等压缩算法。所以GIF的图像深度从lbit到8bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。</p>
<h2 id="6、JPEG格式"><a href="#6、JPEG格式" class="headerlink" title="6、JPEG格式"></a>6、JPEG格式</h2><p>JPEG格式是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。</p>
<p>但是JPEG压缩技术十分先进，它用有损压缩方式去除冗余的图像数据，在获得极高的压缩率的同时能展现十分丰富生动的图像，换句话说，就是可以用最少的磁盘空间得到较好的图像品质。</p>
<h2 id="7、PSD格式"><a href="#7、PSD格式" class="headerlink" title="7、PSD格式"></a>7、PSD格式</h2><p>这是Photoshop图像处理软件的专用文件格式，文件扩展名是．psd，可以支持图层、通道、蒙板和不同色彩模式的各种图像特征，是一种非压缩的原始文件保存格式。</p>
<p>扫描仪不能直接生成该种格式的文件。PSD文件有时容量会很大，但由于可以保留所有原始信息，在图像处理中对于尚未制作完成的图像，选用 PSD格式保存是最佳的选择。</p>
<h2 id="8、PNG小透明"><a href="#8、PNG小透明" class="headerlink" title="8、PNG小透明"></a>8、PNG小透明</h2><p>“可移植网络图形格式“，是图像文件存储格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。对于图片本身质量的减损非常低。因其能够支持压缩不失真、透明背景、渐变图像的制作要求，PNG格式也是各大制图软件例如PS、InDesign输出或编辑的原始格式。PNG文件非常适合在互联网上使用。但它也不足以用作专业印刷。优点：能够相容半透明 / 透明图像，缺点：档案比 JPEG 大，不能用于印刷PNG</p>
<h1 id="经纬度"><a href="#经纬度" class="headerlink" title="经纬度"></a>经纬度</h1><p>度(DDD)：E 108.90593度  N 34.21630度</p>
<p>  如何将度(DDD):： 108.90593度换算成度分秒(DMS)东经E 108度54分22.2秒?转换方法是将108.90593整数位不变取108(度),用0.90593<em>60=54.3558,取整数位54(分),0.3558</em>60=21.348再取整数位21(秒),故转化为108度54分21秒.</p>
<p>  同样将度分秒(DMS):东经E 108度54分22.2秒 换算成度(DDD)的方法如下:108度54分22.2秒=108+(54/60)+(22.2/3600)=108.90616度</p>
<p>因为计算时小数位保留的原因，导致正反计算存在一定误差，但误差影响不是很大。1秒的误差就是几米的样子。</p>
<p>经纬度换算成米</p>
<p>纬度分为60分，每一分再分为60秒以及秒的小数。</p>
<p>纬度线投射在图上看似水平的平行线，但实际上是不同半径的圆。有相同特定纬度的所有位置都在同一个纬线上。<br>赤道的纬度为0°，将行星平分为南半球和北半球。<br>纬度是指某点与地球球心的连线和地球赤道面所成的线面角，其数值在0至90度之间。位于赤道以北的点的纬度叫北纬，记为N，位于赤道以南的点的纬度称南纬，记为S。<br>纬度数值在0至30度之间的地区称为低纬地区，纬度数值在30至60度之间的地区称为中纬地区，纬度数值在60至90度之间的地区称为高纬地区。<br>赤道、南回归线、北回归线、南极圈和北极圈是特殊的纬线。<br>纬度1秒的长度<br>地球的子午线总长度大约40008km。平均：<br>纬度1度 = 大约111km<br>纬度1分 = 大约1.85km<br>纬度1秒 = 大约30.9m </p>
<p>所以：经度120.00001，精确的距离计算方式是：先进0.00001<em>111</em>1000=1.11m。</p>
<p>来源： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ggz19/p/7551088.html">https://www.cnblogs.com/ggz19/p/7551088.html</a></p>
<p>计算经纬度之间的距离与夹角</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EARTH_RADIUS 6378.137</span></span><br><span class="line"><span class="comment">//两点的距离（纬度，经度）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_distance</span><span class="params">(<span class="keyword">double</span> lat1, <span class="keyword">double</span> lng1, <span class="keyword">double</span> lat2, <span class="keyword">double</span> lng2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radLat1 = lat1 * PI / <span class="number">180.0</span>;   <span class="comment">//角度1? = π / 180</span></span><br><span class="line">    <span class="keyword">double</span> radLat2 = lat2 * PI / <span class="number">180.0</span>;   <span class="comment">//角度1? = π / 180</span></span><br><span class="line">    <span class="keyword">double</span> a = radLat1 - radLat2;<span class="comment">//纬度之差</span></span><br><span class="line">    <span class="keyword">double</span> b = lng1 * PI / <span class="number">180.0</span> - lng2* PI / <span class="number">180.0</span>;  <span class="comment">//经度之差</span></span><br><span class="line">    <span class="keyword">double</span> dst = <span class="number">2</span> * <span class="built_in">asin</span>((<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">sin</span>(a / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">cos</span>(radLat1) * <span class="built_in">cos</span>(radLat2) * <span class="built_in">pow</span>(<span class="built_in">sin</span>(b / <span class="number">2</span>), <span class="number">2</span>))));</span><br><span class="line">    dst = dst * EARTH_RADIUS;</span><br><span class="line">    dst = <span class="built_in">round</span>(dst * <span class="number">10000</span>) / <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算角度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_angle</span><span class="params">(<span class="keyword">double</span> lat1, <span class="keyword">double</span> lng1, <span class="keyword">double</span> lat2, <span class="keyword">double</span> lng2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = lat1 - lat2;<span class="comment">//t d</span></span><br><span class="line">    <span class="keyword">double</span> y = lng1 - lng2;<span class="comment">//z y</span></span><br><span class="line">    <span class="keyword">int</span> angle = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span>) angle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span>) angle = <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="number">270</span>;</span><br><span class="line">    <span class="keyword">if</span> (angle == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dislat = <span class="built_in">get_distance</span>(lat1, lng2, lat2, lng2);</span><br><span class="line">        <span class="keyword">double</span> dislng = <span class="built_in">get_distance</span>(lat2, lng1, lat2, lng2);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislng, dislat) / PI * <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislat, dislng) / PI * <span class="number">180</span> + <span class="number">90</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislng, dislat) / PI * <span class="number">180</span> + <span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) angle = <span class="built_in">atan2</span>(dislat, dislng) / PI * <span class="number">180</span> + <span class="number">270</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> angle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ARM与X86-CPU架构区别"><a href="#ARM与X86-CPU架构区别" class="headerlink" title="ARM与X86 CPU架构区别"></a>ARM与X86 CPU架构区别</h1><p>所谓的X86 ARM 说的都是指令集。 </p>
<p>CISC(复杂指令集计算机)和RISC(精简指令集计算机)是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。早期的CPU全部是CISC架构，它的设计目的是 CISC要用最少的机器语言指令来完成所需的计算任务。 </p>
<p>RISC和CISC是设计制造微处理器的两种典型技术，虽然它们都是试图在体系结构、操作运行、软件硬件、编译时间和运行时间等诸多因素中做出某种平衡，以求达到高效的目的，但采用的方法不同，因此，在很多方面差异很大。</p>
<blockquote>
<p><strong>x86架构采用CISC，而ARM采用RISC。</strong> </p>
</blockquote>
<p>ARM成立于1991年，是一家出售IP（技术知识产权）的公司，所谓的技术知识产权，有点像卖房屋的结构设计图，至于要怎么修改，哪边开窗户，以及要怎么添加其它的花园，则由买了设计图的厂商自己决定。 </p>
<p>而ARM的架构是采用RISC架构，如同它的名称一样，Advanced RISC Machines，RISC架构在当初的PC架构争霸战虽然败给Intel所主导的x86处理器架构，却默默在另外的领域成长壮大；小到硬盘转速控制、电信基地台的计算、汽车喷射引擎的控制、音响系统、相机引擎，大到电动机具的控制等等，都能够看见采用ARM授权架构处理器的身影。 </p>
<p>而有了设计图，当然还要有把设计图实现的厂商，而这些就是ARM架构的授权客户群。包括： </p>
<p>TI OMAP、Qualcomm Snapdragon、三星的蜂鸟（Hummingbird）、猎户座（Orion）、飞思卡尔（Freescale）的i.MX，或是ST-Ericsson的应用处理器、Freescale、联发科、Telechip、新岸线等。 </p>
<p>X86是英特尔Intel首先开发制造的一种微处理器体系结构的泛称，包括Intel8086、80186、80286、80386以及80486以86结尾系列，英特尔统治整个CPU产业链长达数十年。但是，Intel以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。 </p>
<p>ARM（Advanced RISC Machines）公司是苹果、Acorn、VLSI、Technology等公司的合资企业。ARM采用将芯片的设计方案授权（licensing）给其他公司生产的模式，在世界范围结成了超过100个的合作伙伴（Partners），将封闭设计的Intel公司变成全民公敌。</p>
<p>ARM处理器非常适用于移动通信领域，具有 <mark class="hl-label blue">低成本、高性能和低耗电</mark>  的特性，ARM的高性价比和低耗能在移动市场比英特尔更具优势。 </p>
<p>ARM的架构相较于x86有哪些特点？相较于基于CISC的x86架构处理器，由于为了满足电脑产业发展而不断加入指令集，使得处理器日益庞大，但每个指令集用到的频率也越差越大，许多指令到后来已经相当少用，甚至是可以被新的指令所取代。</p>
<p>而ARM架构则大幅简化架构，仅保留所需要的指令，可以让整个处理器更为简化，拥有小体积、高效能的特性。 </p>
<p>另外，ARM的架构老早就已经做到高密度整合，由于ARM授权的弹性以及核心架构的单纯，ARM处理器架构可以很容易与其它专职的特殊核心，像GPU、多媒体译码核心、基频调制解调器、I/O控制等架构整合，透过SoC（System On a Chip，系统单芯片）的方式，一颗小小的ARM架构应用处理器，完成近年x86架构处理器积极跨足的单芯片设计，并且通过各种不同的核心分工各司其职。</p>
<p>ARM架构应用处理器的核心负担相较传统x86处理器低了许多，并且因为早前应用处理器的需求就是以低功耗为重点，即便如今效能不断提升，仍是以保有省电的特性为前提发展条件。 </p>
<p>ARM架构的另一个优点是自由性，只要向ARM买下核心授权，就可以与其它IP公司的方案以及这家授权客户本身的优势技术整合，虽同为同一世代的ARM核心架构，即便频率相同，结果也不同。</p>
<p>不过这也使得ARM应用处理器光从基本规格不一定能看出其操作效能，例如同样隶属高通Snapdragon，频率1GHz的第一世代旗舰QSD8x50甚至不敌频率仅800MHz的第二世代MSM7230。 </p>
<p>ARM的架构之所以能够在智能手机以及平板领域迅速窜红，苹果iOS可说是大功臣，在苹果之前，智能手机在市场上一直载浮载沉，虽然有着号称智能手机平台市占率第一的Nokia Symbian，以及Windows Mobile、Palm OS、BlackBerry等系统，不过当时的环境缺乏移动网络为后盾，在线商店的概念还未发展成型；</p>
<p>一直到苹果以iPhone打响新世代智能手机第一炮后，市场才真正体会到智能手机原来可以是这么容易使用。 </p>
<p>iPhone的出现也间接带起市场对于ARM架构应用处理器的需求，不过光是苹果也无法带起市场对于ARM处理器的需求，还有WM（WP7)手机与Symbian也纷纷加入新一代智能手机战局。</p>
<p>但是真正成为关键的是Google Android宣布参战后，其它手机厂商取得一个相较过去成熟的通用智能手机平台，而各厂商又为了进行产品差异化，开始针对ARM架构应用处理器的效能以及硬件支持要求，使得过去发展缓慢的ARM架构一下子热络起来，也让ARM一夕之间成为火热话题。 </p>
<p>GOOGLE的Android系统和苹果的IPAD、IPHONE推出后，ARM架构的电脑系统（特别是在终端方面应用）受到用户的广泛支持和追捧，ARM+Android成为IT、通信领域最热门的话题，众多芯片厂商纷纷推出具有各种独特应用功能基于ARM结构开发的产品，近期最新形成的“异构概念”更成为电脑今后发展主要方向。</p>
<p>在IT行业推崇了20多年的“性价比“概念受到根本的动摇和冲击，“适用的才是最好的”已经被越来越多的用户接受。 </p>
<p>我们就ARM架构的系统与X86架构系统的特性进行一个系统分析，方便用户在选择系统时进行理性、合理的比价分析。 </p>
<h2 id="一、性能："><a href="#一、性能：" class="headerlink" title="一、性能："></a>一、性能：</h2><p>X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，这几年才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面，ARM根本不是X86的对手。 </p>
<p><strong>但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。</strong> </p>
<h2 id="二、扩展能力"><a href="#二、扩展能力" class="headerlink" title="二、扩展能力"></a>二、扩展能力</h2><p>X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。 </p>
<p>ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则。 </p>
<h2 id="三、操作系统的兼容性"><a href="#三、操作系统的兼容性" class="headerlink" title="三、操作系统的兼容性"></a>三、操作系统的兼容性</h2><p>X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。 </p>
<p>ARM系统几乎都采用Linux操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的Android系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力。 </p>
<h2 id="四、软件开发的方便性及可使用工具的多样性"><a href="#四、软件开发的方便性及可使用工具的多样性" class="headerlink" title="四、软件开发的方便性及可使用工具的多样性"></a>四、软件开发的方便性及可使用工具的多样性</h2><p>X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。 </p>
<p>ARM结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成ARM结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。 </p>
<p>对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比ARM结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。 </p>
<p>从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：功耗.</p>
<h2 id="五、功耗"><a href="#五、功耗" class="headerlink" title="五、功耗"></a>五、功耗</h2><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能 + 速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑无法相比。 </p>
<p>ARM的设计及发展思路是：满足某个特殊方面的应用即可，在某一专项领域是最强的，（哪怕在其他方面一无是处），这样ARM以其不是最强的技术，同样也不是很高级制程的制造工艺，生产出性能不是很强的电脑系统，但在某个专业应用方面则是最好的，特别是在众多终端应用，尤其在移动终端应用上占有绝对优势的统治地位，这个原因就是：功耗。 </p>
<p>高功耗导致了一系列X86系统无法解决的问题出现：系统的续航能力弱、体积无法缩小、稳定性差、对使用环境要求高等问题。从这里我们可以看到X86系统与ARM系统是在两个完全不同领域方面的应用，他们之间根本不存在替换性，在服务器、工作站以及其他高性能运算等应用方面，可以不考虑功耗和使用环境等条件时，X86系统占了绝对优势；</p>
<p>但受功耗、环境等条件制约且工作任务固定的情况下ARM占有很大的优势，在手持式移动终端领域，X86的功耗更使他英雄毫无用武之地。 </p>
<p>但在很多的应用终端领域，现正成为两大阵营争夺的重点，ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 </p>
<p>我们今天讨论的重点就是在两大阵营都能可以覆盖的终端应用领域进行对比、分析。这类型的应用一定是终端应用，通常有下面几个特征： </p>
<blockquote>
<p>1、系统的工作性质比较固定（如：POS、ATM、车载电脑系统、多媒体广告播放系统、视频监控系统，以及众多的信息接收、控制系统和专业的工控系统等等）； </p>
</blockquote>
<blockquote>
<p>2、应用环境比较恶劣，如：温度变化很大，高温超过40度，低温达零下20度；多尘、潮湿等； </p>
</blockquote>
<blockquote>
<p>3、有一定的应用数量，但数量不是很大。 </p>
</blockquote>
<p>这部分的应用领域传统上是由X86结构的低功耗工控机（系统）实现的，但近几年ARM系统的飞速发展，特别是Android操作系统出现后，ARM + Android大有取代x86系统占领（低功耗）终端应用领域的趋势。我们在考虑这种应用对比时根据ARM和X86的特性，主要还考虑以下因素： </p>
<p>1、性能： </p>
<p>如果ARM系统的性能能满足应用需求时，建议尽可能采用ARM结构的产品，否则考虑X86的产品。注意在这里我们要强调的是：不要将两个系统的绝对性能进行比较，而是以能否您的应用特点为标准进行分析。 </p>
<p>2、应用数量： </p>
<p>如果您的应用数量太少，您可能根本不值得独立开发一套应用系统，但如果您的应用数量达到几百甚至过千时，您是值得考虑自己开发一套新的系统的。因为：ARM的开发成本和制造成本相对比较低，如果有几百个以上终端应用，应该可以分摊掉开发成本。 </p>
<p>如果选用X86结构的系统，根本不应该考虑单独开发一套专用系统（因为开发成本太高，可能是ARM的10倍），而是在市场上筛选出最接近您需求的产品，以避免高昂的硬件开发成本，和今后的制造成本。</p>
<p>3、操作系统 </p>
<p>ARM的操作系统通常是单独建立一个自己的Linux系统，且系统与系统间不能兼容，这严重制约了ARM的应用扩展，但Android出现后，系统兼容的屏障正逐步消失，促进了系统以及应用软件的兼容，大大扩大了ARM应用软件的的数量同时扩大了其应用空间。 </p>
<p>4、功耗以及功耗延伸的系列问题 </p>
<p>ARM的优势是功耗低，其实低功耗还意味着： </p>
<p>1）稳定性高：因为功耗越高电子元器件的稳定性和可靠性越差，对低功耗的产品只要选择好外围元件的品质，系统的稳定性不会有太大问题； </p>
<p>2）散热成本低和可以考虑更小的产品体积：对高功耗的产品不可避免要考虑散热问题，而散热设备（或器件）的存在，有制约了产品的体积，对某些场合的应用构成致命的制约。但ARM的功耗 &lt; 1W，完全不用考虑散热问题。 </p>
<p>3）功耗低对供电电源的要求低：几乎所有电子产品，（在同等条件下）功耗越高对电源的要求越高，电源的成本就越高。 </p>
<p>4）功耗低电池的续航时间长。</p>
<p>5）功耗低对抗环境伤害的能力强：低功耗产品因为不用考虑散热，可以将产品密封保护起来，但高功耗产品必须散热，甚至需要风扇帮助散热，这样必然使很多的元件和线路裸露在空气中，被空气中的尘埃、湿气、酸碱物质等腐蚀。 </p>
<p>5、软件开发成本问题 </p>
<p>ARM的操作系统很小（精简）不可能带很多工具，通常基于ARM的软件大多用C或JAVA开发，其成本会比基于X86系统的高。而且对大多数ARM而言，因其操作系统不一样，软件业不能在两个系统中自由互换使用，但一般来说：用C或JAVA编写的软件只需在ARM平台的操作系统中编译一下就可以移植过去。 </p>
<p>但对Android系统开发的软件，只要能在某台ARM设备中运行，就可以在另一台基于同样系统的设备中运行。 </p>
<p>6、硬件的开发成本 </p>
<p>ARM实际上在CPU芯片中已经整合了几乎所有功能，几乎所有线路按原理图直接拉出就可以了，需要扩展的部分一般不多，所以其开发成本会比较低，通常三五万就可以了。 </p>
<p>但X86的外围线路很多，需要相当经验的工程师，而且还有BIOS等设计，所以X86主板的设计费用会比较高，通常要二三十万。 </p>
<p>7、硬件的制造及应用成本 </p>
<p>无论ARM或X86主板其制造成本都是由元件和加工费构成，通常一片ARM的主板价格与一片X86主板的价格差不多，但ARM是一片可以独立使用的产品，x86主板通常还要加上：CPU、内存、硬盘甚至还有显卡。 </p>
<p>另外X86还要配上一个电源，这个电源比ARM的电源要贵很多。 </p>
<p>所以：明显X86在硬件方面的成本比ARM高得多。 </p>
<p>总结上面对比，X86系统和ARM系统应该是两个完全不同领域的应用，如果功能单一又受到环境制约的应用，如：POS、ATM、多媒体广告机（现已经有ARM+DSP的产品）、车载电脑终端等应用，应该首先考虑ARM方案，ARM方案与X86相比，其功耗和成本占有很大优势。</p>
<p>来源： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/CZM-/p/9611312.html">https://www.cnblogs.com/CZM-/p/9611312.html</a></p>
<p>  如图所示，从上到下，计算机系统分为四个层次，分别为应用软件、基础软件、逻辑硬件和物理载体。软件以指令形式运行在CPU硬件上，而指令系统介于软件和硬件之间，是软硬件交互的界面，或者说，CPU是以指令集中的一条指令为最小单位来定义cpu的硬件结构的（注意，x86引入微码之后，应该是以微码为最小单位定义和设计cpu硬件结构的），简单来说就是，一条指令直接一一对应一部分硬件芯片功能。</p>
<p>  指令集是指在处理器内被处理的程序，指令集为汇编语言的设计师和编译器所见。指令集包含execution model，寄存器，地址以及数据格式。微体系结构包含处理器内部的构成以及这些构成起来的部分如何运行指令集架构。微体系结构通常被表示成流程图，以描述机器内部组件的链接状况，从一个闸或是寄存器，到算术逻辑单元（ALU）。图上分布着数据路径（可以显示数据在微架构的位置）以及控制路径（显示数据该被什么指令所处理）。</p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210620212605497.png" alt="image-20210620212605497"></p>
<p>  Computer architect（也叫计算机体系结构，计算机系统结构，计算机结构），它是指令系统（ISA）与微体系结构（microarchitecture）的总称。个人认为，这就是我们作为的 “ 架构 ”一词的意思。CPU是一个执行部件，它之所以能执行，也是因为人们在里面制作了执行各种功能的硬件电路，然后再用一定的逻辑让它按照一定的顺序工作，这样就能完成人们给它的任务。也就是说，如果把CPU看作一个人，首先它要有正常的工作能力（既执行能力），然后又有足够的逻辑能力（能明白做事的顺序,这就是指微架构），最后还要听的懂别人的话（既指令集），才能正常工作。而这些集中在一起就构成了所谓的“架构”，它可以理解为一套“工具”、“方法”和“规范”的集合。不同的架构之间，工具可能不同，方法可能不同，规范也可能不同，这也造成了它们之间的不兼容——你给一个意大利泥瓦匠看一份中文写成的烹饪指南，他当然不知道应该干什么了。所以X86 ARM MIPS是不同指令集，那么使用它们的体系结构（也就是架构）也就是不同的架构。</p>
<p>  那么这两个指令集的区别又在哪里呢？从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。我们可以继续举个例子，比如说我们要命令一个人吃饭，那么我们应该怎么命令呢？我们可以直接对他下达“吃饭”的命令，也可以命令他“先拿勺子，然后舀起一勺饭，然后张嘴，然后送到嘴里，最后咽下去”。从这里可以看到，对于命令别人做事这样一件事情，不同的人有不同的理解，有人认为，如果我首先给接受命令的人以足够的训练，让他掌握各种复杂技能（即在硬件中实现对应的复杂功能），那么以后就可以用非常简单的命令让他去做很复杂的事情——比如只要说一句“吃饭”，他就会吃饭。但是也有人认为这样会让事情变的太复杂，毕竟接受命令的人要做的事情很复杂，如果你这时候想让他吃菜怎么办？难道继续训练他吃菜的方法？我们为什么不可以把事情分为许多非常基本的步骤，这样只需要接受命令的人懂得很少的基本技能，就可以完成同样的工作，无非是下达命令的人稍微累一点——比如现在我要他吃菜，只需要把刚刚吃饭命令里的“舀起一勺饭”改成“舀起一勺菜”，问题就解决了，多么简单。</p>
<p>  这就是“复杂指令集”和“精简指令集”的逻辑区别。可能有人说，明显是精简指令集好啊，但是我们不好去判断它们之间到底谁好谁坏，因为目前他们两种指令集都在蓬勃发展，而且都很成功——X86是复杂指令集（CISC）的代表，而ARM则是精简指令集（RISC）的代表，甚至ARM的名字就直接表明了它的技术：Advanced RISC Machine——高级RISC机。</p>
<p>  到了这里你就应该明白为什么RISC和CISC之间不好直接比较性能了，因为它们之间的设计思路差异太大。这样的思路导致了CISC和RISC分道扬镳——前者更加专注于高性能但同时高功耗的实现，而后者则专注于小尺寸低功耗领域。实际上也有很多事情CISC更加合适，而另外一些事情则是RISC更加合适，比如在执行高密度的运算任务的时候CISC就更具备优势，而在执行简单重复劳动的时候RISC就能占到上风，比如假设我们是在举办吃饭大赛，那么CISC只需要不停的喊“吃饭吃饭吃饭”就行了，而RISC则要一遍一遍重复吃饭流程，负责喊话的人如果嘴巴不够快（即内存带宽不够大），那么RISC就很难吃的过CISC。但是如果我们只是要两个人把饭舀出来，那么CISC就麻烦得多，因为CISC里没有这么简单的舀饭动作，而RISC就只需要不停喊“舀饭舀饭舀饭”就OK。</p>
<p>  这就是CISC和RISC之间的区别。但是在实际情况中问题要比这复杂许许多多，因为各个阵营的设计者都想要提升自家架构的性能。这里面最普遍的就是所谓的“发射”概念。什么叫发射？发射就是同时可以执行多少指令的意思，例如双发射就意味着CPU可以同时拾取两条指令，三发射则自然就是三条了。现代高级处理器已经很少有单发射的实现，例如Cortex A8和A9都是双发射的RISC，而Cortex A15则是三发射。ATOM是双发射CISC，Core系列甚至做到了四发射——这个方面大家倒是不相上下，但是不要忘了CISC的指令更加复杂，也就意味着指令更加强大，还是吃饭的例子，CISC只需要1个指令，而RISC需要5个，那么在内存带宽相同的情况下，CISC能达到的性能是要超过RISC的（就吃饭而言是5倍），而实际中CISC的Core i处理器内存带宽已经超过了100GB/s，而ARM还在为10GB/s而苦苦奋斗，一个更加吃带宽的架构，带宽却只有别人的十分之一，性能自然会受到非常大的制约。为什么说ARM和X86不好比，这也是很重要的一个原因，因为不同的应用对带宽需求是不同的。一旦遇到带宽瓶颈，哪怕ARM处理器已经达到了很高的运算性能，实际上根本发挥不出来，自然也就会落败了。</p>
<p>  说到这儿大家应该也已经明白CISC和RISC的区别和特色了。简而言之，CISC实际上是以增加处理器本身复杂度作为代价，去换取更高的性能，而RISC则是将复杂度交给了编译器，牺牲了程序大小和指令带宽，换取了简单和低功耗的硬件实现。但如果事情就这样发展下去，为了提升性能，CISC的处理器将越来越大，而RISC需要的内存带宽则会突破天际，这都是受到技术限制的。所以进十多年来，关于CISC和RISC的区分已经慢慢的在模糊，例如自P6体系（即Pentium Pro）以来，作为CISC代表的X86架构引入了微码概念，与此对应的，处理器内部也增加了所谓的译码器，负责将传统的CISC指令“拆包”为更加短小的微码（uOPs）。一条CISC指令进来以后，会被译码器拆分为数量不等的微码，然后送入处理器的执行管线——这实际上可以理解为RISC内核+CISC解码器。而RISC也引入了指令集这个就逻辑角度而言非常不精简的东西，来增加运算性能。正常而言，一条X86指令会被拆解为2～4个uOPs，平均来看就是3个，因此同样的指令密度下，目前X86的实际指令执行能力应该大约是ARM的3倍左右。不过不要忘了这是基于“同样指令密度”下的一个假设，实际上X86可以达到的指令密度是十倍甚至百倍于ARM的。</p>
<p>  最后一个需要考虑的地方就是指令集。这个东西的引入，是为了加速处理器在某些特定应用上性能而设计的，已经有了几十年的历史了。而实际上在目前的应用环境内，起到决定作用的很多时候是指令集而不是CPU核心。X86架构的强大，很多时候也源于指令集的强大，比如我们知道的ATOM，虽然它的X86核心非常羸弱，但是由于它支持SSE3，在很多时候性能甚至可以超过核心性能远远强大于它的Pentium M，这就是指令集的威力。目前X86指令集已经从MMX，发展到了SSE，AVX，而ARM依然还只有简单而基础的NEON。它们之间不成比例的差距造成了实际应用中成百上千倍的性能落差，例如即便是现今最强大的ARM内核依然还在为软解1080p H.264而奋斗，但一颗普通的中端Core i处理器却可以用接近十倍播放速度的速度去压缩1080p H.264视频。至少在这点上，说PC处理器的性能百倍于ARM是无可辩驳的，而实际中这样的例子比比皆是。这也是为什么我在之前说平均下来ARM只有X86几十分之一的性能的原因。</p>
<p>  然现在ARM很强大，但它距离X86还是非常遥远，并没有因为这几年的进步而缩短，实际上反而在被更快的拉大。毕竟它们设计的出发点不一样，因此根本不具备多少可比性，X86无法做到ARM的功耗，而ARM也无法做到X86的性能。</p>
<h1 id="内核模式和用户模式"><a href="#内核模式和用户模式" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h1><p>首先我们要解释一个概念——进程（Process）。简单来说，<strong>一个可执行程序就是一个进程</strong>，我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。</p>
<p>严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个<strong>静态</strong>的概念；进程是程序加载到内存运行后一些列的活动，是一个<strong>动态</strong>的概念。</p>
<p>“程序的地址空间”的说法，这其实是不严谨的，应该说“进程的地址空间”。<strong>一个进程对应一个地址空间，而一个程序可能会创建多个进程</strong>。</p>
<h2 id="内核模式和用户模式-1"><a href="#内核模式和用户模式-1" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h2><p>内核空间存放的是操作系统内核代码和数据，是被所有程序<strong>共享</strong>的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。</p>
<p>要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。</p>
<p><strong>用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。</strong></p>
<p><strong>用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。</strong></p>
<p>计算机会经常在内核模式和用户模式之间切换：<br>·当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；</p>
<p>·操作完成后，继续执行应用程序的代码，就又回到了用户模式。</p>
<p>总结：<strong>用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。</strong></p>
<h2 id="为什么要区分两种模式"><a href="#为什么要区分两种模式" class="headerlink" title="为什么要区分两种模式"></a>为什么要区分两种模式</h2><p>内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。</p>
<p>从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以<strong>运行在 ring0 ~ ring3 四个不同的权限级别</strong>，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：</p>
<p>·一个是<strong>内核模式，对应 ring0 级</strong>，操作系统的核心部分和设备驱动都运行在该模式下。<br>·另一个是<strong>用户模式，对应 ring3 级</strong>，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。</p>
<h2 id="为什么内核和用户程序要共用地址空间"><a href="#为什么内核和用户程序要共用地址空间" class="headerlink" title="为什么内核和用户程序要共用地址空间"></a>为什么内核和用户程序要共用地址空间</h2><p>既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？</p>
<p><strong>让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。</strong></p>
<p>而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。</p>
<h1 id="bat"><a href="#bat" class="headerlink" title="bat"></a>bat</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line">echo 当前位置 </span><br><span class="line">set curdir=%~dp0</span><br><span class="line">cd /d %curdir%</span><br><span class="line"></span><br><span class="line">echo %curdir%</span><br><span class="line">echo ******************</span><br><span class="line">rem 查询是否存在必要的文件</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist testCrack.<span class="built_in">exe</span> ( </span><br><span class="line">	echo 不存在testCrack.exe</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist SPxCrack.<span class="built_in">dll</span> ( </span><br><span class="line">	echo 不存在SPxCrack.dll</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist RecordCPR.<span class="built_in">exe</span> ( </span><br><span class="line">	echo 不存在RecordCPR.exe</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line">rem 删除旧版本的破解文件</span><br><span class="line"><span class="keyword">if</span> exist *.<span class="built_in">lic</span> ( </span><br><span class="line">	del *.lic</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist RecordCPR_Crack.<span class="built_in">exe</span> ( </span><br><span class="line">	del RecordCPR_Crack.exe</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rem 启动另外的程序，后面跟的是传入的参数，start表示不等待子线程，没有start表示要等待子线程结束</span><br><span class="line">testCrack.exe %curdir%RecordCPR.exe </span><br><span class="line">echo *******************</span><br><span class="line">rem 检测是否破解成功</span><br><span class="line"><span class="keyword">if</span> %errorlevel%==<span class="number">1</span> (</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist cp-spx.<span class="built_in">lic</span> ( </span><br><span class="line">	echo 没有生成.lic</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> exist RecordCPR_Crack.<span class="built_in">exe</span> (  rem 前括号要放这</span><br><span class="line">	echo 没有生成_Crack.exe</span><br><span class="line">	pause</span><br><span class="line">	exit</span><br><span class="line">)</span><br><span class="line">) <span class="built_in"><span class="keyword">else</span></span> (  rem <span class="keyword">else</span>要和<span class="keyword">if</span>的后括号在一行</span><br><span class="line">	 echo crack失败 </span><br><span class="line">	 pause</span><br><span class="line">	 exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">echo 切换至release_y</span><br><span class="line">set desdir=%cd%\release_y</span><br><span class="line">cd /d %desdir%</span><br><span class="line">echo %desdir%</span><br><span class="line"></span><br><span class="line">rem 删除旧版本的破解文件</span><br><span class="line"><span class="keyword">if</span> exist *.<span class="built_in">lic</span> ( </span><br><span class="line">	echo 已删除旧版本lic</span><br><span class="line">	del *.lic</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist RecordCPR_Crack.<span class="built_in">exe</span> ( </span><br><span class="line">	echo 已删除旧版本_Crack.exe</span><br><span class="line">	del RecordCPR_Crack.exe</span><br><span class="line">)</span><br><span class="line">rem 拷贝新的破解文件</span><br><span class="line">copy %curdir%cp-spx.lic %desdir%</span><br><span class="line">copy %curdir%RecordCPR_Crack.exe %desdir%</span><br><span class="line">echo 已拷贝新版本_Crack.exe与lic</span><br><span class="line">rem 删除破解位置的文件，避免混淆</span><br><span class="line">del %curdir%RecordCPR_Crack.exe</span><br><span class="line">del %curdir%cp-spx.lic</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist SPxErrors.<span class="built_in">txt</span> ( </span><br><span class="line">	del SPxErrors.txt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rem 创建快捷方式</span><br><span class="line">rem mshta VBScript:<span class="built_in">Execute</span>(<span class="string">&quot;Set a=CreateObject(&quot;</span><span class="string">&quot;WScript.Shell&quot;</span><span class="string">&quot;):Set b=a.CreateShortcut(a.SpecialFolders(&quot;</span><span class="string">&quot;Desktop&quot;</span><span class="string">&quot;) &amp; &quot;</span><span class="string">&quot;\快捷方式名字.lnk&quot;</span><span class="string">&quot;):b.TargetPath=&quot;</span><span class="string">&quot;程序路径&quot;</span><span class="string">&quot;:b.WorkingDirectory=&quot;</span><span class="string">&quot;%~dp0&quot;</span><span class="string">&quot;:b.Save:close&quot;</span>)</span><br><span class="line">rem https:<span class="comment">//blog.csdn.net/mimishy2000/article/details/88533858</span></span><br><span class="line">mshta VBScript:<span class="built_in">Execute</span>(<span class="string">&quot;Set a=CreateObject(&quot;</span><span class="string">&quot;WScript.Shell&quot;</span><span class="string">&quot;):Set b=a.CreateShortcut(a.SpecialFolders(&quot;</span><span class="string">&quot;Desktop&quot;</span><span class="string">&quot;) &amp; &quot;</span><span class="string">&quot;\RecordCPR_Crack.exe.lnk&quot;</span><span class="string">&quot;):b.TargetPath=&quot;</span><span class="string">&quot;%desdir%\RecordCPR_Crack.exe&quot;</span><span class="string">&quot;:b.WorkingDirectory=&quot;</span><span class="string">&quot;%desdir%&quot;</span><span class="string">&quot;:b.Save:close&quot;</span>)</span><br><span class="line">echo 已创建快捷方式至桌面</span><br><span class="line">echo *************整个过程已结束*************</span><br><span class="line">pause</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="指定进制输出"><a href="#指定进制输出" class="headerlink" title="指定进制输出"></a>指定进制输出</h1><h2 id="1-C中指定进制输出"><a href="#1-C中指定进制输出" class="headerlink" title="1.C中指定进制输出"></a>1.C中指定进制输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05o\n&quot;</span>,<span class="number">35</span>);    <span class="comment">//按八进制格式输出，保留5位高位补零</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%03d\n&quot;</span>,<span class="number">35</span>);    <span class="comment">//按十进制格式输出，保留3位高位补零</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05x\n&quot;</span>,<span class="number">35</span>);    <span class="comment">//按十六进制格式输出，保留5位高位补零</span></span><br></pre></td></tr></table></figure>

<h2 id="2-C-中指定进制输出"><a href="#2-C-中指定进制输出" class="headerlink" title="2.C++中指定进制输出"></a>2.C++中指定进制输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的8进制:&quot;</span> &lt;&lt; std::oct &lt;&lt; <span class="number">35</span>&lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的10进制&quot;</span> &lt;&lt; std::dec &lt;&lt; <span class="number">35</span> &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的16进制:&quot;</span> &lt;&lt; std::hex &lt;&lt; <span class="number">35</span> &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;35的2进制: &quot;</span> &lt;&lt; bitset&lt;8&gt;(<span class="number">35</span>) &lt;&lt; endl;      <span class="comment">//&lt;8&gt;：表示保留8位输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">使用cout输出时，hex控制符只对整数有效，所以需要先将<span class="number">16</span>进制转成整数，再输出。</span><br></pre></td></tr></table></figure>

<h1 id="指定格式输出"><a href="#指定格式输出" class="headerlink" title="指定格式输出"></a>指定格式输出</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输出<span class="keyword">unsigned</span> <span class="keyword">short</span> ,<span class="keyword">unsigned</span> <span class="keyword">int</span> 一般用 %u</span><br><span class="line">像<span class="keyword">unsigned</span> <span class="keyword">long</span> 输出的话一bai般用%lu</span><br><span class="line"></span><br><span class="line">d 以十进制形式输出带符号整数(正数不输出符号)</span><br><span class="line">o 以八进制形式输出无符号整数(不输出前缀<span class="number">0</span>)</span><br><span class="line">x,X 以十六进制形式输出无符号整数(不输出前缀Ox)</span><br><span class="line">u 以十进制形式输出无符号整数</span><br><span class="line">f 以小数形式输出单、双精度实数</span><br><span class="line">e,E 以指数形式输出单、双精度实数</span><br><span class="line">g,G 以%f或%e中较短的输出宽度输出单、双精度实数</span><br><span class="line">c 输出单个字符</span><br><span class="line">s 输出字符串</span><br></pre></td></tr></table></figure>

<h1 id="获得屏幕区域的所有RGB值，保存成JPG图片"><a href="#获得屏幕区域的所有RGB值，保存成JPG图片" class="headerlink" title="获得屏幕区域的所有RGB值，保存成JPG图片"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/zerocnd/article/details/4503939">获得屏幕区域的所有RGB值，保存成JPG图片</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">	LPRECT lpRect=<span class="keyword">new</span> RECT;</span><br><span class="line">	lpRect-&gt;left = m_radarWidget-&gt;<span class="built_in">getXMouse</span>() - <span class="number">130</span>;</span><br><span class="line">	lpRect-&gt;top = m_radarWidget-&gt;<span class="built_in">getYMouse</span>() - <span class="number">130</span>;</span><br><span class="line">	lpRect-&gt;right = m_radarWidget-&gt;<span class="built_in">getXMouse</span>() + <span class="number">130</span>;</span><br><span class="line">	lpRect-&gt;bottom = m_radarWidget-&gt;<span class="built_in">getYMouse</span>() + <span class="number">130</span>;</span><br><span class="line"></span><br><span class="line">	HDC hScrDC;	<span class="comment">//声明屏幕设备描述表</span></span><br><span class="line"></span><br><span class="line">	hScrDC = <span class="built_in">CreateDC</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;DISPLAY&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	                  <span class="comment">//为屏幕创建设备描述表</span></span><br><span class="line">	<span class="built_in">gdiRectangle</span>(hScrDC, lpRect, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MainWindow::gdiRectangle</span><span class="params">(HDC hdc,<span class="keyword">const</span> RECT *rect,COLORREF color, <span class="keyword">unsigned</span> <span class="keyword">char</span> alpha)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BYTE *g_pBits;</span><br><span class="line">	HDC g_hMemDC;</span><br><span class="line">	HBITMAP g_hBmp, g_hOldBmp;</span><br><span class="line">	<span class="keyword">if</span>(!rect || !hdc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xMin = rect-&gt;left;</span><br><span class="line">	<span class="keyword">int</span> yMin = rect-&gt;top;</span><br><span class="line">	<span class="keyword">int</span> xMax = rect-&gt;right;</span><br><span class="line">	<span class="keyword">int</span> yMax = rect-&gt;bottom;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	byte r = <span class="built_in">GetRValue</span>(color);</span><br><span class="line">	byte g = <span class="built_in">GetGValue</span>(color);</span><br><span class="line">	byte b = <span class="built_in">GetBValue</span>(color);</span><br><span class="line">	COLORREF clSrc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> rSrc;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> gSrc;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> bSrc;</span><br><span class="line"></span><br><span class="line">	g_hMemDC = ::<span class="built_in">CreateCompatibleDC</span>(hdc);</span><br><span class="line">	<span class="keyword">if</span> (!g_hMemDC)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">DeleteDC</span>(hdc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> iWidth = rect-&gt;right - rect-&gt;left;</span><br><span class="line">	<span class="keyword">int</span> iHeight = rect-&gt;bottom - rect-&gt;top;</span><br><span class="line">	BYTE bmibuf[<span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFO) + <span class="number">256</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD)];</span><br><span class="line">	<span class="built_in">memset</span>(bmibuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(bmibuf));</span><br><span class="line">	BITMAPINFO* pbmi = (BITMAPINFO*)bmibuf;</span><br><span class="line">	<span class="comment">// BITMAPINFO pbmi;­</span></span><br><span class="line">	pbmi-&gt;bmiHeader.biSize = <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER);</span><br><span class="line">	pbmi-&gt;bmiHeader.biWidth = iWidth;</span><br><span class="line">	pbmi-&gt;bmiHeader.biHeight = iHeight;</span><br><span class="line">	pbmi-&gt;bmiHeader.biPlanes = <span class="number">1</span>;</span><br><span class="line">	pbmi-&gt;bmiHeader.biBitCount = <span class="number">24</span>;</span><br><span class="line">	pbmi-&gt;bmiHeader.biCompression = BI_RGB;</span><br><span class="line"></span><br><span class="line">	g_hBmp = ::<span class="built_in">CreateDIBSection</span>(g_hMemDC, pbmi, DIB_RGB_COLORS, (<span class="keyword">void</span> **)&amp;g_pBits, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!g_hBmp)</span><br><span class="line">	&#123;</span><br><span class="line">		::<span class="built_in">DeleteDC</span>(g_hMemDC);</span><br><span class="line">	&#125;</span><br><span class="line">	g_hOldBmp = (HBITMAP)::<span class="built_in">SelectObject</span>(g_hMemDC, g_hBmp);</span><br><span class="line">	<span class="built_in">BitBlt</span>(g_hMemDC,<span class="number">0</span>,<span class="number">0</span> , iWidth, iHeight, hdc, rect-&gt;left, rect-&gt;top, SRCCOPY);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * data = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[iWidth*iWidth * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//这的数据要处理，第一行变成最后一行，第二行变成倒数第二行...</span></span><br><span class="line">	<span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; iHeight; y++)</span><br><span class="line">	&#123;</span><br><span class="line">		i = iHeight - y - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; iWidth; x++)</span><br><span class="line">		&#123;</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span>+ x * <span class="number">4</span>] = g_pBits[y * iWidth * <span class="number">3</span> + x * <span class="number">3</span>];</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span> + x * <span class="number">4</span> + <span class="number">1</span>] = g_pBits[y * iWidth * <span class="number">3</span> + x * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span> + x * <span class="number">4</span> + <span class="number">2</span>] = g_pBits[y * iWidth * <span class="number">3</span> + x * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">			data[i  * iWidth * <span class="number">4</span> + x * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">/*rSrc = g_pBits[y * iWidth * 3 + x * 3 + 2];</span></span><br><span class="line"><span class="comment">			gSrc = g_pBits[y * iWidth * 3 + x * 3 + 1];</span></span><br><span class="line"><span class="comment">			bSrc = g_pBits[y * iWidth * 3 + x * 3];</span></span><br><span class="line"><span class="comment">			qDebug() &lt;&lt; rSrc&lt;&lt;&quot; &quot;&lt;&lt; gSrc&lt;&lt;&quot; &quot; &lt;&lt; bSrc &lt;&lt; &quot; &quot; &lt;&lt; endl;*/</span></span><br><span class="line">			<span class="comment">/*rSrc = (rSrc * alpha + r * (255 - alpha)) &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">			gSrc = (gSrc * alpha + g * (255 - alpha)) &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">			bSrc = (bSrc * alpha + b * (255 - alpha)) &gt;&gt; 8;</span></span><br><span class="line"><span class="comment">			g_pBits[y * iWidth * 3 + x * 3 + 2] = rSrc;</span></span><br><span class="line"><span class="comment">			g_pBits[y * iWidth * 3 + x * 3 + 1] = gSrc;</span></span><br><span class="line"><span class="comment">			g_pBits[y * iWidth * 3 + x * 3] = bSrc;*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	data[iWidth*iWidth * <span class="number">4</span>] = <span class="built_in">string</span>(<span class="string">&quot;/0&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">	QImage desImage = <span class="built_in">QImage</span>(data, iWidth, iHeight, QImage::Format_RGB32); <span class="comment">//RGB24</span></span><br><span class="line">	desImage.<span class="built_in">save</span>(<span class="string">&quot;222.jpg&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">BitBlt</span>(hdc, <span class="number">0</span>, <span class="number">0</span>, iWidth, iHeight, g_hMemDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line">	<span class="built_in">SelectObject</span>(g_hMemDC,g_hOldBmp);</span><br><span class="line">	<span class="built_in">DeleteObject</span>(g_hBmp);</span><br><span class="line">	<span class="built_in">DeleteDC</span>(g_hMemDC);</span><br><span class="line">	<span class="built_in">ReleaseDC</span>(<span class="literal">NULL</span>, hdc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个奇慢无比</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXY 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXX 100</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> R[MAXY][MAXX], G[MAXY][MAXX], B[MAXY][MAXX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrgb</span><span class="params">(LPRECT lpRect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = lpRect-&gt;left; x &lt; lpRect-&gt;right; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = lpRect-&gt;top; y &lt; lpRect-&gt;bottom; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            COLORREF color = <span class="built_in">GetPixel</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), x, y);</span><br><span class="line">            <span class="keyword">int</span> Y = y - lpRect-&gt;top;</span><br><span class="line">            <span class="keyword">int</span> X = x - lpRect-&gt;left;</span><br><span class="line">            R[Y][X] = <span class="built_in">GetRValue</span>(color);</span><br><span class="line">            G[Y][X] = <span class="built_in">GetGValue</span>(color);</span><br><span class="line">            B[Y][X] = <span class="built_in">GetBValue</span>(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="if-中同时出现赋值语句和判断"><a href="#if-中同时出现赋值语句和判断" class="headerlink" title="if 中同时出现赋值语句和判断"></a>if 中同时出现赋值语句和判断</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span> &gt; res;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">if</span> ((iter = map1.<span class="built_in">find</span>(complement) )!= map1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        map1[nums[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制台程序，接收键盘信息"><a href="#控制台程序，接收键盘信息" class="headerlink" title="控制台程序，接收键盘信息"></a>控制台程序，接收键盘信息</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="keyword">if</span> (_kbhit()) <span class="comment">/*检测是否有键盘键被按下。*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">getchar</span>()) <span class="comment">//才处理 游戏都是du用非中断函数</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Program is a!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Program is b!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h1 id="防止头文件被重复包含"><a href="#防止头文件被重复包含" class="headerlink" title="防止头文件被重复包含"></a>防止头文件被重复包含</h1><p>#Program once  和 #ifndef  #define A #endif 的功能是一样的，前者是C++，后者是C</p>
<h1 id="C标准输入输出流"><a href="#C标准输入输出流" class="headerlink" title="C标准输入输出流"></a>C标准输入输出流</h1><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220151665.png" alt="image-20210720220151665"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220215699.png" alt="image-20210720220215699"></p>
<h2 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h2><p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220227511.png" alt="image-20210720220227511"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220235388.png" alt="image-20210720220235388"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220239415.png" alt="image-20210720220239415"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220243923.png" alt="image-20210720220243923"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220248508.png" alt="image-20210720220248508"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220252976.png" alt="image-20210720220252976"></p>
<h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220313769.png" alt="image-20210720220313769"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220319088.png" alt="image-20210720220319088"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220325466.png" alt="image-20210720220325466"></p>
<p><img src="/2021/06/20/%E5%85%B6%E4%BB%96/image-20210720220335240.png" alt="image-20210720220335240"></p>
<h1 id="三角函数与反三角函数"><a href="#三角函数与反三角函数" class="headerlink" title="三角函数与反三角函数"></a>三角函数与反三角函数</h1><p>（是以相对于圆心的）</p>
<p>角度 / 180 * π = 弧度。</p>
<p>弧度* 180 / π = 角度 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtMath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是弧度，结果是比例值</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;cos(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">cos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qCos(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qCos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;sin(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">sin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qSin(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qSin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;tan(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">tan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qTan(45.0*3.1415926/180.0)=&quot;</span>&lt;&lt;<span class="built_in">qTan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是比例值，结果是弧度，需要转成角度</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;acos(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">acos</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAcos(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">qAcos</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;asin(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">asin</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAsin(0.707107)=&quot;</span>&lt;&lt;<span class="built_in">qAsin</span>(<span class="number">0.707107</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;atan(1)=&quot;</span>&lt;&lt;<span class="built_in">atan</span>(<span class="number">1</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qAtan(1)=&quot;</span>&lt;&lt;<span class="built_in">qAtan</span>(<span class="number">1</span>)/<span class="number">3.1415926</span>*<span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">qCos</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">qSin</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">0.707107</span></span><br><span class="line"><span class="built_in">tan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">1</span></span><br><span class="line"><span class="built_in">qTan</span>(<span class="number">45.0</span>*<span class="number">3.1415926</span>/<span class="number">180.0</span>)= <span class="number">1</span></span><br><span class="line"><span class="built_in">acos</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAcos</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAsin</span>(<span class="number">0.707107</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">atan</span>(<span class="number">1</span>)= <span class="number">45</span></span><br><span class="line"><span class="built_in">qAtan</span>(<span class="number">1</span>)= <span class="number">45</span></span><br></pre></td></tr></table></figure>

<h1 id="exe不在工具栏里显示图标"><a href="#exe不在工具栏里显示图标" class="headerlink" title="exe不在工具栏里显示图标"></a>exe不在工具栏里显示图标</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> QWidget* parent = new QWidget;</span><br><span class="line"> MainWindow *w= new MainWindow(parent);</span><br><span class="line"> QDesktopWidget *desktop = QApplication::desktop();</span><br><span class="line"> //       QRect screen1=desktop-&gt;screenGeometry(0);//主显示器</span><br><span class="line"> //       QRect screen2=desktop-&gt;screenGeometry(1);//扩展显示器</span><br><span class="line"></span><br><span class="line">//获得当前程序所在屏幕的编号</span><br><span class="line">int curWidgetScreenNum=desktop-&gt;screenNumber(0);</span><br><span class="line">//当前程序所在屏幕的编号获取屏幕分辨率</span><br><span class="line">QRect rect = desktop-&gt;availableGeometry(curWidgetScreenNum);</span><br><span class="line">//qDebug()&lt;&lt;&quot;****************&quot;&lt;&lt;rect;</span><br><span class="line">w-&gt;parentWidget()-&gt;move(rect.height()*5/4,rect.height()/2);</span><br><span class="line">w-&gt;parentWidget()-&gt;resize(rect.width()-rect.height()*5/4, rect.height()/2);</span><br></pre></td></tr></table></figure>

<h1 id="linux和windows目录相互映射"><a href="#linux和windows目录相互映射" class="headerlink" title="linux和windows目录相互映射"></a>linux和windows目录相互映射</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39318565/article/details/121753417">https://blog.csdn.net/weixin_39318565/article/details/121753417</a></p>
<p>一、linux文件夹映射到windows**</p>
<p>安装samba<br>yum install -y samba</p>
<p>将root用户添加到samba中<br>smbpasswd -a root</p>
<p>设置selinux:（或者关闭selinux）<br>chcon -t samba_share_t /home/work/ -R</p>
<p>修改配置文件<br>etc/samba/smb.conf<br>增加<br>[work]<br>comment = work<br>path =/home/work/<br>valid users = @root<br>read list = @root<br>write list = root<br>public = no<br>printable = no</p>
<p>重启服务<br>service smb restart</p>
<p>在windows下网络右键选择”映射网络驱动器”</p>
<p><img src="https://img-blog.csdnimg.cn/b15866cb3f9f4eef816c27316ff9598d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluX3BhbmRh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/93c8886e2b3e44bb955e4414176da06f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluX3BhbmRh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>二、windows文件夹映射到linux</p>
<p>在windows下设置共享文件夹 共享work_git</p>
<p><img src="https://img-blog.csdnimg.cn/e41665f7bd9d42698e9f230472c213fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2VpeGluX3BhbmRh,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>在linux下新建work文件夹</p>
<p>mkdir work</p>
<p>在linux下挂载<br>sudo mount -t cifs -o uid=1000,gid=1000,username=1,password=password //192.168.5.10/work_git work</p>
<h1 id="获取浏览器的下载记录"><a href="#获取浏览器的下载记录" class="headerlink" title="获取浏览器的下载记录"></a>获取浏览器的下载记录</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Demonslzh/article/details/125062240">https://blog.csdn.net/Demonslzh/article/details/125062240</a></p>
<p>Edge和Chrome均在用户目录下生成记录数据库，在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default\History</span><br><span class="line">C:\Users\Administrator\AppData\Local\Microsoft\Edge\User Data\Default\History</span><br></pre></td></tr></table></figure>

<p>里面有所有的操作记录，但是在打开状态下不能使用，会被锁住，因此使用的时候先拷贝再读取！</p>
<h1 id="生成GIF"><a href="#生成GIF" class="headerlink" title="生成GIF"></a>生成GIF</h1><p><a target="_blank" rel="noopener" href="https://github.com/charlietangora/gif-h">https://github.com/charlietangora/gif-h</a></p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool">https://www.w3cschool.cn/tools/index?name=decode_encode_tool</a></p>
<h2 id="350-257-267-346-202-250"><a href="#350-257-267-346-202-250" class="headerlink" title="\350\257\267\346\202\250\"></a>\350\257\267\346\202\250\</h2><p>UTF-8编码</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Smt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwlbird.github.io/2021/06/20/%E5%85%B6%E4%BB%96/">https://zwlbird.github.io/2021/06/20/%E5%85%B6%E4%BB%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwlbird.github.io" target="_blank">.oOo.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Qt/">Qt</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/27/muMz2oUV3hWjZbE.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/20/%E8%BD%AC%E6%8D%A2/"><img class="prev-cover" src="https://i.loli.net/2021/06/27/vOGiJokCe6rIA2u.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">转换</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/"><img class="next-cover" src="https://i.loli.net/2021/06/27/W8xTBGA2O7JhRHl.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">字符串相关</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/03/Hexo/" title="Hexo"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">Hexo</div></div></a></div><div><a href="/2021/06/27/C/" title="C++"><img class="cover" src="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-27</div><div class="title">C++</div></div></a></div><div><a href="/2021/06/27/函数积累/" title="函数积累"><img class="cover" src="https://s2.loli.net/2023/12/12/dkLQxaftyKTzXoR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-27</div><div class="title">函数积累</div></div></a></div><div><a href="/2021/06/20/头文件/" title="头文件"><img class="cover" src="https://i.loli.net/2021/06/27/bhoY29lQPvSAr6z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-20</div><div class="title">头文件</div></div></a></div><div><a href="/2021/06/20/字符串相关/" title="字符串相关"><img class="cover" src="https://i.loli.net/2021/06/27/W8xTBGA2O7JhRHl.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-20</div><div class="title">字符串相关</div></div></a></div><div><a href="/2021/08/11/数据结构/" title="数据结构"><img class="cover" src="https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="title">数据结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Smt</div><div class="author-info__description">哇咔咔</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zwlbird/zwlbird.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zwl931025@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">获取程序当前目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt"><span class="toc-number">1.1.</span> <span class="toc-text">Qt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C"><span class="toc-number">1.2.</span> <span class="toc-text">C++</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.</span> <span class="toc-text">通配符模糊查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E7%A3%81%E7%9B%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.</span> <span class="toc-text">某个磁盘的大小</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows"><span class="toc-number">3.1.</span> <span class="toc-text">windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-number">3.2.</span> <span class="toc-text">Linux</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9B%91%E8%A7%86"><span class="toc-number">4.</span> <span class="toc-text">所占内存大小监视</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-1"><span class="toc-number">4.1.</span> <span class="toc-text">windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux"><span class="toc-number">4.2.</span> <span class="toc-text">linux</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E6%AF%AB%E7%A7%92%E6%97%B6%E9%97%B4"><span class="toc-number">5.</span> <span class="toc-text">获得毫秒时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-2"><span class="toc-number">5.1.</span> <span class="toc-text">windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-1"><span class="toc-number">5.2.</span> <span class="toc-text">linux</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E8%8E%B7%E5%BE%97%E8%BF%9B%E7%A8%8BID"><span class="toc-number">6.</span> <span class="toc-text">Linux 获得进程ID</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sleep-%E6%AF%AB%E7%A7%92"><span class="toc-number">7.</span> <span class="toc-text">Sleep 毫秒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-3"><span class="toc-number">7.1.</span> <span class="toc-text">windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-2"><span class="toc-number">7.2.</span> <span class="toc-text">linux</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#windows-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4"><span class="toc-number">8.</span> <span class="toc-text">windows 程序运行多长时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8Bwindows%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">9.</span> <span class="toc-text">看windows系统信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#configure%E3%80%81make%E3%80%81make-install-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">.&#x2F;configure、make、make install 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.</span> <span class="toc-text">一、基本信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-number">10.2.</span> <span class="toc-text">二、详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81configure%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.1.</span> <span class="toc-text">1、configure命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81make"><span class="toc-number">10.2.2.</span> <span class="toc-text">2、make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81make-insatll"><span class="toc-number">10.2.3.</span> <span class="toc-text">3、make insatll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%A9%E5%B1%95%E8%AF%B4%E6%98%8E"><span class="toc-number">10.3.</span> <span class="toc-text">三、扩展说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmake-make"><span class="toc-number">11.</span> <span class="toc-text">cmake  make</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%EF%BC%8CC-%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AFLinux%EF%BC%8Cwindows%E8%BF%98%E6%98%AFUnix"><span class="toc-number">12.</span> <span class="toc-text">C，C++判断操作系统是Linux，windows还是Unix</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8MinGW-MSVC-GCC-Clang"><span class="toc-number">13.</span> <span class="toc-text">编译器MinGW MSVC GCC Clang</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.</span> <span class="toc-text">十进制与二进制的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">14.1.</span> <span class="toc-text">整数转二进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">14.2.</span> <span class="toc-text">小数转二进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">14.3.</span> <span class="toc-text">二进制转换为十进制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">15.</span> <span class="toc-text">符号位扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%9F%E7%A0%81"><span class="toc-number">15.1.</span> <span class="toc-text">1. 原码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E7%A0%81"><span class="toc-number">15.2.</span> <span class="toc-text">2. 反码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A1%A5%E7%A0%81"><span class="toc-number">15.3.</span> <span class="toc-text">3. 补码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81"><span class="toc-number">15.4.</span> <span class="toc-text">4. 为何要使用原码, 反码和补码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF"><span class="toc-number">16.</span> <span class="toc-text">大小端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">16.1.</span> <span class="toc-text">一、大端模式和小端模式的起源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF"><span class="toc-number">16.2.</span> <span class="toc-text">二、什么是大端和小端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84%E5%9C%A8%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%9A"><span class="toc-number">16.3.</span> <span class="toc-text">三、数组在大端小端情况下的存储：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%86%E5%91%A2%EF%BC%9F"><span class="toc-number">16.4.</span> <span class="toc-text">四、为什么会有大小端模式之分呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">16.4.1.</span> <span class="toc-text">网络字节序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9C%BA%E5%99%A8%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">16.5.</span> <span class="toc-text">五、如何判断机器的字节序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">16.6.</span> <span class="toc-text">六、常见的字节序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-%E5%B8%B8%E8%A7%81CPU%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">16.6.0.0.0.1.</span> <span class="toc-text">4.1 常见CPU的字节序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">16.6.0.0.0.2.</span> <span class="toc-text">4.2 常见文件的字节序</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">16.7.</span> <span class="toc-text">七、如何进行转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BB%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.8.</span> <span class="toc-text">八、从软件的角度理解端模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BB%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.9.</span> <span class="toc-text">九、从系统的角度理解端模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%AE%9E%E9%99%85%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">16.10.</span> <span class="toc-text">十、实际中的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E9%99%84float%E5%92%8Clong%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">16.11.</span> <span class="toc-text">十一、附float和long类型的大小端转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">17.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A7%E6%95%B0%E5%92%8C%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%88%B7%E6%96%B0%E7%8E%87"><span class="toc-number">18.</span> <span class="toc-text">帧数和显示屏刷新率</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E6%95%B0%E5%92%8C%E5%88%B7%E6%96%B0%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">18.1.</span> <span class="toc-text">帧数和刷新率的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%BB%8D"><span class="toc-number">18.2.</span> <span class="toc-text">垂直同步介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">图片格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81TGA%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.1.</span> <span class="toc-text">1、TGA格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81WMF%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.2.</span> <span class="toc-text">2、WMF格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81BMP%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.3.</span> <span class="toc-text">3、BMP格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TIF%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.4.</span> <span class="toc-text">4、TIF格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81GIF%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.5.</span> <span class="toc-text">5、GIF格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81JPEG%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.6.</span> <span class="toc-text">6、JPEG格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81PSD%E6%A0%BC%E5%BC%8F"><span class="toc-number">19.7.</span> <span class="toc-text">7、PSD格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81PNG%E5%B0%8F%E9%80%8F%E6%98%8E"><span class="toc-number">19.8.</span> <span class="toc-text">8、PNG小透明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E7%BA%AC%E5%BA%A6"><span class="toc-number">20.</span> <span class="toc-text">经纬度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM%E4%B8%8EX86-CPU%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">ARM与X86 CPU架构区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%80%A7%E8%83%BD%EF%BC%9A"><span class="toc-number">21.1.</span> <span class="toc-text">一、性能：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B"><span class="toc-number">21.2.</span> <span class="toc-text">二、扩展能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">21.3.</span> <span class="toc-text">三、操作系统的兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%96%B9%E4%BE%BF%E6%80%A7%E5%8F%8A%E5%8F%AF%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">21.4.</span> <span class="toc-text">四、软件开发的方便性及可使用工具的多样性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8A%9F%E8%80%97"><span class="toc-number">21.5.</span> <span class="toc-text">五、功耗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F"><span class="toc-number">22.</span> <span class="toc-text">内核模式和用户模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">22.1.</span> <span class="toc-text">内核模式和用户模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8C%BA%E5%88%86%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">22.2.</span> <span class="toc-text">为什么要区分两种模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%A6%81%E5%85%B1%E7%94%A8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">22.3.</span> <span class="toc-text">为什么内核和用户程序要共用地址空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bat"><span class="toc-number">23.</span> <span class="toc-text">bat</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA"><span class="toc-number">24.</span> <span class="toc-text">指定进制输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA"><span class="toc-number">24.1.</span> <span class="toc-text">1.C中指定进制输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C-%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA"><span class="toc-number">24.2.</span> <span class="toc-text">2.C++中指定进制输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-number">25.</span> <span class="toc-text">指定格式输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%B1%8F%E5%B9%95%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%89%80%E6%9C%89RGB%E5%80%BC%EF%BC%8C%E4%BF%9D%E5%AD%98%E6%88%90JPG%E5%9B%BE%E7%89%87"><span class="toc-number">26.</span> <span class="toc-text">获得屏幕区域的所有RGB值，保存成JPG图片</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if-%E4%B8%AD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%88%A4%E6%96%AD"><span class="toc-number">27.</span> <span class="toc-text">if 中同时出现赋值语句和判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%8E%A5%E6%94%B6%E9%94%AE%E7%9B%98%E4%BF%A1%E6%81%AF"><span class="toc-number">28.</span> <span class="toc-text">控制台程序，接收键盘信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB"><span class="toc-number">29.</span> <span class="toc-text">防止头文件被重复包含</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">30.</span> <span class="toc-text">C标准输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">30.1.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">30.2.</span> <span class="toc-text">标准输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">30.3.</span> <span class="toc-text">标准输出流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0"><span class="toc-number">31.</span> <span class="toc-text">三角函数与反三角函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#exe%E4%B8%8D%E5%9C%A8%E5%B7%A5%E5%85%B7%E6%A0%8F%E9%87%8C%E6%98%BE%E7%A4%BA%E5%9B%BE%E6%A0%87"><span class="toc-number">32.</span> <span class="toc-text">exe不在工具栏里显示图标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%92%8Cwindows%E7%9B%AE%E5%BD%95%E7%9B%B8%E4%BA%92%E6%98%A0%E5%B0%84"><span class="toc-number">33.</span> <span class="toc-text">linux和windows目录相互映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%8B%E8%BD%BD%E8%AE%B0%E5%BD%95"><span class="toc-number">34.</span> <span class="toc-text">获取浏览器的下载记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90GIF"><span class="toc-number">35.</span> <span class="toc-text">生成GIF</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">36.</span> <span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#350-257-267-346-202-250"><span class="toc-number">36.1.</span> <span class="toc-text">\350\257\267\346\202\250\</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/03/Hexo/" title="Hexo"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo"/></a><div class="content"><a class="title" href="/2022/04/03/Hexo/" title="Hexo">Hexo</a><time datetime="2022-04-02T16:33:52.000Z" title="发表于 2022-04-03 00:33:52">2022-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/Android/" title="Android"><img src="https://s2.loli.net/2023/12/12/gfXKlqmwMWzPxH7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android"/></a><div class="content"><a class="title" href="/2021/10/31/Android/" title="Android">Android</a><time datetime="2021-10-31T14:03:21.000Z" title="发表于 2021-10-31 22:03:21">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel"><img src="https://s2.loli.net/2023/12/12/zb5QarqSYDHWZs6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-highlevel"/></a><div class="content"><a class="title" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel">OpenGL-highlevel</a><time datetime="2021-10-19T13:35:33.000Z" title="发表于 2021-10-19 21:35:33">2021-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/OpenGL-light/" title="OpenGL-light"><img src="https://s2.loli.net/2023/12/12/Dlf5uYb78R1Firw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-light"/></a><div class="content"><a class="title" href="/2021/10/17/OpenGL-light/" title="OpenGL-light">OpenGL-light</a><time datetime="2021-10-17T14:09:58.000Z" title="发表于 2021-10-17 22:09:58">2021-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D"><img src="https://s2.loli.net/2023/12/12/EZS5QGm23HLgvW4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL_3D"/></a><div class="content"><a class="title" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D">OpenGL_3D</a><time datetime="2021-09-21T07:31:53.000Z" title="发表于 2021-09-21 15:31:53">2021-09-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/06/27/muMz2oUV3hWjZbE.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Smt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RrMFpOdr0spfIDfRdBukvyf7-gzGzoHsz',
      appKey: 'nipjeGzTyw5yvNk2SgU5KmUQ',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://myhkw.cn/api/player/162393526192" id="myhk" key="162393526192" m="1"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>