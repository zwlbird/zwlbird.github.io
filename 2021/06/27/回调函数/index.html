<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>回调函数 | .oOo.</title><meta name="keywords" content="C++"><meta name="author" content="Smt"><meta name="copyright" content="Smt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="回调函数，static，const">
<meta property="og:type" content="article">
<meta property="og:title" content="回调函数">
<meta property="og:url" content="https://zwlbird.github.io/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content=".oOo.">
<meta property="og:description" content="回调函数，static，const">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg">
<meta property="article:published_time" content="2021-06-27T13:06:24.000Z">
<meta property="article:modified_time" content="2023-12-12T09:32:05.467Z">
<meta property="article:author" content="Smt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwlbird.github.io/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '回调函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-12 17:32:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">.oOo.</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">回调函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-27T13:06:24.000Z" title="发表于 2021-06-27 21:06:24">2021-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-12T09:32:05.467Z" title="更新于 2023-12-12 17:32:05">2023-12-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="回调函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 </p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin">https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin</a> </p>
<p>回调函数机制： </p>
<p>1、定义一个函数（普通函数即可）； </p>
<p>2、将此函数的地址注册给调用者； </p>
<p>3、特定的事件或条件发生时，调用者使用函数指针调用回调函数。 </p>
<p>注：为什么要特定事件或条件发生？不应该随时都可以调用回调函数吗？ </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,callback p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">add</span>(<span class="number">4</span>,<span class="number">2</span>,add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(callBack)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="keyword">size_t</span> size,<span class="keyword">char</span> *p_out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callFunc</span><span class="params">(callBack *consume_bytes, <span class="keyword">char</span> *p_out)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callFunc\n&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">consume_bytes</span>(buffer,<span class="number">0</span>,p_out); <span class="comment">//传入值可以随便填</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">callBackFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">char</span> *p_out)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callBackFunc\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p_out,<span class="number">0x00</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p_out,<span class="string">&quot;encoderCallback:this is string.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> p_out[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">callFunc</span>(callBackFunc,p_out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p_out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> student_id;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> student_age;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Student</span>&#123;</span></span><br><span class="line">    student_id id;</span><br><span class="line">    student_age age;</span><br><span class="line">&#125;Student;</span><br><span class="line"><span class="comment">//类型重定义：函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*pFun)</span><span class="params">(Student, Student)</span></span>;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//冒泡排序法：能够按AGE或ID排序，用同一个函数实现</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Student stu[],<span class="keyword">const</span> <span class="keyword">int</span> num,pFun fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">　　&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num - i <span class="number">-1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((*fun)(stu[j],stu[j+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = stu[j];</span><br><span class="line">                stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line">                stu[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//回调函数：比较年龄</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CompareAge</span><span class="params">(Student stu1,Student stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//更改从大到小还是从小到大的顺序，只需反一下。</span></span><br><span class="line">    <span class="keyword">if</span>(stu1.age &lt; stu2.age)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//回调函数：比较id</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CompareId</span><span class="params">(Student stu1,Student stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//更改从大到小还是从小到大的顺序，只需反一下。</span></span><br><span class="line">    <span class="keyword">if</span>(stu1.id &lt; stu2.id)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stu[] = &#123;</span><br><span class="line">    &#123;<span class="number">1103</span>,<span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1102</span>,<span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1104</span>,<span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1107</span>,<span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1105</span>,<span class="number">21</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    pFun fun = CompareAge;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(stu)/<span class="built_in"><span class="keyword">sizeof</span></span>(Student);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(stu,size,fun);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,stu[i].id,stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是回？"><a href="#什么是回？" class="headerlink" title="什么是回？"></a>什么是回？</h2><p>根据上面的代码，我们知道，库开发方提供了一个方法，然后形参又带有一个函数指针，等着用户去写然后拿来调用，并在其实现中调用了这个函数。<em>站在库开发方的立场</em>，我们可以总结为一句话：库开发方调用了用户的函数（回调函数）。</p>
<p>现在，我们把视角移到<em>回调函数的立场</em>上来看，它被调用了。但同时它也有参数，且传进来的参数是库开发方提供的数据，这里我们又可以总结一句话：回调函数调用了库开发方的数据。</p>
<p>这就是<em>“回”</em>的意思，你调我我也调用你，双方互相调用。</p>
<p><img src="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/0.6947029617222265.png" alt="img"></p>
<h2 id="回调函数的重点是什么"><a href="#回调函数的重点是什么" class="headerlink" title="回调函数的重点是什么?"></a>回调函数的重点是什么?</h2><p>根据上文分析，发现回调函数其实也不是难于理解，我觉得重点在于一定要划分清楚谁是库开发方（也可称为提供方，调用者），谁是用户，把<em>职能</em>划分清楚是最关键的。</p>
<p>库函数中的sort排序是怎么弄的。algorithm它提供了某些排序算法的实现（如冒泡排序、快速排序、shell排序、shake排序等等），为了能让库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，能让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">5</span>,<span class="number">43</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">74</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(a,a+<span class="number">10</span>,cmp);<span class="comment">//callback</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++可以使用全局函数和静态函数作为回调函数。考虑到全局函数会破坏封装性，所以一般都用静态成员函数。故除了理解函数指针，还要理解静态成员函数，具体一点是在静态成员函数中访问非静态成员函数的方法，因为我们很可能需要获取静态成员函数中的数据。</p>
<p>　　<strong>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</strong>下面通过例子来说明这一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> …</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">M</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        A=a;</span><br><span class="line">        B+=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(M m)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">M::f1</span><span class="params">(M m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A=&quot;</span>&lt;&lt;m.a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> M::B=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">M <span class="title">P</span><span class="params">(<span class="number">5</span>)</span>,<span class="title">Q</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    M::<span class="built_in">f1</span>(P); <span class="comment">//调用时不用对象名</span></span><br><span class="line">    M::<span class="built_in">f1</span>(Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38183777/article/details/83958887">https://blog.csdn.net/sinat_38183777/article/details/83958887</a> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32323543/article/details/79738952">https://blog.csdn.net/qq_32323543/article/details/79738952</a> </p>
<p>流程：</p>
<p>接收和使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1.先申明一个函数指针：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span><span class="params">(*replayFunc)</span><span class="params">(<span class="keyword">void</span> * user_parm)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileMergeThread</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//2.接收这个指针和回调函数的参数（函数指针和回调函数的参数要分开）：</span></span><br><span class="line">    <span class="built_in">FileMergeThread</span>(replayFunc func,<span class="keyword">void</span> * parm,QObject *parent =<span class="literal">NULL</span>);</span><br><span class="line">    ~<span class="built_in">FileMergeThread</span>();</span><br><span class="line">    <span class="comment">//3.声明保存回调函数指针的变量</span></span><br><span class="line">    replayFunc m_callback;</span><br><span class="line">    <span class="comment">//4.声明保存回调函数参数变量的变量</span></span><br><span class="line">    <span class="keyword">void</span> *m_parm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FileMergeThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt_io.h&gt;</span></span></span><br><span class="line">FileMergeThread::<span class="built_in">FileMergeThread</span>(replayFunc func, <span class="keyword">void</span> * parm, QObject *parent)</span><br><span class="line">    : <span class="built_in">QThread</span>(parent),</span><br><span class="line">    <span class="comment">//5.赋值回调函数</span></span><br><span class="line">    <span class="built_in">m_callback</span>(func),</span><br><span class="line">    <span class="comment">//6.赋值回调函数参数</span></span><br><span class="line">    <span class="built_in">m_parm</span>(parm)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">FileMergeThread::~<span class="built_in">FileMergeThread</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileMergeThread::createConfigText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//7.在任意地方调用回调函数</span></span><br><span class="line">    <span class="built_in">m_callback</span>(m_parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向目标类注册回调函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.回调函数体(需要是全局函数或者静态函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">void</span> * user_parm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FilePlay *parm = (FilePlay *)user_parm;</span><br><span class="line">    parm-&gt;<span class="built_in">readFileConfigText</span>();</span><br><span class="line">    parm-&gt;<span class="built_in">SetSilderRange</span>();</span><br><span class="line">    parm-&gt;<span class="built_in">sliderValueChanged</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传递回调函数，船给子类</span></span><br><span class="line"><span class="built_in">m_pMergeThread</span>(<span class="keyword">new</span> <span class="built_in">FileMergeThread</span>(start,<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>



<h2 id="Const-define-enum"><a href="#Const-define-enum" class="headerlink" title="Const #define enum"></a>Const #define enum</h2><p>1.区别</p>
<p>这三种都可以定义常量。</p>
<p>define是宏定义，编译器不对其进行错误检查，在预编译阶段处理，没有作用域限制属于全局常量，在程序中编译器会对定义的常量名以数值进行替换，且每次替换都分配内存，此方法对于大量常量的情况下会占用较多内存从而导致程序效率；</p>
<p>const是常量定义，在编译阶段处理，作用域限制，定义常量分配内存后后续再使用常量情况下不会再为其分配内存，只分配一份内存地址（static 局部只初始化一次，和实例无关，与类有关；而const与实例有关，有几个实例就有几个const），故常用于此方法定义常量；</p>
<p>enum是枚举常量定义，在编译阶段处理，有作用域限制，枚举类型中可以定义多个常量（往往是同一归属的常量，比如定义星期可以有7种，enum weekday｛one=1，two=2，three=3｝；（weekday是定义的枚举类型名）），需注意的是在C++中enum枚举类型中只能赋值int型值（即使可以赋值字符，但输出仍是整型）。</p>
<p>define、cosnt和enum的区别：</p>
<p>（1）define 宏定义常量，在开始预处理时就要被替换，所以定义的记号名不会进入记号表，当编译调试时，因为到时直接是一个数值，可能让人产生迷惑。 可以用const 和 enum 来代替宏。常量肯定会进入记号表，可以更容易跟踪，使用常量可能比使用#define导致较小量的码，因为编译器会盲目的将宏定义进行替换，而常量一般在内存中只有一份实体</p>
<p>（2）我们无法利用#define创建一个class专属常量，因为#define并不重视作用域。</p>
<p>（3）取一个const地址是合法的，但取一个enum的地址是不合法的，取一个#define的地址也不合法</p>
<p>2.用途</p>
<p>（1）define：一般用于全局型常量的定义，通常较少使用，在具有较少全局型常量（程序各处都可能用到该常量）时使用；</p>
<p>（2）const：一般用于类常量，常配合static来使用，定义类中静态常量，类的任何对象都能够共享此常量static const常量在定义时初始化。程序中往往多使用const来替代define。</p>
<p>（3）enum：一般用于某种类型具有多个常量的时候定义，比如某种功能实现有三种方法，可定义enum method｛method0=0，method1=1，method2=2｝来选择使用哪种方法实现其功能。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h3><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40311211/article/details/82851300">https://blog.csdn.net/weixin_40311211/article/details/82851300</a></strong> </p>
<h4 id="1-静态局部变量："><a href="#1-静态局部变量：" class="headerlink" title="1.静态局部变量："></a>1.静态局部变量：</h4><p><strong>用于函数体内部修饰变量，这种变量的生存期长于该函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int foo()&#123;</span><br><span class="line">static int i = 1; // note:1</span><br><span class="line">//int i = 1; // note:2</span><br><span class="line">i += 1;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要明白这个用法，我们首先要了解c/c++的内存分布，以及static所在的区间。</p>
<p>对于一个完整的程序，在内存中的分布情况如下图：　<br>1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用域退出而释放空间。<br>3.堆区：程序员分配并释放的区域，像malloc(c),new(c++)<br>3.全局数据区(静态区)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。<br>4.代码区</p>
<p>所以上面note:1的static是在全局数据区分配的,那么它存在的意思是什么？又是什么时候初始化的呢？</p>
<p>首先回答第一个问题：它存在的意义就是随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁(如果把以上的note:1换成note:2,那么就是在栈区分配了，会随着foo的调用结束而释放)。<br>那么第二个问题也就浮出水面了，<mark class="hl-label blue，且只初始化一次">它是在第一次调用进入note:1的时候初始化</mark>  ，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。</p>
<p>那么它跟定义一个全局变量有什么区别呢，同样是初始化一次，连续调用foo()的结果是一样的，但是，使用全局变量的话，变量就不属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<p>那么我们总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：<br>（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);<br>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);<br>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);<br>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);</p>
<h4 id="2-静态全局变量："><a href="#2-静态全局变量：" class="headerlink" title="2.静态全局变量："></a><strong>2.静态全局变量：</strong></h4><p>定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//note:3</span></span><br><span class="line"><span class="comment">//int i = 1; //note:4</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>note:3和note:4有什么差异呢？你调用foo(),无论调用几次，他们的结果都是一样的。也就是说在本文件内调用他们是完全相同的(指的是使用note:3和note:4产生的结果是一样的，并不是单独使用note:3的时候调用几次结果都相同)。那么他们的区别是什么呢？<br><strong>文件隔离！</strong></p>
<p>假设我有一个文件a.c,我们再新建一个b.c,内容如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file a.c</span></span><br><span class="line"><span class="comment">//static int n = 15; //note:5</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">15</span>; <span class="comment">//note:6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file b.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;after: %d\n&quot;</span>,n);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;before: %d\n&quot;</span>,n);</span><br><span class="line"><span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先使用note:6,也就是非静态全局变量，发现输出为:<br>before: 15<br>after: 16<br>也就是我们的b.c通过extern使用了a.c定义的全局变量。<br>那么我们改成使用note:5,也就是使用静态全局变量呢？</p>
<p><em>gcc a.c b.c -o output.out</em></p>
<p>会出现类似undeference to “n”的报错，它是找不到n的，因为static进行了文件隔离，你是没办法访问a.c定义的静态全局变量的，当然你用 #include “a.c”,那就不一样了。</p>
<p>以上我们就可以得出静态全局变量的特点：</p>
<p>静态全局变量不能被其它文件所用(全局变量可以);<br>其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);</p>
<h4 id="3-静态函数："><a href="#3-静态函数：" class="headerlink" title="3.静态函数："></a><strong>3.静态函数：</strong></h4><p>准确的说，静态函数跟静态全局变量的作用类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is non-static func in a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file b.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>; <span class="comment">//我们用extern声明其他文件的fn(),供本文件使用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以正常输出：this is non-static func in a。<br>当给void fn()加上static的关键字之后呢？ undefined reference to “fn”.</p>
<p>所以，静态函数的好处跟静态全局变量的好处就类似了：</p>
<mark class="hl-label 2.其它文件中可以定义相同名字的函数，不会发生冲突;">1.静态函数不能被其它文件所用;</mark>  



<p>上面一共说了三种用法，为什么说准确来说是两种呢？<br>1.一种是修饰变量(静态局部和静态全局)，一种是修饰函数，所以说是两种（这种解释不多）。<br>2.静态全局变量和修饰静态函数的作用是一样的，一般合并为一种。（这是比较多的分法）。</p>
<h4 id="3-静态数据成员："><a href="#3-静态数据成员：" class="headerlink" title="3.静态数据成员："></a><strong>3.静态数据成员</strong>：</h4><p>用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象<mark class="hl-label instance）">（实体</mark>  。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_w,m_h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_sum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_w = w;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_h = h;</span><br><span class="line">        s_sum += (<span class="keyword">this</span>-&gt;m_w * <span class="keyword">this</span>-&gt;m_h);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;s_sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rectangle::s_sum = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(Rectangle)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(Rectangle)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    Rectangle *rect1 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    rect1-&gt;<span class="built_in">GetSum</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect1)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(*rect1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Rectangle <span class="title">rect2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    rect2.<span class="built_in">GetSum</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect2)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(rect2)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/0.5083759780270944.png" alt="img"></p>
<p>由图可知：sizeof(Rectangle)=8bytes=sizeof(m_w)+sizeof(m_h)。也就是说 static 并不占用Rectangle的内存空间。<br>那么static在哪里分配内存的呢？是的，全局数据区(静态区)。<br>再看看GetSum()，第一次12=0+3×4，第二次18=1×2+2×3。由此可得，static只会被初始化一次，于实例无关。</p>
<p>结论：</p>
<p>对于非静态数据成员，每个类对象(实例)都有自己的拷贝（<strong>即每次实例化之后都会重新初始化，变量值可以不同</strong>）。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存(和局部静态变量一样)。<br>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</p>
<p>也就是说，你每new一个Rectangle，并不会为static int s_sum的构建一份内存拷贝，它是不管你new了多少Rectangle的实例，因为它只与类Rectangle挂钩，而跟你每一个Rectangle的对象没关系。</p>
<h4 id="4-静态成员函数："><a href="#4-静态成员函数：" class="headerlink" title="4.静态成员函数："></a>4.静态成员函数：</h4><p>用于修饰 class 的成员函数。<br>我们对上面的例子稍加改动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_w,m_h;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_sum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Rectangle</span>(<span class="keyword">int</span> w,<span class="keyword">int</span> h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_w = w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_h = h;</span><br><span class="line">            s_sum += (<span class="keyword">this</span>-&gt;m_w * <span class="keyword">this</span>-&gt;m_h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span> <span class="comment">//这里加上static</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;s_sum&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">int</span> Rectangle::s_sum = <span class="number">0</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(Rectangle)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(Rectangle)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    Rectangle *rect1 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    rect1-&gt;<span class="built_in">GetSum</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect1)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(*rect1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Rectangle <span class="title">rect2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    rect2.<span class="built_in">GetSum</span>(); <span class="comment">//可以用对象名.函数名访问</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(rect2)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(rect2)&lt;&lt;endl;</span><br><span class="line">    Rectangle::<span class="built_in">GetSum</span>(); <span class="comment">//也可以可以用类名::函数名访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/f95c01fe-c842-4922-b5d1-e2c8b0145288.png" alt="img"></p>
<p>上面注释可见:对GetSum()加上static，使它变成一个静态成员函数，可以用类名::函数名进行访问。</p>
<p>那么静态成员函数有特点呢？<br>1.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;<br>2.非静态成员函数可以任意地访问静态成员函数和静态数据成员;<br>3.静态成员函数不能访问非静态成员函数和非静态数据成员;<br>4.调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)</p>
<p>前三点其实是一点：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态，有点晕吗？没关系，我给你个解释，<br>因为静态是属于类的，它是不知道你创建了10个还是100个对象，所以它对你对象的函数或者数据是一无所知的，所以它没办法调用，而反过来，你创建的对象是对类一清二楚的(不然你怎么从它那里实例化呢)，所以你是可以调用类函数和类成员的，就像不管GetSum是不是static，都可以调用static的s_sum一样。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><strong>const</strong></h3><p> 常变量： <strong>const 类型说明符 变量名</strong></p>
<p> 常引用： <strong>const 类型说明符 &amp;引用名</strong></p>
<p> 常对象： <strong>类名 const 对象名</strong></p>
<p> 常成员函数： <strong>类名::fun(形参) const</strong></p>
<p> 常数组： <strong>类型说明符 const 数组名[大小]   如 int const  p[]</strong></p>
<p> 常指针： <strong>const 类型说明符* 指针名 ，类型说明符*   如 const 指针名  const int *  p; int *const p</strong></p>
<p>**<br>**</p>
<p>首先提示的是：在<strong>常变量</strong>（<strong>const 类型说明符 变量名）、****常引用</strong>（<strong>const 类型说明符 &amp;引用名</strong>）、<strong>常对象</strong>（<strong>类名 const 对象名）、</strong> <strong>常数组</strong>（<strong>类型说明符 const 数组名[大小]）中，</strong> <strong>const”</strong> <strong>与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符）</strong> 的位置可以互换。如：</p>
<p>   const int a=5; 与 int const a=5; 等同</p>
<p>   类名 const 对象名 与 const 类名 对象名 等同</p>
<h4 id="用法1：常量"><a href="#用法1：常量" class="headerlink" title="用法1：常量"></a><strong>用法1：常量</strong></h4><p>  取代了C中的宏定义，声明时必须进行初始化(!c++类中则不然）。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。―《C++ Program Language》<br>  用const声明的变量虽然增加了分配空间，但是可以保证类型安全。<br>  C标准中，const定义的常量是全局的，C++中视声明位置而定。</p>
<h4 id="用法2：指针和常量"><a href="#用法2：指针和常量" class="headerlink" title="用法2：指针和常量"></a><strong>用法2：指针和常量</strong></h4><p>  使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。<br>  所以出现在 * 之前的const是作为基础类型的一部分：<br>char *const cp; //到char的const指针<br>char const *pc1; //到const char的指针<br>const char <em>pc2; //到const char的指针（后两个声明是等同的）<br>  从右向左读的记忆方式：<br>cp is a <strong>const pointer</strong> to char. 故pc不能指向别的字符串，但可以修改其指向的字符串的内容<br>pc2 is a pointer to <strong>const char.</strong> 故</em>pc2的内容不可以改变，但pc2可以指向别的字符串</p>
<p>且注意：允许把非 const 对象的地址赋给指向 const 对象的指针,不允许把一个 const 对象的地址赋给一个普通的、非 const 对象的指针。</p>
<h4 id="用法3：const修饰函数传入参数"><a href="#用法3：const修饰函数传入参数" class="headerlink" title="用法3：const修饰函数传入参数"></a><strong>用法3：const修饰函数传入参数</strong></h4><p>  将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。<br>  通常修饰指针参数和引用参数：<br>void Fun( const A *in); //修饰指针型传入参数<br>void Fun(const A &amp;in); //修饰引用型传入参数</p>
<h4 id="用法4：修饰函数返回值"><a href="#用法4：修饰函数返回值" class="headerlink" title="用法4：修饰函数返回值"></a><strong>用法4：修饰函数返回值</strong></h4><p>  可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。</p>
<h4 id="用法5：const修饰成员函数-c-特性"><a href="#用法5：const修饰成员函数-c-特性" class="headerlink" title="用法5：const修饰成员函数(c++特性)"></a><strong>用法5：const修饰成员函数</strong>(c++特性)</h4><p>const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；<br>const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；<br>const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。</p>
<h4 id="一-：常量与指针"><a href="#一-：常量与指针" class="headerlink" title="(一)：常量与指针"></a><strong>(一)：常量与指针</strong></h4><p> 常量与指针放在一起很容易让人迷糊。对于常量指针和指针常量也不是所有的学习C/C++的人都能说清除。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *m1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的两个表达式中，最容易让人迷惑的是const到底是修饰指针还是指针指向的内存区域？其实，只要知道：<mark class="hl-label red">const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用</mark>  。根据这个规则来判断，m1应该是<strong>常量指针</strong>（即，不能通过m1来修改它所指向的内容。）；而m2应该是<strong>指针常量</strong>（即，不能让m2指向其他的内存模块）。由此可见：</p>
<p>  \1. 对于常量指针，不能通过该指针来改变所指的内容。即，下面的操作是错误的：</p>
<p>   int i = 10;</p>
<p>   const int *pi = &i;</p>
<p>   *pi = 100;</p>
<p>   因为你在试图通过pi改变它所指向的内容。但是，并不是说该内存块中的内容不能被修改。我们仍然可以通过其他方式去修改其中的值。例如：</p>
<p>   // 1: 通过i直接修改。</p>
<p>   i = 100;</p>
<p>   // 2:　使用另外一个指针来修改。</p>
<p>   int <em>p = (int</em>)pi;</p>
<p>   *p = 100;</p>
<p>   实际上，在将程序载入内存的时候，会有专门的一块内存区域来存放常量。但是，上面的i本身不是常量，是存放在栈或者堆中的。我们仍然可以修改它的值。而pi不能修改指向的值应该说是编译器的一个限制。</p>
<p>  \2. 根据上面const的规则，const int *m1 = new int(10);我们也可写作：</p>
<p>   int const　*m1 = new int(10);</p>
<p>   这是，理由就不须作过多说明了。</p>
<p>  \3. 在函数参数中指针常量时表示不允许将该指针指向其他内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func_02</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">      <span class="comment">//错误！P是指针常量。不能对它赋值。</span></span><br><span class="line">      p = pi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">      <span class="built_in">func_02</span>(p);</span><br><span class="line">      <span class="keyword">delete</span> p;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>  \4. 在函数参数中使用常量指针时表示在函数中不能改变指针所指向的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *pi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//错误！不能通过pi去改变pi所指向的内容！</span></span><br><span class="line">    *pi = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(p);　</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们可以使用这样的方法来防止函数调用者改变参数的值。但是，这样的限制是有限的，作为参数调用者，我们也不要试图去改变参数中的值。因此，下面的操作是在语法上是正确的，但是可能破还参数的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">void func(const int *pi)</span><br><span class="line">&#123;</span><br><span class="line">    //这里相当于重新构建了一个指针，指向相同的内存区域。当然就可以通过该指针修改内存中的值了。</span><br><span class="line">    int* pp = (int*)pi;</span><br><span class="line">    *pp = 100;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int* p = new int(10);</span><br><span class="line">    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    func(p);</span><br><span class="line">    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    delete p;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二-：常量与引用"><a href="#二-：常量与引用" class="headerlink" title="(二)：常量与引用"></a><strong>(二)：常量与引用</strong></h4><p>  常量与引用的关系稍微简单一点。因为引用就是另一个变量的别名，它本身就是一个常量。也就是说不能再让一个引用成为另外一个变量的别名, 那么他们只剩下代表的内存区域是否可变。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 正确：表示不能通过该引用去修改对应的内存的内容。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ri = i;</span><br><span class="line"><span class="comment">// 错误！不能这样写。</span></span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">const</span> rci = i;</span><br></pre></td></tr></table></figure>

<p>  由此可见，如果我们不希望函数的调用者改变参数的值。最可靠的方法应该是使用引用。下面的操作会存在编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="comment">// 错误！不能通过i去改变它所代表的内存区域。</span></span><br><span class="line">     i = <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里已经明白了常量与指针以及常量与引用的关系。但是，有必要深入的说明以下。在系统加载程序的时候，系统会将内存分为4个区域：堆区 栈区 全局区（静态）和代码区。从这里可以看出，对于常量来说，<strong>系统没有划定专门的区域来保护其中的数据不能被更改</strong>。也就是说，使用常量的方式对数据进行保护是通过编译器作语法限制来实现的。我们仍然可以绕过编译器的限制去修改被定义为“常量”的内存区域。看下面的代码：</p>
<p>  const int i = 10;</p>
<p>  // 这里i已经被定义为常量，但是我们仍然可以通过另外的方式去修改它的值。</p>
<p>  // 这说明把i定义为常量，实际上是防止通过i去修改所代表的内存。</p>
<p>  int <em>pi = (int</em>) &i;</p>
<h4 id="三-：常量函数"><a href="#三-：常量函数" class="headerlink" title="(三)：常量函数"></a><strong>(三)：常量函数</strong></h4><p>  常量函数是C++对常量的一个扩展，它很好的确保了C++中类的封装性。在C++中，为了防止类的数据成员被非法访问，将类的成员函数分成了两类，一类是常量成员函数（也被称为观察者）；另一类是非常量成员函数（也被成为变异者）。在一个函数的签名后面加上关键字const后该函数就成了常量函数。对于常量函数，最关键的不同是编译器不允许其修改类的数据成员。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> class Test</span><br><span class="line"> &#123;</span><br><span class="line">     public:</span><br><span class="line">     void func() const;</span><br><span class="line">     private:</span><br><span class="line">     int intValue;</span><br><span class="line"> &#125;;</span><br><span class="line">void Test::func() const</span><br><span class="line">&#123;</span><br><span class="line">    intValue = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，常量函数func函数内试图去改变数据成员intValue的值，因此将在编译的时候引发异常。</p>
<p> 当然，对于非常量的成员函数，我们可以根据需要读取或修改数据成员的值。但是，这要依赖调用函数的对象是否是常量。通常，如果我们把一个类定义为常量，我们的本意是希望他的状态（数据成员）不会被改变。那么，如果一个常量的对象调用它的非常量函数会产生什么后果呢？看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Fred</span><br><span class="line">&#123;</span><br><span class="line">      public:</span><br><span class="line">      void inspect() const;</span><br><span class="line">      void mutate();</span><br><span class="line">&#125;;</span><br><span class="line">void UserCode(Fred&amp; changeable, const Fred&amp; unChangeable)</span><br><span class="line">&#123;</span><br><span class="line">    changeable.inspect(); // 正确，非常量对象可以调用常量函数。</span><br><span class="line">    changeable.mutate(); // 正确，非常量对象也允许修改调用非常量成员函数修改数据成员。</span><br><span class="line">    unChangeable.inspect(); // 正确，常量对象只能调用常理函数。因为不希望修改对象状态。</span><br><span class="line">    unChangeable.mutate(); // 错误！常量对象的状态不能被修改，而非常量函数存在修改对象状态的可能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  从上面的代码可以看出，由于常量对象的状态不允许被修改，因此，通过常量对象调用非常量函数时将会产生语法错误。实际上，我们知道每个成员函数都有一个隐含的指向对象本身的this指针。而常量函数则包含一个this的常量指针。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void inspect(const Fred* this) const;</span><br><span class="line">void mutate(Fred* this);</span><br></pre></td></tr></table></figure>

<p>   也就是说对于常量函数，我们不能通过this指针去修改对象对应的内存块。但是，在上面我们已经知道，这仅仅是编译器的限制，我们仍然可以绕过编译器的限制，去改变对象的状态。看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Fred</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void inspect() const;</span><br><span class="line">    private:</span><br><span class="line">    int intValue;</span><br><span class="line">&#125;;</span><br><span class="line">void Fred::inspect() const</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;At the beginning. intValue = &quot;&lt;&lt; intValue &lt;&lt; endl;</span><br><span class="line">    // 这里，我们根据this指针重新定义了一个指向同一块内存地址的指针。</span><br><span class="line">    // 通过这个新定义的指针，我们仍然可以修改对象的状态。</span><br><span class="line">    Fred* pFred = (Fred*)this;</span><br><span class="line">    pFred-&gt;intValue = 50;</span><br><span class="line">    cout &lt;&lt; &quot;Fred::inspect() called. intValue = &quot;&lt;&lt; intValue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Fred fred;</span><br><span class="line">    fred.inspect();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的代码说明，只要我们愿意，我们还是可以通过常量函数修改对象的状态。同理，对于常量对象，我们也可以构造另外一个指向同一块内存的指针去修改它的状态。这里就不作过多描述了。</p>
<p>  另外，也有这样的情况，虽然我们可以绕过编译器的错误去修改类的数据成员。但是C++也允许我们在数据成员的定义前面加上mutable，以允许该成员可以在常量函数中被修改。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Fred&#123;</span><br><span class="line">    public:</span><br><span class="line">    void inspect() const;</span><br><span class="line">    private:</span><br><span class="line">    mutable int intValue;</span><br><span class="line">&#125;;</span><br><span class="line">void Fred::inspect() const</span><br><span class="line">&#123;</span><br><span class="line">    intValue = 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  但是，并不是所有的编译器都支持mutable关键字。这个时候我们上面的歪门邪道就有用了。</p>
<p>  关于常量函数，还有一个问题是重载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Fred&#123;</span><br><span class="line">    public:</span><br><span class="line">    void func() const;</span><br><span class="line">    void func();</span><br><span class="line">&#125;;</span><br><span class="line">void Fred::func() const</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;const function is called.&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Fred::func()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;non-const function is called.&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void UserCode(Fred&amp; fred, const Fred&amp; cFred)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;fred is non-const object, and the result of fred.func() is:&quot; &lt;&lt; endl;</span><br><span class="line">    fred.func();</span><br><span class="line">    cout &lt;&lt; &quot;cFred is const object, and the result of cFred.func() is:&quot; &lt;&lt; endl;</span><br><span class="line">    cFred.func();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Fred fred;</span><br><span class="line">    UserCode(fred, fred);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出结果为：</p>
<p>   从上面的输出结果，我们可以看出。当存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。常量对象调用常量成员；非常量对象调用非常量的成员。</p>
<p>  总之，我们需要明白常量函数是为了最大程度的保证对象的安全。通过使用常量函数，我们可以只允许必要的操作去改变对象的状态，从而防止误操作对对象状态的破坏。但是，就像上面看见的一样，这样的保护其实是有限的。关键还是在于我们开发人员要严格的遵守使用规则。另外需要注意的是常量对象不允许调用非常量的函数。这样的规定虽然很武断，但如果我们都根据原则去编写或使用类的话这样的规定也就完全可以理解了。</p>
<h4 id="四-：常量返回值"><a href="#四-：常量返回值" class="headerlink" title="(四)：常量返回值"></a><strong>(四)：常量返回值</strong></h4><p>   很多时候，我们的函数中会返回一个地址或者引用。调用这得到这个返回的地址或者引用后就可以修改所指向或者代表的对象。这个时候如果我们不希望这个函数的调用这修改这个返回的内容，就应该返回一个常量。这应该很好理解，大家可以去试试。</p>
<p>+++++++++++++++++++++++++++++++++++++++</p>
<blockquote>
<p>**c++ 中const<br>**</p>
</blockquote>
<p>+++++++++++++++++++++++++++++++++++++++</p>
<p>\1. const常量，如const int max = 100;<br>优点：const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误（边际效应）<br>\2. const 修饰类的数据成员。如：<br>class A<br>{</p>
<p>  const int size;</p>
<p>  …</p>
<p>}</p>
<p>const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。如</p>
<p>class A</p>
<p>{</p>
<p> const int size = 100;  //错误</p>
<p> int array[size];     //错误，未知的size</p>
<p>}<br>const数据成员的初始化只能在类的构造函数的初始化表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现。如</p>
<p>class A</p>
<p>{…</p>
<p> enum {size1=100, size2 = 200 };</p>
<p>int array1[size1];</p>
<p>int array2[size2];</p>
<p>}</p>
<p>枚举常量不会占用对象的存储空间，他们在编译时被全部求值。但是枚举常量的隐含数据类型是整数，其最大值有限，且不能表示浮点数。</p>
<p>\3. const修饰指针的情况，见下式：</p>
<p>int b = 500;<br>const int* a = &amp;         [1]<br>int const <em>a = &amp;         [2]<br>int</em> const a = &amp;         [3]<br>const int* const a = &amp;      [4]</p>
<p>如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effectivec++》Item21上的做法，如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。</p>
<p>\4. const的初始化</p>
<p>先看一下const变量初始化的情况 </p>
<ol>
<li><p>非指针const常量初始化的情况：A b;<br>const A a = b;</p>
</li>
<li><p>指针const常量初始化的情况：</p>
</li>
</ol>
<p>A* d = new A();<br>const A* c = d;<br>或者：const A* c = new A();<br>3）引用const常量初始化的情况：<br>A f;<br>const A&amp; e = f;   // 这样作e只能访问声明为const的函数，而不能访问一般的成员函数；</p>
<p>  [思考1]： 以下的这种赋值方法正确吗？<br>  const A* c=new A();<br>  A* e = c;<br>  [思考2]： 以下的这种赋值方法正确吗？<br>  A* const c = new A();<br>  A* b = c;</p>
<p>\5. 另外const 的一些强大的功能在于它在函数声明中的应用。在一个函数声明中，const可以修饰函数的返回值，或某个参数；对于成员函数，还可以修饰是整个函数。有如下几种情况，以下会逐渐的说明用法：A&amp;operator=(const A&amp; a);<br>void fun0(const A* a );<br>void fun1( ) const; // fun1( ) 为类成员函数<br>const A fun2( );</p>
<ol>
<li>修饰参数的const，如 void fun0(const A* a ); void fun1(const A&amp; a);<br>调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，如形参为const A*a，则不能对传递进来的指针的内容进行改变，保护了原指针所指向的内容；如形参为const A&amp;a，则不能对传递进来的引用对象进行改变，保护了原对象的属性。<br>[注意]：参数const通常用于参数为指针或引用的情况，且只能修饰输入参数;若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。</li>
</ol>
<p>[总结]对于非内部数据类型的输入参数，因该将“值传递”的方式改为“const引用传递”，目的是为了提高效率。例如，将void Func(A a)改为void Func(const A &amp;a)</p>
<p>   对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x)不应该改为void Func(const int &amp;x)</p>
<ol start="2">
<li>修饰返回值的const，如const A fun2( ); const A* fun3( );<br>这样声明了返回值后，const按照”修饰原则”进行修饰，起到相应的保护作用。</li>
</ol>
<p>const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)<br>{ </p>
<blockquote>
<p>return Rational(lhs.numerator() * rhs.numerator(), </p>
<p>lhs.denominator() * rhs.denominator()); </p>
</blockquote>
<p>}</p>
<p>返回值用const修饰可以防止允许这样的操作发生:</p>
<p>Rational a,b;<br>Radional c;<br>(a*b) = c;</p>
<p>一般用const修饰返回值为对象本身（非引用和指针）的情况多用于二目操作符重载函数并产生新对象的时候。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="[总结]"></a><strong>[总结]</strong></h4><p>\1. 一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A实例）或某个对象的引用为const（const A&amp; test = A实例），则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
<p>\2. 如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。如：</p>
<p>const char * GetString(void);</p>
<p>如下语句将出现编译错误：</p>
<p>char *str=GetString();</p>
<p>正确的用法是：</p>
<p>const char *str=GetString();</p>
<p>\3.   函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赙值函数中，目的是为了实现链式表达。如：</p>
<p>class A</p>
<p>{…</p>
<p> A &amp;operate = (const A &amp;other); //负值函数</p>
<p>}<br>A a,b,c;       //a,b,c为A的对象</p>
<p>…</p>
<p>a=b=c;      //正常</p>
<p>(a=b)=c;     //不正常，但是合法</p>
<p>若负值函数的返回值加const修饰，那么该返回值的内容不允许修改，上例中a=b=c依然正确。(a=b)=c就不正确了。<br>[思考3]： 这样定义赋值操作符重载函数可以吗？<br>const A&amp; operator=(const A&amp; a);</p>
<p>\6.   类成员函数中const的使用<br>一般放在函数体后，形如：void fun() const;<br>任何不会修改数据成员的函数都因该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其他非const成员函数，编译器将报错，这大大提高了程序的健壮性。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;   <span class="comment">//const 成员函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> m_num;</span><br><span class="line">      <span class="keyword">int</span> m_data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ++m_num;              <span class="comment">//编译错误，企图修改数据成员m_num</span></span><br><span class="line">  <span class="built_in">Pop</span>();                <span class="comment">//编译错误，企图调用非const函数</span></span><br><span class="line">  Return m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>\7. 使用const的一些建议</p>
<ol>
<li>要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委； </li>
<li>要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题； </li>
<li>在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上； </li>
<li>const在成员函数中的三种用法（参数、返回值、函数）要很好的使用； </li>
<li>不要轻易的将函数的返回值类型定为const; </li>
<li>除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;</li>
</ol>
<p>[思考题答案] </p>
<p>  [思考1]： 以下的这种赋值方法正确吗？<br>  const A* c=new A();<br>  A* e = c;<br>  [思考2]： 以下的这种赋值方法正确吗？<br>  A* const c = new A();<br>  A* b = c;</p>
<ol>
<li>这种方法不正确，因为声明指针的目的是为了对其指向的内容进行改变，而声明的指针e指向的是一个常量，所以不正确； </li>
<li>这种方法正确，因为声明指针所指向的内容可变； </li>
<li>这种做法不正确；<br>在const A::operator=(const A&amp; a)中，参数列表中的const的用法正确，而当这样连续赋值的时侯，问题就出现了：<br>A a,b,c:<br>(a=b)=c;<br>因为a.operator=(b)的返回值是对a的const引用，不能再将c赋值给const常量。</li>
</ol>
<p>++++++++++++++++++++++++++++++++++++++++</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://tech.e800.com.cn/articles/2009/722/1248229886744_1.html"><strong>const 在c和c++中的区别</strong></a></p>
</blockquote>
<p>++++++++++++++++++++++++++++++++++++++++</p>
<p>\1. C++中的const正常情况下是看成编译期的常量,编译器并不为const分配空间,只是在编译的时候将期值保存在名字表中,并在适当的时候折合在代码中.所以,以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const int a = 1;</span><br><span class="line">const int b = 2;</span><br><span class="line">int array[ a + b ] = &#123;0&#125;;</span><br><span class="line">for (int i = 0; i &lt; sizeof array / sizeof *array; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; array &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在可以通过编译,并且正常运行.但稍加修改后,放在C编译器中,便会出现错误:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">const int a = 1;</span><br><span class="line">const int b = 2;</span><br><span class="line">int array[ a + b ] = &#123;0&#125;;</span><br><span class="line">for (i = 0; i &lt; sizeof array / sizeof *array; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,array);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误消息:<br>c:\test1\te.c(8): error C2057: 应输入常数表达式<br>c:\test1\te.c(8): error C2466: 不能分配常数大小为 0 的数组<br>出现这种情况的原因是:在C中,const是一个不能被改变的普通变量,既然是变量,就要占用存储空间,所以编译器不知道编译时的值.而且,数组定义时的下标必须为常量.<br>\2. 在C语言中: const int size; 这个语句是正确的，因为它被C编译器看作一个声明,指明在别的地方分配存储空间.但在C++中这样写是不正确的.C++中const默认是内部连接,如果想在C++中达到以上的效果,必须要用extern关键字.即<strong>C++中,const默认使用内部连接.而C中使用外部连接.</strong><br><strong>(1) 内连接</strong>:编译器只对正被编译的文件创建存储空间,别的文件可以使用相同的表示符或全局变量.C/C++中内连接使用static关键字指定.<br><strong>(2) 外连接</strong>:所有被编译过的文件创建一片单独存储空间.一旦空间被创建,连接器必须解决对这片存储空间的引用.全局变量和函数使用外部连接.通过extern关键字声明,可以从其他文件访问相应的变量和函数.<br>/* C++代码 header.h <em>/<br>const int test = 1;<br>/</em> C++代码 test1.cpp <em>/<br>#include “header.h”<br>using namespace std;<br>int main() { cout &lt;&lt; “in test1 :” &lt;&lt; test &lt;&lt; endl; }<br>/</em> C++代码 test2.cpp <em>/<br>#include “header.h”<br>using namespace std;<br>void print() { cout &lt;&lt; “in test2:” &lt;&lt; test &lt;&lt; endl;}<br>以上代码编译连接完全不会出问题,但如果把header.h改为:<br>extern const int test = 1;<br>在连接的时候,便会出现以下错误信息:<br>test2 error LNK2005: “int const test” (<a href="mailto:?test@@3HB">?test@@3HB</a>) 已经在 test1.obj 中定义<br>  因为extern关键字告诉C++编译器test会在其他地方引用,所以,C++编译器就会为test创建存储空间,不再是简单的存储在名字表里面.所以,当两个文件同时包含header.h的时候,会发生名字上的冲突.<br>此种情况和C中const含义相似:<br>/</em> C代码 header.h <em>/<br>const int test = 1;<br>/</em> C代码 test1.c <em>/<br>#include “header.h”<br>int main() { printf(“in test1:%d\n”,test); }<br>/</em> C代码 test2.c */<br>#include “header.h”<br>void print() { printf(“in test2:%d\n”,test); }<br>错误消息:<br>test3 fatal error LNK1169: 找到一个或多个多重定义的符号<br>test3 error LNK2005: _test 已经在 test1.obj 中定义</p>
<p>也就是说：在c++ 中const 对象默认为文件的局部变量。与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象：<br>   // file_1.cc<br>   // defines and initializes a const that is accessible to other files<br>   extern const int bufSize = fcn();<br>   // file_2.cc<br>   extern const int bufSize; // uses bufSize from file_1<br>   // uses bufSize defined in file_1<br>   for (int index = 0; index != bufSize; ++index)<br>      // …</p>
<p>\3. C++中,是否为const分配空间要看具体情况.如果加上关键字extern或者取const变量地址,则编译器就要为const分配存储空间.<br>\4. C++中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.</p>
<p>来源： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanjianhappy/p/7298427.html">https://www.cnblogs.com/lanjianhappy/p/7298427.html</a></p>
<p><strong>static  const</strong>  </p>
<p>**const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。<br>**</p>
<p>**对于非静态数据成员，每个类对象(实例)都有自己的拷贝（**即每次实例化之后都会重新初始化，变量值可以不同**）。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存(和局部静态变量一样)。<br>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。<br>**</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tobefxz/article/details/14109697">https://blog.csdn.net/tobefxz/article/details/14109697</a> </p>
<p>const定义的常量在超出其作用域之后其空间会被释放，而<strong>static定义的静态常量在函数执行后不会释放其存储空间</strong>。</p>
<p>static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。<strong>即使没有具体对象，也能调用类的静态成员函数和成员变量</strong>。<strong>一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中</strong>。</p>
<p>在C++中，<strong>static静态成员变量不能在类的内部初始化</strong>。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static</p>
<p>在C++中，<strong>const成员变量也不能在类定义处初始化</strong>，只能通过构造函数初始化列表进行，并且必须有构造函数。</p>
<p>const数据成员 <strong>只在某个对象生存期内是常量，而对于整个类而言却是可变的</strong>。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。</p>
<p>const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cost。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">public:</span><br><span class="line">    Test():a(0)&#123;&#125;</span><br><span class="line">    enum &#123;size1=100,size2=200&#125;;</span><br><span class="line">private:</span><br><span class="line">    const int a;//只能在构造函数初始化列表中初始化</span><br><span class="line">    static int b;//在类的实现文件中定义并初始化</span><br><span class="line">    const static int c;//与 static const int c;相同。</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。</span><br><span class="line">cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。</span><br></pre></td></tr></table></figure>

<p>cosnt成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。</p>
<p>static成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1、不能直接存取类的非静态成员变量，调用非静态成员函数2、不能被声明为virtual</p>
<h3 id="关于static、const、static-cosnt、const-static成员的初始化问题："><a href="#关于static、const、static-cosnt、const-static成员的初始化问题：" class="headerlink" title="关于static、const、static cosnt、const static成员的初始化问题："></a>关于static、const、static cosnt、const static成员的初始化问题：</h3><h4 id="1、类里的const成员初始化："><a href="#1、类里的const成员初始化：" class="headerlink" title="1、类里的const成员初始化："></a>1、类里的const成员初始化：</h4><p>在一个<strong>类里建立一个const时，不能给他初值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">public:</span><br><span class="line">    foo():i(100)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    const int i=100;//error!!!</span><br><span class="line">&#125;;</span><br><span class="line">//或者通过这样的方式来进行初始化</span><br><span class="line">foo::foo():i(100)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、类里的static成员初始化："><a href="#2、类里的static成员初始化：" class="headerlink" title="2、类里的static成员初始化："></a>2、类里的static成员初始化：</h4><p>类中的static变量是属于类的，不属于某个对象，它在整个程序的运行过程中只有一个副本，因此<strong>不能在定义对象时对变量进行初始化，就是不能用构造函数进行初始化</strong>，其正确的初始化方法是：</p>
<p>数据类型 类名::静态数据成员名=值；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class foo&#123;</span><br><span class="line">public:</span><br><span class="line">    foo();</span><br><span class="line">private:</span><br><span class="line">static int i;</span><br><span class="line">&#125;;</span><br><span class="line">int foo::i=20;</span><br></pre></td></tr></table></figure>

<p>这表明：</p>
<p>1、<strong>初始化在类体外进行，而前面不加static</strong>，以免与<strong>一般静态变量</strong>或对象相混淆</p>
<p>2、初始化时不加该成员的访问权限控制符private、public等</p>
<p>3、初始化时使用<strong>作用域运算符来表明它所属的类</strong>，因此，静态数据成员是类的成员而不是对象的成员。</p>
<h4 id="3、类里的static-cosnt-和-const-static成员初始化"><a href="#3、类里的static-cosnt-和-const-static成员初始化" class="headerlink" title="3、类里的static cosnt 和 const static成员初始化"></a>3、类里的static cosnt 和 const static成员初始化</h4><p>**这两种写法的作用一样，为了便于记忆，在此值说明一种通用的初始化方法：<br>*</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">public:</span><br><span class="line">    static const int mask1;</span><br><span class="line">    const static int mask2;</span><br><span class="line">&#125;;</span><br><span class="line">const Test::mask1=0xffff;</span><br><span class="line">const Test::mask2=0xffff;</span><br><span class="line">//它们的初始化没有区别，虽然一个是静态常量一个是常量静态。静态都将存储在全局变量区域，其实最后结果都一样。</span><br><span class="line">//可能在不同编译器内，不同处理，但最后结果都一样。</span><br></pre></td></tr></table></figure>

<h4 id="这是一个完整的例子："><a href="#这是一个完整的例子：" class="headerlink" title="这是一个完整的例子："></a>这是一个完整的例子：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#ifdef A_H_</span><br><span class="line">#define A_H_</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">usingnamespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int a);</span><br><span class="line">    static void print();//静态成员函数</span><br><span class="line">private:</span><br><span class="line">    static int aa;//静态数据成员的声明</span><br><span class="line">    static const int count;//常量静态数据成员（可以在构造函数中初始化）</span><br><span class="line">    const int bb;//常量数据成员</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int A::aa=0;//静态成员的定义+初始化</span><br><span class="line">const int A::count=25;//静态常量成员定义+初始化</span><br><span class="line"> </span><br><span class="line">A::A(int a):bb(a)&#123;//常量成员的初始化</span><br><span class="line">aa+=1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void A::print()&#123;</span><br><span class="line">cout&lt;&lt;&quot;count=&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;aa=&quot;&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">void main()&#123;</span><br><span class="line">    A a(10);</span><br><span class="line">    A::print();//通过类访问静态成员函数</span><br><span class="line">    a.print();//通过对象访问静态成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化位置"><a href="#初始化位置" class="headerlink" title="初始化位置"></a>初始化位置</h3><p>静态成员不能在类的定义里初始化（除int外）。不能在头文件里初始化。<br>比如定义了 myclass.h，一般放到myclass.cpp里初始化它。</p>
<p>1、根据primer第4版的解释，static局部对象必须遵守【确保不迟于在程序执行流程第一次经过该对象的定义语句时进行<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>】的这一个原则。<br>2、同时，我们知道类内部的执行顺序并不是按行次序执行的，而是按对象调用执行的。<br>3、以上两者决定了一个问题：如果在类内定义，那么不建立对象时，<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态数据</a>成员无法<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>，或<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>时间太迟。【可能原因之一】<br>4、再者，<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态成员</a>的生命周期是，一经建立便会存在与整个程序的生命周期内。而<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态数据</a>成员即属于类、也不属于类的原因便在此，在类内定义，会使其完全成为该类中的成员，也就是说，当建立复数个该类对象时，会再次声明并定义这个变量的位置，且<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">名字空间</a>和作用域相同下，导致重名问题。【可能原因之二】<br>5、因此static的成员需要独立于类作定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-----------------Test.h----------------------------</span><br><span class="line">#pragma once</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">private :</span><br><span class="line">    int var1;</span><br><span class="line">    // int var11= 4; 错误的初始化方法</span><br><span class="line">    const int var2 ;</span><br><span class="line">    // const int var22 =22222; 错误的初始化方法</span><br><span class="line">    static int var3;</span><br><span class="line">    // static int var3333=33333; 错误，只有静态常量int成员才能直接赋值来初始化</span><br><span class="line">    static const int var4=4444; //正确，静态常量成员可以直接初始化  </span><br><span class="line">    static const int var44;</span><br><span class="line">public:</span><br><span class="line">    Test(void);</span><br><span class="line">    ~Test(void);</span><br><span class="line">&#125;;</span><br><span class="line">--------------------Test.cpp-----------------------------------</span><br><span class="line">#include &quot;.\test.h&quot;</span><br><span class="line"> </span><br><span class="line">int Test::var3 = 3333333; //静态成员的正确的初始化方法</span><br><span class="line"> </span><br><span class="line">// int Test::var1 = 11111;; 错误静态成员才能初始化</span><br><span class="line">// int Test::var2 = 22222; 错误</span><br><span class="line">// int Test::var44 = 44444; // 错误的方法，提示重定义</span><br><span class="line">Test::Test(void)：var1(11111),var2(22222)正确的初始化方法//var3(33333)不能在这里初始化</span><br><span class="line">&#123;</span><br><span class="line">    var1 =11111; //正确, 普通变量也可以在这里初始化</span><br><span class="line">    //var2 = 222222; 错误，因为常量不能赋值，只能在 “constructor initializer （构造函数的初始化列表）” 那里初始化  </span><br><span class="line">    var3 =44444; //这个赋值是正确的，不过因为所有对象一个静态成员，所以会影响到其他的，这不能叫做初始化了吧</span><br><span class="line">&#125;</span><br><span class="line">Test::~Test(void)&#123;&#125;</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>

<p><strong>有些成员变量的数据类型比较特别，它们的初始化方式也和普通数据类型的成员变量有所不同。这些特殊的类型的成员变量包括：</strong></p>
<p>  a. 常量型成员变量 const int </p>
<p>  b. 引用型成员变量 int &amp;</p>
<p><em><strong>*对于常量型成员变量和引用型成员变量的初始化，必须通过构造函数初始化列表的方式进行。在构造函数体内给常量型成员变量和引用型成员变量赋值的方式是行不通的。*</strong></em></p>
<p>  c. 静态成员变量 static int </p>
<p>  d. 整型静态常量成员变量 static const int </p>
<p>  e. 非整型静态常量成员变量 static const double</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// Initialization of Special Data Member</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;     </span><br><span class="line">class BClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    BClass() : i(1),ci(2), ri(i) // 对于常量型成员变量和引用型成员变量，必须通过  </span><br><span class="line">    &#123;               // 参数化列表的方式进行初始化。在构造函数体内进行赋值的方式，是行不通的。</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    voidprint_values()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; &quot;i =\t&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;ci =\t&quot; &lt;&lt; ci &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;ri =\t&quot; &lt;&lt; ri &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;si =\t&quot; &lt;&lt; si &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;csi =\t&quot; &lt;&lt; csi &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;csi2 =\t&quot; &lt;&lt; csi2 &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; &quot;csd =\t&quot; &lt;&lt; csd &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    int i; // 普通成员变量</span><br><span class="line">    const int ci; // 常量成员变量</span><br><span class="line">    int &amp;ri; // 引用成员变量</span><br><span class="line">    static int si; // 静态成员变量</span><br><span class="line">    //static int si2 = 100; // error: 只有静态常量成员变量，才可以这样初始化</span><br><span class="line">    static const int csi; // 静态常量成员变量</span><br><span class="line">    static const int csi2 = 100; // 静态常量成员变量的初始化(Integral type) (1)</span><br><span class="line">    static const double csd; // 静态常量成员变量(non-Integral type)</span><br><span class="line">    //staticconst double csd2 = 99.9; // error: 只有静态常量整型数据成员才可以在类中初始化</span><br><span class="line">&#125;;</span><br><span class="line">// 静态成员变量的初始化(Integral type)</span><br><span class="line">int BClass::si = 0;</span><br><span class="line">// 静态常量成员变量的初始化(Integral type)</span><br><span class="line">const int BClass::csi = 1;</span><br><span class="line">// 静态常量成员变量的初始化(non-Integral type)</span><br><span class="line">const double BClass::csd = 99.9;</span><br><span class="line"> </span><br><span class="line">// 在初始化(1)中的csi2时，根据Stanley B. Lippman的说法下面这行是必须的。</span><br><span class="line">// 但在VC2003中如果有下面一行将会产生错误，而在VC2005中，下面这行则可有可无，这个和编译器有关。</span><br><span class="line">const int BClass::csi2;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    BClassb_class;</span><br><span class="line">    b_class.print_values(); </span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-静态成员小结-c-static"><a href="#c-静态成员小结-c-static" class="headerlink" title="c++静态成员小结,c++,static"></a><strong>c++静态成员小结,c++,static</strong></h3><p>静态类成员包括静态数据成员和静态函数成员两部分。 </p>
<p><strong>静态数据成员</strong></p>
<p>类体中的数据成员的声明前加上static关键字，该数据成员就成为了该类的静态数据成员。和其他数据成员一样，静态数据成员也遵守public/protected/private访问规则。同时，静态数据成员还具有以下特点： </p>
<p><strong>1.静态数据成员的定义。</strong> </p>
<p>静态数据成员实际上是<strong>类域中的全局变量</strong>。所以，静态数据成员的定义(初始化)不应该被放在头文件中。 （声明vs.定义（初始化））</p>
<p>其定义方式与全局变量相同。举例如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xxx.h文件 </span><br><span class="line">class base&#123; </span><br><span class="line">private: </span><br><span class="line">    static const int _i;//声明，标准c++支持有序类型在类体中初始化,但vc6不支持。 </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">xxx.cpp文件 </span><br><span class="line">const int base::_i=10;//定义(初始化)时不受private和protected访问限制. </span><br></pre></td></tr></table></figure>

<p>注：不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。 </p>
<p><strong>2.静态数据成员被类的所有对象所共享，包括该类派生类的对象。即派生类对象与基类对象共享基类的静态数据成员。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public : </span><br><span class="line">    static int _num;//声明 </span><br><span class="line">&#125;; </span><br><span class="line">int base::_num=0;//静态数据成员的真正定义 </span><br><span class="line">class derived:public base&#123; &#125;; </span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    base a; </span><br><span class="line">    derived b; </span><br><span class="line">    a._num++; </span><br><span class="line">    cout&lt;&lt;&quot;base class static data number_num is&quot;&lt;&lt;a._num&lt;&lt;endl; </span><br><span class="line">    b._num++; </span><br><span class="line">    cout&lt;&lt;&quot;derived class static datanumber _num is&quot;&lt;&lt;b._num&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">// 结果为1,2;可见派生类与基类共用一个静态数据成员。 </span><br></pre></td></tr></table></figure>

<p><strong>3.静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public : </span><br><span class="line">    static int _staticVar; </span><br><span class="line">    int _var; </span><br><span class="line">    void foo1(int i=_staticVar);//正确,_staticVar为静态数据成员 </span><br><span class="line">    void foo2(int i=_var);//错误,_var为普通数据成员 </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>4.★静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为所属类类型的指针或引用。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public : </span><br><span class="line">    static base _object1;//正确，静态数据成员 </span><br><span class="line">    base _object2;//错误 </span><br><span class="line">    base *pObject;//正确，指针 </span><br><span class="line">    base &amp;mObject;//正确，引用 </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>5.★这个特性，我不知道是属于标准c++中的特性，还是vc6自己的特性。</strong> </p>
<p><strong>静态数据成员的值在const成员函数中可以被合法的改变。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">public: </span><br><span class="line">    base()&#123;</span><br><span class="line">        _i=0;</span><br><span class="line">        _val=0;</span><br><span class="line">    &#125; </span><br><span class="line">    mutable int _i; </span><br><span class="line">    static int _staticVal; </span><br><span class="line">    int _val; </span><br><span class="line">    void test() const&#123;//const 成员函数 </span><br><span class="line">        _i++;//正确，mutable数据成员 </span><br><span class="line">        _staticVal++;//正确，static数据成员 </span><br><span class="line">        _val++;//错误 </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">int base::_staticVal=0; </span><br></pre></td></tr></table></figure>

<p><strong>静态成员函数</strong> </p>
<p>静态成员函数没有什么太多好讲的。 </p>
<p><strong>1.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用类成员函数指针来储存。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">    static int func1(); </span><br><span class="line">    int func2(); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">int (*pf1)()=&amp;base::func1;//普通的函数指针 </span><br><span class="line">int (base::*pf2)()=&amp;base::func2;//成员函数指针 </span><br></pre></td></tr></table></figure>

<p><strong>2.静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。</strong> </p>
<p>***静态成员变量的函数形参中没有默认的this指针指向类对象本身（不能指向具体的类对象）。所以当我们调用对象的非静态成员变量的时候它不能识别该变量然而对于静态成员变量而言，其存在于整个类中，为每个类对象共有，所以就算没有默认的this形参仍然可以识别该静态成员变量*<br>**</p>
<p><strong>3.静态成员函数不可以同时声明为 virtual、const、volatile函数。举例如下：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class base&#123; </span><br><span class="line">    virtual static void func1();//错误 </span><br><span class="line">    static void func2() const;//错误 </span><br><span class="line">    static void func3() volatile;//错误 </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>最后要说的一点是，静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Smt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwlbird.github.io/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">https://zwlbird.github.io/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwlbird.github.io" target="_blank">.oOo.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/27/C/"><img class="prev-cover" src="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/27/%E5%87%BD%E6%95%B0%E7%A7%AF%E7%B4%AF/"><img class="next-cover" src="https://s2.loli.net/2023/12/12/dkLQxaftyKTzXoR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">函数积累</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/03/Hexo/" title="Hexo"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">Hexo</div></div></a></div><div><a href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel"><img class="cover" src="https://s2.loli.net/2023/12/12/zb5QarqSYDHWZs6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-19</div><div class="title">OpenGL-highlevel</div></div></a></div><div><a href="/2021/10/17/OpenGL-light/" title="OpenGL-light"><img class="cover" src="https://s2.loli.net/2023/12/12/Dlf5uYb78R1Firw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-17</div><div class="title">OpenGL-light</div></div></a></div><div><a href="/2021/07/13/C-11/" title="C++11"><img class="cover" src="https://s2.loli.net/2023/12/12/w6gBS4XVHa8hA7O.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="title">C++11</div></div></a></div><div><a href="/2021/06/27/C/" title="C++"><img class="cover" src="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-27</div><div class="title">C++</div></div></a></div><div><a href="/2021/07/13/STL/" title="STL"><img class="cover" src="https://s2.loli.net/2023/12/12/dEMek6rKx2XmsD5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="title">STL</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Smt</div><div class="author-info__description">哇咔咔</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zwlbird/zwlbird.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zwl931025@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是回？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">回调函数的重点是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Const-define-enum"><span class="toc-number">3.</span> <span class="toc-text">Const #define enum</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">3.1.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.静态局部变量：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.静态全局变量：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.静态函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.静态数据成员：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">3.1.5.</span> <span class="toc-text">4.静态成员函数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">3.2.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%951%EF%BC%9A%E5%B8%B8%E9%87%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">用法1：常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%952%EF%BC%9A%E6%8C%87%E9%92%88%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">用法2：指针和常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%953%EF%BC%9Aconst%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">用法3：const修饰函数传入参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%954%EF%BC%9A%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.4.</span> <span class="toc-text">用法4：修饰函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%955%EF%BC%9Aconst%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-c-%E7%89%B9%E6%80%A7"><span class="toc-number">3.2.5.</span> <span class="toc-text">用法5：const修饰成员函数(c++特性)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%EF%BC%9A%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">3.2.6.</span> <span class="toc-text">(一)：常量与指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%EF%BC%9A%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.7.</span> <span class="toc-text">(二)：常量与引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%EF%BC%9A%E5%B8%B8%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.8.</span> <span class="toc-text">(三)：常量函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-%EF%BC%9A%E5%B8%B8%E9%87%8F%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.9.</span> <span class="toc-text">(四)：常量返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.10.</span> <span class="toc-text">[总结]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Estatic%E3%80%81const%E3%80%81static-cosnt%E3%80%81const-static%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">关于static、const、static cosnt、const static成员的初始化问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E9%87%8C%E7%9A%84const%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、类里的const成员初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%B1%BB%E9%87%8C%E7%9A%84static%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、类里的static成员初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%B1%BB%E9%87%8C%E7%9A%84static-cosnt-%E5%92%8C-const-static%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">3、类里的static cosnt 和 const static成员初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">3.3.4.</span> <span class="toc-text">这是一个完整的例子：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.4.</span> <span class="toc-text">初始化位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%B0%8F%E7%BB%93-c-static"><span class="toc-number">3.5.</span> <span class="toc-text">c++静态成员小结,c++,static</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/03/Hexo/" title="Hexo"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo"/></a><div class="content"><a class="title" href="/2022/04/03/Hexo/" title="Hexo">Hexo</a><time datetime="2022-04-02T16:33:52.000Z" title="发表于 2022-04-03 00:33:52">2022-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/Android/" title="Android"><img src="https://s2.loli.net/2023/12/12/gfXKlqmwMWzPxH7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android"/></a><div class="content"><a class="title" href="/2021/10/31/Android/" title="Android">Android</a><time datetime="2021-10-31T14:03:21.000Z" title="发表于 2021-10-31 22:03:21">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel"><img src="https://s2.loli.net/2023/12/12/zb5QarqSYDHWZs6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-highlevel"/></a><div class="content"><a class="title" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel">OpenGL-highlevel</a><time datetime="2021-10-19T13:35:33.000Z" title="发表于 2021-10-19 21:35:33">2021-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/OpenGL-light/" title="OpenGL-light"><img src="https://s2.loli.net/2023/12/12/Dlf5uYb78R1Firw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-light"/></a><div class="content"><a class="title" href="/2021/10/17/OpenGL-light/" title="OpenGL-light">OpenGL-light</a><time datetime="2021-10-17T14:09:58.000Z" title="发表于 2021-10-17 22:09:58">2021-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D"><img src="https://s2.loli.net/2023/12/12/EZS5QGm23HLgvW4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL_3D"/></a><div class="content"><a class="title" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D">OpenGL_3D</a><time datetime="2021-09-21T07:31:53.000Z" title="发表于 2021-09-21 15:31:53">2021-09-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Smt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RrMFpOdr0spfIDfRdBukvyf7-gzGzoHsz',
      appKey: 'nipjeGzTyw5yvNk2SgU5KmUQ',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://myhkw.cn/api/player/162393526192" id="myhk" key="162393526192" m="1"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>