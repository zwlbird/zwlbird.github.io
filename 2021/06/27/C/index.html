<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ | .oOo.</title><meta name="keywords" content="Qt,C++"><meta name="author" content="Smt"><meta name="copyright" content="Smt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="可变参数函数1.带可变参数的函数由来当函数中的参数个数不确定时，这时候就需要带可变参数的函数！ 如我们经常使用的C库函数printf()实际就是一个可变参数的函数， 其原型为： 1int   printf(   const   char*   format,   ...);  它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法： 123prin">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://zwlbird.github.io/2021/06/27/C/index.html">
<meta property="og:site_name" content=".oOo.">
<meta property="og:description" content="可变参数函数1.带可变参数的函数由来当函数中的参数个数不确定时，这时候就需要带可变参数的函数！ 如我们经常使用的C库函数printf()实际就是一个可变参数的函数， 其原型为： 1int   printf(   const   char*   format,   ...);  它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法： 123prin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg">
<meta property="article:published_time" content="2021-06-27T13:44:49.000Z">
<meta property="article:modified_time" content="2023-12-18T09:22:42.068Z">
<meta property="article:author" content="Smt">
<meta property="article:tag" content="Qt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwlbird.github.io/2021/06/27/C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-18 17:22:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">.oOo.</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-27T13:44:49.000Z" title="发表于 2021-06-27 21:44:49">2021-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-18T09:22:42.068Z" title="更新于 2023-12-18 17:22:42">2023-12-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">40.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>145分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/06/27/C/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/06/27/C/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><h2 id="1-带可变参数的函数由来"><a href="#1-带可变参数的函数由来" class="headerlink" title="1.带可变参数的函数由来"></a>1.带可变参数的函数由来</h2><p>当<strong>函数中的参数个数不确定</strong>时，这时候就需要带可变参数的函数！</p>
<p>如我们经常使用的C库函数printf()实际就是一个可变参数的函数，</p>
<p><strong>其原型为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int   printf(   const   char*   format,   ...);</span><br></pre></td></tr></table></figure>

<p>它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf( &quot;%d &quot;,i);   </span><br><span class="line">printf( &quot;%s &quot;,s);   </span><br><span class="line">printf( &quot;the   number   is   %d   ,string   is:%s &quot;,   i,   s);   </span><br></pre></td></tr></table></figure>

<h2 id="2-带可变参数函数的实现，"><a href="#2-带可变参数函数的实现，" class="headerlink" title="2.带可变参数函数的实现，"></a>2.带可变参数函数的实现，</h2><p>原理：</p>
<ul>
<li>使用了<strong>指针参数</strong>来解决参数的可变问题，指针参数随着其移动指向不同的参数；</li>
<li>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数。</li>
</ul>
<p>C语言标准库中头文件stdarg.h索引的接口包含了一组能够遍历变长参数列表的宏。</p>
<p>头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdarg.h&gt;</span><br></pre></td></tr></table></figure>

<p>几个宏</p>
<p>(1).  <strong>va_list</strong> 定义一个指针</p>
<p>用来<strong>定义</strong>一个<strong>表示参数表中各个参数</strong>的<strong>变量</strong>，即定义了一个指向参数的指针， 用于指示可选的参数.</p>
<p>如：<strong>va_list ap</strong>;</p>
<p>(2). <strong>va_start(ap,v)</strong> 初始化指针  </p>
<p>使参数列表指针<strong>ap</strong>指向函数参数列表中的第一个<strong>可选参数</strong>，<strong>v</strong>是位于第一个可选参数之前的<strong>固定参数</strong>, 或者说最后一个固定参数.通常用于指定可变参数列表中参数的个数！</p>
<p>如有一va函数的声明是void va_test(char a, char b, char c, …), 则它的固定参数依次是a,b,c, 最后一个固定参数v为c, 因此就是va_start(<strong>ap</strong>, c).</p>
<p>(3). va_arg(<strong>ap</strong>, type) 返回参数列表中指针<strong>ap</strong>所指的参数, 返回类型为type. 并使指针<strong>ap</strong>指向参数列表中下一个参数.返回的是可选参数, 不包括固定参数.</p>
<p>(4). va_end(<strong>ap</strong>) 清空参数列表, 并置参数指针arg_ptr无效.</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="keyword">int</span> i,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">simple_va_fun</span>(<span class="number">100</span>);   </span><br><span class="line">    <span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="keyword">int</span> i,...)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    va_list   arg_ptr;   <span class="comment">//定义可变参数指针 </span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_ptr,i);   <span class="comment">// i为最后一个固定参数</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="built_in">va_arg</span>(arg_ptr,<span class="keyword">int</span>);   <span class="comment">//返回第一个可变参数，类型为int</span></span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">va_arg</span>(arg_ptr,<span class="keyword">char</span>);   <span class="comment">//返回第二个可变参数，类型为char</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_ptr);        <span class="comment">//  清空参数指针</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;%d %d %c\n&quot;</span>,i,j,c);   </span><br><span class="line">    <span class="keyword">return</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出为</span></span><br><span class="line"><span class="comment">100 4193388 ?</span></span><br><span class="line"><span class="comment">100 200 ?</span></span><br><span class="line"><span class="comment">100 200 a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>  思路：</p>
<p>（1）首先在函数里定义一个va_list型的变量,这里是arg_ptr,这个变量是指向参数的指针.</p>
<p>（2）然后用va_start宏初始化变量arg_ptr,这个宏的第二个参数是第一个可变参数的前一个参数,是一个固定的参数.</p>
<p>（3）然后用va_arg返回第一个可变的参数,并赋值给整数j。va_arg的第二个参数是你要返回的参数的类型,这里是int型. 返回第一个可变参数后arg_ptr指向第二个可变参数，用同样的方法返回并赋值给c，类型为char类型。</p>
<p>（4）最后用va_end宏结束可变参数的获取。</p>
<p>**小结：<br>**可变参数的函数原理其实很简单,而va系列是以宏定义来定义的,实现跟堆栈相关.我们写一个可变函数的C函数时,有利也有弊,所以在不必要的场合,我们无需用到可变参数.如果在C++里,我们应该利用C++的多态性来实现可变参数的功能,尽量避免用C语言的方式来实现。</p>
<h1 id="隐式类型转换与显式类型转换"><a href="#隐式类型转换与显式类型转换" class="headerlink" title="隐式类型转换与显式类型转换"></a>隐式类型转换与显式类型转换</h1><h2 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1. 隐式类型转换"></a>1. 隐式类型转换</h2><p>在有隐式类型转换的表达式中，不需要明确指定一个类型的对象该转换为另外哪一个类型，这个工作将隐含地由编译器来完成，编译器将分析表达式的含义，进行类型转换。</p>
<p>隐式类型转换针对不同的类型有不同的转换方式，总体可以分为两种类型，算术类型和类类型。</p>
<h3 id="1-1-算术类型转换"><a href="#1-1-算术类型转换" class="headerlink" title="1.1 算术类型转换"></a>1.1 算术类型转换</h3><p>算术类型转换的设计原则是尽可能避免损失精度。</p>
<p>具体地，有以下几条参考规则：</p>
<ol>
<li><strong>整型提升：将小整数类型转换成较大的整数类型</strong>。例如，如果一个运算对象的类型是long double，那么另外一个运算对象，无论它的类型是什么，都会被转换成long double。</li>
<li><strong>有符号类型转换为无符号类型</strong>。类型转换一般不会改变对象内存的值，当一个有符号类型的对象转换为无符号类型时，其表示出来的值可能发生变化，例如，int a = -1 (0xff); unsigned int b = a; 则b的值为255。</li>
<li><strong>在条件判断中，非布尔类型自动转换为布尔类型</strong>。如果指针或算术类型的值为0，转换为false，否则转换为true。</li>
</ol>
<p>类型级别从高到低的顺序是long double, double, float, unsigned long long, long long, long, unsigned int 和 int。</p>
<h3 id="1-2-类类型转换"><a href="#1-2-类类型转换" class="headerlink" title="1.2 类类型转换"></a>1.2 类类型转换</h3><p>在C++中，可以通过定义单参数构造函数或者转换函数来进行类类型转换，这种方式也称为用户定义的转换（User-Defined Conversion）。这种方式在使用的时候不需要指明转换类型，而是由编译器自动进行选择转换函数，所以也是一种隐式类型转换。</p>
<p>用户定义的类类型转换可以由编译器自动执行，但是编译器每次只能执行一种类类型的转换。如果一个类型转换为另外一个类型，需要同时进行多次转换，这种转换将会失败。</p>
<p><strong>1.2.1 转换构造函数</strong></p>
<p>如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制，我们把这种构造函数称为转换构造函数。在转换中只允许一步类类型的转换。</p>
<p>最常见的例子就是将C类型字符串转换为string类型，例如 string s = “hello world”，因为string类有一个构造函数string(const char *s)。</p>
<p>《C++ Primer》中提到：</p>
<blockquote>
<p><strong>“可以用 单个形参来调用 的构造函数定义了从 形参类型 到 该类类型 的一个隐式转换。”</strong></p>
</blockquote>
<p><strong>这里应该注意的是， “可以用单个形参进行调用” 并不是指构造函数只能有一个形参，而是它可以有多个形参，但那些形参都是有默认实参的。</strong></p>
<p><strong>那么，什么是“隐式转换”呢？ 上面这句话也说了，是从 构造函数形参类型 到 该类类型 的一个编译器的自动转换。</strong></p>
<p>下面通过代码来看一看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOOK</span>  //定义了一个书类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _bookISBN ;  <span class="comment">//书的ISBN号</span></span><br><span class="line">        <span class="keyword">float</span> _price ;    <span class="comment">//书的价格</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//定义了一个成员函数，这个函数即是那个“期待一个实参为类类型的函数”</span></span><br><span class="line">        <span class="comment">//这个函数用于比较两本书的ISBN号是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSameISBN</span><span class="params">(<span class="keyword">const</span> BOOK &amp; other )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> other._bookISBN==_bookISBN;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">//类的构造函数，即那个“能够用一个参数进行调用的构造函数”（虽然它有两个形参，但其中一个有默认实参，只用一个参数也能进行调用）</span></span><br><span class="line">        <span class="built_in">BOOK</span>(string ISBN,<span class="keyword">float</span> price=<span class="number">0.0f</span>):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">&quot;A-A-A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">&quot;B-B-B&quot;</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(B)&lt;&lt;endl;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">string</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">BOOK</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl;    <span class="comment">//显式创建临时对象，也即是编译器干的事情。（char* --&gt; string也是一次转换）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>代码中可以看到，isSameISBN函数是期待一个BOOK类类型形参的，但我们却传递了一个string类型的给它，这不是它想要的啊！还好，BOOK类中有个构造函数，它使用一个string类型实参进行调用，编译器调用了这个构造函数，隐式地将stirng类型转换为BOOK类型（构造了一个BOOK临时对象），再传递给isSameISBN函数。</strong></p>
<p>　　<strong>隐式类类型转换还是会带来风险的，正如上面标记，隐式转换得到类的临时变量，完成操作后就消失了，我们构造了一个完成测试后被丢弃的对象。</strong></p>
<p>　　<strong>我们可以通过explicit声明来抑制这种转换:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explicit BOOK(string ISBN,float price=0.0f):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>explicit关键字只能用于类内部的构造函数声明上.这样一来，BOOK类构造函数就不能用于隐式地创造对象了，编译上面的代码会出现这样的提示：</strong></p>
<p><img src="/2021/06/27/C/0.9681160255789087.png" alt="img"></p>
<p> <strong>现在用户只能进行显示类型转换，显式地创建临时对象。</strong></p>
<p> <strong>总结一下：</strong></p>
<ol>
<li>　　<strong>可以使用一个实参进行调用，不是指构造函数只能有一个形参。</strong></li>
<li>　　<strong>隐式类类型转换容易引起错误，除非你有明确理由使用隐式类类型转换，否则，将可以用一个实参进行调用的构造函数都声明为explicit。</strong></li>
<li>   <strong>explicit只能用于类内部构造函数的声明。它虽然能避免隐式类型转换带来的问题，但需要用户能够显式创建临时对象（对用户提出了要求）。</strong></li>
</ol>
<p><strong>1.2.2 类型转换函数</strong></p>
<p>在类类型转换中，我们通常有两个需求，一个是将其他类型的数据转换为我们自定义类的类型，另一个是将自定义类的类型在需要的时候转换为其他的数据类型。转换构造函数能很好地满足前一个需求，针对后面一个需求，我们除了可以使用普通的成员函数进行显示转换，在C++中，还可以使用类型转换函数进行隐式转换。</p>
<p>类型转换函数的作用就是将一个类的对象转换成另一类型的数据。</p>
<p>我们经常写下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while( cin &gt;&gt; num )&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入操作符 &gt;&gt; 是二元操作符，返回做操作数作为其表达式结果，因此cin &gt;&gt; num返回cin,然而cin是输入流istream的对象，该对象能出现在条件表达式中，是因为在istream中定义了类型转换函数 operator bool();</p>
<p>类型转换函数一般形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">operator 目标类型()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    return 目标类型数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    A(const int x) : _x(x) &#123;&#125;</span><br><span class="line">    operator int() &#123; return _x; &#125;</span><br><span class="line">private:</span><br><span class="line">    int _x;</span><br><span class="line">&#125;;</span><br><span class="line">int main () &#123;</span><br><span class="line">    A a(10);</span><br><span class="line">    int res = a + 20;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为30.</p>
<p>由于类A定义了从该类对象到int类型的转换函数，所以在进行整数算术运算的时候，可以直接使用该类对象，因为编译器会隐式地调用该类型转换函数将类对象转换为整型数据。</p>
<h2 id="2-显示类型转换"><a href="#2-显示类型转换" class="headerlink" title="2. 显示类型转换"></a>2. 显示类型转换</h2><p>显示类型转换就是在表达式中明确指定将一种类型转换为另一种类型。隐式类型转换一般是由编译器进行转换操作，显示类型转换是由程序员写明要转换成的目标类型。显示类型转换又被称为强制类型转换。</p>
<h3 id="2-1-C风格的强制转换"><a href="#2-1-C风格的强制转换" class="headerlink" title="2.1 C风格的强制转换"></a>2.1 C风格的强制转换</h3><p>C风格的强制转换很简单，不管什么类型的转换都可以使用使用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type val = (type)(expression);</span><br></pre></td></tr></table></figure>

<p>当然，C++支持C风格的强制转换，但是C风格的强制转换可能带来一些隐患，让一些问题难以察觉。</p>
<h3 id="2-2-C-命名的强制类型转换"><a href="#2-2-C-命名的强制类型转换" class="headerlink" title="2.2 C++命名的强制类型转换"></a>2.2 C++命名的强制类型转换</h3><p>C++提供了4个命名的强制类型转换，它们都有如下的基本形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type val = cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>cast-name是static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种。在这里简单探讨一下。</p>
<p>const_cast 把const强转成非const修饰</p>
<p>在 c 语言中强转是可以把一个不想关的类型都可以强转，但是这样就很容易出问题，如果我们用了const_cast 如果要把两个两个不相关的类型的const转到非const是不行的。这样就限制了出错的概率，，增强了代码的可读性，但是实际中，大多数还是喜欢采用c语言，但是我们必须得知道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int i = 10;//在c++中这样编译器会优化为寄存器变量用volatile</span><br><span class="line">int* j = const_cast&lt;int*&gt;(&amp;i); // const 与非 const 转换</span><br></pre></td></tr></table></figure>

<p>static_cast 隐式类型转换</p>
<p>什么是隐式类型的转换，隐式类型转换，就像c语言中我们可以把一个整型 int 赋值给一个 float 这就是隐式类型的转换。 </p>
<p>我们简单的写一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    float j = i; // 在c语言中的隐式类型的转换</span><br><span class="line">    // 用static_cast转换</span><br><span class="line">    float j = static_cast&lt;float&gt;(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写增强了代码的可读性</p>
<p>reinterpret_cast 不相关类型转换</p>
<p>这强制类型转换是就像 c语言中的强转。 </p>
<p>我们举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef void (* FUNC)();</span><br><span class="line">int DoSomething (int i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;DoSomething&quot; &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void Test ()</span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">    // reinterpret_cast可以编译器以FUNC的定义方式去看待 DoSomething函数</span><br><span class="line">    // C++不保证所有的函数指针都被一样的使用，所以这样用有时会产生不确定的结果</span><br><span class="line">    //</span><br><span class="line">    FUNC f = reinterpret_cast&lt; FUNC&gt;(DoSomething );</span><br><span class="line">    f(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就把一个函数赋值，还可以调用。</p>
<p>dynamic_cast虚函数中的父类赋给子类的转化</p>
<p>dynamic_cast用于将一个父类对象的指针转换为子类对象的指针或引用（动态转换） </p>
<p>向上转型：子类对象指针-&gt;父类指针/引用（不需要转换）  <strong>多态</strong></p>
<p>向下转型：父类对象指针-&gt;子类指针/引用（用dynamic_cast转型是安全的）</p>
<p>这里用这种强转必须要虚函数的类，用dynamic_cast来转换父类付给子类的时候，有时候可以，有时候不行，这样用dynamic_cast 强转就会在转变的过程中去判断，如果可以把父类给子类就强转，如果不行就返回0.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public :</span><br><span class="line">    virtual void f()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;&#125;;</span><br><span class="line">void fun (A* pa)</span><br><span class="line">&#123;</span><br><span class="line">    // dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回</span><br><span class="line">    B* pb1 = static_cast&lt;B*&gt;(pa);</span><br><span class="line">    B* pb2 = dynamic_cast&lt;B*&gt;(pa);</span><br><span class="line">    cout&lt;&lt;&quot;pb1:&quot; &lt;&lt;pb1&lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt;&quot;pb2:&quot; &lt;&lt;pb2&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    fun(&amp;a);</span><br><span class="line">    fun(&amp;b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/oOo/source/_posts/C/1e3067cc-a5f4-481b-ba39-7197037f07de.png" alt="img"></p>
<p>红色标记的是强转失败，因为把父类赋给子类失败。强转就会判断是否成功。 </p>
<p>如果用c语言中强转可以成功，但是如果强转后，去访问有可能会访问越界。</p>
<p>explicit关键字</p>
<p>在强转中，对于单参数的构造函数，支持隐式类型的转换，所以当我们不需要隐式类型的转换的时候，我们就可以加上explicit关键字来防止，在构造函数的时候发生隐式类型的转换。 </p>
<p>单参数的类构造函数的隐式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span> <span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A(int a)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A(const A&amp; a)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">int</span> _a ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span> <span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 隐式转换-&gt; A tmp(1); A a2(tmp);</span></span><br><span class="line">    A a2 = <span class="number">1</span>; <span class="comment">// 这是因为单参数支持隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们加上关键字后，用 = 来进行隐式类型转换，是编译不能通过的。 </p>
<p><img src="/2021/06/27/C/cdb1adc2-b704-4f96-a34f-5c84dcad9daa.png" alt="img"></p>
<p>如果我们不加就可以通过。</p>
<h1 id="左值-右值-width-既能被赋值又能取值的原因所在"><a href="#左值-右值-width-既能被赋值又能取值的原因所在" class="headerlink" title="左值 右值   width()既能被赋值又能取值的原因所在"></a>左值 右值   width()既能被赋值又能取值的原因所在</h1><p>C/C++编程中不是经常出现术语（左值）和rvalue（右值），但是一旦出现，它们的语意就不是特别清晰。最经常看到它们的地方是在编译错误和警告信息中。比如，用gcc编译下面的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123; return 2; &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo() = 2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.c: In function &#x27;main&#x27;:</span><br><span class="line">test.c:8:5: error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure>

<p>是的，这段代码不是合法的并且不是你想写的，但是那个错误信息提到了lvalue，一个通常在C/C++教程中不能找到的术语。另一个例子就是用g++编译下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int&amp; foo()</span><br><span class="line">&#123;</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在那个错误为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testcpp.cpp: Infunction &#x27;int&amp; foo()&#x27;:</span><br><span class="line">testcpp.cpp:5:12: error: invalid initialization of non-const reference of type &#x27;int&amp;&#x27; from an rvalue of type &#x27;int&#x27;</span><br></pre></td></tr></table></figure>

<p>再次，那个错误信息提到了难以理解的rvalue。那么在C/C++中lvalue和rvalue意味着什么？这是我打算 在这篇文字中探讨的。</p>
<h2 id="一个简单定义"><a href="#一个简单定义" class="headerlink" title="一个简单定义"></a>一个简单定义</h2><p>这个部分先给出lvalue和rvalue的一个简单定义。文章下面将会详细描述。<br>lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。<br>rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是在不在内存中占有确定位置的表达式。</p>
<h2 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h2><p>上面的术语定义可能不是特别清楚，所以马上看一些简单例子是重要的。<br>假设我们定义了一个整形变量并且给它赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int var;</span><br><span class="line">var = 4;</span><br></pre></td></tr></table></figure>

<p>赋值运算符要求一个lvalue作为它的左操作数，当然var是一个左值，因为它是一个占确定内存空间的对象。另一方面，下面的代码是无效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 = var;        //ERROR!</span><br><span class="line">(var + 10) = 4; //ERROR!</span><br></pre></td></tr></table></figure>

<p>常量<code>4</code>和表达式<code>var+1</code>都不是lvalue(它们是rvalue)。它们不是lvalue，因为都是表达式的临时结果，没有确定的内存空间（换句话说，它们只是计算的周期驻留在临时的寄存器中）。因此给它们赋值没有语意-这里没有地方给它们赋值。<br>因此现在应该清楚了第一个代码片段的错误信息。<code>foo</code>返回一个临时的rvalue。尝试给它赋值，<code>foo()=2</code>，是一个错误；编译器期待在赋值运算符的左部分看到一个lvalue。 </p>
<blockquote>
<p><strong>不是所有的对函数调用结果赋值都是无效的。比如，C++的引用（reference）让这成为可能：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int globalvar = 20;</span><br><span class="line">int&amp; foo()</span><br><span class="line">&#123;</span><br><span class="line">    return globalvar;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    foo() = 10;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>foo</code>返回一个引用，这是一个左值，所以它可以被赋值。实际上，C++从函数中返回左值的能力对于实现一些重载运算符时很重要的。一个普遍的例子是在类中为实现某种查找访问而重载中括号运算符 []。<code>std::map</code>可以这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;int, float&gt; mymap;</span><br><span class="line">mymap[10]=5.6;</span><br></pre></td></tr></table></figure>

<p>给 mymap[10] 赋值是合法的因为非const的重载运算符 std::map::operator[] 返回一个可以被赋值的引用。</p>
<h2 id="可修改的左值"><a href="#可修改的左值" class="headerlink" title="可修改的左值"></a>可修改的左值</h2><p>开始在C语言中左值定义，它字面上意味着“合适作为赋值的左边部分”。然而，之后C标准中添加了const关键字后，这个定义不得不重新定义。毕竟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a = 10; //‘a’是一个左值</span><br><span class="line">a = 10;           //但是它不能被赋值</span><br></pre></td></tr></table></figure>

<p>因此需要更深层次的重定义。不是所有的左值都能被赋值。这些可以称为可修改的左值。正式的，C99标准定义可修改左值为：</p>
<blockquote>
<p>[…] 一个左值没有数组类型，没有不完全类型，没有const修饰的类型，并且如果它是结构体或联合体，则没有任何const修饰的成员(包含，递归包含，任何成员元素的集合)。</p>
</blockquote>
<h2 id="左值和右值的转换"><a href="#左值和右值的转换" class="headerlink" title="左值和右值的转换"></a>左值和右值的转换</h2><p>通常来说，语言构造一个对象的值要求右值作为它的参数。例如，二元加运算符 ‘+’ 要求两个右值作为它的参数并且返回一个右值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;     //a是一个左值</span><br><span class="line">int b = 2;     //b是一个左值</span><br><span class="line">int c = a + b; //＋需要右值，所以a和b都转换成右值，并且返回一个右值</span><br></pre></td></tr></table></figure>

<p>从先前分析可以看到，<code>a</code>和<code>b</code>都是左值。因此，在代码第三行，它们经历了一次从左值到右值的转换。所以的左值不能是数组，函数或不完全类型都可以转换成右值。<br><strong>另一个方向的转换呢？右值可以转换成左值吗？当然不能！根据它的定义这将违反左值的语义[1]。</strong><br>当然，这并不意味着左值不能通过更加显式的方法产生至右值。例如，一元运算符‘*’（解引用）拿一个右值作为参数而产生一个左值作为结果。考虑下面有效的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr[] = &#123;1, 2&#125;;</span><br><span class="line">int* p = &amp;arr[0];</span><br><span class="line">*(p + 1) = 10;    //对的：p+1是一个右值，但是*(p+1)是一个左值</span><br></pre></td></tr></table></figure>

<p>相反的，一元取地址符 ‘&amp;’ 拿一个左值作为参数并且生成一个右值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int var = 10;</span><br><span class="line">int* bad_addr = &amp;(var + 1); //错误：‘&amp;’运算符要求一个左值</span><br><span class="line">int* addr = &amp;var;           //正确：var是左值</span><br><span class="line">&amp;var = 40;                  //错误：赋值运算符的左操作数要求一个左值</span><br></pre></td></tr></table></figure>

<p>‘&amp;’ 符号在C++中扮演了另一个重要角色-它允许定义应用类型。这被称为“左值引用”。非const左值引用不能被赋右值，因为这将要求一个无效的右值到左值的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string&amp; sref = std::string(); //错误：无效的初始化，用一个右值类型‘std::string’初始化非const引用类型‘std::string&amp;’</span><br></pre></td></tr></table></figure>

<p>常量左值引用可以被赋右值。因为它们是常量，不能通过引用被修改，因此修改一个右值没问题。这使得C++中接受常量引用作为函数形参成为可能，这避免了一些不必要的临时对象的拷贝和构造。</p>
<h2 id="CV修饰的右值"><a href="#CV修饰的右值" class="headerlink" title="CV修饰的右值"></a>CV修饰的右值</h2><p>如果我们仔细地读了C++标准中讨论左值到右值的转换问题[2]，我们注意到它这样说的：</p>
<blockquote>
<p>一个非函数，非数组类型的左值（3.10）T可以被转换成一个右值。[…]如果T是一个非类类型，那么转换成的右值类型是T的非CV修饰版本。否则，那个右值类型是T。</p>
</blockquote>
<p>什么是“cv-unqualified”的东西？CV-qualifier是一个被用来描述const和volatile类型修饰符的术语。<br>C++标准的3.9.3部分：</p>
<blockquote>
<p>每个非CV修饰的完全或不完全对象类型或者是空类型（3.9）都有三个相关的cv修饰版本的类型：const修饰版，volatile修饰版，和一个const-volatile版。[…]一个类型的cv修饰和非cv修饰版是不同的类型。然而，它们有想同的代指和对齐要求（3.9）</p>
</blockquote>
<p>但是这和右值右什么关系？是的，在C语言中，右值没有cv修饰的类型。仅仅左值可以。在C++中，一方面，类的右值有cv修饰的类型，但是内置类型（像int）则不能。考虑下面的这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    void foo() const &#123; std::cout &lt;&lt; &quot;A::foo() const\n&quot;; &#125;</span><br><span class="line">    void foo() &#123; std::cout &lt;&lt; &quot;A::foo()\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A bar() &#123; return A(); &#125;</span><br><span class="line">const A cbar() &#123; return A(); &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    bar().foo();  //调用foo</span><br><span class="line">    cbar().foo(); //调用foo const</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 函数的第二个调用实际上调用的是 <code>A</code> 的 <code>foo () const</code> 方法，因为 <code>cbar</code> 返回的是 <code>const A</code> 类型，这是与 <code>A</code> 不同的。这正是上个引用中最后一句话的意思。也可以注意到 <code>cbar</code> 返回的是一个右值。因此这也是一个 cv修饰的右值的例子。</p>
<h2 id="右值引用（C-11）"><a href="#右值引用（C-11）" class="headerlink" title="右值引用（C++11）"></a>右值引用（C++11）</h2><p>右值引用和相关的移动语义是C++11标准中引入的最强大的特性之一。对这个特性更广泛的讨论超过了这篇小文章的范畴[3]，但是我任然想提供一些简单的例子，因为我认为这是一个合适的地方去证明理解左值和右值对理解重要的语言概念有帮助。<br>我已经在文章中花了大部分去解释左值和右值主要的区别之一是左值可以被修改，而右值不能。好的，C++11中对于这个区别添加了一个关键的转换，通在一些特殊的情况允许我们去定义右值得引用然后修改它。<br>作为一个例子，考虑下面一个简单的动态 “整数vector” 实现。这里我只展示相关的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Intvec</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Intvec(size_t num = 0)</span><br><span class="line">        : m_size(num), m_data(new int[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Intvec()</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;destructor&quot;);</span><br><span class="line">        if (m_data) &#123;</span><br><span class="line">            delete[] m_data;</span><br><span class="line">            m_data = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Intvec(const Intvec&amp; other)</span><br><span class="line">        : m_size(other.m_size), m_data(new int[m_size])</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;copy constructor&quot;);</span><br><span class="line">        for (size_t i = 0; i &lt; m_size; ++i)</span><br><span class="line">            m_data[i] = other.m_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Intvec&amp; operator=(const Intvec&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        log(&quot;copy assignment operator&quot;);</span><br><span class="line">        Intvec tmp(other);</span><br><span class="line">        std::swap(m_size, tmp.m_size);</span><br><span class="line">        std::swap(m_data, tmp.m_data);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void log(const char* msg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;[&quot; &lt;&lt; this &lt;&lt; &quot;] &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t m_size;</span><br><span class="line">    int* m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，我们定义了通常的构造器，析构器，拷贝构造器和拷贝赋值运算符[4]，所有这些都用一个打印输出函数让我们知道它们实际上是在什么时候被调用。<br>我们运行一些简单代码，将 <code>v1</code> 的内容 拷贝到 <code>v2</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intvec v1(20);</span><br><span class="line">Intvec v2;</span><br><span class="line">cout &lt;&lt; &quot;assigning lvalue...\n&quot;;</span><br><span class="line">v2 = v1;</span><br><span class="line">cout &lt;&lt; &quot;ended assigning lvalue...\n&quot;;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assigning lvalue...</span><br><span class="line">[0x28fef8] copy assignment operator</span><br><span class="line">[0x28fec8] copy constructor</span><br><span class="line">[0x28fec8] destructor</span><br><span class="line">ended assigning lvalue...</span><br></pre></td></tr></table></figure>

<p>的确是这样-这显示了 <code>operator=</code> 内部执行过程。但是假设我们赋一些右值给 <code>v2</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;assigning rvalue...\n&quot;;</span><br><span class="line">v2 = Intvec(33);</span><br><span class="line">cout &lt;&lt; &quot;ended assigning rvalue...\n&quot;;</span><br></pre></td></tr></table></figure>

<p>虽然这里我只是赋一个刚刚构造的vector，但是这只是真是证明一个非常普遍的例子，一些临时的右值被构造然后被赋值给 <code>v2</code>（比如，这可能发生在函数中返回一个<code>vector</code>）。现在的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[0x28ff08] constructor</span><br><span class="line">[0x28fef8] copy assignment operator</span><br><span class="line">[0x28fec8] copy constructor</span><br><span class="line">[0x28fec8] destructor</span><br><span class="line">[0x28ff08] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure>

<p>哇，这看起来有好多工作。尤其是，它有一对额外的构造/析构调用。不幸的是，这是个额外工作，没有任何用，因为在拷贝赋值运算符的内部，另一个临时拷贝的对象在被创建和析构。<br>还好，没问题。C++11给我们右值引用可以实现“移动语义”，特别是一个“移动赋值运算符”[5]。我们来添加另一个 <code>operator=</code> 到 <code>Intvec</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intvec&amp; operator=(Intvec&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    log(&quot;move assignment operator&quot;);</span><br><span class="line">    std::swap(m_size, other.m_size);</span><br><span class="line">    std::swap(m_data, other.m_data);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&amp;&amp;</code> 语法是新的右值引用。的确如它名字一样-给我们一个右值的引用，在调用之后将被析构。我们可以使用我们只是“偷”这个内部的右值这个事实-我们根本不需要它们！输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assigning rvalue...</span><br><span class="line">[0x28ff08] constructor</span><br><span class="line">[0x28fef8] move assignment operator</span><br><span class="line">[0x28ff08] destructor</span><br><span class="line">ended assigning rvalue...</span><br></pre></td></tr></table></figure>

<p>这里发生的是我们的移动赋值运算符被调用，因为我们的给<code>v2</code>赋右值。临时对象Intvec(33)创建的构造和析构调用任然需要，但是另一个在赋值运算符内部的临时对象不再需要。移动运算符只是简单的切换右值的内部缓冲区为自己的，分配它所以右值析构器将会释放我们对象自己不再使用的缓冲区。很紧凑。<br>我要再次提醒的是这个例子只是移动语义和右值引用的冰山一角。你可以料到，这是个复杂的主题，有许多的案例需要考虑。我这里只是证明C++中左值和右值不同的一个有趣应用。编译器显然知道一些对象什么时候是右值，并且能够在编译期分配调用正确的构造器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>[1] 右值可以显式地赋给左值。隐式转换的缺乏意味着右值不能再左值期待的地方使用。<br>[2] 这在C++11标准草案的4.1部分。<br>[3] 你可以简单的通过谷歌“rvalue references”找到很多有用的资料。一些我个人认为有用的资源：<a target="_blank" rel="noopener" href="https://www.artima.com/cppsource/rvalue.html">这个</a>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11">这个</a>，<a target="_blank" rel="noopener" href="http://thbecker.net/articles/rvalue_references/section_01.html">尤其是这个</a>。<br>[4] 从异常安全的角度，这是一个标准的拷贝赋值运算符实现。通过使用拷贝构造器和不抛出异常的 <code>std::swap</code>，它确保如果异常抛出，未初始化的内存没有中间状态发生。<br>[5] 因此现在你应该知道为什么我一直指出我的 <code>operator=</code> 为拷贝赋值运算符。在C++11中这个区别很重要。</p>
<h1 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h1><blockquote>
<mark class="hl-label red">指针本身存在调用栈中，指针指的数据在堆中。</mark>  
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">test</span><span class="params">(<span class="keyword">int</span> *b)</span> <span class="comment">//b可以是静态数组的数组名，也可以是动态数组的首地址</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="comment">//输出传入的数组各元素 </span></span><br><span class="line">    cout&lt;&lt;*(b+i)&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">int</span> *c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//动态创建一个数组  </span></span><br><span class="line">    <span class="comment">//如果将绿色部分换为int c[5];则主函数中调用test无法得到c数组  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  <span class="comment">//新数组的各项值等于传入的数组各项值加5  </span></span><br><span class="line">     *(c+i)=*(b+i)+<span class="number">5</span>;  </span><br><span class="line">    <span class="keyword">return</span> c;     <span class="comment">//返回新创建的动态数组的首地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *b=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line">    <span class="comment">//创建动态数组b </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//赋值 </span></span><br><span class="line">     *(b+i)=i;  <span class="comment">//绿色部分也可以换为int b[5]=&#123;0,1,2,3,4&#125;;即也可以是静态数组</span></span><br><span class="line">    <span class="keyword">int</span> *c=<span class="built_in">test</span>(b);   <span class="comment">//将b作为参数，调用test函数，返回值赋给c </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  <span class="comment">//输出test返回的数组的各项  </span></span><br><span class="line">     cout&lt;&lt;*(c+i)&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</p>
<p>声明格式为：*类型标识符 函数名(参数表)</p>
<p>这似乎并不难理解，再进一步描述一下。</p>
<p>看看下面这个函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fun(int x,int y);</span><br></pre></td></tr></table></figure>

<p>这种函数应该都很熟悉，其实就是一个函数，然后返回值是一个 int 类型，是一个数值。</p>
<p>接着看下面这个函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *fun(int x,int y);</span><br></pre></td></tr></table></figure>

<p>这和上面那个函数唯一的区别就是在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。</p>
<p>这样描述应该很容易理解了，所谓的<strong>指针函数也没什么特别的，和普通函数对比不过就是其返回了一个指针（即地址值）而已。</strong></p>
<p>指针函数的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *fun(int x,int y);</span><br><span class="line">int * fun(int x,int y)；</span><br><span class="line">int* fun(int x,int y);</span><br></pre></td></tr></table></figure>

<p>这个写法看个人习惯，其实如果*靠近返回值类型的话可能更容易理解其定义。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Data&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;Data;</span><br><span class="line">//指针函数</span><br><span class="line">Data* f(int a,int b)&#123;</span><br><span class="line">    Data * data = new Data;</span><br><span class="line">    data-&gt;a = a;</span><br><span class="line">    data-&gt;b = b;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    //调用指针函数</span><br><span class="line">    Data * myData = f(4,5);</span><br><span class="line">    qDebug() &lt;&lt; &quot;f(4,5) = &quot; &lt;&lt; myData-&gt;a &lt;&lt; myData-&gt;b;</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(4,5) = 4 5</span><br></pre></td></tr></table></figure>

<p>注意：在调用指针函数时，需要一个同类型的指针来接收其函数的返回值。</p>
<p>不过也可以将其返回值定义为 void*类型，在调用的时候强制转换返回值为自己想要的类型，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//指针函数</span><br><span class="line">void* f(int a,int b)&#123;</span><br><span class="line">    Data * data = new Data;</span><br><span class="line">    data-&gt;a = a;</span><br><span class="line">    data-&gt;b = b;</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span><br></pre></td></tr></table></figure>

<p>其输出结果是一样的，不过不建议这么使用，因为强制转换可能会带来风险。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p>
<p>声明格式：类型说明符 (*函数名) (参数)</p>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*fun)(int x,int y);</span><br></pre></td></tr></table></figure>

<p>函数指针是需要把一个函数的地址赋值给它，有两种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br></pre></td></tr></table></figure>

<p>取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</p>
<p>调用函数指针的方式也有两种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br></pre></td></tr></table></figure>

<p>两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。</p>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//第一种写法</span></span><br><span class="line">    fun = add;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"> <span class="comment">//第二种写法</span></span><br><span class="line">    fun = &amp;sub;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;(*fun)(5,3) = &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">fun</span>(<span class="number">5</span>,<span class="number">3</span>)；</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*fun)(1,2) = 3</span><br><span class="line">(*fun)(5,2) = 2 2</span><br></pre></td></tr></table></figure>

<p>上面说到的几种赋值和调用方式我都分别使用了，其输出结果是一样的。</p>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><h3 id="定义不同"><a href="#定义不同" class="headerlink" title="定义不同"></a>定义不同</h3><p>指针函数本质是一个函数，其返回值为指针。</p>
<p>函数指针本质是一个指针，其指向一个函数。</p>
<h3 id="写法不同"><a href="#写法不同" class="headerlink" title="写法不同"></a>写法不同</h3><p>指针函数：int* fun(int x,int y);</p>
<p>函数指针：int (*fun)(int x,int y);</p>
<p>可以简单粗暴的理解为，指针函数的*是属于数据类型的，而函数指针的星号是属于函数名的。</p>
<p>再简单一点，可以这样辨别两者：函数名带括号的就是函数指针，否则就是指针函数。</p>
<h3 id="类成员函数的指针（非静态）"><a href="#类成员函数的指针（非静态）" class="headerlink" title="类成员函数的指针（非静态）"></a><strong>类成员函数的指针（非静态）</strong></h3><p>指向类成员函数的指针与普通函数指针的区别在于，前者需要匹配函数的参数类型和个数以及返回值类型，还要匹配该函数指针所属的类类型。</p>
<p>这是因为非静态的成员函数必须被绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数（所有类的对象都有自己数据成员的拷贝，但是成员函数都是共用的，为了区分是谁调用了成员函数，就必须有this指针，this指针是隐式的添加到函数参数列表里去的）。</p>
<p>所以，对于类成员函数的指针使用包含以下几个步骤：</p>
<p>声明： 指向类的成员函数的指针需要在指针前面加上类的类型，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef 返回值 (类名::*指针类型名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>赋值： 需要用类的成员函数地址赋值，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针类型名 指针名 = &amp;类名::成员函数名;</span><br></pre></td></tr></table></figure>

<p>注意：这里的这个&amp;符号是比较重要的：不加&amp;，编译器会认为是在这里调用成员函数，所以需要给出参数列表，否则会报错；加了&amp;，才认为是要获取函数指针。这是C++专门做了区别对待。</p>
<p>调用： 针对调用的对象是对象还是指针，分别用.*和-&gt;*进行调用，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(类对象.*指针名)(参数列表);</span><br><span class="line">(类指针-&gt;*指针名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>注意：这里的前面一对括号是很重要的，因为()的优先级高于成员操作符指针的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Calculation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int add(int a,int b)&#123; //非静态函数</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef int (Calculation::*FuncCal)(int,int);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FuncCal funAdd = &amp;Calculation::add;</span><br><span class="line">    Calculation * calPtr = new Calculation;</span><br><span class="line">    int ret = (calPtr-&gt;*funAdd)(1,2); //通过指针调用</span><br><span class="line">    Calculation cal;</span><br><span class="line">    int ret2 = (cal.*funAdd)(3,4); //通过对象调用</span><br><span class="line">    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ret2 = &quot; &lt;&lt; ret2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指向类的静态函数的指针"><a href="#指向类的静态函数的指针" class="headerlink" title="指向类的静态函数的指针"></a><strong>指向类的静态函数的指针</strong></h3><p>类的静态成员函数和普通函数的函数指针的区别在于，他们是不依赖于具体对象的，所有实例化的对象都共享同一个静态成员，所以静态成员也没有this指针的概念。</p>
<p>所以，指向类的静态成员的指针就是普通的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Calculation</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static int add(int a,int b)&#123; //静态函数</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef int (*FuncCal)(int,int);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FuncCal funAdd = &amp;Calculation::add;</span><br><span class="line">    int ret = (*funAdd)(1,2); //直接引用</span><br><span class="line">    int ret2 = funAdd(3,4); //直接引用</span><br><span class="line">    cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ret2 = &quot; &lt;&lt; ret2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C++中的匿名对象是pure RValue, 因而不能作为引用传进去。</span><br><span class="line">匿名对象只存在于构造该对象的那行代码，离开构造匿名对象的那行代码后立即调用析构函数。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Some</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="built_in">Some</span>(<span class="keyword">int</span> s)&#123;n=s;&#125;  </span><br><span class="line">  ~<span class="built_in">Some</span>()&#123;  </span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;destroy\n&quot;</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ret</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="built_in">Some</span>(<span class="number">111</span>).<span class="built_in">ret</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;wait\n&quot;</span>;  </span><br><span class="line">        cin.<span class="built_in">get</span>();  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象的使用与优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    string course;</span><br><span class="line">public:</span><br><span class="line">    Teacher(const char *n,const char *c):name(n),course(c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;创建&quot; &lt;&lt; course &lt;&lt; &quot;老师&quot; &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Teacher(const Teacher&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        name = t.name;</span><br><span class="line">        course = t.course;</span><br><span class="line">        cout &lt;&lt; &quot;复制&quot; &lt;&lt; course &lt;&lt; &quot;老师&quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Teacher()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;辞退&quot; &lt;&lt; course &lt;&lt; &quot;老师&quot;  &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Teacher t1(&quot;陈宗权&quot;,&quot;C++&quot;);//构造函数</span><br><span class="line">    Teacher t2 = t1;//拷贝构造函数</span><br><span class="line">    //用临时匿名对象来初始化一个新对象</span><br><span class="line">    //编译器一般会优化成直接用创建临时对象的参数来创建新对象</span><br><span class="line">    Teacher t3 = Teacher(&quot;杨强&quot;,&quot;UC&quot;);</span><br><span class="line">    t2 = t3; //赋值函数</span><br><span class="line">    cout &lt;&lt; &quot;=======&quot; &lt;&lt;endl;</span><br><span class="line">    t2 = Teacher(&quot;徐薇薇&quot;,&quot;咨询&quot;); // 没有优化 创建匿名对象  调用赋值操作赋值函数，且匿名对象被析构</span><br><span class="line">    cout &lt;&lt; &quot;=======&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">创建C++老师陈宗权</span><br><span class="line">复制C++老师陈宗权</span><br><span class="line">创建UC老师杨强</span><br><span class="line">=======</span><br><span class="line">创建咨询老师徐薇薇</span><br><span class="line">辞退咨询老师徐薇薇</span><br><span class="line">=======</span><br><span class="line">辞退UC老师杨强</span><br><span class="line">辞退咨询老师徐薇薇</span><br><span class="line">辞退C++老师陈宗权</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ol>
<li>匿名对象的生命周期</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat类 无参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Cat</span>(Const Cat&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat类 拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat类 析构函数 &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">playStage</span><span class="params">()</span> <span class="comment">//一个舞台，展示对象的生命周期</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Cat</span>();             <span class="comment">/*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；执行完此行代码，</span></span><br><span class="line"><span class="comment">                            因为外部没有接此匿名对象的变量，此匿名又被析构了*/</span> 赋值操作</span><br><span class="line">    Cat cc = <span class="built_in">Cat</span>();    <span class="comment">/*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；然后将此匿名变</span></span><br><span class="line"><span class="comment">                            成了cc这个实例对象，此匿名对象没有被析构。*/</span> 拷贝构造函数</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;cc 对象好没有被析构&quot;</span>&lt;&lt;endl;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">playStage</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="if-中同时出现赋值语句和判断"><a href="#if-中同时出现赋值语句和判断" class="headerlink" title="if 中同时出现赋值语句和判断"></a>if 中同时出现赋值语句和判断</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span> &gt; res;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">            <span class="keyword">if</span> ((iter = map1.<span class="built_in">find</span>(complement) )!= map1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            map1[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-调用-python3-6"><a href="#C-调用-python3-6" class="headerlink" title="C++ 调用 python3.6"></a>C++ 调用 python3.6</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lingtianyulong/article/details/81146495">https://blog.csdn.net/lingtianyulong/article/details/81146495</a> </p>
<p>使用Python3.6,在VS2013与VS2017中进行调用，其中的遇到了各种坑，将暂时遇到的坑先进行整理；</p>
<p>1：py文件不能以 test命名，不知道为什么，以test1,test2之类的命名都可以，但就是不能使用 test命名，否则，找不到函数名，即</p>
<p>  pFunc = PyObject_GetAttrString(pModule, “hello”);该代码找不到 python 中的 hello()函数；</p>
<p>2：若 .py 文件中，有语法错误，则不能导入；</p>
<p>  这点尤为重要，一定先运行python文件，没问题了再放到c++里，第一次调用就因为函数下面的代码没有对齐一直找不到问题</p>
<p>3：要导入.py文件所在的路径，如下所示：</p>
<p>  PyRun_SimpleString(“import sys”);</p>
<p>  PyRun_SimpleString(“sys.path.append(‘F:\C++ WorkSpace\CallPython\CallPython’)”);</p>
<p>其中，修改后的C++代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化python</span></span><br><span class="line">    <span class="built_in">Py_Initialize</span>();</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;sys.path.append(&#x27;F:\\C++ WorkSpace\\CallPython\\CallPython&#x27;)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义python类型的变量</span></span><br><span class="line">    PyObject *pModule = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pFunc = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pArg = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *result = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pClass = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pInstance = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *pDict = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//直接运行python代码</span></span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;print(&#x27;python start&#x27;)&quot;</span>);</span><br><span class="line">    <span class="comment">//引入模块</span></span><br><span class="line">    pModule = <span class="built_in">PyImport_ImportModule</span>(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!pModule)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Import Module Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取模块字典属性</span></span><br><span class="line">    pDict = <span class="built_in">PyModule_GetDict</span>(pModule);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">////直接获取模块中的函数</span></span><br><span class="line">    pFunc = <span class="built_in">PyObject_GetAttrString</span>(pModule, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//参数类型转换，传递一个字符串。将c/c++类型的字符串转换为python类型，元组中的python类型查看python文档</span></span><br><span class="line">    pArg = <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;(s)&quot;</span>, <span class="string">&quot;hello charity&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用直接获得的函数,并传递参数</span></span><br><span class="line">    <span class="built_in">PyEval_CallObject</span>(pFunc, pArg);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从字典属性中获取函数</span></span><br><span class="line">    pFunc = <span class="built_in">PyDict_GetItemString</span>(pDict, <span class="string">&quot;arg&quot;</span>);</span><br><span class="line">    <span class="comment">// 参数类型转换,传递两个整型参数</span></span><br><span class="line">    pArg = <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;(i, i)&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 调用函数,并得到 python 类型的返回值</span></span><br><span class="line">    result = <span class="built_in">PyEval_CallObject</span>(pFunc, pArg);</span><br><span class="line">    <span class="comment">// c 用来保存 C/C++ 类型的返回值</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将 python 类型的返回值转换为 C/C++类型</span></span><br><span class="line">    <span class="built_in">PyArg_Parse</span>(result, <span class="string">&quot;i&quot;</span>, &amp;c);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a+b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过字典属性获取模块中的类 </span></span><br><span class="line">    pClass = <span class="built_in">PyDict_GetItemString</span>(pDict, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!pClass)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;获取模块中的类失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实例化获取的类</span></span><br><span class="line">    pInstance = <span class="built_in">PyInstanceMethod_New</span>(pClass);</span><br><span class="line">    <span class="comment">//调用类的方法</span></span><br><span class="line">    result = <span class="built_in">PyObject_CallMethod</span>(pInstance, <span class="string">&quot;say_hello&quot;</span>, <span class="string">&quot;(s,s)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;charity&quot;</span>);</span><br><span class="line">    <span class="comment">//输出返回值</span></span><br><span class="line">    <span class="keyword">char</span>* name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">PyArg_Parse</span>(result, <span class="string">&quot;s&quot;</span>, &amp;name);   <span class="comment">//这个函数的第二个参数相当扯淡，具体看下文的英文，类型使用字符来表示的，例如“s”代表 str &quot;i&quot; 代表int，个人感觉相当扯淡</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;print(&#x27;python end&#x27;)&quot;</span>);</span><br><span class="line">    <span class="comment">////释放python</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Py_Finalize</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">hello</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="function">    print(<span class="string">&quot;hello world&quot;</span>)</span></span><br><span class="line"><span class="function">    print(s)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">def arg(a, b):</span></span><br><span class="line"><span class="function">    print(<span class="string">&#x27;a=&#x27;</span>, a)</span></span><br><span class="line"><span class="function">    print(<span class="string">&#x27;b=&#x27;</span>, b)</span></span><br><span class="line"><span class="function">    return a + b</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">class Test:</span></span><br><span class="line"><span class="function">    def __init__(self):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;init&quot;</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    def say_hello(self, name):</span></span><br><span class="line"><span class="function">        print(<span class="string">&quot;hello&quot;</span>, name)</span></span><br><span class="line"><span class="function">        return name</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python start</span><br><span class="line">hello world</span><br><span class="line">hello charity</span><br><span class="line">a= <span class="number">1</span></span><br><span class="line">b= <span class="number">2</span></span><br><span class="line">a+b = <span class="number">3</span></span><br><span class="line">hello charity</span><br><span class="line">charity</span><br><span class="line">python end</span><br></pre></td></tr></table></figure>

<p>请按任意键继续. . .</p>
<p>给python函数中的变量赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Py_SetPythonHome</span>(<span class="string">L&quot;C:\\Anaconda&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化Python</span></span><br><span class="line">    <span class="comment">//在使用Python系统前，必须使用Py_Initialize对其</span></span><br><span class="line">    <span class="comment">//进行初始化。它会载入Python的内建模块并添加系统路</span></span><br><span class="line">    <span class="comment">//径到模块搜索路径中。这个函数没有返回值，检查系统</span></span><br><span class="line">    <span class="comment">//是否初始化成功需要使用Py_IsInitialized。</span></span><br><span class="line">    <span class="built_in">Py_Initialize</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 检查初始化是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Py_IsInitialized</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加当前路径。这里注意下面三句都不可少，</span></span><br><span class="line">    <span class="comment">//添加的是当前路径。但是我打印了sys.path,</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;import sys&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;from sklearn.externals import joblib&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;import librosa&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;import numpy as np&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;print &#x27;---import sys---&#x27;&quot;);</span></span><br><span class="line">    <span class="comment">//下面这个./表示当前工程的路径，如果使用../则为上级路径，根据此来设置</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;sys.path.append(&#x27;./&#x27;)&quot;);</span></span><br><span class="line">    <span class="comment">//PyRun_SimpleString(&quot;print(&#x27;python start&#x27;)&quot;);</span></span><br><span class="line">    PyObject *pName = <span class="literal">NULL</span>, *pModule = <span class="literal">NULL</span>, *pDict = <span class="literal">NULL</span>, *pFunc = <span class="literal">NULL</span>, *pArgs = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 载入名为python的脚本</span></span><br><span class="line">    <span class="comment">//pName = PyString_FromString(&quot;cpython&quot;);</span></span><br><span class="line">    pModule = <span class="built_in">PyImport_ImportModule</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pModule) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t find your_file.py&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pDict = <span class="built_in">PyModule_GetDict</span>(pModule);</span><br><span class="line">    <span class="keyword">if</span> (!pDict) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 找出函数名为signal_classfication的函数</span></span><br><span class="line">    pFunc = <span class="built_in">PyDict_GetItemString</span>(pDict, <span class="string">&quot;signal_classfication&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pFunc || !<span class="built_in">PyCallable_Check</span>(pFunc)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t find function [display]&quot;</span>);</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将参数传进去。1代表一个参数。</span></span><br><span class="line">    pArgs = <span class="built_in">PyTuple_New</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//  PyObject* Py_BuildValue(char *format, ...)</span></span><br><span class="line">    <span class="comment">//  把C++的变量转换成一个Python对象。当需要从</span></span><br><span class="line">    <span class="comment">//  C++传递变量到Python时，就会使用这个函数。此函数</span></span><br><span class="line">    <span class="comment">//  有点类似C的printf，但格式不同。常用的格式有</span></span><br><span class="line">    <span class="comment">//  s 表示字符串，</span></span><br><span class="line">    <span class="comment">//  i 表示整型变量，</span></span><br><span class="line">    <span class="comment">//  f 表示浮点数，</span></span><br><span class="line">    <span class="comment">//  O 表示一个Python对象。</span></span><br><span class="line">    PyObject* pList = <span class="literal">NULL</span>;</span><br><span class="line">    pList = <span class="built_in">PyList_New</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PyList_Append</span>(pList, <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;i&quot;</span>, boxing[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PyTuple_SetItem</span>(pArgs, <span class="number">0</span>, pList);</span><br><span class="line">    <span class="built_in">PyTuple_SetItem</span>(pArgs, <span class="number">1</span>, <span class="built_in">Py_BuildValue</span>(<span class="string">&quot;s&quot;</span>, date));</span><br><span class="line">    <span class="comment">// 调用Python函数</span></span><br><span class="line">    PyObject* pReturn = <span class="built_in">PyObject_CallObject</span>(pFunc, pArgs);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">PyList_Size</span>(pReturn);</span><br><span class="line">    <span class="comment">//int size = 7;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;sum：&quot; &lt;&lt;  size &lt;&lt; endl; </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> res[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">if</span> (pReturn != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PyObject *pListItem_1 = <span class="built_in">PyList_GetItem</span>(pReturn, j);</span><br><span class="line">            <span class="built_in">PyArg_Parse</span>(pListItem_1, <span class="string">&quot;d&quot;</span>, &amp;res[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="按位于-按位或"><a href="#按位于-按位或" class="headerlink" title="按位于 按位或"></a>按位于 按位或</h1><p>8位二进制=2位十六进制=1位十进制=1字节</p>
<p>value &amp; 0x2000，把第三位取出来，别的都不要了，然后&gt;&gt;12,向右移动了12位，原来的第三位就变成了第15位，别的位都是0，然后转成两个字节16位的数</p>
<p>0x2000（0010 0000 0000 0000）-&gt;0000 0000 0000 0010</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8位</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FeatureSupports</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  MIN = <span class="number">0x0001</span>,  <span class="comment">//0000 0001</span></span><br><span class="line">  SECOND = <span class="number">0x0002</span>,<span class="comment">//0000 0010</span></span><br><span class="line">  THIRD = <span class="number">0x0004</span>, <span class="comment">//0000 0100</span></span><br><span class="line">  FORTH = <span class="number">0x0008</span>, <span class="comment">//0000 1000</span></span><br><span class="line">  FIFTH = <span class="number">0x0010</span>, <span class="comment">//0001 0000</span></span><br><span class="line">  SIX = <span class="number">0x0020</span>,  <span class="comment">//0010 0000</span></span><br><span class="line">  SEVEN = <span class="number">0x0040</span>, <span class="comment">//0100 0000</span></span><br><span class="line">  MAX = <span class="number">0x0080</span>,  <span class="comment">//1000 0000</span></span><br><span class="line">  FULL = <span class="number">0x00FF</span>,  <span class="comment">//1111 1111</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>位操作</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>***/</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立一个标志位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> globalMark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入第2、3、4位</span></span><br><span class="line">globalMark |= FeatureSupports::SECOND| FeatureSupports::THIRD | FeatureSupports::FORTH;<span class="comment">//0000 1110,得14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取位</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a= globalMark &amp; FeatureSupports::SECOND;<span class="comment">//检查第二位是否为1，得0010即2</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b = globalMark &amp; <span class="number">0x0006</span>;<span class="comment">//检查第二位与第三位是否都为1，得0110即6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个体现了优先级：位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> c = (globalMark &amp; <span class="number">0x0006</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">//源数据是1110，与0x0006（0110）按位与，得到0110，右移一位，得0011即3</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> d = globalMark &amp; <span class="number">0x0006</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//源数据是0x0006（0110），右移一位，得0011,与1110按位与，得到0010，即2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消除第三位，取反的方法不依赖机器字长，而且还能指定要清除的实际位，所以比下面的【消除后两位】使用的直接按位与的方法好</span></span><br><span class="line">globalMark &amp;= ~FeatureSupports::THIRD;<span class="comment">//0000 0100取反得1111 1011，与0000 1110按位与， 得0000 1010即10</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> e=~FeatureSupports::THIRD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消除后两位</span></span><br><span class="line">globalMark &amp;= <span class="number">0xFFFFFFFC</span>;<span class="comment">//1111 1100与0000 1010按位与，得0000 1000即8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反置一位，可用异或运算符</span></span><br><span class="line">globalMark ^= <span class="number">0x2</span>;<span class="comment">//0000 1000异或第二位，即得0000 1010,即10</span></span><br><span class="line">globalMark ^= <span class="number">0x2</span>;<span class="comment">//0000 1010异或第二位，即得0000 1000,即8</span></span><br></pre></td></tr></table></figure>



<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>1 位逻辑运算符：</p>
<p>   <strong>&amp;</strong> （位  “与”）  and<br>   <strong>^</strong> （位  “异或”）<br>   <strong>|</strong>  （位   “或”）  or<br>   <strong>~</strong> （位  “取反”）<br>2 移位运算符：<br>   **&lt;&lt;**（左移）</p>
<p>   **&gt;&gt;**（右移）</p>
<p><strong>优先级</strong></p>
<p>位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </p>
<h2 id="二：位逻辑运算"><a href="#二：位逻辑运算" class="headerlink" title="二：位逻辑运算"></a>二：位逻辑运算</h2><p><strong>&amp; 运算</strong>  ———————–**-2个都为1-》1**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&amp;<span class="number">1</span> =<span class="number">0</span>;  </span><br><span class="line"><span class="number">0</span>&amp;<span class="number">0</span> =<span class="number">0</span>;</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">0</span> =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&amp;<span class="number">1</span> =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00111</span>&amp; <span class="number">11100</span>  =<span class="number">00100</span></span><br></pre></td></tr></table></figure>

<p>&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。</p>
<p>这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数</p>
<p>—————————————————————–</p>
<p><strong>| 运算</strong>—————————<strong>1个为1–》1</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">0</span>=<span class="number">0</span>;  </span><br><span class="line"><span class="number">0</span>|<span class="number">1</span>=<span class="number">1</span>;</span><br><span class="line"><span class="number">1</span>|<span class="number">0</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00111</span>|  <span class="number">11100</span>  =<span class="number">11111</span></span><br></pre></td></tr></table></figure>

<p>| 运算通常用于二进制特定位上的无条件赋值，例如一个数|1的结果就是把二进制最末位强行变为1</p>
<p>如果需要把二进制最末位变成0，对这个数 |1之后再减一就可以了，其实际意义就是把这个数强行变成最近接的偶数</p>
<p>——————————————————————–</p>
<p><strong>^ 运算</strong>—————————<strong>不同则为1，相同则为0 // 当且仅当两个运算值中有一个为1但不同时为1时，返回值为1</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>^<span class="number">1</span>=<span class="number">1</span>；</span><br><span class="line"><span class="number">1</span>^<span class="number">0</span>=<span class="number">1</span>；</span><br><span class="line"><span class="number">1</span>^<span class="number">1</span>=<span class="number">0</span>；</span><br><span class="line"><span class="number">0</span>^<span class="number">0</span>=<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="number">00111</span> ^ <span class="number">11100</span>     =<span class="number">11011</span></span><br></pre></td></tr></table></figure>

<p>^运算通常用于对二进制的特定一位进行取反操作，^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a^b)^b=a；</p>
<p>^运算可以用于简单的加密，比如原始值int a = 19880516;密钥 int key =1314520; 进行加密 int data=key^a = 20665500;解密 data^key == a；</p>
<p>^运算还可以实现两个值的交换而不需要中间变量，例如：</p>
<p>先看加减法中交换实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> &amp;a,<span class="keyword">long</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = a+b;</span><br><span class="line">   b = a-b;</span><br><span class="line">   a = a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> &amp;a,<span class="keyword">long</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a = a^b;</span><br><span class="line">  b = a^b;</span><br><span class="line">  a = a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 ^运算可以理解成类似加法（+）记忆 ， 1+1 =0，1+0 =1，0+1 =1；0+0 =0；//因为机器码是二进制，1+1=2%2 =0，其实不然</p>
<p>—————————————————————————————————</p>
<p><strong>~运算</strong></p>
<p><del>运算的定义把内存中的0和1全部取反，所以</del>运算时要格外小心，你需要注意整数类型有没符号，如果~的对象是无符号整数（不能表示负数），那么他的值就是它与它的上界限的之差，因为无符号类型的数是用0000到0000到FFFF依次表示的。</p>
<p>下面的两个程序（仅语言不同）均返回65435。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var</span><br><span class="line">   a:word;</span><br><span class="line">begin</span><br><span class="line">   a:=<span class="number">100</span>;</span><br><span class="line">   a:=<span class="keyword">not</span>  a;</span><br><span class="line">   <span class="built_in">writenln</span>(a);</span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">​    unsingned <span class="keyword">short</span> a = <span class="number">100</span>;</span><br><span class="line">​    a = ~a;</span><br><span class="line">​    <span class="built_in">printf</span>(“%d\n”,a);</span><br><span class="line">​    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 ~的对象是有符号的整数，情况就不一样了，详见最后面整数类型的存储</p>
<h2 id="三：位移运算"><a href="#三：位移运算" class="headerlink" title="三：位移运算"></a>三：位移运算</h2><p><strong>&lt;&lt;运算</strong></p>
<p>a&lt;&lt;b 表示把a转为二进制后左移b位（在后面添加 b个0）。例如100的二进制表示为1100100，100左移2位后（后面加2个零）：1100100&lt;&lt;2 =110010000 =400，可以看出，a&lt;&lt;b的值实际上就是a乘以2的b次方，因为在二进制数后面添加一个0就相当该数乘以2，2个零即2的2次方 等于4。通常认为a&lt;&lt;1比a*2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作尽量用左移一位来代替。</p>
<p>定义一些常量可能会用到&lt;&lt;运算。你可以方便的用1&lt;&lt;16 -1 来表示65535（unsingned int  最大值16位系统）。很多<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure">算法</a>和<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure">数据结构</a>要求数据模块必须是2的幂，此时就可以用&lt;&lt;来定义MAX_N等常量。</p>
<p><strong>&gt;&gt;运算</strong></p>
<p>和&lt;&lt;相似，a&gt;&gt;b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们经常用&gt;&gt;1来代替 /2（div 2),比如二分查找、堆的插入操作等等。想办法用&gt;&gt;代替除法运算可以使程序的效率大大提高。最大公约数的二进制算法用除以2操作来代替慢的出奇的%（mod）运算，效率可以提高60%。</p>
<p>int a =100;</p>
<p>a/4 ==a&gt;&gt;2;</p>
<p><strong>位移运算运用 例子</strong></p>
<p><strong>1.合并数据</strong></p>
<p>缩短数据：int a =4; int b=2;  可以将数据 a,b 保存于一个变量 int c中,在此int 类型为32位</p>
<p>a=0x0000 0004; / /十六进制</p>
<p>b=0x0000 0002;</p>
<p>int c = a&lt;&lt;16;//左移操作-将a数据向左移动16位=0x0004 0000</p>
<p> c |=b;  // （|）操作，一个为1 则为1，所以高16位不变，低16位值为 b值，即c = 0x0004 0002;完成数据的合并</p>
<p><strong>2.解析数据</strong></p>
<p>上面c = 0x0004 0002;</p>
<p>读取高位：int a1 = c&gt;&gt;16; / / 右移16位，消除低位数据，读取高位数据 a1 = 0x0000 0004</p>
<p>读取低位：int a2 = c&0xFFFF; //（&amp;）操作，2个都为1 则为1，所以0xFFFF 即 0X0000 FFFF, 所以高位全为0，低位的 1不变，0还是0，a2=0x0000 0002,读取低位成功</p>
<p>读取低位2：int a2 = c&lt;&lt;16; 消除高位，低位存入高位，a2=0x0002 0000;</p>
<p>​                      a2 = a2&gt;&gt;16;高位存入低位，消除低位; a2 = 0x0000 0002;</p>
<p><strong>下面列举一些常见的二进制位的变换操作</strong></p>
<table>
<thead>
<tr>
<th>去掉最后一位</th>
<th>101101-&gt;10110</th>
<th>x&gt;&gt;1</th>
</tr>
</thead>
<tbody><tr>
<td>在最后加一个0</td>
<td>101101-&gt;1011010</td>
<td>x&lt;&lt;1</td>
</tr>
<tr>
<td>在最后加一个1</td>
<td>101101-&gt;1011011</td>
<td>(x&lt;&lt;1)+1</td>
</tr>
<tr>
<td>把最后一位变成1</td>
<td>101100-&gt;101101</td>
<td>x | 1</td>
</tr>
<tr>
<td>把最后一位变成0</td>
<td>101101-&gt;101100</td>
<td>(x |1) - 1</td>
</tr>
<tr>
<td>最后一位取反</td>
<td>101101-&gt;101100</td>
<td>x ^ 1</td>
</tr>
<tr>
<td>把右数第K位变成1</td>
<td>101001-&gt;101101,k=3</td>
<td>x  | (1&lt;&lt;(k-1))</td>
</tr>
<tr>
<td>把右数第K位变成0</td>
<td>101101-&gt;101101,k=3</td>
<td>x &amp; ~(1&lt;&lt;(k-1))</td>
</tr>
<tr>
<td>右数第k位取反</td>
<td>101001-&gt;101101,k=3</td>
<td>x ^ (1&lt;&lt;(k-1))</td>
</tr>
<tr>
<td>取末三位</td>
<td>1101101-&gt;101</td>
<td>x &amp;7</td>
</tr>
<tr>
<td>取末k位</td>
<td>1101101-&gt;1101,k=5</td>
<td>x &amp; (1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>取右数第k位</td>
<td>1101101-&gt;1,k=4</td>
<td>x &gt;&gt; (k-1)&amp;1</td>
</tr>
<tr>
<td>把末k位变成1</td>
<td>101001-&gt;101111,k=4</td>
<td>x|(1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>末k位取反</td>
<td>101001-&gt;100110,k=4</td>
<td>x^(1&lt;&lt;k-1)</td>
</tr>
<tr>
<td>把右边连续的1变成0</td>
<td>100101111-&gt;100100000</td>
<td>x&amp;(x+1)</td>
</tr>
<tr>
<td>把右起第一个0变成1</td>
<td>100101111-&gt;100111111</td>
<td>x|(x+1)</td>
</tr>
<tr>
<td>把右边连续的0变成1</td>
<td>11011000-&gt;11011111</td>
<td>x|(x-1)</td>
</tr>
<tr>
<td>取右边连续的1</td>
<td>100101111-&gt;1111</td>
<td>(x^(x+1))&gt;&gt;1</td>
</tr>
<tr>
<td>去掉右起第一个1的左边</td>
<td>100101000-&gt;1000</td>
<td>x&amp;(x^(x-1))</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>最后一个会在树状数组中用到</p>
<p><strong>整数类型的储存</strong></p>
<p>前面 所说的位运算都没有涉及负数，都假设这些运算是在unsingned/word类型（只能表示正数的整型）上进行操作。</p>
<p>但计算机如何处理有正负符号的整型呢？这个设计到补码，反码知识点，请看下面</p>
<p>​    假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：00000000 00000000 00000000 00000101<br>5转换成二进制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。<br>​    现在想知道，-5在计算机中如何表示？<br>   <strong>在计算机中，负数以其正值的补码形式表达</strong>。</p>
<p>   什么叫补码呢？这得从原码，反码说起。</p>
<h2 id="四：反码，补码-可借鉴《字符串相关-gt-十进制与二进制的转换》"><a href="#四：反码，补码-可借鉴《字符串相关-gt-十进制与二进制的转换》" class="headerlink" title="四：反码，补码(可借鉴《字符串相关-&gt;十进制与二进制的转换》)"></a><strong>四：反码，补码</strong>(可借鉴《字符串相关-&gt;十进制与二进制的转换》)</h2><p>​    反码和补码的目的就是为了解决负数的问题</p>
<p>​    在计算机内，定点数有3种表示法：<mark class="hl-label blue">原码、反码和补码</mark>  </p>
<p>​    所谓原码就是前面所介绍的二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。</p>
<blockquote>
<p><strong>反码表示法规定</strong>：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</p>
<p><strong>补码表示法规定</strong>：正数的补码与其原码相同；负数的补码是在其反码的末位加1。</p>
</blockquote>
<p>   有原码就可以了，为什么还需要反码和补码？</p>
<p>   反码是用来算补码的，原码和补码都是用在CPU的基本运算里的，比如数据类型是short：<br>   计算5  -  2，并由于实际上CPU没有实现减法电路（注：计算机的硬件结构中只有加法器，所以大部分的运算都必须最终转换为加法，原码没有办法做减法，而在我们使用的汇编、C等其他高级语言中使用的都是原码，原码转换成补码都是在计算机的最底层进行的）。原码计算是  5＋（－2）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    0101</span><br><span class="line">＋  1010</span><br><span class="line">——- </span><br><span class="line">    1111 </span><br></pre></td></tr></table></figure>

<p> ＝－7？显然出错<br> 所以不管正数还是负数，都使用补码来表示（正数原码和补码是一样的）， 2的补码是1110，然后用5补  +  2补  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0101  </span><br><span class="line">+ 1110  </span><br><span class="line">——  </span><br><span class="line">  0011  </span><br></pre></td></tr></table></figure>

<p> ＝3，正确</p>
<p>《<a target="_blank" rel="noopener" href="http://blog.csdn.net/wuguai4/article/details/7321440">补码的运算方法详见此链接</a>》<br>所以理论上（也仅仅是理论上）我们只要让减数通过一个求反电路，再通过一个+1电路，然后通过加法电路就可以实现减法了。 </p>
<p>所以补码的设计目的是:<br>⑴使符号位能与有效值部分一起参加运算,从而简化运算规则.<br>⑵使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计</p>
<p>​    <strong>原码</strong>：在数值前直接加一符号位的表示法。</p>
<p>　　       例如： 符号位 数值位　　            [+7]原= 0 0000111 　　            [-7]原= 1 0000111 </p>
<p>​    注意：a： 数0的原码有两种形式：        [+0]原= 0 0000000                     [<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1199203.htm">-0</a>]原=1 0000000</p>
<p>　  　     b： 8位二进制原码的表示范围：-127～+127<br>　<strong>反码</strong>：正数：正数的反码与原码相同。</p>
<p>　　       负数：负数的反码，符号位为“1”，数值部分按位取反。</p>
<p>   例如： 符号位 数值位               　             [+7]反= 0 0000111 　　             [-7]反= 1 1111000 　  </p>
<p>   注意：a：数0的反码也有两种形式，即   [+0]反= 0 0000000　  　            [- 0]反=1 1111111　      </p>
<p>​              b.：8位二进制反码的表示范围：-127～+127</p>
<p>​    <strong>补码：</strong></p>
<p>​     <strong>1）</strong>模的概念：把一个计量单位称之为模或模数。例如，时钟是以12进制进行计数循环的，即以12为模。在时钟上，时针加上（正拨）12的整数位或减去（反拨）12的整数位，时针的位置不变。14点钟在舍去模12后，成为（下午）2点钟（14=14-12=2）。从0点出发逆时针拨10格即减去10小时，也可看成从0点出发顺时针拨2格（加 上2时），即2点（0-10=-10=-10+12=2）。因此，在模12的前提下，-10可映射为+2。由此可见，对于一个模数为12的循环系统来说，加2和减10的效果是一样的； 因此，在以12为模的系统中，凡是减10的运算都可以用加2来代替，这就把减法问题转化成加法问题了（注：计算机的硬件结构中只有加法器，所以大部分的运算都必 须最终转换为加法）。10和2对模12而言互为补数。</p>
<p>　　     同理，计算机的运算部件与寄存器都有一定字长的限制（假设字长为8），因此它的运算也是一种模运算。当计数器计满8位也就是256个数后会产生溢出，又从头开始         计数。产生溢出的量就是计数器的模，显然，8位二进制数，它的模数为8=256。在计算中，两个互补的数称为“补码”。</p>
<p>  <strong>2）</strong>补码的表示：</p>
<p>　　    正数：正数的补码和原码相同。　　    </p>
<p>​           负数：负数的补码则是符号位为“1”。并且，这个“1”既是符号位，也是数值位。数值部分按位取反后再在末位（最低位）加1。也就是“反码+1”。　　</p>
<p>​           例如： 符号位 数值位　　       [+7]补= 0 0000111    [-7]补= 1 1111001 </p>
<p>　　   补码在微型机中是一种重要的编码形式，请注意：</p>
<p>　　<strong>a：</strong> 采用补码后，可以方便地将减法运算转化成加法运算，运算过程得到简化。正数的补码即是它所表示的数的真值，而负数的补码的数值部份却不是它所表示的数的真值。采用补码进行运算，所得结果仍为补码。</p>
<p>　　<strong>b.：</strong>与原码、反码不同，数值0的补码只有一个，即 [0]补=0 0000000。</p>
<p>　　<strong>c.：</strong>若字长为8位，则补码所表示的范围为-128～+127；进行补码运算时，应注意所得结果不应超过补码所能表示数的范围。</p>
<p><strong>源码、反码和补码之间的转化</strong></p>
<p>​    由于正数的源码、反码、补码表示方法相同，不需转换。</p>
<p>​     在此，仅以负数情况分析。</p>
<p>​     <strong>1）已知原码，求补码</strong></p>
<p>​         例：已知某数X的源码为10110100，试求X的补码和反码。</p>
<p>​         解：由【X】原=10110100看出，X为负数。求其反码时，符号位不变，数值部分按位求反；求其补码时，再在其反码的末位加1。</p>
<p>​         10110100 原码</p>
<p>​         11001011反码，符号位不变，数值取反</p>
<p>​         1+1</p>
<p>​         11001100 补码</p>
<p>​         故：【X】补 = 11001100，【X】反 = 11001011。</p>
<p>​      <strong>2）已知补码，求原码。</strong></p>
<p>​         分析：按照求负数补码的你过程，数值部分应是最低位减1，然后取反。但是对二进制数来说，先减1后取反和先取反后加1得到的结果是一样的，故仍可采用取反加1的方法。</p>
<p>​         例：已知某数X的补码1110110，试求其原码。</p>
<p>​        解：由【X】补 = 11101110知，X为负数。</p>
<p>​         采用逆推法</p>
<p>​         11101110 补码</p>
<p>​         11101101反码（符号位不变，数值取反加1）</p>
<p>​         10010010原码（符号位不变，数值取反）</p>
<p>​          算法2：</p>
<p>​         设源码 =  A；可见A为负数</p>
<p>​         设反码 = B；</p>
<p>​         因为补码 = 反码+1；所以</p>
<p>​          B +1 = 11101110；</p>
<p>​          B = 11101110 - 1 </p>
<p>​            = 11101101;</p>
<p>​          A =B取反（符号位不变） = 10010010；</p>
<p><strong>有符号数运算时的溢出问题，看下下面两个题目</strong></p>
<p>两个数相加怎么变成了负数？？？</p>
<p><strong>1）</strong> （+72）+（+98）=？</p>
<p>　　0 1 0 0 1 0 0 0  +72</p>
<p>　　+</p>
<p>​        0 1 1 0 0 0 1 0  +98</p>
<p>　　1 0 1 0 1 0 1 0  -86　　两负数相加怎么会得出正数？？？ </p>
<p><strong>2）</strong>（-83）+（-80）=？　　</p>
<p>​        1 0 1 0 1 1 0 1 -83</p>
<p>　　+</p>
<p>​        1 0 1 1 0 0 0 0  -80</p>
<p>　　0 1 0 1 1 1 0 1  +93　　</p>
<p>思考：这两个题目，按照正常的法则来运算，但结果显然不正确，这是怎么回事呢？　　</p>
<p>答案：这是因为发生了溢出。　　</p>
<p>如果计算机的字长为n位，n位二进制数的最高位为符号位，其余n-1位为数值位，采用补码表示法时，可表示的数X的范围是 -2的<em>n-1</em>次幂≤X≤2的<em>n-1</em>次幂-1　　</p>
<p>当n=8时，可表示的有符号数的范围为-128～+127。两个有符号数进行加法运算时，如果运算结果超出可表示的有符号数的范围时，就会发生溢出，使计算结果出错。很显然，溢出只能出现在两个同符号数相加或两个异符号数相减的情况下。　　</p>
<p>对于加法运算，如果次高位（数值部分最高位）形成进位加入最高位，而最高位（符号位）相加（包括次高位的进位）却没有进位输出时，或者反过来，次高位没有进位加入最高位，但最高位却有进位输出时，都将发生溢出。因为这两种情况是：两个正数相加，结果超出了范围，形式上变成了负数；两负数相加，结果超出了范围，形式上变成了正数。　</p>
<p>而对于减法运算，当次高位不需从最高位借位，但最高位却需借位（正数减负数，差超出范围），或者反过来，次高位需从最高位借位，但最高位不需借位（负数减正数，差超出范围），也会出现溢出。　　</p>
<p>在计算机中，数据是以补码的形式存储的，所以补码在<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1219.htm">c语言</a>的教学中有比较重要的地位，而讲解补码必须涉及到原码、反码。本部分演示作何一个整数的原码、反码、补码。过程与结果显示在列表框中，结果比较少，不必自动清除，而过程是相同的，没有必要清除。故需设清除各部分及清除全部的按钮。测试时注意最大、最小正负数。用户使用时注意讲解不会溢出：当有一个数的反码的全部位是1才会溢出，那么它的原码是10000…，它不是负数，故不会溢出。　　</p>
<p>在n位的机器数中，最高位为符号位，该位为零表示为正，为一表示为负；其余n-1位为数值位，各位的值可为零或一。当真值为正时，原码、反码、补码数值位完全相同；当真值为负时，原码的数值位保持原样，反码的数值位是原码数值位的各位取反，补码则是反码的最低位加一。注意符号位不变。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h2 id="提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。"><a href="#提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。" class="headerlink" title="提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。"></a>提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。</h2><p>　　1.原码的求法:</p>
<p>​       (1)对于正数,转化为二进制数,在最前面添加一符号位(这是规定的),用1表示负数,0表示正数.如:0000 0000是一个字节,其中0为符号位,表示是正数,其它七位表示二进制的值.其实,机器不管这些,什么符号位还是值,机器统统看作是值来计算. 正数的原码、反码、补码是同一个数!</p>
<p>　　(2)对于负数,转化为二进制数,前面符号位为1.表示是负数.　　计算原码只要在转化的二进制数前面加上相应的符号位就行了.　</p>
<p>​    　2.反码的求法:对于负数,将原码各位取反,符号位不变.　　</p>
<p>​        3.补码的求法:对于负数,将反码加上二进制的1即可,也就是反码在最后一位上加上1就是补码了.</p>
<p>来源： <a target="_blank" rel="noopener" href="https://blog.csdn.net/a1351937368/article/details/77746574/">https://blog.csdn.net/a1351937368/article/details/77746574/</a></p>
<h2 id="位屏蔽"><a href="#位屏蔽" class="headerlink" title="位屏蔽"></a>位屏蔽</h2><p>位屏蔽是指为了检查一个字节中的某些位,可以让这个字节和屏蔽字(<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=bit&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">bit</a> mask)进行按位与操作–屏蔽字中与要检查的位对应的位全部为1,而其余的位(被屏蔽的位)全部为0.<br>为了置位所需要的位,可以让数据和屏蔽字进行按位或操作.<br>为了清除所需的位,可以让数据和对屏蔽字按位取反所得的值进行按位与操作</p>
<p>位屏蔽的含义是从包含多个位集的一个或一组字节中选出指定的一(些)位。为了检查一个字节中的某些位，可以让这个字节和屏蔽字(<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=bit&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">bit</a> mask)进行按位与操作(C的按位与运算符为＆)——屏蔽字中与要检查的位对应的位全部为1，而其余的位(被屏蔽的位)全部为0。例如，为了检查变量flags的最低位，你可以让flags和最低位的屏蔽字进行按位与操作：flags&amp;1；<br>为了置位所需的位，可以让数据和屏蔽字进行按位或操作(C的按位或运算符为|)。例如，你可以这样置位flags的最低位：flags = flags | 1；或者这样：flags |= 1；<br>为了清除所需的位，可以让数据和对屏蔽字按位取反所得的值进行按位与操作。例如，你可以这样清除flags的最低位：flags = flags&amp; <del>1;或者这样：flags&amp;=</del>1 ;</p>
<h1 id="C-说明符与限定符"><a href="#C-说明符与限定符" class="headerlink" title="C++说明符与限定符"></a>C++说明符与限定符</h1><h2 id="说明符"><a href="#说明符" class="headerlink" title="说明符"></a><strong>说明符</strong></h2><p>\1. auto： 在C++11中不再是说明符。在C++11前，auto指出变量为自动变量，但在C++11后，auto用于自动类型推导。</p>
<p>\2. register：用于声明中指示寄存器存储，但在C++11中，它只是显示地指出变量是自动的。</p>
<p>\3. static：静态声明。用在作用域为整个文件的声明中时，表示内部链接行；用于局部声明中，表示无链接性。表示静态存储变量，只要定义过一次，便永久存储（直到程序结束），但是只能在一个函数体和代码块或者一个文件中使用。</p>
<p>\4. extern：引用声明，即声明引用其他地方定义的变量。</p>
<p>\5. thread_local：C++11新增。该变量的生命周期与其所属线程的生命周期一致。thread_local变量之于线程，犹如常规静态变量之于整个程序。</p>
<p>\6. mutable：表面变量是可更改的。即使结构（类）或变量为const类型，其成员也是可以被修改的。</p>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>\1. const：常量声明。const类型变量的连接性为内部的，即所有的文件可以声明相同的const变量。但全局变量默认是外部的。</p>
<p>\2. volatile：表面即使程序代码没有对内存单元做修改，但其值也可能发生了改变。该关键字表面不要对该变量进行优化，程序取值时会去内存中取值。</p>
<h1 id="C-四个cast的用法"><a href="#C-四个cast的用法" class="headerlink" title="C++四个cast的用法"></a>C++四个cast的用法</h1><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static_cast</td>
<td>用于良性转换，一般不会导致意外发生，风险很低。</td>
</tr>
<tr>
<td>const_cast</td>
<td>用于 const 与非 const、volatile 与非 volatile 之间的转换。</td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>借助 RTTI，用于类型安全的向下转型（Downcasting）。</td>
</tr>
</tbody></table>
<p>这四个的使用方式都一样：**T t = XXX_cast<T>(expressions)**。</T></p>
<p><strong>1，****const_cast</strong> 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。</p>
<p>下面我们以 const 为例来说明 const_cast 的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;n);</span><br><span class="line">    *p = <span class="number">234</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p = &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>n = 100<br>*p = 234</p>
<p><code>&amp;n</code>用来获取 n 的地址，它的类型为<code>const int *</code>，必须使用 const_cast 转换为<code>int *</code>类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。</p>
<p>有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的<code>#define</code>，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，第 8 行代码被修改成了下面的形式：</p>
<p>cout&lt;&lt;”n = “&lt;&lt;100&lt;&lt;endl;</p>
<p>这样以来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。</p>
<p>使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。</p>
<p><strong>2<strong><strong>，</strong></strong>static_cast</strong> 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；void <a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等；有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。<br>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。<br>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。</p>
<p>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</p>
<p>下面的代码演示了 static_cast 的正确用法和错误用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//下面是正确的用法</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">12.5</span>, <span class="number">23.8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line">    <span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line">    <span class="keyword">void</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line">    <span class="keyword">double</span> real= <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c);  <span class="comment">//调用类型转换函数</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//下面的用法是错误的</span></span><br><span class="line">    <span class="keyword">float</span> *p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">    p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3，****dynamic_cast</strong> 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。<br>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。<strong>dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</strong></p>
<p>dynamic_cast 的语法格式为：</p>
<p>dynamic_cast <newType> (expression)</newType></p>
<p>newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。</p>
<p>对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出<code>std::bad_cast</code>异常。</p>
<h2 id="1-向上转型（Upcasting）"><a href="#1-向上转型（Upcasting）" class="headerlink" title="1) 向上转型（Upcasting）"></a>1) 向上转型（Upcasting）</h2><p>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了。<br>「向上转型时不执行运行期检测」虽然提高了效率，但也留下了安全隐患，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> a = <span class="number">0</span>): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): <span class="built_in">Base</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    Derived *pd1 = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">35</span>, <span class="number">78</span>);</span><br><span class="line">    Base *pb1 = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(pd1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd1 = &quot;</span>&lt;&lt;pd1&lt;&lt;<span class="string">&quot;, pb1 = &quot;</span>&lt;&lt;pb1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb1-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;</span><br><span class="line">    pb1-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    Derived *pd2 = <span class="keyword">reinterpret_cast</span>&lt;Derived*&gt;(&amp;n);</span><br><span class="line">    Base *pb2 = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(pd2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd2 = &quot;</span>&lt;&lt;pd2&lt;&lt;<span class="string">&quot;, pb2 = &quot;</span>&lt;&lt;pb2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb2-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;  <span class="comment">//输出一个垃圾值</span></span><br><span class="line">    pb2-&gt;<span class="built_in">func</span>();  <span class="comment">//内存错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况①是正确的，没有任何问题。对于情况②，pd 指向的是整型变量 n，并没有指向一个 Derived 类的对象，在使用 dynamic_cast 进行类型转换时也没有检查这一点，而是将 pd 的值直接赋给了 pb（这里并不需要调整偏移量），最终导致 pb 也指向了 n。因为 pb 指向的不是一个对象，所以<code>get_a()</code>得不到 m_a 的值（实际上得到的是一个垃圾值），<code>pb2-&gt;func()</code>也得不到 func() 函数的正确地址。</p>
<blockquote>
<p><code>pb2-&gt;func()</code>得不到 func() 的正确地址的原因在于，pb2 指向的是一个假的“对象”，它没有虚函数表，也没有虚函数表指针，而 func() 是虚函数，必须到虚函数表中才能找到它的地址。</p>
</blockquote>
<h2 id="2-向下转型（Downcasting）"><a href="#2-向下转型（Downcasting）" class="headerlink" title="2) 向下转型（Downcasting）"></a>2) 向下转型（Downcasting）</h2><p>向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。那么，哪些向下转型是安全地呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    B *pb;</span><br><span class="line">    C *pc;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> <span class="built_in">D</span>();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>Downcasting failed: A* to B*<br>Downcasting failed: A* to C*<br>-————————<br>Downcasting successfully: A* to B*<br>Class D<br>Downcasting successfully: A* to C*<br>Class D</p>
<p>这段代码中类的继承顺序为：A –&gt; B –&gt; C –&gt; D。pa 是<code>A*</code>类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为<code>B*</code>或<code>C*</code>类型。当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为<code>B*</code>或<code>C*</code>类型。同样都是向下转型，为什么 pa 指向的对象不同，转换的结果就大相径庭呢？</p>
<p>在《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_2304.html">C++ RTTI机制下的对象内存模型（透彻）</a>》一节中，虚函数存在时对象的真实内存模型中，每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheri<a target="_blank" rel="noopener" href="http://c.biancheng.net/ref/tan.html">tan</a>ce Chain），也就是如下图所示的样子：<img src="/2021/06/27/C/0.829305009718994.png" alt="img"><br>当使用 dynamic_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类)的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p>
<p>对于本例中的情况①，pa 指向 A 类对象，根据该对象找到的就是 A 的类型信息，当程序从这个节点开始向上遍历时，发现 A 的上方没有要转换的 B 类型或 C 类型（实际上 A 的上方没有任何类型了），所以就转换败了。对于情况②，pa 指向 D 类对象，根据该对象找到的就是 D 的类型信息，程序从这个节点向上遍历的过程中，发现了 C 类型和 B 类型，所以就转换成功了。</p>
<p>总起来说，dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。</p>
<p>从表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，dynamic_cast 只是让不同的基类指针指向同一个派生类对象罢了。</p>
<p><strong>4</strong>  <strong>reinterpret_cast 关键字</strong></p>
<p>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</p>
<p>reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。</p>
<p>下面的代码代码演示了 reinterpret_cast 的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将 char* 转换为 float*</span></span><br><span class="line">    <span class="keyword">char</span> str[]=<span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="keyword">float</span> *p1 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">float</span>*&gt;(str);</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//将 int 转换为 int*</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//将 A* 转换为 int*</span></span><br><span class="line">    p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">25</span>, <span class="number">96</span>));</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>3.0262e+29<br>25</p>
<p>可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将<code>A*</code>转换为<code>int*</code>，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。</p>
<h1 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h1><p>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。c++中的友元为封装隐藏这堵不透明的墙开了一个小孔，外界可以通过这个小孔窥视内部的秘密。</p>
<p>友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。 </p>
<h2 id="友元函数-："><a href="#友元函数-：" class="headerlink" title="友元函数 ："></a>友元函数 ：</h2><p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> 类型 函数名(形式参数);</span><br><span class="line">友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。</span><br><span class="line">一个函数可以是多个类的友元函数，只需要在各个类中分别声明。</span><br><span class="line">友元函数的调用与一般函数的调用方式和原理一致。</span><br></pre></td></tr></table></figure>

<h2 id="友元类-："><a href="#友元类-：" class="headerlink" title="友元类 ："></a>友元类 ：</h2><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。 </p>
<p>当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下： </p>
<p>friend class 类名; </p>
<p>其中：friend和class是关键字，类名必须是程序中的一个已定义过的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Radius</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span>;</span>               <span class="comment">//声明Circle为Radius的友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Show_r</span><span class="params">(Radius &amp;n)</span></span>;     <span class="comment">//声明Show_r为友元函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Radius</span>(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Radius</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show_r</span><span class="params">(Radius &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;圆的半径为: &quot;</span>&lt;&lt;n.r&lt;&lt;endl;    <span class="comment">//调用Radius对象的私有成员变量r</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>()    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(Radius a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s = a.r * a.r * <span class="number">3.1415926</span>;             <span class="comment">//调用Radius对象的私有成员变量r</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Radius <span class="title">objRadius</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    Circle objCircle;</span><br><span class="line">    <span class="built_in">Show_r</span>( objRadius );</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;面积为：&quot;</span>&lt;&lt;objCircle.<span class="built_in">area</span>(objRadius)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> 类型 函数名(形式参数);</span><br></pre></td></tr></table></figure>

<p>转载部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、为什么要引入友元函数：在实现类之间数据共享时，减少系统开销，提高效率</span><br><span class="line">  具体来说：为了使其他类的成员函数直接访问该类的私有变量</span><br><span class="line">  即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数</span><br><span class="line">  优点：能够提高效率，表达简单、清晰</span><br><span class="line">  缺点：友元函数破环了封装机制，尽量不使用成员函数，除非不得已的情况下才使用友元函数。</span><br></pre></td></tr></table></figure>

<h2 id="2、什么时候使用友元函数："><a href="#2、什么时候使用友元函数：" class="headerlink" title="2、什么时候使用友元函数："></a>2、什么时候使用友元函数：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)运算符重载的某些场合需要使用友元。</span><br><span class="line">2)两个类要共享数据的时候</span><br></pre></td></tr></table></figure>

<h2 id="3、怎么使用友元函数："><a href="#3、怎么使用友元函数：" class="headerlink" title="3、怎么使用友元函数："></a>3、怎么使用友元函数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">友元函数的参数：</span><br><span class="line">   因为友元函数没有<span class="keyword">this</span>指针，则参数要有三种情况：</span><br><span class="line">   <span class="number">1</span>、  要访问非<span class="keyword">static</span>成员时，需要对象做参数；--常用(友元函数常含有参数)</span><br><span class="line">   <span class="number">2</span>、  要访问<span class="keyword">static</span>成员或全局变量时，则不需要对象做参数</span><br><span class="line">   <span class="number">3</span>、  如果做参数的对象是全局对象，则不需要对象做参数</span><br></pre></td></tr></table></figure>

<p>友元函数的位置：</p>
<p>  因为友元函数是类外的函数，所以它的声明可以放在类的私有段或公有段且没有区别。</p>
<p>友元函数的调用：</p>
<p>  可以直接调用友元函数，不需要通过对象或指针</p>
<p>友元函数的分类：</p>
<p>根据这个函数的来源不同，可以分为三种方法：</p>
<p>1、普通函数友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a) 目的：使普通函数能够访问类的友元</span><br><span class="line">b) 语法：声明位置：公有私有均可，常写为公有</span><br><span class="line">                 声明： <span class="keyword">friend</span> + 普通函数声明</span><br><span class="line">                 实现位置：可以在类外或类中</span><br><span class="line">                 实现代码：与普通函数相同（不加不用<span class="keyword">friend</span>和类::）</span><br><span class="line">                 调用：类似普通函数，直接调用</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INTEGER</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj)</span></span>;<span class="comment">//声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> INTEGER&amp; obj)</span><span class="comment">//不使用friend和类：：</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INTEGER obj;</span><br><span class="line">    <span class="built_in">Print</span>(obj);<span class="comment">//直接调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、类Y的所有成员函数都为类X友元函数—友元类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a）目的：使用单个声明使Y类的所有函数成为类X的友元</span><br><span class="line">       它提供一种类之间合作的一种方式，使类Y的对象可以具有类X和类Y的功能</span><br><span class="line">       具体来说：</span><br><span class="line">       前提：A是B的友元（=》A中成员函数可以访问B中有所有成员，包括私有成员和公有成员--老忘）</span><br><span class="line">       则：在A中，借助类B，可以直接使用～B . 私有变量～的形式访问私有变量</span><br><span class="line">b）语法：声明位置：公有私有均可，常写为私有(把类看成一个变量)</span><br><span class="line">       声明： <span class="keyword">friend</span> + 类名---不是对象啊</span><br><span class="line">       调用：</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">boy</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(girl &amp;)</span></span>;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span> <span class="comment">//函数disp()为类boy的成员函数，也是类girl的友元函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;boy&#x27;s name is:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;age&lt;&lt;endl;<span class="comment">//正常情况，boy的成员函数disp中直接访问boy的私有变量</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;girl&#x27;s name is:&quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;x.age&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span></span><br><span class="line">    <span class="comment">//正常情况下，只允许在girl的成员函数中访问girl的私有变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line">    <span class="keyword">friend</span> boy;   <span class="comment">//声明类boy是类girl的友元 </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">girl</span>();  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    boy b; </span><br><span class="line">    girl g; </span><br><span class="line">    b.<span class="built_in">disp</span>(g);  <span class="comment">//b调用自己的成员函数，但是以g为参数，友元机制体现在函数disp中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、类Y的一个成员函数为类X的友元函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a）目的：使类Y的一个成员函数成为类X的友元</span><br><span class="line">         具体而言：而在类Y的这个成员函数中，借助参数X，可以直接以X。私有变量的形式访问私有变量</span><br><span class="line">  b）语法：声明位置：声明在公有中 （本身为函数）</span><br><span class="line">         声明：<span class="keyword">friend</span> + 成员函数的声明</span><br><span class="line">         调用：先定义Y的对象y---使用y调用自己的成员函数---自己的成员函数中使用了友元机制</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">boy</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">boy</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(girl &amp;)</span></span>;    </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name; </span><br><span class="line">    <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">girl</span>(<span class="keyword">char</span> *N,<span class="keyword">int</span> A); </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;)</span></span>; <span class="comment">//声明类boy的成员函数disp()为类girl的友元函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;boy&#x27;s name is:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;age&lt;&lt;endl;  <span class="comment">//访问自己(boy)的对象成员,直接访问自己的私有变量  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;girl&#x27;s name is:&quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;x.age&lt;&lt;endl; </span><br><span class="line">    <span class="comment">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span></span><br><span class="line">    <span class="comment">//正常情况下，只允许在girl的成员函数中访问girl的私有变量 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">boy <span class="title">b</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">girl <span class="title">g</span><span class="params">()</span></span>; </span><br><span class="line">    b.<span class="built_in">disp</span>(g); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在模板类中使用友元operator&lt;&lt;(对&lt;&lt;运算符的重载)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a)使用方法：</span><br><span class="line">在模板类中声明：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br><span class="line">在模板类中定义：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VexType</span>,<span class="keyword">class</span> <span class="title">ArcType</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b)注意</span><br><span class="line">把函数声明非模板函数：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; cout,<span class="keyword">const</span> MGraph&amp; G); </span><br><span class="line">把函数声明为模板函数：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br><span class="line">或：</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;VexType,ArcType&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>在函数声明中加入operator&lt;&lt; &lt;&gt;：是将operator&lt;&lt;函数定义为函数模板，将函数模板申明为类模板的友员时,是一对一绑定的 </p>
<p>实际的声明函数：这里模板参数可以省略，但是尖括号不可以省略 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;VexType,ArcType&gt;(ostream&amp; cout,<span class="keyword">const</span> MGraph&lt;VexType,ArcType&gt;&amp; G); </span><br></pre></td></tr></table></figure>

<p>5、友元函数和类的成员函数的区别：成员函数有this指针，而友元函数没有this指针。</p>
<p>6、记忆：A是B的友元《=》A是B的朋友《=》借助B的对象，在A中可以直接 通过B。成员变量（可以是公有，也可以为私有变量） 的方式访问B</p>
<hr>
<p>因为友元函数是类外的函数所以友元函数的声明放在了类外或则类内是没有区别的 </p>
<p>友元函数可以直接调用不需要通过对象或者指针</p>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><h2 id="一、什么是拷贝构造函数"><a href="#一、什么是拷贝构造函数" class="headerlink" title="一、什么是拷贝构造函数"></a><strong>一、什么是拷贝构造函数</strong></h2><p>  首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b=a;</span><br></pre></td></tr></table></figure>

<p> 而类对象与普通对象不同，类对象内部结构一般较为复杂，存在各种成员变量。<br> 下面看一个类对象拷贝的简单例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行程序，屏幕输出100。从以上代码的运行结果可以看出，系统为对象 B 分配了内存并完成了与对象 A 的复制过程。就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。<br> <img src="/2021/06/27/C/0.24860487489486371.png" alt="img"><br> CExample(const CExample&amp; C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种<strong>特殊的****构造函数</strong>，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个<strong>引用变量</strong>。</p>
<h2 id="二、拷贝构造函数的调用时机"><a href="#二、拷贝构造函数的调用时机" class="headerlink" title="二、拷贝构造函数的调用时机"></a><strong>二、拷贝构造函数的调用时机</strong></h2><h3 id="1-当函数的参数为类的对象时"><a href="#1-当函数的参数为类的对象时" class="headerlink" title="1. 当函数的参数为类的对象时"></a>1. 当函数的参数为类的对象时</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">(CExample c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;g_func&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">A</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    CExample B=A;</span><br><span class="line">    B.<span class="built_in">Show</span>(); </span><br><span class="line">    <span class="built_in">g_fun</span>(A);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> **调用g_fun()时，会产生以下几个重要步骤：<br>(1).A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。<br>(2).然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);<br>(3).等g_fun()执行完后, 析构掉 C 对象。 </p>
<p>  <img src="/2021/06/27/C/0.8089142535956775.png" alt="img">**</p>
<h3 id="2-函数的返回值是类的对象"><a href="#2-函数的返回值是类的对象" class="headerlink" title="2. 函数的返回值是类的对象"></a>2. 函数的返回值是类的对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">     a=b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">     a=c.a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;copy constructor is called\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CExample</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;destructor is called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">CExample <span class="title">g_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CExample <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">g_fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当g_Fun()函数执行到return时，会产生以下几个重要步骤：<br>(1). 先会产生一个临时变量，就叫XXXX吧。<br>(2). 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);<br>(3). 在函数执行到最后先析构temp局部变量。<br>(4). 等g_fun()执行完后再析构掉XXXX对象。<br> <img src="/2021/06/27/C/0.4009268745368213.png" alt="img"></strong></p>
<h3 id="3-对象需要通过另外一个对象进行初始化"><a href="#3-对象需要通过另外一个对象进行初始化" class="headerlink" title="3. 对象需要通过另外一个对象进行初始化"></a>3. 对象需要通过另外一个对象进行初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CExample A(100); CExample B=A;</span><br></pre></td></tr></table></figure>



<h2 id="三、浅拷贝与深拷贝"><a href="#三、浅拷贝与深拷贝" class="headerlink" title="三、浅拷贝与深拷贝"></a>三、浅拷贝与深拷贝</h2><h3 id="1-默认拷贝构造函数"><a href="#1-默认拷贝构造函数" class="headerlink" title="1. 默认拷贝构造函数"></a>1. 默认拷贝构造函数</h3><p>  很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rect::<span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r) </span><br><span class="line">&#123;    </span><br><span class="line">width=r.width;    </span><br><span class="line">height=r.height; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了，让我们来考虑以下一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Rect::count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码对前面的类，加入了一个静态成员，目的是进行计数。</p>
<p>在主函数中，首先创建对象rect1，输出此时的对象个数，然后使用rect1复制出对象rect2，再输出此时的对象个数，按照理解，此时应该有两个对象存在，但实际程序运行时，输出的都是1，反应出只有1个对象。</p>
<p>此外，在销毁对象时，由于会调用销毁两个对象，类的析构函数会调用两次，此时的计数器将变为负数。</p>
<p>说白了，就是拷贝构造函数没有处理静态数据成员。出现这些问题最根本就在于在复制对象时，计数器没有递增，我们重新编写拷贝构造函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">        width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Rect::count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The count of Rect:&quot;</span>&lt;&lt;Rect::<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2. 浅拷贝"></a><strong>2. 浅拷贝</strong></h3><p>  所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了，让我们考虑如下一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码运行结束之前，会出现一个运行错误。原因就在于在进行对象复制时，对于动态分配的内容没有进行正确的操作。我们来分析一下：</p>
<p>  在运行定义rect1对象后，由于在构造函数中有一个动态分配的语句，因此执行后的内存情况大致如下：</p>
<p>   <img src="/2021/06/27/C/0.737730505979939.png" alt="img"><br> 在使用rect1复制rect2时，由于执行的是浅拷贝，只是将成员的值进行赋值，这时 rect1.p = rect2.p，也即这两个指针指向了堆里的同一个空间，如下图所示：<br>  <img src="/2021/06/27/C/0.6941223025580505.png" alt="img"></p>
<p> 当然，这不是我们所期望的结果，在销毁对象时，两个对象的析构函数将对同一个内存空间释放两次，这就是错误出现的原因。我们需要的不是两个p有相同的值，而是两个p指向的空间有相同的值，解决办法就是使用“深拷贝”。</p>
<h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3. 深拷贝"></a><strong>3. 深拷贝</strong></h3><p> 在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间，如上面的例子就应该按照如下的方式进行处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Rect</span>(<span class="keyword">const</span> Rect&amp; r)</span><br><span class="line">    &#123;</span><br><span class="line">     width=r.width;</span><br><span class="line">        height=r.height;</span><br><span class="line">     p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);</span><br><span class="line">        *p=*(r.p);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ~<span class="built_in">Rect</span>()</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">assert</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect rect1;</span><br><span class="line">    <span class="function">Rect <span class="title">rect2</span><span class="params">(rect1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，在完成对象的复制后，内存的一个大致情况如下：<br>  <img src="/2021/06/27/C/0.41521417522049453.png" alt="img"><br>此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。</p>
<h3 id="3-防止默认拷贝发生"><a href="#3-防止默认拷贝发生" class="headerlink" title="3. 防止默认拷贝发生"></a><strong>3. 防止默认拷贝发生</strong></h3><p>  通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——<strong>声明一个私有拷贝构造函数</strong>。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止按值传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">int</span> b) </span><br><span class="line">    &#123; </span><br><span class="line">        a = b; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;creat: &quot;</span>&lt;&lt;a&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//拷贝构造函数，只是声明</span></span><br><span class="line">    <span class="built_in">CExample</span>(<span class="keyword">const</span> CExample&amp; C); </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~<span class="built_in">CExample</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;delete: &quot;</span>&lt;&lt;a&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout&lt;&lt;a&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//???? </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_Fun</span><span class="params">(CExample C)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;test&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">CExample <span class="title">test</span><span class="params">(<span class="number">1</span>)</span></span>; </span><br><span class="line">    <span class="comment">//g_Fun(test);   //按值传递将出错</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>  拷贝有两种：深拷贝，浅拷贝。</p>
<p>   当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但<strong>当数据成员中有指针时</strong>，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。</p>
<p>   深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。<strong>简而言之，当数据成员中有指针时，必须要用深拷贝</strong>。</p>
<h2 id="四、拷贝构造函数的几个细节"><a href="#四、拷贝构造函数的几个细节" class="headerlink" title="四、拷贝构造函数的几个细节"></a>四、拷贝构造函数的几个细节</h2><h3 id="1-为什么拷贝构造函数必须是引用传递，不能是值传递？"><a href="#1-为什么拷贝构造函数必须是引用传递，不能是值传递？" class="headerlink" title="1.为什么拷贝构造函数必须是引用传递，不能是值传递？"></a>1.为什么拷贝构造函数必须是引用传递，不能是值传递？</h3><p>   简单的回答是为了防止递归引用。<br>     具体一些可以这么讲：<br>     当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。</p>
<h3 id="2-拷贝构造函数的作用。"><a href="#2-拷贝构造函数的作用。" class="headerlink" title="2. 拷贝构造函数的作用。"></a><strong>2. 拷贝构造函数的作用。</strong></h3><p>​      作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</p>
<h3 id="3-参数传递过程到底发生了什么？"><a href="#3-参数传递过程到底发生了什么？" class="headerlink" title="3.参数传递过程到底发生了什么？"></a>3.参数传递过程到底发生了什么？</h3><p>​    将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！<br>   i)值传递:<br>​     对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；<br>​     对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用<br>   ii)引用传递:<br>​    无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).</p>
<h3 id="4-在类中有指针数据成员时，拷贝构造函数的使用？"><a href="#4-在类中有指针数据成员时，拷贝构造函数的使用？" class="headerlink" title="4. 在类中有指针数据成员时，拷贝构造函数的使用？"></a>4. 在类中有指针数据成员时，拷贝构造函数的使用？</h3><p>如果不显式声明拷贝构造函数的时候，编译器也会生成一个默认的拷贝构造函数，而且在一般的情况下运行的也很好。但是在遇到类有指针数据成员时就出现问题 了：因为默认的拷贝构造函数是按成员拷贝构造，这导致了两个不同的指针(如ptr1=ptr2)指向了相同的内存。当一个实例销毁时，调用析构函数 free(ptr1)释放了这段内存，那么剩下的一个实例的指针ptr2就无效了，在被销毁的时候free(ptr2)就会出现错误了, 这相当于重复释放一块内存两次。这种情况必须显式声明并实现自己的拷贝构造函数，来为新的实例的指针分配新的内存。</p>
<p>问题1和2回答了为什么拷贝构造函数使用值传递会产生无限递归调用的问题；<br>问题3回答了在类中有指针数据成员时，拷贝构造函数使用值传递等于显式定义了拷贝构造函数，因为默认的拷贝构造函数就是这么干的。</p>
<h3 id="5-拷贝构造函数里能调用private成员变量吗"><a href="#5-拷贝构造函数里能调用private成员变量吗" class="headerlink" title="5. 拷贝构造函数里能调用private成员变量吗?"></a>5. 拷贝构造函数里能调用private成员变量吗?</h3><p>解答：<strong>这个问题是在网上见的，当时一下子有点晕。其时从名子我们就知道拷贝构造函数其时就是一个特殊的</strong>构造函数**，操作的还是自己类的成员变量，所以不受private的限制。</p>
<h3 id="6-以下函数哪个是拷贝构造函数-为什么"><a href="#6-以下函数哪个是拷贝构造函数-为什么" class="headerlink" title="6. 以下函数哪个是拷贝构造函数,为什么?"></a>6. 以下函数哪个是拷贝构造函数,为什么?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X::X(const X&amp;);   //拷贝构造函数</span><br><span class="line">X::X(X); </span><br><span class="line">X::X(X&amp;, int a=1);   //拷贝构造函数</span><br><span class="line">X::X(X&amp;, int a=1, int b=2);  //拷贝构造函数</span><br></pre></td></tr></table></figure>

<p>  **<em>*解答：*<em>对于一个类X, 如果一个构造函数的第一个参数是下列之一:<br>  a) X&amp;<br>  b) const X&amp;<br>  c) volatile X&amp;<br>  d) const volatile X&amp;<br>  且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.</em></em></p>
<h3 id="7-一个类中可以存在多于一个的拷贝构造函数吗"><a href="#7-一个类中可以存在多于一个的拷贝构造函数吗" class="headerlink" title="7. 一个类中可以存在多于一个的拷贝构造函数吗?"></a>7. 一个类中可以存在多于一个的拷贝构造函数吗?</h3><p>  解答：**类中可以存在超过一个拷贝构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class X &#123; </span><br><span class="line">public: </span><br><span class="line">  X(const X&amp;); // const 的拷贝构造 </span><br><span class="line">  X(X&amp;); // 非const的拷贝构造 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  注意,如果一个类中只存在一个参数为 X&amp; 的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.<br> 如果一个类中没有定义拷贝构造函数,那么编译器会自动产生一个默认的拷贝构造函数。<br> 这个默认的参数可能为 X::X(const X&amp;)或 X::X(X&amp;),由编译器根据上下文决定选择哪一个。</p>
<p>来源： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8459250.html">https://www.cnblogs.com/alantu2018/p/8459250.html</a></p>
<h1 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;拷贝构造\n&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = a.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = a.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;赋值构造\n&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = a.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = a.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">int</span> t) &#123;</span><br><span class="line">        x = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span> (<span class="number">0</span>);</span><br><span class="line">        y = t;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;address: %x, point: %x, value: %d\n&quot;</span>, <span class="keyword">this</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;delete %x\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ret</span> <span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;stack address: %x, point: %x, value: %d\n&quot;</span>, &amp;ret, ret.x, ret.y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.对象以值传递方式从函数返回，且接受返回值的对象已经初始化过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A c;</span><br><span class="line">    c = <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;global address: %x, point: %x, value: %d\n&quot;</span>, &amp;c, c.x, c.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/4ce1da14-4554-44cb-a0be-a56eefe7309a.png" alt="img"></p>
<p>2.对象直接赋值给另一个对象，且接受值的对象已经初始化过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    A c;</span><br><span class="line">    c = a;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;global address: %x, point: %x, value: %d\n&quot;</span>, &amp;c, c.x, c.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/4f4fa877-8c19-42e6-86c9-698319f2197e.png" alt="img"></p>
<p>总结</p>
<p>对象以值传递方式从函数返回时，若接受返回值的对象已经初始化过，则会调用赋值构造函数，且该对象还会调用析构函数，当对象中包含指针时，会使该指针失效，因此需要重载赋值构造函数，使用类似深拷贝或移动构造函数的方法赋值，才能避免指针失效。</p>
<h1 id="stdcall、-cdcel和-fastcall三者的区别"><a href="#stdcall、-cdcel和-fastcall三者的区别" class="headerlink" title="_stdcall、__cdcel和__fastcall三者的区别"></a>_stdcall、__cdcel和__fastcall三者的区别</h1><blockquote>
<p>__stdcall、__cdecl和__fastcall是三种<mark class="hl-label blue">函数调用协议</mark>  ，函数调用协议会影响函数参数的入栈方式、栈内数据的清除方式、编译器函数名的修饰规则等。 </p>
</blockquote>
<ol>
<li>调用协议常用场合</li>
<li><ol>
<li>__stdcall：Windows API默认的函数调用协议。</li>
<li>__cdecl：C/C++默认的函数调用协议。</li>
<li>__fastcall：适用于对性能要求较高的场合。</li>
</ol>
</li>
<li>函数参数入栈方式</li>
<li><ol>
<li>__stdcall：函数参数由右向左入栈。</li>
<li>__cdecl：函数参数由右向左入栈。</li>
<li>__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。</li>
<li>问题一：__fastcall在寄存器中放入不大于4字节的参数，故性能较高，适用于需要高性能的场合。</li>
</ol>
</li>
<li>栈内数据清除方式</li>
<li><ol>
<li>__stdcall：函数调用结束后由被调用函数清除栈内数据。</li>
<li>__cdecl：函数调用结束后由函数调用者清除栈内数据。</li>
<li>__fastcall：函数调用结束后由被调用函数清除栈内数据。</li>
<li>问题一：不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。</li>
<li>问题二：某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。</li>
<li>问题三：由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。</li>
</ol>
</li>
<li>C语言编译器函数名称修饰规则</li>
<li><ol>
<li>__stdcall：编译后，函数名被修饰为“_functionname@number”。</li>
<li>__cdecl：编译后，函数名被修饰为“_functionname”。</li>
<li>__fastcall：编译后，函数名给修饰为“@functionname@nmuber”。</li>
<li>注：“functionname”为函数名，“number”为参数字节数。</li>
<li>注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。</li>
</ol>
</li>
<li>C++语言编译器函数名称修饰规则</li>
<li><ol>
<li>__stdcall：编译后，函数名被修饰为“?functionname@@YG******@Z”。</li>
<li>__cdecl：编译后，函数名被修饰为“?functionname@@YA******@Z”。</li>
<li>__fastcall：编译后，函数名被修饰为“?functionname@@YI******@Z”。</li>
<li>注：“******”为函数返回值类型和参数类型表。</li>
<li>注：函数实现和函数定义时如果使用了不同的函数调用协议，则无法实现函数调用。</li>
<li>C语言和C++语言间如果不进行特殊处理，也无法实现函数的互相调用。</li>
</ol>
</li>
</ol>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><p>赋值操作是在两个已经存在的对象间进行的，而<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>是要创建一个新的对象（可以用构造），并且其初值来源于另一个已存在的对象。<br>int a=12 ; //<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>, copy 0X000C to a<br>a =12 ; //赋值, copy 0X000C to a</p>
<p>1、<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态变量</a>在定义时未显式地指定初值，则自动<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%88%9D%E5%A7%8B%E5%8C%96&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">初始化</a>为相应类型的零值（数e799bee5baa6e79fa5e98193e78988e69d8331333361323562值型为0或0.0；字符型为’\0’），即<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态变量</a>能够自动初始化（有称之为隐式初始化），且<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">静态变量</a>只初始化一次。静态变量定义时显式地指定了值，则其初值为指定的值。定义时无论是否显式地指定了初始值，都只能被初始化一次。但可以通过赋值的方式多次修改静态变量的值。</p>
<p>2、初始化与赋值是不同的概念。</p>
<p>静态变量的初始化是在编译时进行，变量的赋值是在函数或程序运行时进行。静态变量只初始化一次，但可以通过赋值的方式多次修改静态变量的值。</p>
<h1 id="C-中new一个类的指针，有何没有括号有什么区别"><a href="#C-中new一个类的指针，有何没有括号有什么区别" class="headerlink" title="C++中new一个类的指针，有何没有括号有什么区别"></a>C++中new一个类的指针，有何没有括号有什么区别</h1><h2 id="一、-中括号的情况。"><a href="#一、-中括号的情况。" class="headerlink" title="一、 中括号的情况。"></a>一、 中括号的情况。</h2><p>中括号是用来标示申请的是一个对象，还是一组对象。<br>1 没有中括号时，即ptest = new test; 这时ptest得到的是一个对象*ptest， 释放时使用delete ptest;<br>2 带有中括号时，在中括号中需要有一个正整数参数。<br>ptest = new test[N];<br>N可以是变量，也可以是常量。<br>这时申请到的ptest指向的空间是N个连续的对象ptest[0],ptest[1]…ptest[N-1]，即可以当做一个数组使用。<br>释放时需要调用delete [] ptest;</p>
<h2 id="二、小括号的情况。"><a href="#二、小括号的情况。" class="headerlink" title="二、小括号的情况。"></a>二、小括号的情况。</h2><p>小括号是用来指定初始化参数，用于类指针时，就是指定调用哪个构造函数。</p>
<h3 id="1-有小括号时，小括号中可以有若干参数，也可以没有参数。"><a href="#1-有小括号时，小括号中可以有若干参数，也可以没有参数。" class="headerlink" title="1 有小括号时，小括号中可以有若干参数，也可以没有参数。"></a>1 有小括号时，小括号中可以有若干参数，也可以没有参数。</h3><p>比如<br>ptest = new test();  这样在构造时就会调用无参构造test();<br>ptest = new test(1); 就会调用构造函数test(int)，即一个整型参数的构造函数。</p>
<h3 id="2-没有小括号时，默认调用无参构造。"><a href="#2-没有小括号时，默认调用无参构造。" class="headerlink" title="2 没有小括号时，默认调用无参构造。"></a>2 没有小括号时，默认调用无参构造。</h3><p>即<br>ptest = new test;<br>和ptest = new test();是一样的。</p>
<h1 id="浮点数存储"><a href="#浮点数存储" class="headerlink" title="浮点数存储"></a>浮点数存储</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 浮点数存储</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 1.浮点数如何存储：符号位 指数位 尾数位</span></span><br><span class="line"><span class="comment">	 2.如何将十进制浮点数转换成二进制</span></span><br><span class="line"><span class="comment">	 3.将二进制浮点数存储在一组字节中</span></span><br><span class="line"><span class="comment">	 4.如何将浮点数以二进制输出</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//《2》.将十进制整数转换为二进制</span></span><br><span class="line">	<span class="function">bitset&lt;16&gt; <span class="title">myset</span><span class="params">(<span class="number">443</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; myset &lt;&lt; endl;<span class="comment">//0000000110111011</span></span><br><span class="line">	<span class="comment">/*将十进制浮点数转换为二进制</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	以20.5和20.3为例</span></span><br><span class="line"><span class="comment">	浮点数转二进制，先转整数部分(除2)，再转小数部分(乘2)；</span></span><br><span class="line"><span class="comment">	20.5-&gt;20 and 0.5</span></span><br><span class="line"><span class="comment">	20  -&gt; 10100   note:16+4,16-&gt;10000,4-&gt;100</span></span><br><span class="line"><span class="comment">	0.5 -&gt; 0.5*2=1.0 取整数部分1，用结果减去整数部分1=0</span></span><br><span class="line"><span class="comment">		   0  *2=0   取整数部分0，用结果减去整数部分0=0</span></span><br><span class="line"><span class="comment">		   0  *2=0   取整数部分0，用结果减去整数部分0=0</span></span><br><span class="line"><span class="comment">		   ————————————————————</span></span><br><span class="line"><span class="comment">		   0.5-&gt;0.1</span></span><br><span class="line"><span class="comment">	20.5-&gt;10100.1(二进制)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	20.3-&gt;20 and 0.3</span></span><br><span class="line"><span class="comment">	20  -&gt; 10100   note:16+4,16-&gt;10000,4-&gt;100</span></span><br><span class="line"><span class="comment">	0.3 -&gt; 0.3*2=0.6 取整数部分0，用结果减去整数部分0=0.6</span></span><br><span class="line"><span class="comment">	       0.6*2=1.2 取整数部分1，用结果减去整数部分1=0.2</span></span><br><span class="line"><span class="comment">		   0.2*2=0.4 取整数部分0，用结果减去整数部分0=0.4</span></span><br><span class="line"><span class="comment">		   0.4*2=0.8 取整数部分0，用结果减去整数部分0=0.8</span></span><br><span class="line"><span class="comment">		   0.8*2=1.6 取整数部分1，用结果减去整数部分1=0.6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		   0.6*2=1.2 取整数部分1，用结果减去整数部分1=0.2</span></span><br><span class="line"><span class="comment">		   0.2*2=0.4 取整数部分0，用结果减去整数部分0=0.4</span></span><br><span class="line"><span class="comment">		   0.4*2=0.8 取整数部分0，用结果减去整数部分0=0.8</span></span><br><span class="line"><span class="comment">		   0.8*2=1.6 取整数部分1，用结果减去整数部分1=0.6</span></span><br><span class="line"><span class="comment">		   ...无限循环...</span></span><br><span class="line"><span class="comment">		   ————————————————————</span></span><br><span class="line"><span class="comment">		   0.3-&gt;0.010011001...1001</span></span><br><span class="line"><span class="comment">	20.3-&gt;10100.010011001...1001(二进制)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*《3》.将二进制浮点数存储在一组字节中，如float存入4个字节，double存入8个字节</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	20.5-&gt;10100.1-&gt;1.01001E100 (2^4) E表示2的n次方，不是10的n次方了</span></span><br><span class="line"><span class="comment">	存储方式（float）:0-10000011-01001000000000000000000</span></span><br><span class="line"><span class="comment">	移位存储指数位：float 127 double 1023  + 指实际计算的100才是存储的指数位</span></span><br><span class="line"><span class="comment">					127-&gt;01111111   1023-&gt;01111111111</span></span><br><span class="line"><span class="comment">					所以在这的指数位应该是：01111111+100=10000011</span></span><br><span class="line"><span class="comment">					在使用的时候，指数位会减去127，变成实际需要的100(2^4)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	20.3-&gt;10100.010011001...1001-&gt;1.0100010011001...E100</span></span><br><span class="line"><span class="comment">	存储方式（float）:0-10000011-01000100110011001100110</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	float 20.5 == double 20.5 但是 float 20.3 != double 20.3?</span></span><br><span class="line"><span class="comment">	20.5-&gt;10100.1-&gt;1.01001E100 (2^4) </span></span><br><span class="line"><span class="comment">	存储方式（double）:0-10000000011-01001000000000000000000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	20.3-&gt;10100.010011001...1001-&gt;1.0100010011001...E100</span></span><br><span class="line"><span class="comment">	存储方式（double）:0-10000000011-010001001100110011001...1001...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	所以float 20.5==double 20.5 但是 float 20.3 == double 20.3，为什么？</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	在比较的时候对应部分比较，相同的数，不同类型，如float 20.5==double 20.5，</span></span><br><span class="line"><span class="comment">	符号位相同，指数位转换成</span></span><br><span class="line"><span class="comment">	float：00000100</span></span><br><span class="line"><span class="comment">	double：000000000100</span></span><br><span class="line"><span class="comment">	比较的时候前面补0，所以指数位也一样，而尾数位01001后面都是0，不管多少位结果都一样，</span></span><br><span class="line"><span class="comment">	所以float 20.5 == double 20.5 </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	而20.3呢，符号位和指数位相等，但是尾数位不同，一个是010001001一共23位，后面补0，</span></span><br><span class="line"><span class="comment">	而double是010001001一共52位，两者不同，所以float 20.3 != double 20.3</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	double强转float：</span></span><br><span class="line"><span class="comment">	0-10000000011-010001001100110011001...1001...</span></span><br><span class="line"><span class="comment">	0-10000011-01000100110011001100110</span></span><br><span class="line"><span class="comment">	会将指数位先还原成100，再+127，尾数位直接截断</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*《4》 如何将浮点数以二进制输出</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">float</span> v1 = <span class="number">20.5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *n = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(&amp;v1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float 20.5:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*n &gt;&gt; i &amp; <span class="number">1</span>)&lt;&lt;(i==<span class="number">31</span>|| i==<span class="number">23</span> ?<span class="string">&quot;-&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> v2 = <span class="number">20.3</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *m = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(&amp;v2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float 20.3:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*m &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (i == <span class="number">31</span> || i == <span class="number">23</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> v3 = <span class="number">20.5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *k = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *)(&amp;v3);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double 20.5:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*k &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (i == <span class="number">52</span> || i == <span class="number">63</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> v4 = <span class="number">20.3</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *p= (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  *)(&amp;v4);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double 20.3:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; (*p &gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (i == <span class="number">52</span> || i == <span class="number">63</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 1 </span></span></span><br></pre></td></tr></table></figure>

<h1 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#if 0 宽字符</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;C++ 宽字符&quot; &lt;&lt; endl;</span><br><span class="line">	/*</span><br><span class="line">	以前的宽字符：</span><br><span class="line">		wchar_t L</span><br><span class="line">	C++11;</span><br><span class="line">		char16_t u</span><br><span class="line">		char32_t U</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	char c = &#x27;a&#x27;;</span><br><span class="line">	wchar_t c1 = L&#x27;a&#x27;;</span><br><span class="line">	char16_t c2 = u&#x27;a&#x27;;</span><br><span class="line">	char32_t c3 = U&#x27;a&#x27;;</span><br><span class="line">	cout &lt;&lt; &quot;char size = &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;wchar_t size = &quot; &lt;&lt; sizeof(c1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;char16_t size = &quot; &lt;&lt; sizeof(c2) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;char32_t size = &quot; &lt;&lt; sizeof(c3) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;//输出a</span><br><span class="line">	cout &lt;&lt; (int)c &lt;&lt; endl;//输出97，ascii码</span><br><span class="line">	wcout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	char16_t cc = u&#x27;中&#x27;;</span><br><span class="line">	cout &lt;&lt; cc &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;\u4e2d&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	//不能输出中文</span><br><span class="line">	wcout &lt;&lt; cc &lt;&lt; endl;//十进制20013，转为二进制是4e2d</span><br><span class="line">	//wcout &lt;&lt; (wchar_t)cc &lt;&lt; endl;//不会输出</span><br><span class="line">	wcout &lt;&lt; c2 &lt;&lt; endl;//输出97，ascii码</span><br><span class="line">	wcout &lt;&lt; (wchar_t)c2 &lt;&lt; endl;//输出a</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;中各个&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif // 0</span><br></pre></td></tr></table></figure>

<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#if 0 初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;C++ 初始化&quot; &lt;&lt; endl;</span><br><span class="line">	//C++98 </span><br><span class="line">	float fl(30.5);</span><br><span class="line">	//fl(11.2);不允许</span><br><span class="line">	int i_a = &#123; 1 &#125;;</span><br><span class="line">	cout &lt;&lt; &quot;i_a = &quot; &lt;&lt; i_a &lt;&lt; endl;</span><br><span class="line">	i_a = &#123; 3 &#125;;//允许</span><br><span class="line">	cout &lt;&lt; &quot;i_a = &quot; &lt;&lt; i_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	//C++ 11</span><br><span class="line">	int i_b&#123; 20 &#125;;</span><br><span class="line">	cout &lt;&lt; &quot;i_b = &quot; &lt;&lt; i_b &lt;&lt; endl;</span><br><span class="line">	int i_c&#123;&#125;;//默认值</span><br><span class="line">	cout &lt;&lt; &quot;i_c = &quot; &lt;&lt; i_c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif // 1 </span><br></pre></td></tr></table></figure>

<h1 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if 0 自动类型转换</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	将一个值赋给某一类型的变量时</span><br><span class="line">	表达式中有多种类型，会自动类型转换为取值范围最大的类型</span><br><span class="line">	当传递参数值到函数或者方法中时</span><br><span class="line">	*/</span><br><span class="line">	short s_v = 20;</span><br><span class="line">	int i_v = 20.3;</span><br><span class="line"></span><br><span class="line">	//传统C语言强制类型转换</span><br><span class="line">	// C++中的强制类型转换</span><br><span class="line">	// 强制类型转换操作符static_cast&lt;typeName&gt;(Var)</span><br><span class="line">	int x = 11;</span><br><span class="line">	char c&#123; (char)x &#125;;//传统C语言强制类型转换</span><br><span class="line">	int y = 98;</span><br><span class="line">	char c1&#123; char(y) &#125;;	// C++中的强制类型转换</span><br><span class="line">	char z = static_cast&lt;char&gt;(x);	// 强制类型转换操作符static_cast&lt;typeName&gt;(Var)</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif // 1 </span><br></pre></td></tr></table></figure>

<h1 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h1><p>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，</p>
<p>但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，</p>
<p>如外部变量。</p>
<h1 id="sizeof-和-strlen-的区别"><a href="#sizeof-和-strlen-的区别" class="headerlink" title="sizeof 和 strlen 的区别"></a>sizeof 和 strlen 的区别</h1><p>sizeof 和 strlen 有以下区别：</p>
<p>1 sizeof 是一个操作符，strlen 是库函数。</p>
<p>2 sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。</p>
<p>3 编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。</p>
<p>4 数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。</p>
<h1 id="typdef和define区别"><a href="#typdef和define区别" class="headerlink" title="typdef和define区别"></a>typdef和define区别</h1><p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<p>typedef (int*) pINT;</p>
<p>#define pINT2 int*</p>
<p>效果相同？实则不同！实践中见差别：pINT a,b;的效果同int *a; int *b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。</p>
<h1 id="malloc-和-new-有以下不同："><a href="#malloc-和-new-有以下不同：" class="headerlink" title="malloc 和 new 有以下不同："></a>malloc 和 new 有以下不同：</h1><p>（1）  new、delete 是操作符，可以重载，只能在 C++中使用。</p>
<p>（2）  malloc对开辟的空间大小严格指定，而new只需要对象名</p>
<p>（2） malloc、free 是函数，可以覆盖，C、C++中都可以使用。</p>
<p>（3） new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。</p>
<p>（4） malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数</p>
<p>（5） new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。</p>
<p>malloc/free是库函数，new/delete是C++运算符。对于非内部数据类型而言，光用malloc/free无法满足动态对象都要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。</p>
<h1 id="引用作为函数参数以及返回值的好处"><a href="#引用作为函数参数以及返回值的好处" class="headerlink" title="引用作为函数参数以及返回值的好处"></a>引用作为函数参数以及返回值的好处</h1><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）</p>
<h2 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h2><p>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，</p>
<p>不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</p>
<h2 id="指针传递："><a href="#指针传递：" class="headerlink" title="指针传递："></a>指针传递：</h2><p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</p>
<h2 id="引用传递："><a href="#引用传递：" class="headerlink" title="引用传递："></a>引用传递：</h2><p>形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。什么是</p>
<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。</p>
<p>成因：</p>
<p>1）指针变量没有被初始化</p>
<p>2）指针指向的内存被释放了，但是指针没有置NULL</p>
<p>3）指针超过了变量了的作用范围，比如b[10]，指针b+11</p>
<h1 id="C-的空类有哪些成员函数"><a href="#C-的空类有哪些成员函数" class="headerlink" title="C++的空类有哪些成员函数"></a>C++的空类有哪些成员函数</h1><p> 缺省构造函数。</p>
<p> 缺省拷贝构造函数。</p>
<p> 缺省析构函数。</p>
<p> 缺省赋值运算符。</p>
<h1 id="拷贝构造函数和赋值运算符的认识"><a href="#拷贝构造函数和赋值运算符的认识" class="headerlink" title="拷贝构造函数和赋值运算符的认识"></a>拷贝构造函数和赋值运算符的认识</h1><p>拷贝构造函数和赋值运算符重载有以下两个不同之处：</p>
<p>（1） 拷贝构造函数生成新的类对象，而赋值运算符不能。</p>
<p>（2） 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉</p>
<p>注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</p>
<p>在默认情况下（用户没有定义，但是也没有显式的删除），编译器会自动的隐式生成一个拷贝构造函数和赋值运算符。但如果用户将拷贝构造函数和赋值运算符定义成私有的（private），则用户不能使用拷贝构造和对象赋值。可以使用delete来指定不生成拷贝构造函数和赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示无法调用该函数，它是已删除的函数。</p>
<p><strong>注意：拷贝构造函数必须以引用的方式传递参数。这是因为以值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参（创建副本临时变量）。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。</strong></p>
<h1 id="C-中指针和引用的区别"><a href="#C-中指针和引用的区别" class="headerlink" title="C++中指针和引用的区别"></a>C++中指针和引用的区别</h1><p>1、引用概念上是定义一个变量的别名，而指针是存储一个变量的地址。</p>
<p>2、引用在定义时必须要初始化，但是指针没有要求。</p>
<p>3、引用在初始化时引用一个实体后，就不能再引用其他实体，因为其本质是一个指针常量，无法改变指向。而指针可以在任何时候指向任何一个同类型实体。</p>
<p>4、没有NULL引用，但有NULL指针。</p>
<p>5、在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是空地址空间所占字节个数（32位平台下占用4个字节，64位占用8字节）。</p>
<p>6、引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。</p>
<p>7、有多级指针，但是没有多级引用。</p>
<p>8、访问实体方式不同，指针需要显示解引用，引用则由编译器自己处理。</p>
<p>9、引用比指针使用起来相对安全。</p>
<h1 id="结构体struct和共同体union（联合）的区别"><a href="#结构体struct和共同体union（联合）的区别" class="headerlink" title="结构体struct和共同体union（联合）的区别"></a>结构体struct和共同体union（联合）的区别</h1><p>结构体：将不同类型的数据组合成一个整体，是自定义类型</p>
<p>共同体：不同类型的几个变量共同占用一段内存</p>
<p>1）结构体中的每个成员都有自己独立的地址，它们是同时存在的；</p>
<p>共同体中的所有成员占用同一段内存，它们不能同时存在；</p>
<p>2）sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度、</p>
<h1 id="结构体为什么要内存对齐呢？"><a href="#结构体为什么要内存对齐呢？" class="headerlink" title="结构体为什么要内存对齐呢？"></a>结构体为什么要内存对齐呢？</h1><p>1.平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p>
<p>2.硬件原因：</p>
<p>因为大多数处理器并不是按照字节块来存取内存，而是2个字节，4个字节，甚至更多的字节为单位来存取内存</p>
<p>如果没有内存对齐机制，假如有一个int类型的变量存放在地址为1的连续4个字节地址中。当处理器去取数据时，它会先从0地址开始读取4个字节，然后剔除不想要的字节，再从4地址开始，读取4个字节，再剔除不想要的字节，最后再将剩余数据合并</p>
<p>总结：所以内存对齐后可以增加我们访问数据时的效率</p>
<p>在window下：#pragma pack（8）</p>
<p>在linux下：#pragma pack（4）</p>
<h1 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="#define和const的区别"></a>#define和const的区别</h1><p>1）#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域</p>
<p>2）处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。</p>
<p>3）#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址</p>
<p>4）#define可以定义简单的函数，const不可以定义函数</p>
<p>const修饰类的成员变量，表示常量不可能被修改</p>
<p>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</p>
<p>const函数只能调用const函数，非const函数可以调用const函数</p>
<h1 id="重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"><a href="#重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别" class="headerlink" title="重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别"></a>重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别</h1><p>1）overload，将语义相近的几个函数用同一个名字表示，但是参数列表（参数的类型，个数，顺序不同）不同，这就是函数重载，返回值类型可以不同</p>
<p>特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无</p>
<p>2）override，派生类覆盖基类的虚函数，实现接口的重用，返回值类型必须相同</p>
<p>特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）</p>
<p>3）overwrite，派生类屏蔽了其同名的基类函数，返回值类型可以不同</p>
<p>特征：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字</p>
<h1 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h1><p>虚函数：虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数,是C++中多态性的一个重要体现。利用基类指针访问派生类中的虚函数，这种情况下采用的是动态绑定技术。</p>
<p>纯虚函数：纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”.纯虚函数不能实例化对象。</p>
<h2 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h2><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<p>（1）抽象类的定义： 称带有纯虚函数的类为抽象类。</p>
<p>（2）抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
<p>（3）使用抽象类时注意：</p>
<p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>抽象类是不能定义对象的。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</p>
<p>2、虚函数声明如下：virtual ReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错</p>
<p>3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</p>
<p>4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</p>
<p>5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。</p>
<p>6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</p>
<h2 id="纯虚函数的引入，是出于两个目的："><a href="#纯虚函数的引入，是出于两个目的：" class="headerlink" title="纯虚函数的引入，是出于两个目的："></a>纯虚函数的引入，是出于两个目的：</h2><p>1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。</p>
<p>2、为了效率，不是程序执行的效率，而是为了编码的效率。</p>
<p>动态绑定：基类指针是调用派生类的中的成员函数还是调用基类中的成员函数要到程序运行时确定。主要看此时基类指针所指向的对象。这里要涉及一些很重要的概念:静态类型和动态类型，静态绑定和动态绑定。静态绑定和动态绑定。静态绑定是说前期绑定。 所谓对象的静态类型，就是它在程序中被声明的时候采用的类型。 考虑下面的class继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color = Red)</span> <span class="keyword">const</span></span>=<span class="number">0</span>; </span><br><span class="line">...</span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color = Red)</span> <span class="keyword">const</span></span>; </span><br><span class="line">...</span><br><span class="line">... </span><br><span class="line">&#125;；</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape </span><br><span class="line">&#123; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(color = Red)</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">现在考虑以下这些指针：</span><br><span class="line">Shape* ps;<span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape*pc =<span class="keyword">new</span> Circle;<span class="comment">//静态类型Shape*</span></span><br><span class="line">Shape*pr = <span class="keyword">new</span> Rectangle;<span class="comment">//静态类型Shape*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在本例中，ps,pc,pr都被声明为Shape<em>类型的，所以它们的静态类型都是Shape</em>。注意：无论它们真正指向什么，它们的静态类型都是Shape*. 所谓的对象的动态类型是指“当前所指对象的类型”。也就是说，动态类型可以表现出一个对象将会有什么行为。根据上面的例子，pc的动态类型是Circle<em>，pr的动态类型是Rectangle</em>。ps没有动态类型，因为它没有指向任何对象。 动态类型一如其名所示，可以在执行过程中改变（通常是经过赋值运算）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps=pc; \\ps的动态类型如今是Circle*</span><br><span class="line">ps=pr; \\ps的动态类型如今是Rectangle*</span><br></pre></td></tr></table></figure>

<p>Virtual函数系动态绑定而来，意思是调用一个virtual函数的时候，究竟调用的是哪一个函数代码，取决于发出调用的那个对象的动态类型。</p>
<p>ps-&gt;draw(); \调用的是Rectangle::draw(Red)</p>
<h1 id="一-多态"><a href="#一-多态" class="headerlink" title="一 . 多态"></a>一 . 多态</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_57023347/article/details/119978550">https://blog.csdn.net/weixin_57023347/article/details/119978550</a></p>
<p>多态的概念</p>
<h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>多态就是当要完成某个行为，当不同的对象去完成时会产生不同的效果。或者是说，不同的对象处理某一件事有不同的方法。</p>
<p>比如：在火车站买票，普通成年人，需要全价买票，学生可以半价买票，军人可以优先买票。</p>
<h2 id="1-2-多态的构成条件"><a href="#1-2-多态的构成条件" class="headerlink" title="1.2 多态的构成条件"></a>1.2 多态的构成条件</h2><p>多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。</p>
<p>条件：</p>
<blockquote>
<p>l 被调用的函数必须是虚函数，并且派生类必须对基类的虚函数进行重写。</p>
<p>l 必须通过基类的指针或者引用调用虚函数</p>
</blockquote>
<p>第一点注意点是：调用的函数只能是虚函数，并且派生类必须对基类的虚函数进行重写。如果不重写，只是继承，实现方法一样。如果基类的不是虚函数，重写函数只是构成隐藏。</p>
<p>第二个注意点就是：必须通过基类的指针或者引用调用虚函数。</p>
<blockquote>
<p><strong>l 满足多态：跟对象的类型无关，跟指向的对象有关，指向哪个对象调用就是它的虚函数。</strong></p>
<p><strong>l 不满足多态：跟调用对象的类型有关，类型是什么就调用谁的虚函数。</strong></p>
</blockquote>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173312206.png" alt="image-20230129173312206"></p>
<p>如果不满足多态条件：</p>
<p>1.不重写虚函数</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173319541.png" alt="image-20230129173319541"></p>
<p>2.不是虚函数，重写</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173326160.png" alt="image-20230129173326160"></p>
<p>3.不用指针或者引用调用</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173353074.png" alt="image-20230129173353074"></p>
<h2 id="1-3-虚函数"><a href="#1-3-虚函数" class="headerlink" title="1.3 虚函数"></a>1.3 虚函数</h2><p>虚函数：被virtual修饰的成员函数称为虚函数。注意：修饰的是成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  //虚函数</span><br><span class="line">  virtual void BuyTicket()</span><br><span class="line">  &#123;</span><br><span class="line">​    cout &lt;&lt; &quot;全价买票&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-虚函数的重写"><a href="#1-4-虚函数的重写" class="headerlink" title="1.4 虚函数的重写"></a>1.4 虚函数的重写</h2><p>虚函数的重写(覆盖)：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类的虚函数的返回值类型，函数名字，参数列表完全相同)，但是函数的实现不同，称派生类重写了基类的虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;全价买票&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//虚函数重写</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;半价买票&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//注意：在在虚函数重写时，派生类的虚函数不加virtual关键字，也可以构成重写</span></span><br><span class="line">    <span class="comment">//因为继承，将基类的虚函数继承了下来，在派生类依旧保持虚函数的属性。</span></span><br><span class="line">    <span class="comment">//但是这种写法不规范，不建议这样写。</span></span><br><span class="line">    <span class="comment">//void BuyTicket()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;半价买票&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​    <strong>虚函数的重写，需要函数名，参数，返回值类型一样。但是派生类只是继承了函数的接口，接口就是函数名，参数，返回值类型。派生类重写只是实现不同。</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173504034.png" alt="image-20230129173504034"></p>
<h3 id="1-4-1-协变"><a href="#1-4-1-协变" class="headerlink" title="1.4.1 协变"></a>1.4.1 协变</h3><p>派生类重写基类虚函数，与基类虚函数的返回值不同。并且基类虚函数的返回值基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用，称为协变。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173511207.png" alt="image-20230129173511207"></p>
<h3 id="1-4-2-析构函数的重写"><a href="#1-4-2-析构函数的重写" class="headerlink" title="1.4.2 析构函数的重写"></a>1.4.2 析构函数的重写</h3><p>问题：</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173521643.png" alt="image-20230129173521643"></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173527397.png" alt="image-20230129173527397">这里是一个注意点，申请空间为派生类，但是赋值给基类时，需要将析构函数写成虚函数，构成多态。</p>
<h3 id="1-4-3-C-11里的override和final关键字"><a href="#1-4-3-C-11里的override和final关键字" class="headerlink" title="1.4.3 C++11里的override和final关键字"></a>1.4.3 C++11里的override和final关键字</h3><ol>
<li>final：</li>
</ol>
<p>修饰虚函数，表示该虚函数不能被继承，不能进行重写。</p>
<p>修饰类，类不能被继承</p>
<p>   2.override </p>
<p>检查派生类虚函数是否重写了基类的虚函数，如果没有编译错误。</p>
<p>这个只能修饰派生类的虚函数，不能修饰基类虚函数</p>
<p>override关键字最好用来检查派生类虚函数接口(函数名，参数，返回值)是否写错</p>
<h2 id="1-5-抽象类"><a href="#1-5-抽象类" class="headerlink" title="1.5 抽象类"></a>1.5 抽象类</h2><p>在虚函数后面写上=0，这个函数称为纯虚函数。</p>
<p>包含纯虚函数的类叫做抽象类(也叫接口类)，抽象类不能实例化出对象。派生类继承之后也不能实例化出对象，只有重写的纯虚函数，派生类才能实例化出对象。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173705921.png" alt="image-20230129173705921"></p>
<p>只有派生类经过纯虚函数重写才能实例化出对象。但是基类还是抽象类，不能实例化对象。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173724524.png" alt="image-20230129173724524"></p>
<p>纯虚函数的作用：</p>
<p>  <em><strong>1.一定程度上强制了派生类对纯虚函数的重写，如果不重写，派生类就不能实例化对象。</strong></em></p>
<p>  <em><strong>2.表示抽象的类型</strong></em></p>
<p><em><strong>应用场景：</strong></em></p>
<p>  <em><strong>比如：比如，只说一辆车，车是抽象的，是一个很笼统的概念。因为有多车，不知道具体什么车，并且你不会拿车实例化对象，车这个类就可以定义成抽象类，里可以写成员函数，但是不写具体实现。</strong></em></p>
<p>  <em><strong>但是某个品牌的车，比如奔驰，可以继承车这个抽象类，只需要重写纯虚函数，就可以实例化对象。</strong></em></p>
<p>  <em><strong>具体的继承抽象的。</strong></em></p>
<h1 id="二-多态的原理"><a href="#二-多态的原理" class="headerlink" title="二.多态的原理"></a>二.多态的原理</h1><h2 id="2-1-虚函数表"><a href="#2-1-虚函数表" class="headerlink" title="2.1 虚函数表"></a>2.1 虚函数表</h2><p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173815362.png" alt="image-20230129173815362"></p>
<p>通过观察我们发现，对象b是8个字节，除了_num外，还有_vfptr指针。这个指针是我们叫做虚函数表指针，简称虚表指针。一个含有虚函数的类中至少有一个这样的指针。</p>
<p>_vfptr指针变量保存的是虚函数表的起始地址。</p>
<p>虚函数表实际是一个函数指针数组，虚函数表简称虚表。虚表里面保存的都是虚函数的地址。 </p>
<p><strong>2.2</strong> <strong>派生类中的虚表指针</strong></p>
<p> <strong>派生类不重写基类的虚函数。</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173826299.png" alt="image-20230129173826299"></p>
<p>通过上面现象说明一个结论：</p>
<p>派生类会继承基类的虚函数，会继承基类的虚表。但是派生类和基类的_vfptr变量内容不相等，说明两个虚表不是同一种虚表，只是虚表里的内容相同，所以会调用同一个函数。</p>
<p><strong>派生类重写虚函数</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173834891.png" alt="image-20230129173834891"></p>
<p>通过上面现象说明一个结论：</p>
<p>派生类重写基类虚函数，会重写派生类虚函数表里的内容，将对应位置覆盖层重写虚函数的指针。</p>
<p><strong>派生类增加虚函数</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173843091.png" alt="image-20230129173843091"></p>
<p><strong>注意：</strong></p>
<p>​    **1.**<strong>类中有虚函数只是这个类中多一个虚函数表指针，不是将虚函数表保存到类中。</strong></p>
<p>​    *<em>2.<strong><strong>虚函数表最后会以</strong></strong>nullptr</em>*<strong>结尾。</strong></p>
<p>​    **3.**<strong>同类型的对象共用一张虚表，可以理解成一个类的虚表属于这个类的，实例化的对象，都公用这一张虚表。</strong></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173849344.png" alt="image-20230129173849344"></p>
<p>总结派生类虚表的生成：</p>
<p>1.派生类会继承基类的虚表，但是两个虚表并不是一张虚表。派生类先将基表虚表的内容拷贝一份到派生类的虚表中</p>
<p>2.如果虚表重写虚函数，用派生类重写虚函数的地址覆盖掉虚表中对应虚函数的地址。</p>
<p>3.派生类增加虚函数，会在派生类虚表中声明次序增加到虚表的最后。</p>
<h2 id="2-4-多态原理"><a href="#2-4-多态原理" class="headerlink" title="2.4 多态原理"></a>2.4 多态原理</h2><p>多态是基于虚函数的虚函数表。构成多态，跟对象有关。如果是基类对象，会去基类的虚表中找要调用虚函数的地址，去执行虚函数的代码。如果是派生类对象，会去派生类的虚表中找要调用虚函数的地址，去执行虚函数的代码。</p>
<p>派生类虚函数重写之后，可以实现不同的对象，有不同的实现方法，展现不同的效果。</p>
<p>再来段代码理解一下：</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173859792.png" alt="image-20230129173859792"></p>
<p>通过汇编分析，看出满足多态以后函数调用，不是再编译时确定的，是在运行起来后到对象的需表中找的。</p>
<p>不满足多态，是在编译时确定好的。</p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173910217.png" alt="image-20230129173910217"></p>
<h2 id="2-5-动态绑定和静态绑定"><a href="#2-5-动态绑定和静态绑定" class="headerlink" title="2.5 动态绑定和静态绑定"></a>2.5 动态绑定和静态绑定</h2><blockquote>
<p>l 静态绑定又称为前期绑定，在程序编译期间确定了程序的行为，也称静态多态。比如函数重载。在编译的时候确定了调用的函数。</p>
<p>l 动态绑定也称后期绑定，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称动态多态。就像上面的，运行时在到虚表中找调用函数的地址。</p>
<p>l 多态，多数都是动态绑定。</p>
</blockquote>
<h1 id="三-单继承和多继承的虚函数表"><a href="#三-单继承和多继承的虚函数表" class="headerlink" title="三.单继承和多继承的虚函数表"></a>三.单继承和多继承的虚函数表</h1><h2 id="3-1-单继承中的虚表"><a href="#3-1-单继承中的虚表" class="headerlink" title="3.1 单继承中的虚表"></a>3.1 单继承中的虚表</h2><p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173927542.png" alt="image-20230129173927542"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Person func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Person func2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Student func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Student func3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span><span class="params">()</span></span>;<span class="comment">//声明一个函数指针即 typedef void (*)() VFPTR;</span></span><br><span class="line"><span class="comment">//打印代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVfTable</span><span class="params">(VFPTR *vftable)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vftable[i] != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">		<span class="comment">//打印虚表内容</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;vftable[%d]:%p\n&quot;</span>, i, vftable[i]);</span><br><span class="line">		<span class="comment">//调用这个函数</span></span><br><span class="line">		VFPTR fun = vftable[i];</span><br><span class="line">		<span class="built_in">fun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Student s;</span><br><span class="line">	<span class="comment">//要得到虚表指针的内容，由于这个平台，虚表指针是保存在开始的</span></span><br><span class="line">	<span class="comment">//先得到对象地址，强转成int *得到前四个字节，就是虚表指针的地址</span></span><br><span class="line">	<span class="comment">//再解引用，得到虚表指针的内容</span></span><br><span class="line">	<span class="comment">//再强转成函数二级指针</span></span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)&amp;p);</span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)&amp;s);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129173954774.png" alt="image-20230129173954774"></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174004490.png" alt="image-20230129174004490"></p>
<h2 id="3-2-多继承中的虚表"><a href="#3-2-多继承中的虚表" class="headerlink" title="3.2 多继承中的虚表"></a>3.2 多继承中的虚表</h2><p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174035132.png" alt="image-20230129174035132"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base1 : func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base1 : func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2 : func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2 : func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base2 : func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deirve</span> :</span><span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deirve : func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deirve : func4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Deirve : func5()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*VFPTR)</span><span class="params">()</span></span>;<span class="comment">//声明一个函数指针即 typedef void (*)() VFPTR;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintVfTable</span><span class="params">(VFPTR *vftable)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;虚表地址：%p\n&quot;</span>, vftable);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vftable[i] != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">		<span class="comment">//打印虚表内容</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;vftable[%d]:%p\n&quot;</span>, i, vftable[i]);</span><br><span class="line">		<span class="comment">//调用这个函数</span></span><br><span class="line">		VFPTR fun = vftable[i];</span><br><span class="line">		<span class="built_in">fun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Deirve d;</span><br><span class="line">	<span class="comment">//打印继承Base1的虚表</span></span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)&amp;d);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//打印继承Base2的虚表</span></span><br><span class="line">	<span class="comment">//加Base1大小的字节数，到Base2的虚表指针。</span></span><br><span class="line">	<span class="comment">//要加先强转成char *，步长为一个字节。不强转的话，步长为Deirve</span></span><br><span class="line">	<span class="built_in">PrintVfTable</span>((VFPTR *)*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)&amp;d + <span class="built_in"><span class="keyword">sizeof</span></span>(Base1)));</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174103295.png" alt="image-20230129174103295"></p>
<p><img src="/2021/06/27/C/oOo\source_posts\C\image-20230129174107432.png" alt="image-20230129174107432"></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>1）栈 stack 存放函数的参数值、局部变量，由编译器自动分配释放</p>
<p>堆heap，是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收</p>
<p>2）因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片</p>
<p>3）对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。</p>
<p>C++内存区域分为5个区域。分别是堆，栈，自由存储区，全局/静态存储区和常量存储区。</p>
<p>栈：由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面通常是局部变量，函数参数等。</p>
<p>堆：由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>自由存储区：由malloc等分配的内存块，和堆十分相似，不过它使用free来结束自己的生命。</p>
<p>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的c语言中。全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存。**<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>常量也是存储在静态存储区**</p>
<p>​    <strong>对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。</strong></p>
<p>常量存储区：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
<h2 id="C-内存区域中堆和栈的区别："><a href="#C-内存区域中堆和栈的区别：" class="headerlink" title="C++内存区域中堆和栈的区别："></a>C++内存区域中堆和栈的区别：</h2><p>管理方式不同：栈是由编译器自动管理，无需我们手工控制；对于堆来说，释放由程序员完成，容易产生内存泄漏。</p>
<p>空间大小不同：一般来讲，在32位系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project–&gt;setting–&gt;link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。</p>
<p>能否产生碎片：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。</p>
<p>生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。</p>
<p>分配方式不同：堆都是动态分配的；栈有静态和动态两种分配方式。静态分配由编译器完成，比如局部变量的分配。动态分配由malloca函数进行、但栈的动态分配和堆是不同的，它的动态分配由编译器进行释放，无需我们手工实现。</p>
<p>分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。</p>
<p>进程内存中的映像，主要有代码区，堆（动态存储区，new/delete的动态数据），栈，静态存储区</p>
<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>char *c=”zhouming”;<br><em>书上说： “zhouming”这个字符串被当作常量而且被放置在此程序的内存静态区。</em><br><em>c为一个字符型指针，若为局部变量，则存储在栈内，该指针变量里面存了个地址，该地址为字符串中第一个字母Z的地址。</em></p>
<p><em>当使用printf()输出时，格式化时选择%s，会输出zhouming，这是printf遇到结尾符号‘\0’即停止显示打印。</em></p>
<p><em>字符串“zhouming”是个常量，存储在一片连续的内存中，末尾有结尾符表示字符串的结束。</em></p>
<p>所有的字符窜常量都被放在静态内存区</p>
<p>因为字符串常量很少需要修改，放在静态内存区会提高效率</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str7 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str8 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str1 == str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str3 == str6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str5 == str6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str7 == str8);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, str5 == str8);</span><br></pre></td></tr></table></figure>

<p>结果是：0 0 1 1 1<br>str1,str2,str3,str4是数组变量，它们有各自的内存空间；字符数组作为局部变量被存储在栈区；<br>而str5,str6,str7,str8是指针，它们指向相同的常量区域。，”abcd”被存储在静态数据区，而且是全局的。</p>
<p>问题的引入：<br>看看下面的程序的输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">returnStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;<span class="comment">//一定要初始化，好习惯</span></span><br><span class="line">str=<span class="built_in">returnStr</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在静态数据区，<br>把该字符串常量存放的静态数据区的首地址赋值给了指针，<br>所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p>
<p>但是，下面的就有问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">returnStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> p[]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;<span class="comment">//一定要初始化，好习惯</span></span><br><span class="line">str=<span class="built_in">returnStr</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“hello world!”是一个字符串常量，存放在静态数据区，没错，<br>但是把一个字符串常量赋值给了一个局部变量(char []型数组)，该局部变量存放在栈中，<br>这样就有两块内容一样的内存，也就是说“char p[]=”hello world!”;”这条语句让“hello world!”这个字符串在内存中有两份拷贝，一份在动态分配的栈中，另一份在静态存储区。<strong>这是与前者最本质的区别</strong>，<br>当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，<br>所以这时的函数返回的是一个已被释放的内存地址，所以打印出来的是乱码。</p>
<p>如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型</p>
<h1 id="关键字static的作用"><a href="#关键字static的作用" class="headerlink" title="关键字static的作用"></a>关键字static的作用</h1><p>1）函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值</p>
<p>2）模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内</p>
<p>3）类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝</p>
<p>4）类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量</p>
<p>注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象</p>
<h1 id="C-文件编译与执行的四个阶段"><a href="#C-文件编译与执行的四个阶段" class="headerlink" title="C++文件编译与执行的四个阶段"></a>C++文件编译与执行的四个阶段</h1><p>1）预处理：根据文件中的预处理指令来修改源文件的内容</p>
<p>2）编译：编译成汇编代码</p>
<p>3）汇编：把汇编代码翻译成目标机器指令</p>
<p>4）链接：链接目标代码生成可执行程序</p>
<h1 id="构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因"><a href="#构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因" class="headerlink" title="构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因"></a>构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因</h1><p>1、构造函数不能声明为虚函数</p>
<p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<p>2、析构函数最好声明为虚函数</p>
<p>首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数<strong>（没有发生多态）</strong>，这样就会造成派生类对象析构不完全。</p>
<p>子类析构时，要调用父类的析构函数吗？</p>
<p>析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。</p>
<p>不用显式调用，会自动调用</p>
<h1 id="静态绑定和动态绑定的介绍"><a href="#静态绑定和动态绑定的介绍" class="headerlink" title="静态绑定和动态绑定的介绍"></a>静态绑定和动态绑定的介绍</h1><p>静态绑定和动态绑定是C++多态性的一种特性</p>
<p>1）对象的静态类型和动态类型</p>
<p>静态类型：对象在声明时采用的类型，在编译时确定</p>
<p>动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改</p>
<p>2）静态绑定和动态绑定</p>
<p>静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定</p>
<p>动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定</p>
<p>只有虚函数才使用的是动态绑定，其他的全部是静态绑定</p>
<h1 id="C-中内存泄漏的几种情况"><a href="#C-中内存泄漏的几种情况" class="headerlink" title="C++中内存泄漏的几种情况"></a>C++中内存泄漏的几种情况</h1><p>内存泄漏是指动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Smt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwlbird.github.io/2021/06/27/C/">https://zwlbird.github.io/2021/06/27/C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwlbird.github.io" target="_blank">.oOo.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Qt/">Qt</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/27/Qt/"><img class="prev-cover" src="https://s2.loli.net/2023/12/12/SNjXLprxbadKoJ8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Qt</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/27/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"><img class="next-cover" src="https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">回调函数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/03/Hexo/" title="Hexo"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">Hexo</div></div></a></div><div><a href="/2021/06/27/函数积累/" title="函数积累"><img class="cover" src="https://s2.loli.net/2023/12/12/dkLQxaftyKTzXoR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-27</div><div class="title">函数积累</div></div></a></div><div><a href="/2021/06/20/头文件/" title="头文件"><img class="cover" src="https://i.loli.net/2021/06/27/bhoY29lQPvSAr6z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-20</div><div class="title">头文件</div></div></a></div><div><a href="/2021/06/20/字符串相关/" title="字符串相关"><img class="cover" src="https://i.loli.net/2021/06/27/W8xTBGA2O7JhRHl.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-20</div><div class="title">字符串相关</div></div></a></div><div><a href="/2021/08/11/数据结构/" title="数据结构"><img class="cover" src="https://s2.loli.net/2023/12/12/9iokGWsR2Lrux78.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="title">数据结构</div></div></a></div><div><a href="/2021/06/20/文件操作/" title="文件操作"><img class="cover" src="https://i.loli.net/2021/06/27/oW4MJr2aCzHYjZG.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-20</div><div class="title">文件操作</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Smt</div><div class="author-info__description">哇咔咔</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zwlbird/zwlbird.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zwl931025@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">可变参数函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%A6%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E7%94%B1%E6%9D%A5"><span class="toc-number">1.1.</span> <span class="toc-text">1.带可变参数的函数由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%A6%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C"><span class="toc-number">1.2.</span> <span class="toc-text">2.带可变参数函数的实现，</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">隐式类型转换与显式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">1. 隐式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 算术类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 类类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">2. 显示类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-C%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 C风格的强制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-C-%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 C++命名的强制类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC-width-%E6%97%A2%E8%83%BD%E8%A2%AB%E8%B5%8B%E5%80%BC%E5%8F%88%E8%83%BD%E5%8F%96%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%89%80%E5%9C%A8"><span class="toc-number">3.</span> <span class="toc-text">左值 右值   width()既能被赋值又能取值的原因所在</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">一个简单定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BE%8B%E5%AD%90"><span class="toc-number">3.2.</span> <span class="toc-text">基本例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E5%B7%A6%E5%80%BC"><span class="toc-number">3.3.</span> <span class="toc-text">可修改的左值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">左值和右值的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CV%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%B3%E5%80%BC"><span class="toc-number">3.5.</span> <span class="toc-text">CV修饰的右值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88C-11%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">右值引用（C++11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数指针与指针函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">指针函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.2.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">二者区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8D%E5%90%8C"><span class="toc-number">4.3.1.</span> <span class="toc-text">定义不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">4.3.2.</span> <span class="toc-text">写法不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%88%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">类成员函数的指针（非静态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.3.4.</span> <span class="toc-text">指向类的静态函数的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if-%E4%B8%AD%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%88%A4%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">if 中同时出现赋值语句和判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8-python3-6"><span class="toc-number">7.</span> <span class="toc-text">C++ 调用 python3.6</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%BA%8E-%E6%8C%89%E4%BD%8D%E6%88%96"><span class="toc-number">8.</span> <span class="toc-text">按位于 按位或</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">一：简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E4%BD%8D%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.</span> <span class="toc-text">二：位逻辑运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97"><span class="toc-number">8.3.</span> <span class="toc-text">三：位移运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81-%E5%8F%AF%E5%80%9F%E9%89%B4%E3%80%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3-gt-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%8B"><span class="toc-number">8.4.</span> <span class="toc-text">四：反码，补码(可借鉴《字符串相关-&gt;十进制与二进制的转换》)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%E4%B8%8D%E8%A6%81%E5%A4%AA%E5%B0%91%EF%BC%8C%E5%8F%AF%E2%80%9C%E6%9F%90%E6%9F%90%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E6%98%AF%E6%9F%90%E6%9F%90%E2%80%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%95%B0%E5%80%BC%E3%80%82"><span class="toc-number">8.6.</span> <span class="toc-text">提示信息不要太少，可“某某数的反码是某某”，而不是只显示数值。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%B1%8F%E8%94%BD"><span class="toc-number">8.7.</span> <span class="toc-text">位屏蔽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AF%B4%E6%98%8E%E7%AC%A6%E4%B8%8E%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">C++说明符与限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">9.1.</span> <span class="toc-text">说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">9.2.</span> <span class="toc-text">限定符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9B%9B%E4%B8%AAcast%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">C++四个cast的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%88Upcasting%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">1) 向上转型（Upcasting）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%88Downcasting%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">2) 向下转型（Downcasting）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">友元函数和友元类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-%EF%BC%9A"><span class="toc-number">11.1.</span> <span class="toc-text">友元函数 ：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB-%EF%BC%9A"><span class="toc-number">11.2.</span> <span class="toc-text">友元类 ：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">11.3.</span> <span class="toc-text">2、什么时候使用友元函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">11.4.</span> <span class="toc-text">3、怎么使用友元函数：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">一、什么是拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">12.2.</span> <span class="toc-text">二、拷贝构造函数的调用时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BD%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%97%B6"><span class="toc-number">12.2.1.</span> <span class="toc-text">1. 当函数的参数为类的对象时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.2.2.</span> <span class="toc-text">2. 函数的返回值是类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">12.2.3.</span> <span class="toc-text">3. 对象需要通过另外一个对象进行初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">12.3.</span> <span class="toc-text">三、浅拷贝与深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.3.1.</span> <span class="toc-text">1. 默认拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">12.3.2.</span> <span class="toc-text">2. 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">12.3.3.</span> <span class="toc-text">3. 深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%B2%E6%AD%A2%E9%BB%98%E8%AE%A4%E6%8B%B7%E8%B4%9D%E5%8F%91%E7%94%9F"><span class="toc-number">12.3.4.</span> <span class="toc-text">3. 防止默认拷贝发生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">12.3.5.</span> <span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82"><span class="toc-number">12.4.</span> <span class="toc-text">四、拷贝构造函数的几个细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%8C%E4%B8%8D%E8%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">12.4.1.</span> <span class="toc-text">1.为什么拷贝构造函数必须是引用传递，不能是值传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">12.4.2.</span> <span class="toc-text">2. 拷贝构造函数的作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.4.3.</span> <span class="toc-text">3.参数传递过程到底发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9C%A8%E7%B1%BB%E4%B8%AD%E6%9C%89%E6%8C%87%E9%92%88%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E6%97%B6%EF%BC%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">12.4.4.</span> <span class="toc-text">4. 在类中有指针数据成员时，拷贝构造函数的使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8C%E8%83%BD%E8%B0%83%E7%94%A8private%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%90%97"><span class="toc-number">12.4.5.</span> <span class="toc-text">5. 拷贝构造函数里能调用private成员变量吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A5%E4%B8%8B%E5%87%BD%E6%95%B0%E5%93%AA%E4%B8%AA%E6%98%AF%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">12.4.6.</span> <span class="toc-text">6. 以下函数哪个是拷贝构造函数,为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%BA%8E%E4%B8%80%E4%B8%AA%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97"><span class="toc-number">12.4.7.</span> <span class="toc-text">7. 一个类中可以存在多于一个的拷贝构造函数吗?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">赋值构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stdcall%E3%80%81-cdcel%E5%92%8C-fastcall%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">_stdcall、__cdcel和__fastcall三者的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">初始化和赋值的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%ADnew%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E6%9C%89%E4%BD%95%E6%B2%A1%E6%9C%89%E6%8B%AC%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">C++中new一个类的指针，有何没有括号有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E4%B8%AD%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82"><span class="toc-number">16.1.</span> <span class="toc-text">一、 中括号的情况。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B0%8F%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82"><span class="toc-number">16.2.</span> <span class="toc-text">二、小括号的情况。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E5%B0%8F%E6%8B%AC%E5%8F%B7%E6%97%B6%EF%BC%8C%E5%B0%8F%E6%8B%AC%E5%8F%B7%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E8%8B%A5%E5%B9%B2%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">16.2.1.</span> <span class="toc-text">1 有小括号时，小括号中可以有若干参数，也可以没有参数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B2%A1%E6%9C%89%E5%B0%8F%E6%8B%AC%E5%8F%B7%E6%97%B6%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%B0%83%E7%94%A8%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E3%80%82"><span class="toc-number">16.2.2.</span> <span class="toc-text">2 没有小括号时，默认调用无参构造。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8"><span class="toc-number">17.</span> <span class="toc-text">浮点数存储</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">18.</span> <span class="toc-text">宽字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">19.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">20.</span> <span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">变量的声明和定义有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sizeof-%E5%92%8C-strlen-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">sizeof 和 strlen 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typdef%E5%92%8Cdefine%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">typdef和define区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#malloc-%E5%92%8C-new-%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">24.</span> <span class="toc-text">malloc 和 new 有以下不同：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">25.</span> <span class="toc-text">引用作为函数参数以及返回值的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">25.1.</span> <span class="toc-text">值传递：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">25.2.</span> <span class="toc-text">指针传递：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="toc-number">25.3.</span> <span class="toc-text">引用传递：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">26.</span> <span class="toc-text">野指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E7%A9%BA%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">27.</span> <span class="toc-text">C++的空类有哪些成员函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="toc-number">28.</span> <span class="toc-text">拷贝构造函数和赋值运算符的认识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">C++中指针和引用的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93struct%E5%92%8C%E5%85%B1%E5%90%8C%E4%BD%93union%EF%BC%88%E8%81%94%E5%90%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">30.</span> <span class="toc-text">结构体struct和共同体union（联合）的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%91%A2%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">结构体为什么要内存对齐呢？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">#define和const的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDoverload%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89override%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89overwrite%EF%BC%8C%E8%BF%99%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">33.</span> <span class="toc-text">重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">34.</span> <span class="toc-text">虚函数、纯虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">34.1.</span> <span class="toc-text">抽象类的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">34.2.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%95%E5%85%A5%EF%BC%8C%E6%98%AF%E5%87%BA%E4%BA%8E%E4%B8%A4%E4%B8%AA%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-number">34.3.</span> <span class="toc-text">纯虚函数的引入，是出于两个目的：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%A4%9A%E6%80%81"><span class="toc-number">35.</span> <span class="toc-text">一 . 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">35.1.</span> <span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%A4%9A%E6%80%81%E7%9A%84%E6%9E%84%E6%88%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">35.2.</span> <span class="toc-text">1.2 多态的构成条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">35.3.</span> <span class="toc-text">1.3 虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">35.4.</span> <span class="toc-text">1.4 虚函数的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%8D%8F%E5%8F%98"><span class="toc-number">35.4.1.</span> <span class="toc-text">1.4.1 协变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">35.4.2.</span> <span class="toc-text">1.4.2 析构函数的重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-C-11%E9%87%8C%E7%9A%84override%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">35.4.3.</span> <span class="toc-text">1.4.3 C++11里的override和final关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">35.5.</span> <span class="toc-text">1.5 抽象类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">36.</span> <span class="toc-text">二.多态的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">36.1.</span> <span class="toc-text">2.1 虚函数表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">36.2.</span> <span class="toc-text">2.4 多态原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">36.3.</span> <span class="toc-text">2.5 动态绑定和静态绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">37.</span> <span class="toc-text">三.单继承和多继承的虚函数表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E8%A1%A8"><span class="toc-number">37.1.</span> <span class="toc-text">3.1 单继承中的虚表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E8%99%9A%E8%A1%A8"><span class="toc-number">37.2.</span> <span class="toc-text">3.2 多继承中的虚表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">38.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%AD%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">38.1.</span> <span class="toc-text">C++内存区域中堆和栈的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">38.2.</span> <span class="toc-text">字符串常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97static%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">39.</span> <span class="toc-text">关键字static的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">40.</span> <span class="toc-text">C++文件编译与执行的四个阶段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E8%80%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">41.</span> <span class="toc-text">构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">42.</span> <span class="toc-text">静态绑定和动态绑定的介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">43.</span> <span class="toc-text">C++中内存泄漏的几种情况</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/03/Hexo/" title="Hexo"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo"/></a><div class="content"><a class="title" href="/2022/04/03/Hexo/" title="Hexo">Hexo</a><time datetime="2022-04-02T16:33:52.000Z" title="发表于 2022-04-03 00:33:52">2022-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/Android/" title="Android"><img src="https://s2.loli.net/2023/12/12/gfXKlqmwMWzPxH7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android"/></a><div class="content"><a class="title" href="/2021/10/31/Android/" title="Android">Android</a><time datetime="2021-10-31T14:03:21.000Z" title="发表于 2021-10-31 22:03:21">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel"><img src="https://s2.loli.net/2023/12/12/zb5QarqSYDHWZs6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-highlevel"/></a><div class="content"><a class="title" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel">OpenGL-highlevel</a><time datetime="2021-10-19T13:35:33.000Z" title="发表于 2021-10-19 21:35:33">2021-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/OpenGL-light/" title="OpenGL-light"><img src="https://s2.loli.net/2023/12/12/Dlf5uYb78R1Firw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-light"/></a><div class="content"><a class="title" href="/2021/10/17/OpenGL-light/" title="OpenGL-light">OpenGL-light</a><time datetime="2021-10-17T14:09:58.000Z" title="发表于 2021-10-17 22:09:58">2021-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D"><img src="https://s2.loli.net/2023/12/12/EZS5QGm23HLgvW4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL_3D"/></a><div class="content"><a class="title" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D">OpenGL_3D</a><time datetime="2021-09-21T07:31:53.000Z" title="发表于 2021-09-21 15:31:53">2021-09-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Smt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RrMFpOdr0spfIDfRdBukvyf7-gzGzoHsz',
      appKey: 'nipjeGzTyw5yvNk2SgU5KmUQ',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://myhkw.cn/api/player/162393526192" id="myhk" key="162393526192" m="1"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>