<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++11 | .oOo.</title><meta name="keywords" content="C++"><meta name="author" content="Smt"><meta name="copyright" content="Smt"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++11">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11">
<meta property="og:url" content="https://zwlbird.github.io/2021/07/13/C-11/index.html">
<meta property="og:site_name" content=".oOo.">
<meta property="og:description" content="C++11">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/12/12/w6gBS4XVHa8hA7O.jpg">
<meta property="article:published_time" content="2021-07-13T02:23:53.000Z">
<meta property="article:modified_time" content="2023-12-12T09:29:46.467Z">
<meta property="article:author" content="Smt">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/12/12/w6gBS4XVHa8hA7O.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwlbird.github.io/2021/07/13/C-11/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++11',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-12 17:29:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/12/12/w6gBS4XVHa8hA7O.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">.oOo.</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++11</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-13T02:23:53.000Z" title="发表于 2021-07-13 10:23:53">2021-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-12T09:29:46.467Z" title="更新于 2023-12-12 17:29:46">2023-12-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++11"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/07/13/C-11/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/07/13/C-11/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="默认函数控制"><a href="#默认函数控制" class="headerlink" title="默认函数控制"></a><strong>默认函数控制</strong></h2><p>在C++中对于空类编译器会生成一些默认的成员函数，如果在类中显式定义了，编译器将不会重新生成默认版本。有时候这样的规则可能被忘记，最常见的是声明了带参数的构造函数，必要时则需要定义不带参数的版本以实例化无参的对象。而且有时编译器会生成，有时又不生成，容易造成混乱，于是C++11让程序员可以控制是否需要编译器生成。</p>
<p>显式缺省函数</p>
<p>在C++11中，可以在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本，用=default修饰的函数称为显式缺省函数，由编译器生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>删除默认函数</p>
<p>如果能想要限制某些默认函数的生成，在C++98中，是该函数设置成private，并且不给定义，这样只要其他人想要调用就会报错。在C++11中更简单，只需在该函数声明加上=delete即可，该语法指示编译器不生成对应函数的默认版本，称=delete修饰的函数为删除函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>



<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h3><p>使用 auto 的时候必须对变量进行初始化</p>
<p>auto 不能在函数的参数中使用。</p>
<p>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。</p>
<blockquote>
<p>这个和Auto的前提一样，Auto使用必须初始化，只有静态成员变量在定义的时候要求初始化，非静态的只有声明，没有定义，和Auto的前提相悖了。</p>
</blockquote>
<p>auto 关键字不能定义数组</p>
<p>auto 不能作用于模板参数</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><blockquote>
<p>decltype 是 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导</p>
<p>decltype 是“declare type”的缩写，译为“声明类型”。</p>
</blockquote>
<p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br><span class="line"><span class="comment">//其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</strong></p>
<p><strong>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。</strong></p>
<p><strong>auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开</strong></p>
</blockquote>
<p>decltype 可以写成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>exp 注意事项原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</em></p>
</blockquote>
<h3 id="使用-decltype-exp-获取类型时，编译器将根据以下三条规则得出结果："><a href="#使用-decltype-exp-获取类型时，编译器将根据以下三条规则得出结果：" class="headerlink" title="使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果："></a>使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</h3><ul>
<li>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，按照推导规则 1，对于一般的表达式，decltype 的推导结果就和这个表达式的类型一致。</p>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_int</span><span class="params">(<span class="keyword">double</span>)</span></span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>)) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fun_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被<code>( )</code>包围：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span><span class="keyword">public</span>:    <span class="keyword">int</span> x;&#125;;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="keyword">const</span> Base obj;    <span class="comment">//带有括号的表达式    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。    //加法表达式    int n = 0, m = 0;    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们知道，<mark class="hl-label blue">auto只能用于类的静态成员，不能用于类的非静态成员（普通成员）</mark> ，如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>using namespace std;template <span class="meta-string">&lt;typename T&gt;</span>class Base &#123;public:    void func(T&amp; container) &#123;        m_it = container.begin();    &#125;private:    typename T::iterator m_it;  <span class="comment">//注意这里&#125;;int main()&#123;    const vector&lt;int&gt; v;    Base&lt;const vector&lt;int&gt;&gt; obj;    obj.func(v);    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<p>要想解决这个问题，在之前的 C++98/03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="keyword">public</span>:    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;        m_it = container.<span class="built_in">begin</span>();    &#125;<span class="keyword">private</span>:    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里&#125;;</span></span><br></pre></td></tr></table></figure>

<p>看起来是不是很清爽？</p>
<p>注意，有些低版本的编译器不支持<code>T().begin()</code>这种写法，以上代码我在 VS2019 下测试通过，在 VS2015 下测试失败。</p>
<h2 id="auto-和-decltype-的区别"><a href="#auto-和-decltype-的区别" class="headerlink" title="auto 和 decltype 的区别"></a>auto 和 decltype 的区别</h2><p>对 cv 限定符的处理「cv 限定符」是 const 和 volatile 关键字的统称：</p>
<ul>
<li>const 关键字用来表示数据是只读的，也就是不能被修改；</li>
<li>volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取。</li>
</ul>
<p>在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。</p>
<p>以下是 auto 关键字对 cv 限定符的推导规则：</p>
<ul>
<li>如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。</li>
<li>如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。</li>
</ul>
<p>下面的例子演示了对 const 限定符的推导：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非指针非引用类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="number">10</span>;</span><br><span class="line">n2 = <span class="number">99</span>;  <span class="comment">//赋值不报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(n1) n3 = <span class="number">20</span>;</span><br><span class="line">n3 = <span class="number">5</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;n1;</span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br><span class="line">*p2 = <span class="number">66</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(p1) p3 = p1;</span><br><span class="line">*p3 = <span class="number">19</span>;  <span class="comment">//赋值报错</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 中无法将一个变量的完整类型输出，我们通过对变量赋值来判断它是否被 const 修饰；如果被 const 修饰那么赋值失败，如果不被 const 修饰那么赋值成功。虽然这种方案不太直观，但也是能达到目的的。</p>
<p>n2 赋值成功，说明不带 const，也就是 const 被 auto 抛弃了，这验证了 auto 的第一条推导规则。p2 赋值失败，说明是带 const 的，也就是 const 没有被 auto 抛弃，这验证了 auto 的第二条推导规则。</p>
<p>n3 和 p3 都赋值失败，说明 decltype 不会去掉表达式的 const 属性。</p>
<blockquote>
<p>对引用的处理当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。请看下面的例子：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r1 = n;</span><br><span class="line">    <span class="comment">//auto推导</span></span><br><span class="line">    <span class="keyword">auto</span> r2 = r1;</span><br><span class="line">    r2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//decltype推导</span></span><br><span class="line">    <span class="keyword">decltype</span>(r1) r3 = n;</span><br><span class="line">    r3 = <span class="number">99</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>10, 10, 20<br>99, 99, 99</p>
<p>从运行结果可以发现，给 r2 赋值并没有改变 n 的值，这说明 r2 没有指向 n，而是自立门户，单独拥有了一块内存，这就证明 r 不再是引用类型，它的引用类型被 auto 抛弃了。</p>
<p>给 r3 赋值，n 的值也跟着改变了，这说明 r3 仍然指向 n，它的引用类型被 decltype 保留了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>auto 虽然在书写格式上比 decltype 简单，但是它的推导规则复杂，有时候会改变表达式的原始类型；而 decltype 比较纯粹，它一般会坚持保留原始表达式的任何类型，让推导的结果更加原汁原味。</p>
<p>从代码是否健壮的角度考虑，我推荐使用 decltype，它没有那么多是非；但是 decltype 总是显得比较麻烦，尤其是当表达式比较复杂时，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;<span class="keyword">decltype</span>(nums.<span class="built_in">begin</span>()) it = nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<p>而如果使用 auto 就会清爽很多：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<h2 id="C-返回值类型后置（跟踪返回值类型）"><a href="#C-返回值类型后置（跟踪返回值类型）" class="headerlink" title="C++返回值类型后置（跟踪返回值类型）"></a>C++返回值类型后置（跟踪返回值类型）</h2><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。考虑下面这个场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br></pre></td></tr></table></figure>

<p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p>
<p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) <span class="built_in">add</span>(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，直接像上面这样写是编译不过的。因为<mark class="hl-label blue">t、u在参数列表中，而C++的返回值是前置语法，在返回值定义的时候参数变量还不存在。</mark> </p>
<p>可行的写法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>() + <span class="built_in">U</span>()) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;<span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) <span class="built_in">add</span>(T t, U u)&#123;    <span class="keyword">return</span> t + u;&#125;</span><br></pre></td></tr></table></figure>

<p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>因此，在 C++11 中增加了<strong>返回类型后置（trailing-return-type，又称跟踪返回类型）</strong>语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</p>
<p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;<span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span>&#123;    <span class="keyword">return</span> t + u;&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步说明这个语法，再看另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>;<span class="function"><span class="keyword">float</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>&amp; f)</span></span>;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(val))</span></span>&#123;    <span class="keyword">return</span> <span class="built_in">foo</span>(val);&#125;</span><br></pre></td></tr></table></figure>


<p>如果说前一个例子中的 add 使用 C++98/03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。</p>
<p>在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>
<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98/03 那样使用晦涩难懂的写法。</p>
<h2 id="C-11使用using定义别名（替代typedef）"><a href="#C-11使用using定义别名（替代typedef）" class="headerlink" title="C++11使用using定义别名（替代typedef）"></a>C++11使用using定义别名（替代typedef）</h2><p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 中可以通过 typedef 重定义一个类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint_t</span>;</span><br></pre></td></tr></table></figure>

<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">uint_t</span>)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>

<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。</p>
<p>想象下面这个场景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="keyword">int</span>&gt; <span class="keyword">map_int_t</span>;<span class="comment">// ...typedef std::map&lt;std::string, std::string&gt; map_str_t;// ...</span></span><br></pre></td></tr></table></figure>

<p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<p>因此，在 C++98/03 中往往不得不这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;<span class="class"><span class="keyword">struct</span> <span class="title">str_map</span>&#123;</span>    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;&#125;;<span class="comment">// ...str_map&lt;int&gt;::type map1;// ...</span></span><br></pre></td></tr></table></figure>

<p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p>
<p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;<span class="keyword">using</span> <span class="keyword">str_map_t</span> = std::map&lt;std::string, Val&gt;;<span class="comment">// ...str_map_t&lt;int&gt; map1;</span></span><br></pre></td></tr></table></figure>

<p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p>
<p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned inttypedef unsigned int uint_t;using uint_t = unsigned int;// 重定义std::maptypedef std::map&lt;std::string, int&gt; map_int_t;using map_int_t = std::map&lt;std::string, int&gt;;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p>
<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C/C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">func_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">struct</span> <span class="title">func_t</span>&#123;</span>    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;&#125;;<span class="comment">// 使用 func_t 模板func_t&lt;int&gt;::type xx_1;/* C++11 */template &lt;typename T&gt;using func_t = void (*)(T, T);// 使用 func_t 模板func_t&lt;int&gt; xx_2;</span></span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98/03 那样使用烦琐的外敷模板。</p>
<p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</int></p>
<p>因此，下面这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span> (*func_call)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">func_t</span>&lt;<span class="keyword">int</span>&gt; func_call)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>

<p>同样是无法实现重载的，func_t<int> 只是 void(*)(int, int) 类型的等价物。</int></p>
<p>using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p>
<p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="keyword">using</span> <span class="keyword">type_t</span> = T;<span class="comment">// ...type_t&lt;int&gt; i;</span></span><br></pre></td></tr></table></figure>

<p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t<int> 将等价于 int。</int></p>
<h2 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h2><p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>98/03 标准中，<strong>类</strong>模板可以有默认的模板参数，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">int</span>, U N = <span class="number">0</span>&gt;struct Foo&#123;    <span class="comment">// ...&#125;;</span></span><br></pre></td></tr></table></figure>

<p>但是却不支持<strong>函数</strong>的默认模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;  <span class="comment">// error in C++98/03: default template argumentsvoid func()&#123;    // ...&#125;</span></span><br></pre></td></tr></table></figure>


<p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;    <span class="built_in">func</span>();   <span class="comment">//T = int    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
</blockquote>
<p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="keyword">int</span>, <span class="keyword">typename</span> U&gt;R <span class="built_in">func</span>(U val)&#123;    <span class="keyword">return</span> val;&#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int    func&lt;char&gt;(97);         // R=char, U=int    func&lt;double, int&gt;(97);  // R=double, U=int    return 0;&#125;</span></span><br></pre></td></tr></table></figure>


<p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val=97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U = int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</char></p>
<p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="keyword">double</span>&gt;<span class="keyword">void</span> <span class="built_in">func</span>(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)&#123;    <span class="comment">//...&#125;int main()&#123;    func(&#x27;c&#x27;); //T=char, U=double    func();    //编译报错    return 0;&#125;</span></span><br></pre></td></tr></table></figure>


<p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T=char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。</p>
<h2 id="C-11-lambda匿名函数"><a href="#C-11-lambda匿名函数" class="headerlink" title="C++11 lambda匿名函数"></a>C++11 lambda匿名函数</h2><p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则是被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<p>继 Python、Java、C#、PHP 等众多高级编程语言都支持 lambda 匿名函数后，C++11 标准终于引入了 lambda，本节将带领大家系统地学习 lambda 表达式的具体用法。</p>
<h3 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h3><p>定义一个 lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) <span class="keyword">mutable</span> <span class="keyword">noexcept</span>/<span class="keyword">throw</span>() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">  函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中各部分的含义分别为：</p>
<p><strong>1) [外部变量方位方式说明符]</strong><br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</p>
<blockquote>
<p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
</blockquote>
<p><strong>2) (参数)</strong><br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
<p><strong>3) mutable</strong><br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
<p>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<p><strong>4) noexcept/throw()</strong><br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</p>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<p><strong>5) -&gt; 返回值类型</strong><br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p>
<p><strong>6) 函数体</strong><br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<blockquote>
<p>其中，红色标识的参数是定义 lambda 表达式时必须写的，而绿色标识的参数可以省略。</p>
</blockquote>
<p>比如，如下就定义了一个最简单的 lambda 匿名函数：</p>
<p>[]{}</p>
<p>显然，此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，这是一个没有任何功能的 lambda 匿名函数。</p>
<blockquote>
<h4 id="lambda匿名函数中的-外部变量-对于-lambda-匿名函数的使用，令多数初学者感到困惑的就是-外部变量-的使用。其实很简单，无非表-1-所示的这几种编写格式。"><a href="#lambda匿名函数中的-外部变量-对于-lambda-匿名函数的使用，令多数初学者感到困惑的就是-外部变量-的使用。其实很简单，无非表-1-所示的这几种编写格式。" class="headerlink" title="lambda匿名函数中的[外部变量]对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。"></a>lambda匿名函数中的[外部变量]对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。</h4></blockquote>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[=]</td>
<td>只有一个 = 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[=,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p> 注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<p>【例 1】lambda 匿名函数的定义和使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>1 2 3 4</p>
<p>程序第 8 行通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。而如果使用普通函数，需以如下代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_up</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序中 sort_up() 函数的功能和上一个程序中的 lambda 匿名函数完全相同。显然在类似的场景中，使用 lambda 匿名函数更有优势。</p>
<p>除此之外，虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b) -&gt; <span class="keyword">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为</p>
<p>10 20</p>
<p>可以看到，程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<p>【例 2】值传递和引用传递的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda1:<span class="number">1</span> <span class="number">2</span> <span class="number">310l</span>ambda2:<span class="number">10</span> <span class="number">20</span> <span class="number">30100</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。</p>
<p>其中，lambda1 匿名函数是以 [=] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。</p>
<blockquote>
<p>感兴趣的读者，可自行尝试在 lambda1 匿名函数中修改 num_1、num_2 或者 num_3 的值，观察编译器的报错信息。</p>
</blockquote>
<p>当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;    num_1 = <span class="number">10</span>;    num_2 = <span class="number">20</span>;    num_3 = <span class="number">30</span>;    <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改    cout &lt;&lt; num_1 &lt;&lt; &quot; &quot;         &lt;&lt; num_2 &lt;&lt; &quot; &quot;         &lt;&lt; num_3 &lt;&lt; endl;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</p>
<p>【例 3】执行抛出异常类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main()&#123;    auto except = []()throw(int) &#123;        throw 10;    &#125;;        try &#123;        except();    &#125;    catch (int) &#123;        cout &lt;&lt; <span class="meta-string">&quot;捕获到了整形异常&quot;</span>;    &#125;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>捕获到了整形异常</p>
<p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p>
<p>在此基础上，在看一下反例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main()&#123;    auto except1 = []()noexcept&#123;        throw 100;    &#125;;    auto except2 = []()throw(char)&#123;        throw 10;    &#125;;    try&#123;        except1();        except2();    &#125;catch(int)&#123;        cout &lt;&lt; <span class="meta-string">&quot;捕获到了整形异常&quot;</span>&lt;&lt; endl;    &#125;    return 0;&#125;</span></span><br></pre></td></tr></table></figure>


<p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p>
<blockquote>
<p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p>
</blockquote>
<h2 id="C-11非受限联合体（union）"><a href="#C-11非受限联合体（union）" class="headerlink" title="C++11非受限联合体（union）"></a>C++11非受限联合体（union）</h2><p>在 C/<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 中，联合体（Union）是一种<mark class="hl-label blue">构造数据类型</mark>  。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。</p>
<p>C++11 标准规定，任何<mark class="hl-label blue">非引用类型</mark> 都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<p>关于 POD 类型稍后我们会讲解，大家先不要着急。</p>
<p>接下来，我们具体看一下 C++11 对 C++98 的改进。</p>
<h3 id="1-C-11-允许非-POD-类型，C-98-不允许联合体的成员是非-POD-类型，但是-C-1-1-取消了这种限制。"><a href="#1-C-11-允许非-POD-类型，C-98-不允许联合体的成员是非-POD-类型，但是-C-1-1-取消了这种限制。" class="headerlink" title="1. C++11 允许非 POD 类型，C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。"></a>1. C++11 允许非 POD 类型，C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</h3><p>POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。<br>POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ol>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为 public。</li>
<li>类中的第一个非静态成员的类型与其基类不同，例如：</li>
</ol>
<p>class B1{};<br>class B2 : B1 { B1 b; };</p>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。<br>5) 在类或者结构体继承时，满足以下两种情况之一：</p>
<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
<p>我们来看具体的例子：</p>
<p>class B1 { static int n; };<br>class B2 : B1 { int n1; };<br>class B3 : B2 { static int n2; };</p>
<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<ol start="6">
<li><p>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p>
</li>
<li><p>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p>
</li>
</ol>
<h3 id="2-C-11-允许联合体有静态成员C-11-删除了联合体不允许拥有静态成员的限制。例如："><a href="#2-C-11-允许联合体有静态成员C-11-删除了联合体不允许拥有静态成员的限制。例如：" class="headerlink" title="2. C++11 允许联合体有静态成员C++11 删除了联合体不允许拥有静态成员的限制。例如："></a>2. C++11 允许联合体有静态成员C++11 删除了联合体不允许拥有静态成员的限制。例如：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union U &#123;</span><br><span class="line">    static int func() &#123;</span><br><span class="line">        int n = 3;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h3 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h3><blockquote>
<p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
</blockquote>
<p>这条规则可能导致对象构造失败，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new（稍后会讲解这个概念），代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h4 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h4><blockquote>
<p><strong>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</strong></p>
</blockquote>
<p>placement new 的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) <span class="built_in">ClassConstruct</span>(...)</span><br></pre></td></tr></table></figure>

<p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用<mark class="hl-label red">已经申请好的内存来生成对象</mark>  ，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h3 id="非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下："><a href="#非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下："></a>非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</h3><p>union U{<br>  union { int x; }; //此联合体为匿名联合体<br>};</p>
<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为<mark class="hl-label red">“枚举式类”</mark>  。示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> &#123;</span> STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的<mark class="hl-label red">“变长成员”</mark>  来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>
<h2 id="C-11-constexpr：验证是否为常量表达式"><a href="#C-11-constexpr：验证是否为常量表达式" class="headerlink" title="C++11 constexpr：验证是否为常量表达式"></a>C++11 constexpr：验证是否为常量表达式</h2><p>常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段。</p>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<blockquote>
<p>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
</blockquote>
<h3 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h3><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序执行结果为：</p>
<p>2</p>
<blockquote>
<p>可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
</blockquote>
<p>可以看到，程序第 5 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>可以发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足<mark class="hl-label blue">num是const常量且使用常量表达式为其初始化</mark>  这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p>
<blockquote>
<p>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p>
</blockquote>
<blockquote>
<p>另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
</blockquote>
<h3 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h3><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，<mark class="hl-label blue">只能包含一条return返回语句</mark>  。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<ol start="2">
<li>该函数必须有返回值，即函数的返回值类型不能是 void。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<ol start="3">
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>3<br>6</p>
<blockquote>
<p>可自行将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
</blockquote>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<ol start="4">
<li>return 返回的表达式必须是常量表达式，举个例子：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>using namespace std;int num = 3;constexpr int display(int x)&#123;    return num + x;&#125;int main()&#123;    <span class="comment">//调用常量表达式函数    int a[display(3)] = &#123; 1,2,3,4 &#125;;    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<blockquote>
<p>注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣可自行尝试编码测试。</p>
</blockquote>
<h3 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h3><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="keyword">char</span> *name,<span class="keyword">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<blockquote>
<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
</blockquote>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<blockquote>
<p>注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
</blockquote>
<h3 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h3><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。<br>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> =</span> <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10<br>10</p>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li>第 28 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li>
<li>第 21 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li>
</ul>
<h2 id="C-11-constexpr和const的区别"><a href="#C-11-constexpr和const的区别" class="headerlink" title="C++11 constexpr和const的区别"></a>C++11 constexpr和const的区别</h2><p>constexpr 是 C++ 11 标准新添加的关键字，在此之前（C++ 98/03标准）只有 const 关键字，其在实际使用中经常会表现出两种不同的语义。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="keyword">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，dis_1() 和 dis_2() 函数中都包含一个 const int x，但 dis_1() 函数中的 x 无法完成初始化 array 容器的任务，而 dis_2() 函数中的 x 却可以。</p>
<blockquote>
<p><strong>这是因为，dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器。</strong></p>
</blockquote>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p>
<blockquote>
<p>在上面的实例程序中，dis_2() 函数中使用 const int x 是不规范的，应使用 constexpr 关键字。</p>
</blockquote>
<p>有读者可能会问，“只读”不就意味着其不能被修改吗？答案是否定的，“只读”和“不允许被修改”之间并没有必然的联系，举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; con_b = a;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>20</p>
<p>可以看到，程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p>
<p>在大部分实际场景中，const 和 constexpr 是可以混用的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>


<p>它们是完全等价的，都可以在程序的编译阶段计算出结果。但在某些场景中，必须明确使用 constexpr，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">sqr1</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">sqr2</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr1(10)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>,sqr2(10)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中，因为 sqr2() 函数的返回值仅有 const 修饰，而没有用更明确的 constexpr 修饰，导致其无法用于初始化 array 容器（只有常量才能初始化 array 容器）。</p>
<p>总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p>
<h2 id="C-11右值引用"><a href="#C-11右值引用" class="headerlink" title="C++11右值引用"></a>C++11右值引用</h2><blockquote>
<p>C++左值和右值右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。</p>
</blockquote>
<p>在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p>
<blockquote>
<p>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<p>通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。</p>
<ol>
<li>可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5 不能为左值</span></span><br><span class="line"></span><br><span class="line">其中，变量 a 就是一个左值，而字面量 <span class="number">5</span> 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p>
<p>前面提到，其实 C++98/03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98/03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98/03 标准不支持为 <mark class="hl-label blue">右值</mark>   建立 <mark class="hl-label blue">非常量左值</mark>   引用，但允许使用 <mark class="hl-label blue">常量左值引用</mark>   操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">const int &amp;b = num;</span><br><span class="line">const int &amp;c = 10;</span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<blockquote>
<p>话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 /03 标准产生冲突，最终选定了 2 个 ‘&amp;’ 表示右值引用。</p>
</blockquote>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span><br><span class="line">int &amp;&amp; a = 10;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; a = 10;</span><br><span class="line">a = 100;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>程序输出结果为 100。</p>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int&amp;&amp; a = 10;//编译器不会报错</span><br></pre></td></tr></table></figure>


<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用 的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
<p>学到这里，一些读者可能无法记清楚 左值引用 和 右值引用 各自可以引用左值还是右值，这里给大家一张表格，方便大家记忆：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>可以引用的值类型</th>
<th>使用场景</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<p>表中，Y 表示支持，N 表示不支持。</p>
<blockquote>
<p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值（本节中已经做了大篇幅的讲解），而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。对于纯右值和将亡值，都属于右值，读者知道即可，不必深究。</p>
</blockquote>
<h2 id="C-11移动构造函数"><a href="#C-11移动构造函数" class="headerlink" title="C++11移动构造函数"></a>C++11移动构造函数</h2><p>在 C++ 11 标准之前（C++ 98/03 标准中），如果<mark class="hl-label blue">想用其它对象初始化一个同类的新对象</mark>  ，只能借助类中的复制（拷贝）构造函数。通过《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2334.html">C++拷贝构造函数</a>》一节的学习我们知道，拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。</p>
<blockquote>
<p>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   <span class="built_in">demo</span>(<span class="keyword">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。<mark class="hl-label blue">否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次</mark>  。</p>
</blockquote>
<p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
<ol>
<li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个<mark class="hl-label blue">匿名对象</mark>  ；</li>
<li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li>
<li>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li>
<li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li>
</ol>
<p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">destruct</span>!</span></span><br></pre></td></tr></table></figure>

<p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!        &lt;-- 执行 <span class="built_in">demo</span>()</span><br><span class="line">copy construct!    &lt;-- 执行 <span class="keyword">return</span> <span class="built_in">demo</span>()</span><br><span class="line">class destruct!     &lt;-- 销毁 <span class="built_in">demo</span>() 产生的匿名对象</span><br><span class="line">copy construct!    &lt;-- 执行 a = <span class="built_in">get_demo</span>()</span><br><span class="line">class destruct!     &lt;-- 销毁 <span class="built_in">get_demo</span>() 返回的临时对象</span><br><span class="line">class destruct!     &lt;-- 销毁 a</span><br></pre></td></tr></table></figure>

<p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p>
<blockquote>
<p>事实上，此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p>
</blockquote>
<p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p>
<h3 id="C-移动构造函数（移动语义的具体实现）"><a href="#C-移动构造函数（移动语义的具体实现）" class="headerlink" title="C++移动构造函数（移动语义的具体实现）"></a>C++移动构造函数（移动语义的具体实现）</h3><blockquote>
<p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源<mark class="hl-label red">“移为已用”</mark>  。</p>
</blockquote>
<p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p>
<blockquote>
<p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p>
</blockquote>
<p>例如，下面程序对 demo 类进行了修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">demo</span>(<span class="keyword">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p>
<p>construct!<br>move construct!<br>class destruct!<br>move construct!<br>class destruct!<br>class destruct!</p>
<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
<h3 id="C-11-move-函数：将左值强制转换为右值"><a href="#C-11-move-函数：将左值强制转换为右值" class="headerlink" title="C++11 move()函数：将左值强制转换为右值"></a>C++11 move()函数：将左值强制转换为右值</h3><p>C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</p>
<blockquote>
<p>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
</blockquote>
<p>move() 函数的用法也很简单，其语法格式如下：</p>
<p>move( arg )</p>
<p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p>
<p>【例 1】move() 函数的基础应用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">movedemo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="keyword">const</span> movedemo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:\n&quot;</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:\n&quot;</span>;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">demo2:</span><br><span class="line">copy construct!</span><br><span class="line">demo3:</span><br><span class="line">move construct!</span><br></pre></td></tr></table></figure>

<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<blockquote>
<p>注意，调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 28行代码会导致程序运行时发生错误。</p>
</blockquote>
<p>【例 2】灵活使用 move() 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">second</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    <span class="built_in">second</span>(second &amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>construct!<br>first move construct!<br>second move construct</p>
<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 次move() 函数：</p>
<ul>
<li>程序第 28 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li>
<li>程序第 20 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li>
</ul>
<h2 id="C-11完美转发"><a href="#C-11完美转发" class="headerlink" title="C++11完美转发"></a>C++11完美转发</h2><p>完美转发，它指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。</p>
<blockquote>
<p>在 C++ 中，一个表达式不是左值就是右值。有关如何判断一个表达式是左值还是右值，可阅读《<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7829.html">C++右值引用</a>》一文做详细了解。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void function(T t) &#123;</span><br><span class="line">    otherdef(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。</p>
<p>显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</p>
<blockquote>
<p>读者可能会问，完美转发这样严苛的参数传递机制，很常用吗？C++98/03 标准中几乎不会用到，但 C++11 标准为 C++ 引入了右值引用和移动语义，因此很多场景中是否实现完美转发，直接决定了该参数的传递过程使用的是拷贝语义（调用拷贝构造函数）还是移动语义（调用移动构造函数）。</p>
</blockquote>
<p>事实上，C++98/03 标准下的 C++ 也可以实现完美转发，只是实现方式比较笨拙。通过前面的学习我们知道，C++ 98/03 标准中只有左值引用，并且可以细分为非 const 引用和 const 引用。其中，使用非 const 引用作为函数模板参数时，只能接收左值，无法接收右值；而 const 左值引用既可以接收左值，也可以接收右值，但考虑到其 const 属性，除非被调用函数的参数也是 const 属性，否则将无法直接传递。</p>
<p>这也就意味着，单独使用任何一种引用形式，可以实现转发，但无法保证完美。因此如果使用 C++ 98/03 标准下的 C++ 语言，我们可以采用函数模板重载的方式实现完美转发，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数模板，分别接收左值和右值</span></span><br><span class="line"><span class="comment">//接收右值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收左值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);<span class="comment">//5 是右值</span></span><br><span class="line">    <span class="keyword">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);<span class="comment">//x 是左值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>从输出结果中可以看到，对于右值 5 来说，它实际调用的参数类型为 const T&amp; 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T&amp; 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。</p>
<p>显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。</p>
<p>仍以 function() 函数为例，在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; num = n;</span><br><span class="line"><span class="built_in">function</span>(num); <span class="comment">// T 为 int&amp;</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; num2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">function</span>(num2); <span class="comment">// T 为 int &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>其中，由 function(num) 实例化的函数底层就变成了 function(int &amp; &amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。要知道，C++98/03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：</p>
<ul>
<li>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; = A&amp;）；</li>
<li>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; = A&amp;&amp;）。</li>
</ul>
<blockquote>
<p>在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
</blockquote>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p>
<p>C++11 标准的开发者已经帮我们想好的解决方案，该新标准还引入了一个模板函数<mark class="hl-label red">forword<T>()</T></mark>  ，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">otherdef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>注意程序中第 12~16 行，此 function() 模板函数才是实现完美转发的最终版本。可以看到，forword() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。</p>
<p>总的来说，在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数。由此即可轻松实现函数模板中参数的完美转发。 </p>
<h2 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h2><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。</p>
<p>事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。</p>
<p>如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98/03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。</p>
<p>所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<blockquote>
<p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
</blockquote>
<p>接下来，我们将分别对 shared_ptr、unique_ptr 以及 weak_ptr 这 3 个智能指针的特性和用法做详细的讲解，本节先介绍 shared_ptr 智能指针。</p>
<h2 id="C-11-shared-ptr智能指针-1"><a href="#C-11-shared-ptr智能指针-1" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h2><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr<T>（其中 T 表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用<mark class="hl-label blue">计数机制</mark>  ，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h4 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h4><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</T></p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：</T></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure>

<p>注意，空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。</p>
<ol start="2">
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p>
<p>同时，C++11 标准中还提供了 std::make_shared<T> 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：</T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p3 = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>以上 2 种方式创建的 p3 是完全相同。</p>
<ol start="3">
<li>除此之外，shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数，例如：</T></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure>

<p>如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用<mark class="hl-label blue">拷贝构造函数</mark>  。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是<mark class="hl-label blue">移动构造函数</mark>  。另外和调用拷贝构造函数不同，<mark class="hl-label blue">用std::move(p4)初始化p5,会使得p5拥有了p4的堆内存，而p4则变成了空智能指针</mark>  。</p>
<p>注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li>
</ol>
<p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p>
<p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete<T> 模板类，我们也可以自定义释放规则：</T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="keyword">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteInt</span><span class="params">(<span class="keyword">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际上借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shared_ptr<T> 模板类还提供有其它一些初始化智能指针的方法，感兴趣的读者可前往讲解 <a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/memory/shared_ptr/shared_ptr/">shared_ptr 的官网</a>做系统了解。</T></p>
</blockquote>
<h4 id="2、shared-ptr模板类提供的成员方法"><a href="#2、shared-ptr模板类提供的成员方法" class="headerlink" title="2、shared_ptr模板类提供的成员方法"></a>2、shared_ptr<T>模板类提供的成员方法</T></h4><p>为了方便使用 shared_ptr 智能指针，shared_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</T></p>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td>
</tr>
<tr>
<td>operator*()</td>
<td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td>
</tr>
<tr>
<td>get()</td>
<td>获得 shared_ptr 对象内部包含的普通指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td>
</tr>
<tr>
<td>unique()</td>
<td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td>
</tr>
</tbody></table>
<blockquote>
<p> 除此之外，C++11 标准还支持同一类型的 shared_ptr 对象，或者 shared_ptr 和 nullptr 之间，进行 ==，!=，&lt;，&lt;=，&gt;，&gt;= 运算。</p>
</blockquote>
<p>下面程序演示了 shared_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p1 为空<br>10<br>1</p>
<h2 id="C-11-unique-ptr智能指针"><a href="#C-11-unique-ptr智能指针" class="headerlink" title="C++11 unique_ptr智能指针"></a>C++11 unique_ptr智能指针</h2><p>作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
</blockquote>
<p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr<T>（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr智能指针的创建"><a href="#unique-ptr智能指针的创建" class="headerlink" title="unique_ptr智能指针的创建"></a>unique_ptr智能指针的创建</h3><p>考虑到不同实际场景的需要，unique_ptr<T> 模板类提供了多个实用的构造函数，这里列举了几种常用的构造 unique_ptr 智能指针的方式。</T></p>
<ol>
<li>通过以下 2 种方式，可以创建出空的 unique_ptr 指针：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。</p>
<blockquote>
<p>和可以用 make_shared<T>() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。</T></p>
</blockquote>
<ol start="3">
<li>基于 unique_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique_ptr 模板类没有提供拷贝构造函数，<mark class="hl-label blue">只提供了移动构造函数</mark>  。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（nullptr）。</p>
<ol start="4">
<li>默认情况下，unique_ptr 指针采用 std::default_delete<T> 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。例如：</T></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myDel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr模板类提供的成员方法"><a href="#unique-ptr模板类提供的成员方法" class="headerlink" title="unique_ptr模板类提供的成员方法"></a>unique_ptr<T>模板类提供的成员方法</T></h3><p>为了方便使用 unique_ptr 智能指针，unique_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</T></p>
<table>
<thead>
<tr>
<th>成员函数名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator*()</td>
<td>获取当前 unique_ptr 指针指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>operator =()</td>
<td>重载了 = 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。</td>
</tr>
<tr>
<td>operator <a href></a></td>
<td>重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。</td>
</tr>
<tr>
<td>get()</td>
<td>获取当前 unique_ptr 指针内部包含的普通指针。</td>
</tr>
<tr>
<td>get_deleter()</td>
<td>获取当前 unique_ptr 指针释放堆内存空间所用的规则。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。</td>
</tr>
<tr>
<td>release()</td>
<td>释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td>
</tr>
<tr>
<td>reset(p)</td>
<td>其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>交换当前 unique_ptr 指针和同类型的 x 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，C++11标准还支持同类型的 unique_ptr 指针之间，以及 unique_ptr 和 nullptr 之间，做 ==，!=，&lt;，&lt;=，&gt;，&gt;= 运算。</p>
</blockquote>
<p>下面程序演示了 unique_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    *p5 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// p 接收 p5 释放的堆内存,但该存储空间并不会被销毁。</span></span><br><span class="line">    <span class="keyword">int</span> * p = p5.<span class="built_in">release</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断 p5 是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p5) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is not nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; p6;</span><br><span class="line">    <span class="comment">//p6 获取 p 的所有权</span></span><br><span class="line">    p6.<span class="built_in">reset</span>(p);</span><br><span class="line">    cout &lt;&lt; *p6 &lt;&lt; endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p5 is nullptr<br>10</p>
<h2 id="C-11-weak-ptr智能指针"><a href="#C-11-weak-ptr智能指针" class="headerlink" title="C++11 weak_ptr智能指针"></a>C++11 weak_ptr智能指针</h2><p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr<T>（ T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 weak_ptr 类型指针，程序中应首先包含如下 2 条语句：</T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。</p>
<p>需要注意的是，当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。<br>除此之外，weak_ptr<T> 模板类中没有重载 * 和 -&gt; 运算符，这也就意味着，<mark class="hl-label blue">weak_ptr类型指针只能访问所指的堆内存，而无法修改它</mark>  。</T></p>
<h4 id="1、weak-ptr指针的创建"><a href="#1、weak-ptr指针的创建" class="headerlink" title="1、weak_ptr指针的创建"></a>1、weak_ptr指针的创建</h4><p>创建一个 weak_ptr 指针，有以下 3 种方式：</p>
<ol>
<li>可以创建一个空 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="keyword">int</span>&gt; wp1;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）。</p>
<ol start="3">
<li>weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。</p>
<h4 id="2-weak-ptr模板类提供的成员方法"><a href="#2-weak-ptr模板类提供的成员方法" class="headerlink" title="2) weak_ptr模板类提供的成员方法"></a>2) weak_ptr模板类提供的成员方法</h4><p>和 shared_ptr<T>、unique_ptr<T> 相比，weak_ptr<T> 模板类提供的成员方法不多，表 1 罗列了常用的成员方法及各自的功能。</T></T></T></p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator=()</td>
<td>重载 = 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>将当前 weak_ptr 指针置为空指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。</td>
</tr>
<tr>
<td>expired()</td>
<td>判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td>
</tr>
<tr>
<td>lock()</td>
<td>如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相 同的 shared_ptr 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>再次强调，weak_ptr<T> 模板类没有重载 * 和 -&gt; 运算符，因此 weak_ptr 类型指针只能访问某一 shared_ptr 指针指向的堆内存空间，无法对其进行修改。</T></p>
</blockquote>
<p>下面的样例演示了 weak_ptr 指针以及表 1 中部分成员方法的基本用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp2)</span></span>;</span><br><span class="line">    <span class="comment">//输出和 wp 同指向的 shared_ptr 类型指针的数量</span></span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//释放 sp2</span></span><br><span class="line">    sp2.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据</span></span><br><span class="line">    cout &lt;&lt; *(wp.<span class="built_in">lock</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>2<br>1<br>10</p>
<h2 id><a href="#" class="headerlink" title></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Smt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwlbird.github.io/2021/07/13/C-11/">https://zwlbird.github.io/2021/07/13/C-11/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwlbird.github.io" target="_blank">.oOo.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/12/12/w6gBS4XVHa8hA7O.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/13/opencv/"><img class="prev-cover" src="https://s2.loli.net/2023/12/12/Wf2LRwIhBnmXxUN.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">opencv</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/27/Qt/"><img class="next-cover" src="https://s2.loli.net/2023/12/12/SNjXLprxbadKoJ8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Qt</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/03/Hexo/" title="Hexo"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">Hexo</div></div></a></div><div><a href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel"><img class="cover" src="https://s2.loli.net/2023/12/12/zb5QarqSYDHWZs6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-19</div><div class="title">OpenGL-highlevel</div></div></a></div><div><a href="/2021/10/17/OpenGL-light/" title="OpenGL-light"><img class="cover" src="https://s2.loli.net/2023/12/12/Dlf5uYb78R1Firw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-17</div><div class="title">OpenGL-light</div></div></a></div><div><a href="/2021/06/27/C/" title="C++"><img class="cover" src="https://s2.loli.net/2023/12/12/cYpI451Z9oJwFqQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-27</div><div class="title">C++</div></div></a></div><div><a href="/2021/07/13/STL/" title="STL"><img class="cover" src="https://s2.loli.net/2023/12/12/dEMek6rKx2XmsD5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="title">STL</div></div></a></div><div><a href="/2021/07/13/opencv/" title="opencv"><img class="cover" src="https://s2.loli.net/2023/12/12/Wf2LRwIhBnmXxUN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="title">opencv</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Smt</div><div class="author-info__description">哇咔咔</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zwlbird/zwlbird.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zwl931025@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">默认函数控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.</span> <span class="toc-text">auto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">auto 的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">3.</span> <span class="toc-text">decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-decltype-exp-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%86%E6%A0%B9%E6%8D%AE%E4%BB%A5%E4%B8%8B%E4%B8%89%E6%9D%A1%E8%A7%84%E5%88%99%E5%BE%97%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-%E5%92%8C-decltype-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">auto 和 decltype 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">C++返回值类型后置（跟踪返回值类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D%EF%BC%88%E6%9B%BF%E4%BB%A3typedef%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">C++11使用using定义别名（替代typedef）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">C++11支持函数模板的默认模板参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">C++11 lambda匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">lambda匿名函数的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F-%E5%AF%B9%E4%BA%8E-lambda-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BB%A4%E5%A4%9A%E6%95%B0%E5%88%9D%E5%AD%A6%E8%80%85%E6%84%9F%E5%88%B0%E5%9B%B0%E6%83%91%E7%9A%84%E5%B0%B1%E6%98%AF-%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F-%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E6%97%A0%E9%9D%9E%E8%A1%A8-1-%E6%89%80%E7%A4%BA%E7%9A%84%E8%BF%99%E5%87%A0%E7%A7%8D%E7%BC%96%E5%86%99%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-number">8.1.1.</span> <span class="toc-text">lambda匿名函数中的[外部变量]对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">C++11非受限联合体（union）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-C-11-%E5%85%81%E8%AE%B8%E9%9D%9E-POD-%E7%B1%BB%E5%9E%8B%EF%BC%8CC-98-%E4%B8%8D%E5%85%81%E8%AE%B8%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E6%98%AF%E9%9D%9E-POD-%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%86%E6%98%AF-C-1-1-%E5%8F%96%E6%B6%88%E4%BA%86%E8%BF%99%E7%A7%8D%E9%99%90%E5%88%B6%E3%80%82"><span class="toc-number">9.1.</span> <span class="toc-text">1. C++11 允许非 POD 类型，C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-C-11-%E5%85%81%E8%AE%B8%E8%81%94%E5%90%88%E4%BD%93%E6%9C%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98C-11-%E5%88%A0%E9%99%A4%E4%BA%86%E8%81%94%E5%90%88%E4%BD%93%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%A5%E6%9C%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E9%99%90%E5%88%B6%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">9.2.</span> <span class="toc-text">2. C++11 允许联合体有静态成员C++11 删除了联合体不允许拥有静态成员的限制。例如：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E8%B5%8B%E5%80%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.3.</span> <span class="toc-text">非受限联合体的赋值注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#placement-new-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.3.1.</span> <span class="toc-text">placement new 是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%A3%B0%E6%98%8E%E5%92%8C%E2%80%9C%E6%9E%9A%E4%B8%BE%E5%BC%8F%E7%B1%BB%E2%80%9D%E5%8C%BF%E5%90%8D%E8%81%94%E5%90%88%E4%BD%93%E6%98%AF%E6%8C%87%E4%B8%8D%E5%85%B7%E5%90%8D%E7%9A%84%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88%E4%B9%9F%E5%8D%B3%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97%E7%9A%84%E8%81%94%E5%90%88%E4%BD%93%EF%BC%89%EF%BC%8C%E4%B8%80%E8%88%AC%E5%AE%9A%E4%B9%89%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">9.4.</span> <span class="toc-text">非受限联合体的匿名声明和“枚举式类”匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-constexpr%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">C++11 constexpr：验证是否为常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">constexpr修饰普通变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">constexpr修饰函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">constexpr修饰类的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">10.4.</span> <span class="toc-text">constexpr修饰模板函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-constexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">C++11 constexpr和const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">C++11右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">C++11移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">C++移动构造函数（移动语义的具体实现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11-move-%E5%87%BD%E6%95%B0%EF%BC%9A%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC"><span class="toc-number">13.2.</span> <span class="toc-text">C++11 move()函数：将左值强制转换为右值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">14.</span> <span class="toc-text">C++11完美转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-shared-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">15.</span> <span class="toc-text">C++11 shared_ptr智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-shared-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1"><span class="toc-number">16.</span> <span class="toc-text">C++11 shared_ptr智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81shared-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">16.0.1.</span> <span class="toc-text">1、shared_ptr智能指针的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81shared-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">16.0.2.</span> <span class="toc-text">2、shared_ptr模板类提供的成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-unique-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">17.</span> <span class="toc-text">C++11 unique_ptr智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">17.1.</span> <span class="toc-text">unique_ptr智能指针的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">17.2.</span> <span class="toc-text">unique_ptr模板类提供的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-weak-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">18.</span> <span class="toc-text">C++11 weak_ptr智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81weak-ptr%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">18.0.1.</span> <span class="toc-text">1、weak_ptr指针的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-weak-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">18.0.2.</span> <span class="toc-text">2) weak_ptr模板类提供的成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/03/Hexo/" title="Hexo"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo"/></a><div class="content"><a class="title" href="/2022/04/03/Hexo/" title="Hexo">Hexo</a><time datetime="2022-04-02T16:33:52.000Z" title="发表于 2022-04-03 00:33:52">2022-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/Android/" title="Android"><img src="https://s2.loli.net/2023/12/12/gfXKlqmwMWzPxH7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android"/></a><div class="content"><a class="title" href="/2021/10/31/Android/" title="Android">Android</a><time datetime="2021-10-31T14:03:21.000Z" title="发表于 2021-10-31 22:03:21">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel"><img src="https://s2.loli.net/2023/12/12/zb5QarqSYDHWZs6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-highlevel"/></a><div class="content"><a class="title" href="/2021/10/19/OpenGL-highlevel/" title="OpenGL-highlevel">OpenGL-highlevel</a><time datetime="2021-10-19T13:35:33.000Z" title="发表于 2021-10-19 21:35:33">2021-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/OpenGL-light/" title="OpenGL-light"><img src="https://s2.loli.net/2023/12/12/Dlf5uYb78R1Firw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL-light"/></a><div class="content"><a class="title" href="/2021/10/17/OpenGL-light/" title="OpenGL-light">OpenGL-light</a><time datetime="2021-10-17T14:09:58.000Z" title="发表于 2021-10-17 22:09:58">2021-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D"><img src="https://s2.loli.net/2023/12/12/EZS5QGm23HLgvW4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL_3D"/></a><div class="content"><a class="title" href="/2021/09/21/OpenGL-3D/" title="OpenGL_3D">OpenGL_3D</a><time datetime="2021-09-21T07:31:53.000Z" title="发表于 2021-09-21 15:31:53">2021-09-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/12/12/w6gBS4XVHa8hA7O.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Smt</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RrMFpOdr0spfIDfRdBukvyf7-gzGzoHsz',
      appKey: 'nipjeGzTyw5yvNk2SgU5KmUQ',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://myhkw.cn/api/player/162393526192" id="myhk" key="162393526192" m="1"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>